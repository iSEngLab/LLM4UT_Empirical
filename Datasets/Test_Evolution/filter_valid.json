[
    {
        "test_src": "@Test public void testGetResource() { LOGGER.info(ClassLoaderUtil.getResource(\"\") + \"\"); LOGGER.info(\"\" + ClassLoaderUtil.getResource(\"com\")); ClassLoaderUtil.getResource(\"jstl-1.2\", this.getClass()); } ",
        "focal_tgt": "public static URL getResource(String resourceName) { return getResource(getClassLoaderByClass(ClassLoaderUtil.class), resourceName); } ",
        "focal_src": "public static URL getResource(String resourceName) { ClassLoader classLoader = getClassLoaderByClass(ClassLoaderUtil.class); return getResource(classLoader, resourceName); } ",
        "test_tgt": "@Test public void testGetResource() { LOGGER.debug(ClassLoaderUtil.getResource(\"\") + \"\"); LOGGER.debug(\"\" + ClassLoaderUtil.getResource(\"com\")); ClassLoaderUtil.getResourceInAllClassLoader(\"jstl-1.2\", this.getClass()); } "
    },
    {
        "test_src": "@Test public void applyUMaskTest() { Mode umaskPermission = new Mode((short)0022); Permission permission = new Permission(\"user1\", \"group1\", Mode.getDefault()); permission.applyUMask(umaskPermission); Assert.assertEquals(Mode.Bits.ALL, permission.getMode().getUserMode()); Assert.assertEquals(Mode.Bits.READ_EXECUTE, permission.getMode().getGroupMode()); Assert.assertEquals(Mode.Bits.READ_EXECUTE, permission.getMode().getOtherMode()); verifyPermissionStatus(\"user1\", \"group1\", (short)0755, permission); } ",
        "focal_tgt": "public Mode applyUMask(Mode umask) { return new Mode(mUserBits.and(umask.mUserBits.not()), mGroupBits.and(umask.mGroupBits.not()), mOtherBits.and(umask.mOtherBits.not())); } ",
        "focal_src": "public Mode applyUMask(Mode umask) { return new Mode(mUserMode.and(umask.mUserMode.not()), mGroupMode.and(umask.mGroupMode.not()), mOtherMode.and(umask.mOtherMode.not())); } ",
        "test_tgt": "@Test public void applyUMaskTest() { Mode umaskMode = new Mode((short)0022); Permission permission = new Permission(\"user1\", \"group1\", Mode.getDefault()); permission.applyUMask(umaskMode); Assert.assertEquals(Mode.Bits.ALL, permission.getMode().getUserBits()); Assert.assertEquals(Mode.Bits.READ_EXECUTE, permission.getMode().getGroupBits()); Assert.assertEquals(Mode.Bits.READ_EXECUTE, permission.getMode().getOtherBits()); verifyPermission(\"user1\", \"group1\", (short)0755, permission); } "
    },
    {
        "test_src": "@Test public void testScanArtifacts()throws DatabaseException, InvalidSettingException { if(canRun()) { MavenProject project = new MockUp < MavenProject > () { @Mock public Set < Artifact > getArtifacts() { Set < Artifact > artifacts = new HashSet < Artifact > (); Artifact a = new ArtifactStub(); try { File file = new File(Test.class.getProtectionDomain().getCodeSource().getLocation().toURI()); a.setFile(file); artifacts.add(a); } catch(URISyntaxException ex) { Logger.getLogger(BaseDependencyCheckMojoTest.class.getName()).log(Level.SEVERE, null, ex); } return artifacts; }@Mock public String getName() { return \"test-project\"; } }.getMockInstance(); boolean autoUpdate = Settings.getBoolean(Settings.KEYS.AUTO_UPDATE); Settings.setBoolean(Settings.KEYS.AUTO_UPDATE, false); Engine engine = new Engine(null, null); Settings.setBoolean(Settings.KEYS.AUTO_UPDATE, autoUpdate); assertTrue(engine.getDependencies().isEmpty()); BaseDependencyCheckMojoImpl instance = new BaseDependencyCheckMojoImpl(); instance.scanArtifacts(project, engine); assertFalse(engine.getDependencies().isEmpty()); engine.cleanup(); } } ",
        "focal_tgt": "protected void scanArtifacts(MavenProject project, MavenEngine engine) { for(Artifact a : project.getArtifacts()) { if(excludeFromScan(a)) { continue; } final List < Dependency > deps = engine.scan(a.getFile().getAbsoluteFile()); if(deps != null) { if(deps.size() == 1) { final Dependency d = deps.get(0); if(d != null) { final MavenArtifact ma = new MavenArtifact(a.getGroupId(), a.getArtifactId(), a.getVersion()); d.addAsEvidence(\"pom\", ma, Confidence.HIGHEST); d.addProjectReference(project.getName()); if(getLog().isDebugEnabled()) { getLog().debug(String.format(\"Adding project reference %s on dependency %s\", project.getName(), d.getDisplayFileName())); } } } else if(getLog().isDebugEnabled()) { final String msg = String.format(\"More then 1 dependency was identified in first pass scan of '%s:%s:%s'\", a.getGroupId(), a.getArtifactId(), a.getVersion()); getLog().debug(msg); } } } } ",
        "focal_src": "protected void scanArtifacts(MavenProject project, Engine engine) { for(Artifact a : project.getArtifacts()) { if(excludeFromScan(a)) { continue; } final List < Dependency > deps = engine.scan(a.getFile().getAbsoluteFile()); if(deps != null) { if(deps.size() == 1) { final Dependency d = deps.get(0); if(d != null) { final MavenArtifact ma = new MavenArtifact(a.getGroupId(), a.getArtifactId(), a.getVersion()); d.addAsEvidence(\"pom\", ma, Confidence.HIGHEST); d.addProjectReference(project.getName()); if(getLog().isDebugEnabled()) { getLog().debug(String.format(\"Adding project reference %s on dependency %s\", project.getName(), d.getDisplayFileName())); } } } else if(getLog().isDebugEnabled()) { final String msg = String.format(\"More then 1 dependency was identified in first pass scan of '%s:%s:%s'\", a.getGroupId(), a.getArtifactId(), a.getVersion()); getLog().debug(msg); } } } } ",
        "test_tgt": "@Test public void testScanArtifacts()throws DatabaseException, InvalidSettingException { if(canRun()) { MavenProject project = new MockUp < MavenProject > () { @Mock public Set < Artifact > getArtifacts() { Set < Artifact > artifacts = new HashSet < Artifact > (); Artifact a = new ArtifactStub(); try { File file = new File(Test.class.getProtectionDomain().getCodeSource().getLocation().toURI()); a.setFile(file); artifacts.add(a); } catch(URISyntaxException ex) { Logger.getLogger(BaseDependencyCheckMojoTest.class.getName()).log(Level.SEVERE, null, ex); } return artifacts; }@Mock public String getName() { return \"test-project\"; } }.getMockInstance(); boolean autoUpdate = Settings.getBoolean(Settings.KEYS.AUTO_UPDATE); Settings.setBoolean(Settings.KEYS.AUTO_UPDATE, false); MavenEngine engine = new MavenEngine(null, null); Settings.setBoolean(Settings.KEYS.AUTO_UPDATE, autoUpdate); assertTrue(engine.getDependencies().isEmpty()); BaseDependencyCheckMojoImpl instance = new BaseDependencyCheckMojoImpl(); instance.scanArtifacts(project, engine); assertFalse(engine.getDependencies().isEmpty()); engine.cleanup(); } } "
    },
    {
        "test_src": "@Test public void toMap() { String json = \"{'data1':{'name':'get'},'data2':{'name':'set'},'null':{'name':'set'}}\"; Map < String, Person > map = JsonUtil.toMap(json, Person.class); LOGGER.info(JsonUtil.format(map)); } ",
        "focal_tgt": "@SuppressWarnings(\"unchecked\")public static < T > Map < String, T > toMap(String json, Class < T > clazz, Map < String, Class < ? > > classMap) { LOGGER.debug(\"in json:{}\", json); if(Validator.isNullOrEmpty(json)) { return Collections.emptyMap(); } Map < String, T > map = new HashMap < String, T > (); JSONObject jsonObject = toJSONObject(json); Iterator < String > keys = jsonObject.keys(); while(keys.hasNext()) { String key = keys.next(); Object value = jsonObject.get(key); LOGGER.debug(\"key:[{}], value:{}\", key, value); if(null != clazz) { map.put(key, toBean(value, clazz, classMap)); } else { map.put(key, (T)value); } } return map; } ",
        "focal_src": "public static < T > Map < String, T > toMap(String json, Class < T > clazz, Map < String, Class < ? > > classMap) { LOGGER.debug(\"in json:{}\", json); Map < String, T > map = new HashMap < String, T > (); JSONObject jsonObject = toJSONObject(json); @SuppressWarnings(\"unchecked\")Iterator < String > keys = jsonObject.keys(); while(keys.hasNext()) { String key = keys.next(); Object value = jsonObject.get(key); LOGGER.debug(\"key:[{}], value:{}\", key, value); map.put(key, toBean(value, clazz, classMap)); } return map; } ",
        "test_tgt": "@Test public void toMap() { String json = \"{'data1':{'name':'get'},'data2':{'name':'set'}}\"; Map < String, Person > map = JsonUtil.toMap(json, Person.class); LOGGER.info(JsonUtil.format(map)); } "
    },
    {
        "test_src": "@Test public void testSetApplicationsForCommand()throws GenieException { Assert.assertTrue(this.service.getApplicationsForCommand(COMMAND_2_ID).isEmpty()); final Set < String > appIds = new HashSet < > (); appIds.add(APP_1_ID); final Set < Command > preCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(1, preCommands.size()); Assert.assertEquals(1, preCommands.stream().filter(command -> COMMAND_1_ID.equals(command.getId())).count()); this.service.setApplicationsForCommand(COMMAND_2_ID, appIds); final Set < Command > savedCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(2, savedCommands.size()); Assert.assertEquals(1, this.service.getApplicationsForCommand(COMMAND_2_ID).stream().filter(application -> APP_1_ID.equals(application.getId())).count()); } ",
        "focal_tgt": "@Override public void setApplicationsForCommand(@NotBlank(message = \"No command id entered. Unable to set applications.\")final String id, @NotNull(message = \"No application ids entered. Unable to set applications.\")final List < String > applicationIds)throws GenieException { if(applicationIds.size() != applicationIds.stream().filter(this.appRepo :: exists).count()) { throw new GeniePreconditionException(\"All applications need to exist to add to a command\"); } final CommandEntity commandEntity = this.findCommand(id); commandEntity.getApplications().clear(); applicationIds.stream().forEach(applicationId -> commandEntity.getApplications().add(this.appRepo.findOne(applicationId))); } ",
        "focal_src": "@Override public void setApplicationsForCommand(@NotBlank(message = \"No command id entered. Unable to set applications.\")final String id, @NotNull(message = \"No application ids entered. Unable to set applications.\")final Set < String > applicationIds)throws GenieException { if(applicationIds.size() != applicationIds.stream().filter(this.appRepo :: exists).count()) { throw new GeniePreconditionException(\"All applications need to exist to add to a command\"); } final CommandEntity commandEntity = this.findCommand(id); commandEntity.getApplications().clear(); applicationIds.stream().forEach(applicationId -> commandEntity.getApplications().add(this.appRepo.findOne(applicationId))); } ",
        "test_tgt": "@Test public void testSetApplicationsForCommand()throws GenieException { Assert.assertTrue(this.service.getApplicationsForCommand(COMMAND_2_ID).isEmpty()); final List < String > appIds = Lists.newArrayList(APP_1_ID); final Set < Command > preCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(1, preCommands.size()); Assert.assertEquals(1, preCommands.stream().filter(command -> COMMAND_1_ID.equals(command.getId())).count()); this.service.setApplicationsForCommand(COMMAND_2_ID, appIds); final Set < Command > savedCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(2, savedCommands.size()); Assert.assertEquals(1, this.service.getApplicationsForCommand(COMMAND_2_ID).stream().filter(application -> APP_1_ID.equals(application.getId())).count()); } "
    },
    {
        "test_src": "@Test public void testLearn() { System.out.println(\"learn\"); EmpiricalDistribution initial = new EmpiricalDistribution(pi); EmpiricalDistribution[]transition = new EmpiricalDistribution[a.length]; for(int i = 0; i < transition.length; i ++ ) { transition[i] = new EmpiricalDistribution(a[i]); } EmpiricalDistribution[]emission = new EmpiricalDistribution[b.length]; for(int i = 0; i < emission.length; i ++ ) { emission[i] = new EmpiricalDistribution(b[i]); } int[][]sequences = new int[5000][]; int[][]labels = new int[5000][]; for(int i = 0; i < sequences.length; i ++ ) { sequences[i] = new int[30 * (MathEx.randomInt(5) + 1)]; labels[i] = new int[sequences[i].length]; int state = (int)initial.rand(); sequences[i][0] = (int)emission[state].rand(); labels[i][0] = state; for(int j = 1; j < sequences[i].length; j ++ ) { state = (int)transition[state].rand(); sequences[i][j] = (int)emission[state].rand(); labels[i][j] = state; } } HMM hmm = new HMM(sequences, labels); System.out.println(hmm); double[]pi2 = { 0.55, 0.45 }; double[][]a2 = { { 0.7, 0.3 }, { 0.15, 0.85 } }; double[][]b2 = { { 0.45, 0.55 }, { 0.3, 0.7 } }; HMM init = new HMM(pi2, a2, b2); HMM result = init.learn(sequences, 100); System.out.println(result); } ",
        "focal_tgt": "public void update(int[][]observations, int iterations) { for(int iter = 0; iter < iterations; iter ++ ) { iterate(observations); } } ",
        "focal_src": "public HMM < O > learn(int[][]observations, int iterations) { HMM < O > hmm = this; for(int iter = 0; iter < iterations; iter ++ ) { hmm = hmm.iterate(observations); } return hmm; } ",
        "test_tgt": "@Test public void testFit() { System.out.println(\"fit\"); MathEx.setSeed(19650218); EmpiricalDistribution initial = new EmpiricalDistribution(pi); EmpiricalDistribution[]transition = new EmpiricalDistribution[a.length]; for(int i = 0; i < transition.length; i ++ ) { transition[i] = new EmpiricalDistribution(a[i]); } EmpiricalDistribution[]emission = new EmpiricalDistribution[b.length]; for(int i = 0; i < emission.length; i ++ ) { emission[i] = new EmpiricalDistribution(b[i]); } int[][]sequences = new int[5000][]; int[][]labels = new int[5000][]; for(int i = 0; i < sequences.length; i ++ ) { sequences[i] = new int[30 * (MathEx.randomInt(5) + 1)]; labels[i] = new int[sequences[i].length]; int state = (int)initial.rand(); sequences[i][0] = (int)emission[state].rand(); labels[i][0] = state; for(int j = 1; j < sequences[i].length; j ++ ) { state = (int)transition[state].rand(); sequences[i][j] = (int)emission[state].rand(); labels[i][j] = state; } } HMM model = HMM.fit(sequences, labels); System.out.println(model); double[]expPi2 = { 0.5076, 0.4924 }; double[][]expA2 = { { 0.8002, 0.1998 }, { 0.1987, 0.8013 } }; double[][]expB2 = { { 0.5998, 0.4002 }, { 0.4003, 0.5997 } }; double[]pi2 = model.getInitialStateProbabilities(); for(int i = 0; i < pi.length; i ++ ) { assertEquals(expPi2[i], pi2[i], 1E-4); } DenseMatrix a2 = model.getStateTransitionProbabilities(); for(int i = 0; i < a.length; i ++ ) { for(int j = 0; j < a[i].length; j ++ ) { assertEquals(expA2[i][j], a2.get(i, j), 1E-4); } } DenseMatrix b2 = model.getSymbolEmissionProbabilities(); for(int i = 0; i < b.length; i ++ ) { for(int j = 0; j < b[i].length; j ++ ) { assertEquals(expB2[i][j], b2.get(i, j), 1E-4); } } } "
    },
    {
        "test_src": "@Test public void testTrain_C() { System.out.println(\"classify\"); ClassificationDataSet train = FixedProblems.get2ClassLinear(200, RandomUtil.getRandom()); ALMA2 alma = new ALMA2(); alma.setEpochs(1); alma.trainC(train); ClassificationDataSet test = FixedProblems.get2ClassLinear(200, RandomUtil.getRandom()); for(DataPointPair < Integer > dpp : test.getAsDPPList())assertEquals(dpp.getPair().longValue(), alma.classify(dpp.getDataPoint()).mostLikely()); } ",
        "focal_tgt": "@Override public void train(ClassificationDataSet dataSet, boolean parallel) { double[]deci = new double[dataSet.getSampleSize()]; boolean[]label = new boolean[deci.length]; int len = label.length; if(mode == CalibrationMode.CV) { List < ClassificationDataSet > foldList = dataSet.cvSet(folds); int pos = 0; for(int i = 0; i < foldList.size(); i ++ ) { ClassificationDataSet test = foldList.get(i); ClassificationDataSet train = ClassificationDataSet.comineAllBut(foldList, i); base.train(train, parallel); for(int j = 0; j < test.getSampleSize(); j ++ ) { deci[pos] = base.getScore(test.getDataPoint(j)); label[pos] = test.getDataPointCategory(j) == 1; pos ++ ; } } base.train(dataSet, parallel); } else if(mode == CalibrationMode.HOLD_OUT) { List < DataPointPair < Integer > > wholeSet = dataSet.getAsDPPList(); Collections.shuffle(wholeSet); int splitMark = (int)(wholeSet.size() * (1 - holdOut)); ClassificationDataSet train = new ClassificationDataSet(wholeSet.subList(0, splitMark), dataSet.getPredicting()); ClassificationDataSet test = new ClassificationDataSet(wholeSet.subList(splitMark, wholeSet.size()), dataSet.getPredicting()); base.train(train, parallel); for(int i = 0; i < test.getSampleSize(); i ++ ) { deci[i] = base.getScore(test.getDataPoint(i)); label[i] = test.getDataPointCategory(i) == 1; } len = test.getSampleSize(); base.train(dataSet, parallel); } else { base.train(dataSet, parallel); for(int i = 0; i < len; i ++ ) { DataPoint dp = dataSet.getDataPoint(i); deci[i] = base.getScore(dp); label[i] = dataSet.getDataPointCategory(i) == 1; } } calibrate(label, deci, len); } ",
        "focal_src": "private void train(ClassificationDataSet train, ExecutorService threadPool) { if(threadPool == null || threadPool instanceof FakeExecutor)base.trainC(train); else base.trainC(train, threadPool); } ",
        "test_tgt": "@Test public void testTrain_C() { System.out.println(\"classify\"); ClassificationDataSet train = FixedProblems.get2ClassLinear(200, RandomUtil.getRandom()); ALMA2 alma = new ALMA2(); alma.setEpochs(1); alma.train(train); ClassificationDataSet test = FixedProblems.get2ClassLinear(200, RandomUtil.getRandom()); for(DataPointPair < Integer > dpp : test.getAsDPPList())assertEquals(dpp.getPair().longValue(), alma.classify(dpp.getDataPoint()).mostLikely()); } "
    },
    {
        "test_src": "@Test public void workerHeartbeat()throws Exception { long blockId = createFileWithSingleBlock(ROOT_FILE_URI); long fileId = mFileSystemMaster.getFileId(ROOT_FILE_URI); mFileSystemMaster.scheduleAsyncPersistence(ROOT_FILE_URI); FileSystemCommand command = mFileSystemMaster.workerHeartbeat(mWorkerId1, Lists.newArrayList(fileId), WorkerHeartbeatOptions.defaults()); assertEquals(CommandType.Persist, command.getCommandType()); assertEquals(0, command.getCommandOptions().getPersistOptions().getPersistFiles().size()); } ",
        "focal_tgt": "public List < JobCommand > workerHeartbeat(long workerId, List < TaskInfo > taskInfoList) { try(LockResource workersLockShared = new LockResource(mWorkerRWLock.readLock())) { MasterWorkerInfo worker = mWorkers.getFirstByField(mIdIndex, workerId); if(worker == null) { return Collections.singletonList(JobCommand.newBuilder().setRegisterCommand(RegisterCommand.getDefaultInstance()).build()); } worker.updateLastUpdatedTimeMs(); } Map < Long, List < TaskInfo > > taskInfosPerJob = new HashMap < > (); for(TaskInfo taskInfo : taskInfoList) { if( ! taskInfosPerJob.containsKey(taskInfo.getJobId())) { taskInfosPerJob.put(taskInfo.getJobId(), new ArrayList < TaskInfo > ()); } taskInfosPerJob.get(taskInfo.getJobId()).add(taskInfo); } for(Map.Entry < Long, List < TaskInfo > > taskInfosPair : taskInfosPerJob.entrySet()) { JobCoordinator jobCoordinator = mIdToJobCoordinator.get(taskInfosPair.getKey()); jobCoordinator.updateTasks(taskInfosPair.getValue()); } return mCommandManager.pollAllPendingCommands(workerId); } ",
        "focal_src": "public List < JobCommand > workerHeartbeat(long workerId, List < TaskInfo > taskInfoList) { try(LockResource workersLockShared = new LockResource(mWorkerRWLock.readLock())) { MasterWorkerInfo worker = mWorkers.getFirstByField(mIdIndex, workerId); if(worker == null) { return Collections.singletonList(JobCommand.registerCommand(new RegisterCommand())); } worker.updateLastUpdatedTimeMs(); } Map < Long, List < TaskInfo > > taskInfosPerJob = new HashMap < > (); for(TaskInfo taskInfo : taskInfoList) { if( ! taskInfosPerJob.containsKey(taskInfo.getJobId())) { taskInfosPerJob.put(taskInfo.getJobId(), new ArrayList < TaskInfo > ()); } taskInfosPerJob.get(taskInfo.getJobId()).add(taskInfo); } for(Map.Entry < Long, List < TaskInfo > > taskInfosPair : taskInfosPerJob.entrySet()) { JobCoordinator jobCoordinator = mIdToJobCoordinator.get(taskInfosPair.getKey()); jobCoordinator.updateTasks(taskInfosPair.getValue()); } return mCommandManager.pollAllPendingCommands(workerId); } ",
        "test_tgt": "@Test public void workerHeartbeat()throws Exception { long blockId = createFileWithSingleBlock(ROOT_FILE_URI); long fileId = mFileSystemMaster.getFileId(ROOT_FILE_URI); mFileSystemMaster.scheduleAsyncPersistence(ROOT_FILE_URI); FileSystemCommand command = mFileSystemMaster.workerHeartbeat(mWorkerId1, Lists.newArrayList(fileId), WorkerHeartbeatContext.defaults()); assertEquals(alluxio.wire.CommandType.Persist, command.getCommandType()); assertEquals(0, command.getCommandOptions().getPersistOptions().getFilesToPersist().size()); } "
    },
    {
        "test_src": "@Test public void setServerSend_lessThanMicrosRoundUp() { recorder.start(span, START_TIME_MICROSECONDS); brave.serverSpanThreadBinder().setCurrentSpan(serverSpan); PowerMockito.when(System.nanoTime()).thenReturn(500L); brave.serverTracer().setServerSend(); assertThat(spans.get(0).duration).isEqualTo(1L); } ",
        "focal_tgt": "public void setServerSend() { if(submitEndAnnotation(Recorder.SpanKind.SERVER)) { currentSpan().setCurrentSpan(ServerSpan.EMPTY); } } ",
        "focal_src": "public void setServerSend() { if(submitEndAnnotation(Constants.SERVER_SEND)) { currentSpan().setCurrentSpan(ServerSpan.EMPTY); } } ",
        "test_tgt": "@Test public void setServerSend_lessThanMicrosRoundUp() { recorder.start(span, START_TIME_MICROSECONDS); brave.serverSpanThreadBinder().setCurrentSpan(serverSpan); timestamp = START_TIME_MICROSECONDS; brave.serverTracer().setServerSend(); assertThat(spans.get(0).duration).isEqualTo(1L); } "
    },
    {
        "test_src": "@Test public void testGetLastDateOfThisDay() { logDate(DateUtil.getLastDateOfThisDay(NOW)); } ",
        "focal_tgt": "public static Date getLastDateOfThisDay(Date date) { Validate.notNull(date, \"date can't be null!\"); Calendar calendar = toCalendar(date); return CalendarUtil.toDate(CalendarUtil.resetDayEnd(calendar)); } ",
        "focal_src": "public static Date getLastDateOfThisDay(Date date) { Validate.notNull(date, \"date can't be null!\"); Calendar calendar = DateUtil.toCalendar(date); return CalendarUtil.toDate(CalendarUtil.resetDayEnd(calendar)); } ",
        "test_tgt": "@Test public void testGetLastDateOfThisDay() { logDate(DateUtil.getLastDateOfThisDay(NOW)); LOGGER.debug(StringUtils.repeat(\"*\", 20)); logDate(DateUtils.ceiling(NOW, Calendar.DAY_OF_MONTH)); logDate(DateUtils.round(NOW, Calendar.DAY_OF_MONTH)); logDate(DateUtils.truncate(NOW, Calendar.DAY_OF_MONTH)); LOGGER.debug(StringUtils.repeat(\"*\", 20)); logDate(DateUtils.ceiling(NOW, Calendar.MONTH)); logDate(DateUtils.round(NOW, Calendar.MONTH)); logDate(DateUtils.truncate(NOW, Calendar.MONTH)); } "
    },
    {
        "test_src": "@Test public void testDetermineCPE()throws Exception { File file = BaseTest.getResourceAsFile(this, \"struts2-core-2.1.2.jar\"); Dependency struts = new Dependency(file); FileNameAnalyzer fnAnalyzer = new FileNameAnalyzer(); fnAnalyzer.analyze(struts, null); HintAnalyzer hintAnalyzer = new HintAnalyzer(); hintAnalyzer.initializeSettings(getSettings()); hintAnalyzer.initialize(null); JarAnalyzer jarAnalyzer = new JarAnalyzer(); jarAnalyzer.initializeSettings(getSettings()); jarAnalyzer.accept(new File(\"test.jar\")); jarAnalyzer.initialize(null); jarAnalyzer.analyze(struts, null); hintAnalyzer.analyze(struts, null); File fileCommonValidator = BaseTest.getResourceAsFile(this, \"commons-validator-1.4.0.jar\"); Dependency commonValidator = new Dependency(fileCommonValidator); jarAnalyzer.analyze(commonValidator, null); hintAnalyzer.analyze(commonValidator, null); File fileSpring = BaseTest.getResourceAsFile(this, \"spring-core-2.5.5.jar\"); Dependency spring = new Dependency(fileSpring); jarAnalyzer.analyze(spring, null); hintAnalyzer.analyze(spring, null); File fileSpring3 = BaseTest.getResourceAsFile(this, \"spring-core-3.0.0.RELEASE.jar\"); Dependency spring3 = new Dependency(fileSpring3); jarAnalyzer.analyze(spring3, null); hintAnalyzer.analyze(spring3, null); CPEAnalyzer instance = new CPEAnalyzer(); Engine engine = new Engine(getSettings()); engine.openDatabase(); instance.initializeSettings(getSettings()); instance.initialize(engine); instance.determineCPE(commonValidator); instance.determineCPE(struts); instance.determineCPE(spring); instance.determineCPE(spring3); instance.close(); String expResult = \"cpe:/a:apache:struts:2.1.2\"; Identifier expIdentifier = new Identifier(\"cpe\", expResult, expResult); for(Identifier i : commonValidator.getIdentifiers()) { assertFalse(\"Apache Common Validator - found a CPE identifier?\", \"cpe\".equals(i.getType())); } assertTrue(\"Incorrect match size - struts\", struts.getIdentifiers().size() >= 1); assertTrue(\"Incorrect match - struts\", struts.getIdentifiers().contains(expIdentifier)); assertTrue(\"Incorrect match size - spring3 - \" + spring3.getIdentifiers().size(), spring3.getIdentifiers().size() >= 1); jarAnalyzer.close(); engine.close(); } ",
        "focal_tgt": "protected void determineCPE(Dependency dependency)throws CorruptIndexException, IOException, ParseException { String vendors = \"\"; String products = \"\"; for(Confidence confidence : Confidence.values()) { if(dependency.contains(EvidenceType.VENDOR, confidence)) { vendors = addEvidenceWithoutDuplicateTerms(vendors, dependency.getIterator(EvidenceType.VENDOR, confidence)); LOGGER.debug(\"vendor search: {}\", vendors); } if(dependency.contains(EvidenceType.PRODUCT, confidence)) { products = addEvidenceWithoutDuplicateTerms(products, dependency.getIterator(EvidenceType.PRODUCT, confidence)); LOGGER.debug(\"product search: {}\", products); } if( ! vendors.isEmpty() && ! products.isEmpty()) { final List < IndexEntry > entries = searchCPE(vendors, products, dependency.getVendorWeightings(), dependency.getProductWeightings()); if(entries == null) { continue; } boolean identifierAdded = false; for(IndexEntry e : entries) { LOGGER.debug(\"Verifying entry: {}\", e); if(verifyEntry(e, dependency)) { final String vendor = e.getVendor(); final String product = e.getProduct(); LOGGER.debug(\"identified vendor/product: {}/{}\", vendor, product); identifierAdded |= determineIdentifiers(dependency, vendor, product, confidence); } } if(identifierAdded) { break; } } } } ",
        "focal_src": "protected void determineCPE(Dependency dependency)throws CorruptIndexException, IOException, ParseException { String vendors = \"\"; String products = \"\"; for(Confidence confidence : Confidence.values()) { if(dependency.getVendorEvidence().contains(confidence)) { vendors = addEvidenceWithoutDuplicateTerms(vendors, dependency.getVendorEvidence(), confidence); LOGGER.debug(\"vendor search: {}\", vendors); } if(dependency.getProductEvidence().contains(confidence)) { products = addEvidenceWithoutDuplicateTerms(products, dependency.getProductEvidence(), confidence); LOGGER.debug(\"product search: {}\", products); } if( ! vendors.isEmpty() && ! products.isEmpty()) { final List < IndexEntry > entries = searchCPE(vendors, products, dependency.getVendorEvidence().getWeighting(), dependency.getProductEvidence().getWeighting()); if(entries == null) { continue; } boolean identifierAdded = false; for(IndexEntry e : entries) { LOGGER.debug(\"Verifying entry: {}\", e); if(verifyEntry(e, dependency)) { final String vendor = e.getVendor(); final String product = e.getProduct(); LOGGER.debug(\"identified vendor/product: {}/{}\", vendor, product); identifierAdded |= determineIdentifiers(dependency, vendor, product, confidence); } } if(identifierAdded) { break; } } } } ",
        "test_tgt": "@Test public void testDetermineCPE()throws Exception { File file = BaseTest.getResourceAsFile(this, \"struts2-core-2.1.2.jar\"); Dependency struts = new Dependency(file); FileNameAnalyzer fnAnalyzer = new FileNameAnalyzer(); fnAnalyzer.analyze(struts, null); HintAnalyzer hintAnalyzer = new HintAnalyzer(); hintAnalyzer.initializeSettings(getSettings()); hintAnalyzer.initialize(null); JarAnalyzer jarAnalyzer = new JarAnalyzer(); jarAnalyzer.initializeSettings(getSettings()); jarAnalyzer.accept(new File(\"test.jar\")); jarAnalyzer.initialize(null); jarAnalyzer.analyze(struts, null); hintAnalyzer.analyze(struts, null); File fileCommonValidator = BaseTest.getResourceAsFile(this, \"commons-validator-1.4.0.jar\"); Dependency commonValidator = new Dependency(fileCommonValidator); jarAnalyzer.analyze(commonValidator, null); hintAnalyzer.analyze(commonValidator, null); File fileSpring = BaseTest.getResourceAsFile(this, \"spring-core-2.5.5.jar\"); Dependency spring = new Dependency(fileSpring); jarAnalyzer.analyze(spring, null); hintAnalyzer.analyze(spring, null); File fileSpring3 = BaseTest.getResourceAsFile(this, \"spring-core-3.0.0.RELEASE.jar\"); Dependency spring3 = new Dependency(fileSpring3); jarAnalyzer.analyze(spring3, null); hintAnalyzer.analyze(spring3, null); CPEAnalyzer instance = new CPEAnalyzer(); Engine engine = new Engine(getSettings()); engine.openDatabase(); instance.initializeSettings(getSettings()); instance.initialize(engine); instance.determineCPE(commonValidator); instance.determineCPE(struts); instance.determineCPE(spring); instance.determineCPE(spring3); instance.close(); String expResult = \"cpe:/a:apache:struts:2.1.2\"; for(Identifier i : commonValidator.getIdentifiers()) { assertFalse(\"Apache Common Validator - found a CPE identifier?\", \"cpe\".equals(i.getType())); } assertTrue(\"Incorrect match size - struts\", struts.getIdentifiers().size() >= 1); boolean found = false; for(Identifier i : struts.getIdentifiers()) { if(expResult.equals(i.getValue())) { found = true; break; } } assertTrue(\"Incorrect match - struts\", found); assertTrue(\"Incorrect match size - spring3 - \" + spring3.getIdentifiers().size(), spring3.getIdentifiers().size() >= 1); jarAnalyzer.close(); engine.close(); } "
    },
    {
        "test_src": "@Test public void testPutValues_StringArray() { MultiMap < String > mm = new MultiMap < String > (); String key = \"formats\"; String input[] = { \"gzip\", \"jar\", \"pack200\" }; mm.putValues(key, input); assertMapSize(mm, 1); assertValues(mm, key, \"gzip\", \"jar\", \"pack200\"); } ",
        "focal_tgt": "public Object putValues(String name, String ... values) { Object list = null; for(int i = 0; i < values.length; i ++ )list = LazyList.add(list, values[i]); return _map.put(name, list); } ",
        "focal_src": "public Object putValues(K name, String ... values) { Object list = null; for(int i = 0; i < values.length; i ++ )list = LazyList.add(list, values[i]); return _map.put(name, list); } ",
        "test_tgt": "@Test public void testPutValues_StringArray() { MultiMap mm = new MultiMap(); String key = \"formats\"; String input[] = { \"gzip\", \"jar\", \"pack200\" }; mm.putValues(key, input); assertMapSize(mm, 1); assertValues(mm, key, \"gzip\", \"jar\", \"pack200\"); } "
    },
    {
        "test_src": "@Test public void testDeleteTenant()throws Exception { final TenantUserDto tenant = createTenant(); client.deleteTenant(tenant.getId()); checkNotFound(new TestRestCall() { @Override public void executeRestCall()throws Exception { client.getTenant(tenant.getId()); } }); } ",
        "focal_tgt": "public List < UserDto > getAllTenantAdminsByTenantId(String tenantId) { ResponseEntity < List < UserDto > > entity = restTemplate.exchange(restTemplate.getUrl() + \"admins/\" + tenantId, HttpMethod.GET, null, new ParameterizedTypeReference < List < UserDto > > () { }); return entity.getBody(); } ",
        "focal_src": "public void deleteTenant(String userId)throws Exception { MultiValueMap < String, Object > params = new LinkedMultiValueMap < > (); params.add(\"userId\", userId); restTemplate.postForLocation(restTemplate.getUrl() + \"delTenant\", params); } ",
        "test_tgt": "@Ignore@Test public void testDeleteTenant()throws Exception { final TenantDto tenant = createTenant(); checkNotFound(new TestRestCall() { @Override public void executeRestCall()throws Exception { client.getTenant(tenant.getId()); } }); } "
    },
    {
        "test_src": "@Test@RunTestInLooperThread public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling()throws NoSuchFieldException, IllegalAccessException { final AtomicInteger callbackCounter = new AtomicInteger(0); final Realm foregroundRealm = looperThread.getRealm(); TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor()); foregroundRealm.setAutoRefresh(false); foregroundRealm.executeTransactionAsync(new Realm.Transaction() { @Override public void execute(Realm realm) { realm.createObject(AllTypes.class); } }, new Realm.Transaction.OnSuccess() { @Override public void onSuccess() { assertEquals(0, callbackCounter.getAndIncrement()); foregroundRealm.beginTransaction(); foregroundRealm.createObject(AllTypes.class); foregroundRealm.commitTransaction(); } }); foregroundRealm.executeTransactionAsync(new Realm.Transaction() { @Override public void execute(Realm realm) { realm.createObject(AllTypes.class); } }, new Realm.Transaction.OnSuccess() { @Override public void onSuccess() { assertEquals(1, callbackCounter.getAndIncrement()); looperThread.testComplete(); } }); TestHelper.resetRealmThreadExecutor(); looperThread.postRunnable(new Runnable() { @Override public void run() { foregroundRealm.sharedRealm.refresh(); foregroundRealm.setAutoRefresh(true); } }); } ",
        "focal_tgt": "public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnSuccess onSuccess, final Realm.Transaction.OnError onError) { checkIfValid(); if(transaction == null) { throw new IllegalArgumentException(\"Transaction should not be null\"); } final boolean canDeliverNotification = osSharedRealm.capabilities.canDeliverNotification(); if((onSuccess != null || onError != null)) { osSharedRealm.capabilities.checkCanDeliverNotification(\"Callback cannot be delivered on current thread.\"); } final RealmConfiguration realmConfiguration = getConfiguration(); final RealmNotifier realmNotifier = osSharedRealm.realmNotifier; final Future < ? > pendingTransaction = asyncTaskExecutor.submitTransaction(new Runnable() { @Override public void run() { if(Thread.currentThread().isInterrupted()) { return; } OsSharedRealm.VersionID versionID = null; Throwable exception = null; final Realm bgRealm = Realm.getInstance(realmConfiguration); bgRealm.beginTransaction(); try { transaction.execute(bgRealm); if(Thread.currentThread().isInterrupted()) { return; } bgRealm.commitTransaction(); versionID = bgRealm.osSharedRealm.getVersionID(); } catch(final Throwable e) { exception = e; } finally { try { if(bgRealm.isInTransaction()) { bgRealm.cancelTransaction(); } } finally { bgRealm.close(); } } final Throwable backgroundException = exception; final OsSharedRealm.VersionID backgroundVersionID = versionID; if(canDeliverNotification) { if(backgroundVersionID != null && onSuccess != null) { realmNotifier.post(new Runnable() { @Override public void run() { if(isClosed()) { onSuccess.onSuccess(); return; } if(osSharedRealm.getVersionID().compareTo(backgroundVersionID) < 0) { osSharedRealm.realmNotifier.addTransactionCallback(new Runnable() { @Override public void run() { onSuccess.onSuccess(); } }); } else { onSuccess.onSuccess(); } } }); } else if(backgroundException != null) { realmNotifier.post(new Runnable() { @Override public void run() { if(onError != null) { onError.onError(backgroundException); } else { throw new RealmException(\"Async transaction failed\", backgroundException); } } }); } } else { if(backgroundException != null) { throw new RealmException(\"Async transaction failed\", backgroundException); } } } }); return new RealmAsyncTaskImpl(pendingTransaction, asyncTaskExecutor); } ",
        "focal_src": "public RealmAsyncTask executeTransactionAsync(final Transaction transaction, final Realm.Transaction.OnSuccess onSuccess, final Realm.Transaction.OnError onError) { checkIfValid(); if(transaction == null) { throw new IllegalArgumentException(\"Transaction should not be null\"); } final boolean canDeliverNotification = sharedRealm.capabilities.canDeliverNotification(); if((onSuccess != null || onError != null)) { sharedRealm.capabilities.checkCanDeliverNotification(\"Callback cannot be delivered on current thread.\"); } final RealmConfiguration realmConfiguration = getConfiguration(); final RealmNotifier realmNotifier = sharedRealm.realmNotifier; final Future < ? > pendingTransaction = asyncTaskExecutor.submitTransaction(new Runnable() { @Override public void run() { if(Thread.currentThread().isInterrupted()) { return; } SharedRealm.VersionID versionID = null; Throwable exception = null; final Realm bgRealm = Realm.getInstance(realmConfiguration); bgRealm.beginTransaction(); try { transaction.execute(bgRealm); if(Thread.currentThread().isInterrupted()) { return; } bgRealm.commitTransaction(); versionID = bgRealm.sharedRealm.getVersionID(); } catch(final Throwable e) { exception = e; } finally { try { if(bgRealm.isInTransaction()) { bgRealm.cancelTransaction(); } } finally { bgRealm.close(); } } final Throwable backgroundException = exception; final SharedRealm.VersionID backgroundVersionID = versionID; if(canDeliverNotification) { if(backgroundVersionID != null && onSuccess != null) { realmNotifier.post(new Runnable() { @Override public void run() { if(isClosed()) { onSuccess.onSuccess(); return; } if(sharedRealm.getVersionID().compareTo(backgroundVersionID) < 0) { sharedRealm.realmNotifier.addTransactionCallback(new Runnable() { @Override public void run() { onSuccess.onSuccess(); } }); } else { onSuccess.onSuccess(); } } }); } else if(backgroundException != null) { realmNotifier.post(new Runnable() { @Override public void run() { if(onError != null) { onError.onError(backgroundException); } else { throw new RealmException(\"Async transaction failed\", backgroundException); } } }); } } else { if(backgroundException != null) { throw new RealmException(\"Async transaction failed\", backgroundException); } } } }); return new RealmAsyncTaskImpl(pendingTransaction, asyncTaskExecutor); } ",
        "test_tgt": "@Test@RunTestInLooperThread public void executeTransactionAsync_callbacksShouldBeClearedBeforeCalling()throws NoSuchFieldException, IllegalAccessException { final AtomicInteger callbackCounter = new AtomicInteger(0); final Realm foregroundRealm = looperThread.getRealm(); TestHelper.replaceRealmThreadExecutor(RealmThreadPoolExecutor.newSingleThreadExecutor()); foregroundRealm.setAutoRefresh(false); foregroundRealm.executeTransactionAsync(new Realm.Transaction() { @Override public void execute(Realm realm) { realm.createObject(AllTypes.class); } }, new Realm.Transaction.OnSuccess() { @Override public void onSuccess() { assertEquals(0, callbackCounter.getAndIncrement()); foregroundRealm.beginTransaction(); foregroundRealm.createObject(AllTypes.class); foregroundRealm.commitTransaction(); } }); foregroundRealm.executeTransactionAsync(new Realm.Transaction() { @Override public void execute(Realm realm) { realm.createObject(AllTypes.class); } }, new Realm.Transaction.OnSuccess() { @Override public void onSuccess() { assertEquals(1, callbackCounter.getAndIncrement()); looperThread.testComplete(); } }); TestHelper.resetRealmThreadExecutor(); looperThread.postRunnable(new Runnable() { @Override public void run() { foregroundRealm.osSharedRealm.refresh(); foregroundRealm.setAutoRefresh(true); } }); } "
    },
    {
        "test_src": "@Test public void toThriftTest() { CreateFileOptions options = CreateFileOptions.defaults(); CreateFileTOptions thriftOptions = options.toThrift(); Assert.assertTrue(thriftOptions.isRecursive()); Assert.assertTrue(thriftOptions.isSetPersisted()); Assert.assertEquals(mDefaultWriteType.getUnderStorageType().isSyncPersist(), thriftOptions.isPersisted()); Assert.assertEquals(mDefaultBlockSizeBytes, thriftOptions.getBlockSizeBytes()); Assert.assertEquals(Constants.NO_TTL, thriftOptions.getTtl()); } ",
        "focal_tgt": "public CreateFileTOptions toThrift() { CreateFileTOptions options = new CreateFileTOptions(); options.setBlockSizeBytes(mBlockSizeBytes); options.setPersisted(mWriteType.getUnderStorageType().isSyncPersist()); options.setRecursive(mRecursive); options.setTtl(mTtl); options.setTtlExpiryAction(mTtlExpiryAction == TtlExpiryAction.FREE ? alluxio.thrift.TtlExpiryAction.Free : alluxio.thrift.TtlExpiryAction.Delete); return options; } ",
        "focal_src": "public CreateFileTOptions toThrift() { CreateFileTOptions options = new CreateFileTOptions(); options.setBlockSizeBytes(mBlockSizeBytes); options.setPersisted(mWriteType.getUnderStorageType().isSyncPersist()); options.setRecursive(mRecursive); options.setTtl(mTtl); return options; } ",
        "test_tgt": "@Test public void toThriftTest() { CreateFileOptions options = CreateFileOptions.defaults(); CreateFileTOptions thriftOptions = options.toThrift(); Assert.assertTrue(thriftOptions.isRecursive()); Assert.assertTrue(thriftOptions.isSetPersisted()); Assert.assertEquals(mDefaultWriteType.getUnderStorageType().isSyncPersist(), thriftOptions.isPersisted()); Assert.assertEquals(mDefaultBlockSizeBytes, thriftOptions.getBlockSizeBytes()); Assert.assertEquals(Constants.NO_TTL, thriftOptions.getTtl()); Assert.assertEquals(alluxio.thrift.TtlExpiryAction.Delete, thriftOptions.getTtlExpiryAction()); } "
    },
    {
        "test_src": "@Test public void testLoadValidators() { Props props = new Props(baseProps); URL validatorUrl = Resources.getResource(\"project/testValidators\"); URL configUrl = Resources.getResource(\"test-conf/azkaban-validators-test2.xml\"); props.put(XmlValidatorManager.VALIDATOR_PLUGIN_DIR, validatorUrl.getPath()); props.put(XmlValidatorManager.XML_FILE_PARAM, configUrl.getPath()); XmlValidatorManager manager = new XmlValidatorManager(props); assertEquals(\"XmlValidatorManager should contain 2 validators.\", manager.getValidatorsInfo().size(), 2); assertEquals(\"XmlValidatorManager should contain the validator specified in the xml configuration file.\", manager.getValidatorsInfo().get(1), \"Test\"); } ",
        "focal_tgt": "@Override public void loadValidators(Props props, Logger log) { validators = new LinkedHashMap < String, ProjectValidator > (); DirectoryFlowLoader flowLoader = new DirectoryFlowLoader(log); validators.put(flowLoader.getValidatorName(), flowLoader); if( ! props.containsKey(ValidatorConfigs.XML_FILE_PARAM)) { logger.warn(\"Azkaban properties file does not contain the key \" + ValidatorConfigs.XML_FILE_PARAM); return; } String xmlPath = props.get(ValidatorConfigs.XML_FILE_PARAM); File file = new File(xmlPath); if( ! file.exists()) { logger.error(\"Azkaban validator configuration file \" + xmlPath + \" does not exist.\"); return; } DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = null; try { builder = docBuilderFactory.newDocumentBuilder(); } catch(ParserConfigurationException e) { throw new ValidatorManagerException(\"Exception while parsing validator xml. Document builder not created.\", e); } Document doc = null; try { doc = builder.parse(file); } catch(SAXException e) { throw new ValidatorManagerException(\"Exception while parsing \" + xmlPath + \". Invalid XML.\", e); } catch(IOException e) { throw new ValidatorManagerException(\"Exception while parsing \" + xmlPath + \". Error reading file.\", e); } NodeList tagList = doc.getChildNodes(); Node azkabanValidators = tagList.item(0); NodeList azkabanValidatorsList = azkabanValidators.getChildNodes(); for(int i = 0; i < azkabanValidatorsList.getLength(); ++ i) { Node node = azkabanValidatorsList.item(i); if(node.getNodeType() == Node.ELEMENT_NODE) { if(node.getNodeName().equals(VALIDATOR_TAG)) { parseValidatorTag(node, props, log); } } } } ",
        "focal_src": "@Override public void loadValidators(Props props, Logger log) { validators = new LinkedHashMap < String, ProjectValidator > (); DirectoryFlowLoader flowLoader = new DirectoryFlowLoader(log); validators.put(flowLoader.getValidatorName(), flowLoader); if( ! props.containsKey(XML_FILE_PARAM)) { logger.warn(\"Azkaban properties file does not contain the key \" + XML_FILE_PARAM); return; } String xmlPath = props.get(XML_FILE_PARAM); File file = new File(xmlPath); if( ! file.exists()) { logger.error(\"Azkaban validator configuration file \" + xmlPath + \" does not exist.\"); return; } DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = null; try { builder = docBuilderFactory.newDocumentBuilder(); } catch(ParserConfigurationException e) { throw new ValidatorManagerException(\"Exception while parsing validator xml. Document builder not created.\", e); } Document doc = null; try { doc = builder.parse(file); } catch(SAXException e) { throw new ValidatorManagerException(\"Exception while parsing \" + xmlPath + \". Invalid XML.\", e); } catch(IOException e) { throw new ValidatorManagerException(\"Exception while parsing \" + xmlPath + \". Error reading file.\", e); } NodeList tagList = doc.getChildNodes(); Node azkabanValidators = tagList.item(0); NodeList azkabanValidatorsList = azkabanValidators.getChildNodes(); for(int i = 0; i < azkabanValidatorsList.getLength(); ++ i) { Node node = azkabanValidatorsList.item(i); if(node.getNodeType() == Node.ELEMENT_NODE) { if(node.getNodeName().equals(VALIDATOR_TAG)) { parseValidatorTag(node, props, log); } } } } ",
        "test_tgt": "@Test public void testLoadValidators() { Props props = new Props(baseProps); URL validatorUrl = Resources.getResource(\"project/testValidators\"); URL configUrl = Resources.getResource(\"test-conf/azkaban-validators-test2.xml\"); props.put(ValidatorConfigs.VALIDATOR_PLUGIN_DIR, validatorUrl.getPath()); props.put(ValidatorConfigs.XML_FILE_PARAM, configUrl.getPath()); XmlValidatorManager manager = new XmlValidatorManager(props); assertEquals(\"XmlValidatorManager should contain 2 validators.\", manager.getValidatorsInfo().size(), 2); assertEquals(\"XmlValidatorManager should contain the validator specified in the xml configuration file.\", manager.getValidatorsInfo().get(1), \"Test\"); } "
    },
    {
        "test_src": "@Test public void testGetConfigurationSchemaVersionsByApplicationId()throws Exception { List < ConfigurationSchemaDto > configurationSchemas = new ArrayList < ConfigurationSchemaDto > (11); ApplicationDto application = createApplication(tenantAdminDto); loginTenantDeveloper(tenantDeveloperDto.getUsername()); List < ConfigurationSchemaDto > defaultConfigurationSchemas = client.getConfigurationSchemas(application.getId()); configurationSchemas.addAll(defaultConfigurationSchemas); for(int i = 0; i < 10; i ++ ) { ConfigurationSchemaDto configurationSchema = createConfigurationSchema(application.getId()); configurationSchemas.add(configurationSchema); } Collections.sort(configurationSchemas, new IdComparator()); SchemaVersions schemaVersions = client.getSchemaVersionsByApplicationId(application.getId()); List < SchemaDto > storedConfigurationSchemas = schemaVersions.getConfigurationSchemaVersions(); Collections.sort(storedConfigurationSchemas, new IdComparator()); Assert.assertEquals(configurationSchemas.size(), storedConfigurationSchemas.size()); for(int i = 0; i < configurationSchemas.size(); i ++ ) { ConfigurationSchemaDto configurationSchema = configurationSchemas.get(i); SchemaDto storedConfigurationSchema = storedConfigurationSchemas.get(i); assertSchemasEquals(configurationSchema, storedConfigurationSchema); } } ",
        "focal_tgt": "List < VersionDto > getConfigurationSchemaVersionsByApplicationId(String applicationId)throws ControlServiceException; ",
        "focal_src": "List < SchemaDto > getConfigurationSchemaVersionsByApplicationId(String applicationId)throws ControlServiceException; ",
        "test_tgt": "@Test public void testGetConfigurationSchemaVersionsByApplicationId()throws Exception { List < ConfigurationSchemaDto > configurationSchemas = new ArrayList < ConfigurationSchemaDto > (11); ApplicationDto application = createApplication(tenantAdminDto); loginTenantDeveloper(tenantDeveloperDto.getUsername()); List < ConfigurationSchemaDto > defaultConfigurationSchemas = client.getConfigurationSchemas(application.getId()); configurationSchemas.addAll(defaultConfigurationSchemas); for(int i = 0; i < 10; i ++ ) { ConfigurationSchemaDto configurationSchema = createConfigurationSchema(application.getId()); configurationSchemas.add(configurationSchema); } Collections.sort(configurationSchemas, new IdComparator()); SchemaVersions schemaVersions = client.getSchemaVersionsByApplicationId(application.getId()); List < VersionDto > storedConfigurationSchemas = schemaVersions.getConfigurationSchemaVersions(); Collections.sort(storedConfigurationSchemas, new IdComparator()); Assert.assertEquals(configurationSchemas.size(), storedConfigurationSchemas.size()); for(int i = 0; i < configurationSchemas.size(); i ++ ) { ConfigurationSchemaDto configurationSchema = configurationSchemas.get(i); VersionDto storedConfigurationSchema = storedConfigurationSchemas.get(i); assertSchemasEquals(configurationSchema, storedConfigurationSchema); } } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should fail validation if startDate after dateStopped\", method = \"validate(Object,Errors)\")public void validate_shouldFailValidationIfStartDateAfterDiscontinuedDate()throws Exception { Order order = new Order(); order.setConcept(Context.getConceptService().getConcept(88)); order.setPatient(Context.getPatientService().getPatient(2)); order.setOrderer(Context.getProviderService().getProvider(1)); Calendar cal = Calendar.getInstance(); cal.set(Calendar.DAY_OF_MONTH, cal.get(Calendar.DAY_OF_MONTH) - 1); order.setStartDate(new Date()); order.setDateStopped(cal.getTime()); Errors errors = new BindException(order, \"order\"); new OrderValidator().validate(order, errors); Assert.assertTrue(errors.hasFieldErrors(\"startDate\")); Assert.assertTrue(errors.hasFieldErrors(\"dateStopped\")); } ",
        "focal_tgt": "public void validate(Object obj, Errors errors) { Order order = (Order)obj; if(order == null) { errors.reject(\"error.general\"); } else { ValidationUtils.rejectIfEmpty(errors, \"voided\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"concept\", \"Concept.noConceptSelected\"); ValidationUtils.rejectIfEmpty(errors, \"patient\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"encounter\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"orderer\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"urgency\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"action\", \"error.null\"); validateSamePatientInOrderAndEncounter(order, errors); validateOrderTypeClass(order, errors); validateStartDate(order, errors); validateScheduledDate(order, errors); } } ",
        "focal_src": "public void validate(Object obj, Errors errors) { Order order = (Order)obj; if(order == null) { errors.rejectValue(\"order\", \"error.general\"); } else { ValidationUtils.rejectIfEmpty(errors, \"voided\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"concept\", \"Concept.noConceptSelected\"); ValidationUtils.rejectIfEmpty(errors, \"patient\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"encounter\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"orderer\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"urgency\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"action\", \"error.null\"); validateSamePatientInOrderAndEncounter(order, errors); validateOrderTypeClass(order, errors); validateStartDate(order, errors); validateScheduledDate(order, errors); } } ",
        "test_tgt": "@Test@Verifies(value = \"should fail validation if startDate after dateStopped\", method = \"validate(Object,Errors)\")public void validate_shouldFailValidationIfStartDateAfterDateStopped()throws Exception { Order order = new Order(); order.setConcept(Context.getConceptService().getConcept(88)); order.setPatient(Context.getPatientService().getPatient(2)); order.setOrderer(Context.getProviderService().getProvider(1)); Calendar cal = Calendar.getInstance(); cal.set(Calendar.DAY_OF_MONTH, cal.get(Calendar.DAY_OF_MONTH) - 1); order.setStartDate(new Date()); order.setDateStopped(cal.getTime()); Errors errors = new BindException(order, \"order\"); new OrderValidator().validate(order, errors); Assert.assertTrue(errors.hasFieldErrors(\"startDate\")); Assert.assertTrue(errors.hasFieldErrors(\"dateStopped\")); } "
    },
    {
        "test_src": "@Test public void getTable()throws Exception { TransformJob pendingJob = Mockito.mock(TransformJob.class); Mockito.when(pendingJob.getGroupId()).thenReturn(\"PendingJob\"); Mockito.when(pendingJob.progress()).thenReturn(0.5); TransformJob successJob = Mockito.mock(TransformJob.class); TransformResponse successResponse = new TransformResponse(); Mockito.when(successJob.get()).thenReturn(successResponse); Mockito.when(successJob.isDone()).thenReturn(true); TransformService transformService = Mockito.mock(TransformService.class); Mockito.when(transformService.getJob(\"PendingJob\")).thenReturn(pendingJob); Mockito.when(transformService.getJob(\"SuccessJob\")).thenReturn(successJob); AbstractTransformController controller = new AbstractTransformController() { }; controller.transformService = transformService; Response response = controller.getTable(\"PendingJob\"); Assert.assertEquals(Response.Status.OK, response.getStatusInfo()); TransformResponse transformResponse = (TransformResponse)response.getEntity(); Assert.assertEquals(0.5, transformResponse.getProgress(), 0.001); Assert.assertEquals(TransformResponse.Status.PENDING, transformResponse.getStatus()); Assert.assertEquals(\"PendingJob\", transformResponse.getTable()); response = controller.getTable(\"SuccessJob\"); Assert.assertEquals(successResponse, response.getEntity()); Assert.assertEquals(Response.Status.OK, response.getStatusInfo()); } ",
        "focal_tgt": "@GET@Path(\"{table}\")@Consumes(MediaType.APPLICATION_JSON)@Produces(MediaType.APPLICATION_JSON)@ApiOperation(\"Fetches the status of a transformation.\")@ApiResponses( { @ApiResponse(code = 200, message = \"Returns the status of the transformation.\", response = TransformResponse.class), @ApiResponse(code = 404, message = \"The transformation does not exist.\", response = TransformResponse.class), @ApiResponse(code = 500, message = \"There was a problem accessing the data.\", response = TransformResponse.class) })@Nonnull public Response getTable(@Nonnull@PathParam(\"table\")final String id) { try { TransformJob job = transformService.getTransformJob(id); if(job.isDone()) { return Response.ok(job.get()).build(); } else { TransformResponse response = new TransformResponse(); response.setProgress(job.progress()); response.setStatus(TransformResponse.Status.PENDING); response.setTable(job.getGroupId()); return Response.ok(response).build(); } } catch(final IllegalArgumentException e) { return error(Response.Status.NOT_FOUND, \"getTable.notFound\"); } catch(final Exception e) { return error(Response.Status.INTERNAL_SERVER_ERROR, e); } } ",
        "focal_src": "@GET@Path(\"{table}\")@Consumes(MediaType.APPLICATION_JSON)@Produces(MediaType.APPLICATION_JSON)@ApiOperation(\"Fetches the status of a transformation.\")@ApiResponses( { @ApiResponse(code = 200, message = \"Returns the status of the transformation.\", response = TransformResponse.class), @ApiResponse(code = 404, message = \"The transformation does not exist.\", response = TransformResponse.class), @ApiResponse(code = 500, message = \"There was a problem accessing the data.\", response = TransformResponse.class) })@Nonnull public Response getTable(@Nonnull@PathParam(\"table\")final String id) { try { TransformJob job = transformService.getJob(id); if(job.isDone()) { return Response.ok(job.get()).build(); } else { TransformResponse response = new TransformResponse(); response.setProgress(job.progress()); response.setStatus(TransformResponse.Status.PENDING); response.setTable(job.getGroupId()); return Response.ok(response).build(); } } catch(final IllegalArgumentException e) { return error(Response.Status.NOT_FOUND, \"getTable.unknownTable\"); } catch(final Exception e) { return error(Response.Status.INTERNAL_SERVER_ERROR, e); } } ",
        "test_tgt": "@Test public void getTable()throws Exception { TransformJob pendingJob = Mockito.mock(TransformJob.class); Mockito.when(pendingJob.getGroupId()).thenReturn(\"PendingJob\"); Mockito.when(pendingJob.progress()).thenReturn(0.5); TransformJob successJob = Mockito.mock(TransformJob.class); TransformResponse successResponse = new TransformResponse(); Mockito.when(successJob.get()).thenReturn(successResponse); Mockito.when(successJob.isDone()).thenReturn(true); TransformService transformService = Mockito.mock(TransformService.class); Mockito.when(transformService.getTransformJob(\"PendingJob\")).thenReturn(pendingJob); Mockito.when(transformService.getTransformJob(\"SuccessJob\")).thenReturn(successJob); AbstractTransformController controller = new AbstractTransformController() { }; controller.transformService = transformService; Response response = controller.getTable(\"PendingJob\"); Assert.assertEquals(Response.Status.OK, response.getStatusInfo()); TransformResponse transformResponse = (TransformResponse)response.getEntity(); Assert.assertEquals(0.5, transformResponse.getProgress(), 0.001); Assert.assertEquals(TransformResponse.Status.PENDING, transformResponse.getStatus()); Assert.assertEquals(\"PendingJob\", transformResponse.getTable()); response = controller.getTable(\"SuccessJob\"); Assert.assertEquals(successResponse, response.getEntity()); Assert.assertEquals(Response.Status.OK, response.getStatusInfo()); } "
    },
    {
        "test_src": "@Test(description = \"GET /vApp/{id}\")public void testGetVm() { vm = vmApi.get(vmURI); checkVm(vm); assertEquals(vm.isDeployed(), Boolean.FALSE, String.format(OBJ_FIELD_EQ, VM, \"deployed\", \"FALSE\", vm.isDeployed().toString())); assertVmStatus(vm.getHref(), Status.POWERED_OFF); } ",
        "focal_tgt": "@GET@Consumes(VM)@JAXBResponseParser@ExceptionParser(ReturnNullOnNotFoundOr404.class)ListenableFuture < Vm > get(@EndpointParam(parser = VmURNToHref.class)String vmUrn); ",
        "focal_src": "@GET@Consumes(VM)@JAXBResponseParser@ExceptionParser(ReturnNullOnNotFoundOr404.class)ListenableFuture < Vm > getVm(@EndpointParam URI vmURI); ",
        "test_tgt": "@Test(description = \"GET /vApp/{id}\")public void testGetVm() { vm = vmApi.get(vmUrn); checkVm(vm); assertEquals(vm.isDeployed(), Boolean.FALSE, String.format(OBJ_FIELD_EQ, VM, \"deployed\", \"FALSE\", vm.isDeployed().toString())); assertVmStatus(vmUrn, Status.POWERED_OFF); } "
    },
    {
        "test_src": "@Test public void deleteFileTest()throws Exception { Assert.assertFalse(mFileSystemMaster.deleteFile(ROOT_URI, true)); long blockId = createFileWithSingleBlock(NESTED_FILE_URI); Assert.assertTrue(mFileSystemMaster.deleteFile(NESTED_FILE_URI, false)); mThrown.expect(BlockInfoException.class); mBlockMaster.getBlockInfo(blockId); Command heartBeat1 = mBlockMaster.workerHeartbeat(mWorkerId1, ImmutableMap.of(\"MEM\", Constants.KB * 1L), ImmutableList.of(blockId), ImmutableMap. < String, List < Long > > of()); Assert.assertEquals(new Command(CommandType.Nothing, ImmutableList. < Long > of()), heartBeat1); Assert.assertFalse(mBlockMaster.getLostBlocks().contains(blockId)); Assert.assertEquals(IdUtils.INVALID_FILE_ID, mFileSystemMaster.getFileId(NESTED_FILE_URI)); } ",
        "focal_tgt": "public boolean delete(AlluxioURI path, boolean recursive)throws IOException, FileDoesNotExistException, DirectoryNotEmptyException, InvalidPathException, AccessControlException { MasterContext.getMasterSource().incDeletePathOps(1); synchronized(mInodeTree) { mPermissionChecker.checkParentPermission(FileSystemAction.WRITE, path); mMountTable.checkUnderWritableMountPoint(path); Inode < ? > inode = mInodeTree.getInodeByPath(path); long fileId = inode.getId(); long opTimeMs = System.currentTimeMillis(); boolean ret = deleteInternal(fileId, recursive, false, opTimeMs); DeleteFileEntry deleteFile = DeleteFileEntry.newBuilder().setId(fileId).setRecursive(recursive).setOpTimeMs(opTimeMs).build(); writeJournalEntry(JournalEntry.newBuilder().setDeleteFile(deleteFile).build()); flushJournal(); return ret; } } ",
        "focal_src": "public boolean deleteFile(AlluxioURI path, boolean recursive)throws IOException, FileDoesNotExistException, DirectoryNotEmptyException, InvalidPathException, AccessControlException { MasterContext.getMasterSource().incDeletePathOps(1); synchronized(mInodeTree) { checkPermission(FileSystemAction.WRITE, path, true); mMountTable.checkUnderWritableMountPoint(path); Inode < ? > inode = mInodeTree.getInodeByPath(path); long fileId = inode.getId(); long opTimeMs = System.currentTimeMillis(); boolean ret = deleteFileInternal(fileId, recursive, false, opTimeMs); DeleteFileEntry deleteFile = DeleteFileEntry.newBuilder().setId(fileId).setRecursive(recursive).setOpTimeMs(opTimeMs).build(); writeJournalEntry(JournalEntry.newBuilder().setDeleteFile(deleteFile).build()); flushJournal(); return ret; } } ",
        "test_tgt": "@Test public void deleteFileTest()throws Exception { Assert.assertFalse(mFileSystemMaster.delete(ROOT_URI, true)); long blockId = createFileWithSingleBlock(NESTED_FILE_URI); Assert.assertTrue(mFileSystemMaster.delete(NESTED_FILE_URI, false)); mThrown.expect(BlockInfoException.class); mBlockMaster.getBlockInfo(blockId); Command heartBeat1 = mBlockMaster.workerHeartbeat(mWorkerId1, ImmutableMap.of(\"MEM\", Constants.KB * 1L), ImmutableList.of(blockId), ImmutableMap. < String, List < Long > > of()); Assert.assertEquals(new Command(CommandType.Nothing, ImmutableList. < Long > of()), heartBeat1); Assert.assertFalse(mBlockMaster.getLostBlocks().contains(blockId)); Assert.assertEquals(IdUtils.INVALID_FILE_ID, mFileSystemMaster.getFileId(NESTED_FILE_URI)); } "
    },
    {
        "test_src": "@Test(groups = \"slow\", description = \"Verify we don't insert duplicate blocking states\")public void testSetBlockingState()throws Exception { final UUID blockableId = UUID.randomUUID(); final BlockingStateType type = BlockingStateType.ACCOUNT; final String state = \"state\"; final String state2 = \"state-2\"; final String serviceA = \"service-A\"; final String serviceB = \"service-B\"; Assert.assertEquals(blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext).size(), 0); final DateTime stateDateTime = new DateTime(2013, 5, 6, 10, 11, 12, DateTimeZone.UTC); final BlockingState blockingState1 = new DefaultBlockingState(blockableId, type, state, serviceA, false, false, false, stateDateTime); blockingStateDao.setBlockingState(blockingState1, internalCallContext); final List < BlockingState > blockingStates1 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates1.size(), 1); Assert.assertEquals(blockingStates1.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates1.get(0).getStateName(), state); Assert.assertEquals(blockingStates1.get(0).getService(), serviceA); Assert.assertEquals(blockingStates1.get(0).getEffectiveDate(), stateDateTime); blockingStateDao.setBlockingState(blockingState1, internalCallContext); final List < BlockingState > blockingStates2 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates2.size(), 1); Assert.assertEquals(blockingStates2.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates2.get(0).getStateName(), state); Assert.assertEquals(blockingStates2.get(0).getService(), serviceA); Assert.assertEquals(blockingStates2.get(0).getEffectiveDate(), stateDateTime); final BlockingState blockingState2 = new DefaultBlockingState(blockableId, type, state, serviceB, false, false, false, stateDateTime); blockingStateDao.setBlockingState(blockingState2, internalCallContext); final List < BlockingState > blockingStates3 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates3.size(), 2); Assert.assertEquals(blockingStates3.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates3.get(0).getStateName(), state); Assert.assertEquals(blockingStates3.get(0).getService(), serviceA); Assert.assertEquals(blockingStates3.get(0).getEffectiveDate(), stateDateTime); Assert.assertEquals(blockingStates3.get(1).getBlockedId(), blockableId); Assert.assertEquals(blockingStates3.get(1).getStateName(), state); Assert.assertEquals(blockingStates3.get(1).getService(), serviceB); Assert.assertEquals(blockingStates3.get(1).getEffectiveDate(), stateDateTime); final DateTime stateDateTime2 = new DateTime(2013, 6, 6, 10, 11, 12, DateTimeZone.UTC); final BlockingState blockingState3 = new DefaultBlockingState(blockableId, type, state, serviceA, false, false, false, stateDateTime2); blockingStateDao.setBlockingState(blockingState3, internalCallContext); final List < BlockingState > blockingStates4 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates4.size(), 2); Assert.assertEquals(blockingStates4.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates4.get(0).getStateName(), state); Assert.assertEquals(blockingStates4.get(0).getService(), serviceA); Assert.assertEquals(blockingStates4.get(0).getEffectiveDate(), stateDateTime); Assert.assertEquals(blockingStates4.get(1).getBlockedId(), blockableId); Assert.assertEquals(blockingStates4.get(1).getStateName(), state); Assert.assertEquals(blockingStates4.get(1).getService(), serviceB); Assert.assertEquals(blockingStates4.get(1).getEffectiveDate(), stateDateTime); final DateTime stateDateTime3 = new DateTime(2013, 2, 6, 10, 11, 12, DateTimeZone.UTC); final BlockingState blockingState4 = new DefaultBlockingState(blockableId, type, state, serviceA, false, false, false, stateDateTime3); blockingStateDao.setBlockingState(blockingState4, internalCallContext); final List < BlockingState > blockingStates5 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates5.size(), 2); Assert.assertEquals(blockingStates5.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates5.get(0).getStateName(), state); Assert.assertEquals(blockingStates5.get(0).getService(), serviceA); Assert.assertEquals(blockingStates5.get(0).getEffectiveDate(), stateDateTime3); Assert.assertEquals(blockingStates5.get(1).getBlockedId(), blockableId); Assert.assertEquals(blockingStates5.get(1).getStateName(), state); Assert.assertEquals(blockingStates5.get(1).getService(), serviceB); Assert.assertEquals(blockingStates5.get(1).getEffectiveDate(), stateDateTime); final DateTime state2DateTime = new DateTime(2013, 12, 6, 10, 11, 12, DateTimeZone.UTC); final BlockingState blockingState5 = new DefaultBlockingState(blockableId, type, state2, serviceA, false, false, false, state2DateTime); blockingStateDao.setBlockingState(blockingState5, internalCallContext); final List < BlockingState > blockingStates6 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates6.size(), 3); Assert.assertEquals(blockingStates6.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates6.get(0).getStateName(), state); Assert.assertEquals(blockingStates6.get(0).getService(), serviceA); Assert.assertEquals(blockingStates6.get(0).getEffectiveDate(), stateDateTime3); Assert.assertEquals(blockingStates6.get(1).getBlockedId(), blockableId); Assert.assertEquals(blockingStates6.get(1).getStateName(), state); Assert.assertEquals(blockingStates6.get(1).getService(), serviceB); Assert.assertEquals(blockingStates6.get(1).getEffectiveDate(), stateDateTime); Assert.assertEquals(blockingStates6.get(2).getBlockedId(), blockableId); Assert.assertEquals(blockingStates6.get(2).getStateName(), state2); Assert.assertEquals(blockingStates6.get(2).getService(), serviceA); Assert.assertEquals(blockingStates6.get(2).getEffectiveDate(), state2DateTime); } ",
        "focal_tgt": "public void setBlockingStateAndPostBlockingTransitionEvent(BlockingState state, UUID bundleId, InternalCallContext context); ",
        "focal_src": "public void setBlockingState(BlockingState state, InternalCallContext context); ",
        "test_tgt": "@Test(groups = \"slow\", description = \"Verify we don't insert duplicate blocking states\")public void testSetBlockingState()throws Exception { final UUID blockableId = UUID.randomUUID(); final BlockingStateType type = BlockingStateType.ACCOUNT; final String state = \"state\"; final String state2 = \"state-2\"; final String serviceA = \"service-A\"; final String serviceB = \"service-B\"; Assert.assertEquals(blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext).size(), 0); final DateTime stateDateTime = new DateTime(2013, 5, 6, 10, 11, 12, DateTimeZone.UTC); final BlockingState blockingState1 = new DefaultBlockingState(blockableId, type, state, serviceA, false, false, false, stateDateTime); blockingStateDao.setBlockingStateAndPostBlockingTransitionEvent(blockingState1, null, internalCallContext); final List < BlockingState > blockingStates1 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates1.size(), 1); Assert.assertEquals(blockingStates1.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates1.get(0).getStateName(), state); Assert.assertEquals(blockingStates1.get(0).getService(), serviceA); Assert.assertEquals(blockingStates1.get(0).getEffectiveDate(), stateDateTime); blockingStateDao.setBlockingStateAndPostBlockingTransitionEvent(blockingState1, null, internalCallContext); final List < BlockingState > blockingStates2 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates2.size(), 1); Assert.assertEquals(blockingStates2.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates2.get(0).getStateName(), state); Assert.assertEquals(blockingStates2.get(0).getService(), serviceA); Assert.assertEquals(blockingStates2.get(0).getEffectiveDate(), stateDateTime); final BlockingState blockingState2 = new DefaultBlockingState(blockableId, type, state, serviceB, false, false, false, stateDateTime); blockingStateDao.setBlockingStateAndPostBlockingTransitionEvent(blockingState2, null, internalCallContext); final List < BlockingState > blockingStates3 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates3.size(), 2); Assert.assertEquals(blockingStates3.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates3.get(0).getStateName(), state); Assert.assertEquals(blockingStates3.get(0).getService(), serviceA); Assert.assertEquals(blockingStates3.get(0).getEffectiveDate(), stateDateTime); Assert.assertEquals(blockingStates3.get(1).getBlockedId(), blockableId); Assert.assertEquals(blockingStates3.get(1).getStateName(), state); Assert.assertEquals(blockingStates3.get(1).getService(), serviceB); Assert.assertEquals(blockingStates3.get(1).getEffectiveDate(), stateDateTime); final DateTime stateDateTime2 = new DateTime(2013, 6, 6, 10, 11, 12, DateTimeZone.UTC); final BlockingState blockingState3 = new DefaultBlockingState(blockableId, type, state, serviceA, false, false, false, stateDateTime2); blockingStateDao.setBlockingStateAndPostBlockingTransitionEvent(blockingState3, null, internalCallContext); final List < BlockingState > blockingStates4 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates4.size(), 2); Assert.assertEquals(blockingStates4.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates4.get(0).getStateName(), state); Assert.assertEquals(blockingStates4.get(0).getService(), serviceA); Assert.assertEquals(blockingStates4.get(0).getEffectiveDate(), stateDateTime); Assert.assertEquals(blockingStates4.get(1).getBlockedId(), blockableId); Assert.assertEquals(blockingStates4.get(1).getStateName(), state); Assert.assertEquals(blockingStates4.get(1).getService(), serviceB); Assert.assertEquals(blockingStates4.get(1).getEffectiveDate(), stateDateTime); final DateTime stateDateTime3 = new DateTime(2013, 2, 6, 10, 11, 12, DateTimeZone.UTC); final BlockingState blockingState4 = new DefaultBlockingState(blockableId, type, state, serviceA, false, false, false, stateDateTime3); blockingStateDao.setBlockingStateAndPostBlockingTransitionEvent(blockingState4, null, internalCallContext); final List < BlockingState > blockingStates5 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates5.size(), 2); Assert.assertEquals(blockingStates5.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates5.get(0).getStateName(), state); Assert.assertEquals(blockingStates5.get(0).getService(), serviceA); Assert.assertEquals(blockingStates5.get(0).getEffectiveDate(), stateDateTime3); Assert.assertEquals(blockingStates5.get(1).getBlockedId(), blockableId); Assert.assertEquals(blockingStates5.get(1).getStateName(), state); Assert.assertEquals(blockingStates5.get(1).getService(), serviceB); Assert.assertEquals(blockingStates5.get(1).getEffectiveDate(), stateDateTime); final DateTime state2DateTime = new DateTime(2013, 12, 6, 10, 11, 12, DateTimeZone.UTC); final BlockingState blockingState5 = new DefaultBlockingState(blockableId, type, state2, serviceA, false, false, false, state2DateTime); blockingStateDao.setBlockingStateAndPostBlockingTransitionEvent(blockingState5, null, internalCallContext); final List < BlockingState > blockingStates6 = blockingStateDao.getBlockingAllForAccountRecordId(internalCallContext); Assert.assertEquals(blockingStates6.size(), 3); Assert.assertEquals(blockingStates6.get(0).getBlockedId(), blockableId); Assert.assertEquals(blockingStates6.get(0).getStateName(), state); Assert.assertEquals(blockingStates6.get(0).getService(), serviceA); Assert.assertEquals(blockingStates6.get(0).getEffectiveDate(), stateDateTime3); Assert.assertEquals(blockingStates6.get(1).getBlockedId(), blockableId); Assert.assertEquals(blockingStates6.get(1).getStateName(), state); Assert.assertEquals(blockingStates6.get(1).getService(), serviceB); Assert.assertEquals(blockingStates6.get(1).getEffectiveDate(), stateDateTime); Assert.assertEquals(blockingStates6.get(2).getBlockedId(), blockableId); Assert.assertEquals(blockingStates6.get(2).getStateName(), state2); Assert.assertEquals(blockingStates6.get(2).getService(), serviceA); Assert.assertEquals(blockingStates6.get(2).getEffectiveDate(), state2DateTime); } "
    },
    {
        "test_src": "@Test public void testEquals() { DependencyVersion obj = new DependencyVersion(\"1.2.3.r1\"); DependencyVersion instance = new DependencyVersion(\"1.2.3\"); boolean expResult = false; boolean result = instance.equals(obj); assertEquals(expResult, result); obj = new DependencyVersion(\"1.2.3\"); expResult = true; result = instance.equals(obj); assertEquals(expResult, result); } ",
        "focal_tgt": "@Override public boolean equals(Object obj) { if(obj == null) { return false; } if(getClass() != obj.getClass()) { return false; } final DependencyVersion other = (DependencyVersion)obj; final int minVersionMatchLength = (this.versionParts.size() < other.versionParts.size()) ? this.versionParts.size() : other.versionParts.size(); final int maxVersionMatchLength = (this.versionParts.size() > other.versionParts.size()) ? this.versionParts.size() : other.versionParts.size(); if(minVersionMatchLength == 1 && maxVersionMatchLength >= 3) { return false; } for(int i = 0; i < minVersionMatchLength; i ++ ) { final String thisPart = this.versionParts.get(i); final String otherPart = other.versionParts.get(i); if( ! thisPart.equals(otherPart)) { return false; } } if(this.versionParts.size() > minVersionMatchLength) { for(int i = minVersionMatchLength; i < this.versionParts.size(); i ++ ) { if( ! \"0\".equals(this.versionParts.get(i))) { return false; } } } if(other.versionParts.size() > minVersionMatchLength) { for(int i = minVersionMatchLength; i < other.versionParts.size(); i ++ ) { if( ! \"0\".equals(other.versionParts.get(i))) { return false; } } } return true; } ",
        "focal_src": "@Override public boolean equals(Object obj) { if(obj == null) { return false; } if(getClass() != obj.getClass()) { return false; } final DependencyVersion other = (DependencyVersion)obj; final int max = (this.versionParts.size() < other.versionParts.size()) ? this.versionParts.size() : other.versionParts.size(); for(int i = 0; i < max; i ++ ) { final String thisPart = this.versionParts.get(i); final String otherPart = other.versionParts.get(i); if( ! thisPart.equals(otherPart)) { return false; } } if(this.versionParts.size() > max) { for(int i = max; i < this.versionParts.size(); i ++ ) { if( ! \"0\".equals(this.versionParts.get(i))) { return false; } } } if(other.versionParts.size() > max) { for(int i = max; i < other.versionParts.size(); i ++ ) { if( ! \"0\".equals(other.versionParts.get(i))) { return false; } } } return true; } ",
        "test_tgt": "@Test public void testEquals() { DependencyVersion obj = new DependencyVersion(\"1.2.3.r1\"); DependencyVersion instance = new DependencyVersion(\"1.2.3\"); boolean expResult = false; boolean result = instance.equals(obj); assertEquals(expResult, result); obj = new DependencyVersion(\"1.2.3\"); expResult = true; result = instance.equals(obj); assertEquals(expResult, result); instance = new DependencyVersion(\"2.0.0\"); obj = new DependencyVersion(\"2\"); expResult = false; result = instance.equals(obj); assertEquals(expResult, result); obj = new DependencyVersion(\"2.0\"); expResult = true; result = instance.equals(obj); assertEquals(expResult, result); } "
    },
    {
        "test_src": "@Test public void testRunInBackground()throws Exception { final ActionResource.RunnableAction runnableAction = Mockito.spy(ActionResource.RunnableAction.class); Mockito.doReturn(runnableAction).when(resourceMock).createRunnable(actionId, actionClassName, actionUser, actionParams); resourceMock.runInBackground(actionId, actionClassName, actionUser, actionParams); Mockito.verify(resourceMock, Mockito.times(1)).createRunnable(actionId, actionClassName, actionUser, actionParams); Mockito.verify(resourceMock.executorService, Mockito.times(1)).submit(runnableAction); } ",
        "focal_tgt": "@POST@Path(\"/invoke\")@Consumes( { TEXT_PLAIN })@StatusCodes( { @ResponseCode(code = 200, condition = \"Action invoked successfully.\"), @ResponseCode(code = 400, condition = \"Bad input - could not invoke action.\"), @ResponseCode(code = 401, condition = \"User does not have permissions to invoke action\"), @ResponseCode(code = 500, condition = \"Error while retrieving system resources.\"), })public Response invokeAction(@QueryParam(ActionUtil.INVOKER_ASYNC_EXEC)@DefaultValue(ActionUtil.INVOKER_DEFAULT_ASYNC_EXEC_VALUE)String async, @QueryParam(ActionUtil.INVOKER_ACTIONID)String actionId, @QueryParam(ActionUtil.INVOKER_ACTIONCLASS)String actionClass, @QueryParam(ActionUtil.INVOKER_ACTIONUSER)String actionUser, final String actionParams) { boolean isAsyncExecution = Boolean.parseBoolean(async); int httpStatus = HttpStatus.SC_INTERNAL_SERVER_ERROR; if(isAsyncExecution) { executorService.submit(createCallable(actionId, actionClass, actionUser, actionParams)); httpStatus = HttpStatus.SC_ACCEPTED; } else { try { IActionInvokeStatus status = createCallable(actionId, actionClass, actionUser, actionParams).call(); httpStatus = (status != null && status.getThrowable() == null) ? HttpStatus.SC_OK : HttpStatus.SC_INTERNAL_SERVER_ERROR; } catch(Throwable t) { getLogger().error(t); } } return Response.status(httpStatus).build(); } ",
        "focal_src": "@POST@Path(\"/runInBackground\")@Consumes( { TEXT_PLAIN })@StatusCodes( { @ResponseCode(code = 200, condition = \"Action invoked successfully.\"), @ResponseCode(code = 400, condition = \"Bad input - could not invoke action.\"), @ResponseCode(code = 401, condition = \"User does not have permissions to invoke action\"), @ResponseCode(code = 500, condition = \"Error while retrieving system resources.\"), })public Response runInBackground(@QueryParam(ActionUtil.INVOKER_ACTIONID)String actionId, @QueryParam(ActionUtil.INVOKER_ACTIONCLASS)String actionClass, @QueryParam(ActionUtil.INVOKER_ACTIONUSER)String actionUser, final String actionParams) { executorService.submit(createRunnable(actionId, actionClass, actionUser, actionParams)); return Response.status(HttpStatus.SC_ACCEPTED).build(); } ",
        "test_tgt": "@Test public void testRunInBackground()throws Exception { final ActionResource.CallableAction runnableAction = Mockito.spy(ActionResource.CallableAction.class); Mockito.doReturn(runnableAction).when(resourceMock).createCallable(actionId, actionClassName, actionUser, actionParams); resourceMock.invokeAction(ActionUtil.INVOKER_DEFAULT_ASYNC_EXEC_VALUE, actionId, actionClassName, actionUser, actionParams); Mockito.verify(resourceMock, Mockito.times(1)).createCallable(actionId, actionClassName, actionUser, actionParams); Mockito.verify(resourceMock.executorService, Mockito.times(1)).submit(runnableAction); } "
    },
    {
        "test_src": "@Test public void readPrefixAsMap() { Map < String, String > map = ResourceBundleUtil.readPrefixAsMap(BASE_NAME, \"FileType\", \"\\\\.\", Locale.CHINA); LOGGER.info(JsonUtil.format(map)); } ",
        "focal_tgt": "public static Map < String, String > readPrefixAsMap(String baseName, String prefix, String delimiters, Locale locale) { Map < String, String > propertyMap = readAllPropertiesToMap(baseName, locale); if(Validator.isNullOrEmpty(propertyMap)) { return Collections.emptyMap(); } Map < String, String > result = new TreeMap < String, String > (); for(Map.Entry < String, String > entry : propertyMap.entrySet()) { String key = entry.getKey(); String value = entry.getValue(); if(key.startsWith(prefix)) { String[]values = StringUtil.tokenizeToStringArray(key, delimiters); if(values.length >= 2) { result.put(values[1], value); } } } return result; } ",
        "focal_src": "public static Map < String, String > readPrefixAsMap(String baseName, String prefix, String spliter, Locale locale) { Map < String, String > propertyMap = readAllPropertiesToMap(baseName, locale); if(Validator.isNullOrEmpty(propertyMap)) { return Collections.emptyMap(); } Map < String, String > result = new HashMap < String, String > (); for(Map.Entry < String, String > entry : propertyMap.entrySet()) { String key = entry.getKey(); String value = entry.getValue(); if(key.startsWith(prefix)) { String[]values = key.split(spliter); if(values.length >= 2) { result.put(values[1], value); } } } return result; } ",
        "test_tgt": "@Test public void readPrefixAsMap() { Map < String, String > map = ResourceBundleUtil.readPrefixAsMap(BASE_NAME, \"FileType\", \".\", Locale.CHINA); LOGGER.info(JsonUtil.format(map)); } "
    },
    {
        "test_src": "@Test public void testAddCommand_String_int()throws Exception { System.out.println(\"addCommand\"); GcodeParser instance = new GcodeParser(); List < PointSegment > results = instance.addCommand(\"G20 G0X1F150\", 123); testCommand(results, 1, 150, 1., 0., 0., true, false, false, false, false, 123); } ",
        "focal_tgt": "@Override public List < GcodeMeta > addCommand(String command)throws GcodeParserException { return addCommand(command, ++ this.state.commandNumber); } ",
        "focal_src": "@Override public List < PointSegment > addCommand(String command)throws GcodeParserException { return addCommand(command, ++ this.state.commandNumber); } ",
        "test_tgt": "@Test public void testAddCommand_String_int()throws Exception { System.out.println(\"addCommand\"); GcodeParser instance = new GcodeParser(); List < GcodeMeta > results = instance.addCommand(\"G20 G0X1F150\", 123); testCommand(results, 1, 150, 1., 0., 0., true, false, false, false, false, 123); } "
    },
    {
        "test_src": "@Test public void testStatusStringListener() { System.out.println(\"statusStringListener\"); String state = \"\"; Point3d machineCoord = null; Point3d workCoord = null; GUIBackend instance = new GUIBackend(); instance.statusStringListener(state, machineCoord, workCoord); fail(\"The test case is a prototype.\"); } ",
        "focal_tgt": "void statusStringListener(String state, Position machineCoord, Position workCoord); ",
        "focal_src": "void statusStringListener(String state, Point3d machineCoord, Point3d workCoord); ",
        "test_tgt": "@Test public void testStatusStringListener() { System.out.println(\"statusStringListener\"); String state = \"\"; Position machineCoord = null; Position workCoord = null; GUIBackend instance = new GUIBackend(); instance.statusStringListener(state, machineCoord, workCoord); fail(\"The test case is a prototype.\"); } "
    },
    {
        "test_src": "@Test public void testGetProfileMeasurements()throws Exception { Collection < ProfileMeasurement > pms = profiler.getProfileMeasurements(); assertNotNull(pms); assertEquals(4, pms.size()); } ",
        "focal_tgt": "public final ProfileMeasurement[]getProfileMeasurements() { if(pm_cache == null) { synchronized(this) { if(pm_cache == null) { final List < ProfileMeasurement > temp = new ArrayList < ProfileMeasurement > (); for(Field f : this.getClass().getDeclaredFields()) { int modifiers = f.getModifiers(); if(Modifier.isTransient(modifiers) == false && Modifier.isPrivate(modifiers) == false && Modifier.isStatic(modifiers) == false) { Object obj = null; try { obj = f.get(this); } catch(Exception ex) { throw new RuntimeException(\"Failed to get value for field '\" + f.getName() + \"'\", ex); } if(obj instanceof ProfileMeasurement)temp.add((ProfileMeasurement)obj); } } pm_cache = temp.toArray(new ProfileMeasurement[temp.size()]); } } } return(pm_cache); } ",
        "focal_src": "public Collection < ProfileMeasurement > getProfileMeasurements() { List < ProfileMeasurement > ret = new ArrayList < ProfileMeasurement > (); for(Field f : this.getClass().getDeclaredFields()) { Object obj = null; try { obj = f.get(this); } catch(Exception ex) { throw new RuntimeException(\"Failed to get value for field '\" + f.getName() + \"'\", ex); } if(obj instanceof ProfileMeasurement) { ret.add((ProfileMeasurement)obj); } } return(ret); } ",
        "test_tgt": "@Test public void testGetProfileMeasurements()throws Exception { ProfileMeasurement pms[] = profiler.getProfileMeasurements(); assertNotNull(pms); assertEquals(4, pms.length); for(int i = 0; i < pms.length; i ++ ) { assertNotNull(Integer.toString(i), pms[i]); } } "
    },
    {
        "test_src": "@Test public void testShuffle() { TestUtils.log(this.getClass(), \"shuffle\"); RandomValue.setRandomGenerator(new Random(TestConfiguration.RANDOM_SEED)); Integer[]result = { 1, 2, 3, 4, 5 }; Integer[]expResult = { 2, 3, 4, 5, 1 }; PHPfunctions.shuffle(result); assertArrayEquals(expResult, result); } ",
        "focal_tgt": "public static < T > void shuffle(T[]array) { RandomSingleton rnd = RandomSingleton.getInstance(); T tmp; for(int i = array.length - 1; i > 0; -- i) { int index = rnd.nextInt(i + 1); tmp = array[index]; array[index] = array[i]; array[i] = tmp; } } ",
        "focal_src": "public static < T > void shuffle(T[]array) { Random rnd = RandomValue.getRandomGenerator(); T tmp; for(int i = array.length - 1; i > 0; -- i) { int index = rnd.nextInt(i + 1); tmp = array[index]; array[index] = array[i]; array[i] = tmp; } } ",
        "test_tgt": "@Test public void testShuffle() { TestUtils.log(this.getClass(), \"shuffle\"); RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED); Integer[]result = { 1, 2, 3, 4, 5 }; Integer[]expResult = { 2, 3, 4, 5, 1 }; PHPfunctions.shuffle(result); assertArrayEquals(expResult, result); } "
    },
    {
        "test_src": "@Test public void getPartitionProperties() { for(String partitionId : expectedPartitionIds) { StepVerifier.create(client.getPartitionProperties(partitionId)).assertNext(properties -> { Assert.assertEquals(eventHubPath, properties.eventHubPath()); Assert.assertEquals(partitionId, properties.id()); }).verifyComplete(); } } ",
        "focal_tgt": "@Override public Mono < PartitionProperties > getPartitionProperties(String partitionId) { final Map < String, Object > properties = new HashMap < > (); properties.put(MANAGEMENT_ENTITY_TYPE_KEY, MANAGEMENT_PARTITION_ENTITY_TYPE); properties.put(MANAGEMENT_ENTITY_NAME_KEY, eventHubName); properties.put(MANAGEMENT_PARTITION_NAME_KEY, partitionId); properties.put(MANAGEMENT_OPERATION_KEY, READ_OPERATION_VALUE); return getProperties(properties, mapper :: toPartitionProperties); } ",
        "focal_src": "@Override public Mono < PartitionProperties > getPartitionProperties(String partitionId) { final Map < String, Object > properties = new HashMap < > (); properties.put(MANAGEMENT_ENTITY_TYPE_KEY, MANAGEMENT_PARTITION_ENTITY_TYPE); properties.put(MANAGEMENT_ENTITY_NAME_KEY, eventHubPath); properties.put(MANAGEMENT_PARTITION_NAME_KEY, partitionId); properties.put(MANAGEMENT_OPERATION_KEY, READ_OPERATION_VALUE); return getProperties(properties, mapper :: toPartitionProperties); } ",
        "test_tgt": "@Test public void getPartitionProperties() { for(String partitionId : expectedPartitionIds) { StepVerifier.create(client.getPartitionProperties(partitionId)).assertNext(properties -> { Assert.assertEquals(eventHubName, properties.eventHubName()); Assert.assertEquals(partitionId, properties.id()); }).verifyComplete(); } } "
    },
    {
        "test_src": "@Test public void testFindByProperties() { List list = Collections.singletonList(instance); Map props = Collections.singletonMap(\"name\", \"abc\"); when(repository.findByProperties(MyEntity.class, props)).thenReturn(list); assertEquals(list, AbstractEntity.findByProperties(MyEntity.class, props)); } ",
        "focal_tgt": "public static < T extends Entity > List < T > findByProperties(Class < T > clazz, Map < String, Object > propValues) { return getRepository().findByProperties(clazz, MapParameters.create(propValues)); } ",
        "focal_src": "public static < T extends Entity > List < T > findByProperties(Class < T > clazz, Map < String, Object > propValues) { return getRepository().findByProperties(clazz, propValues); } ",
        "test_tgt": "@Test public void testFindByProperties() { List list = Collections.singletonList(instance); Map props = Collections.singletonMap(\"name\", \"abc\"); when(repository.findByProperties(MyEntity.class, MapParameters.create(props))).thenReturn(list); assertEquals(list, AbstractEntity.findByProperties(MyEntity.class, props)); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should not allow deleting an order frequency that is in use\", method = \"purgeOrderFrequency(OrderFrequency)\")public void purgeOrderFrequency_shouldNotAllowDeletingAnOrderFrequencyThatIsInUse()throws Exception { OrderFrequency orderFrequency = orderService.getOrderFrequency(1); assertNotNull(orderFrequency); expectedException.expect(APIException.class); expectedException.expectMessage(\"Order.frequency.cannot.delete\"); orderService.purgeOrderFrequency(orderFrequency); } ",
        "focal_tgt": "@Override public void purgeOrderFrequency(OrderFrequency orderFrequency) { if(dao.isOrderFrequencyInUse(orderFrequency)) { throw CannotDeleteOrderPropertyInUseException.withProperty(\"frequency\"); } dao.purgeOrderFrequency(orderFrequency); } ",
        "focal_src": "@Override public void purgeOrderFrequency(OrderFrequency orderFrequency) { if(dao.isOrderFrequencyInUse(orderFrequency)) { throw new APIException(\"Order.frequency.cannot.delete\"); } dao.purgeOrderFrequency(orderFrequency); } ",
        "test_tgt": "@Test@Verifies(value = \"should not allow deleting an order frequency that is in use\", method = \"purgeOrderFrequency(OrderFrequency)\")public void purgeOrderFrequency_shouldNotAllowDeletingAnOrderFrequencyThatIsInUse()throws Exception { OrderFrequency orderFrequency = orderService.getOrderFrequency(1); assertNotNull(orderFrequency); expectedException.expect(CannotDeleteOrderPropertyInUseException.class); expectedException.expectMessage(\"Order.frequency.cannot.delete\"); orderService.purgeOrderFrequency(orderFrequency); } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void now_Clock() { Instant instant = OffsetDateTime.of(2010, 12, 31, 0, 0, ZoneOffset.UTC).toInstant(); Clock clock = Clock.fixed(instant, ZoneId.UTC); YearMonth test = YearMonth.now(clock); assertEquals(test.getYear(), 2010); assertEquals(test.getMonthOfYear(), Month.DECEMBER); } ",
        "focal_tgt": "public static MonthDay now(Clock clock) { final LocalDate now = LocalDate.now(clock); return MonthDay.of(now.getMonth(), now.getDayOfMonth()); } ",
        "focal_src": "public static MonthDay now(Clock clock) { final LocalDate now = LocalDate.now(clock); return MonthDay.of(now.getMonthOfYear(), now.getDayOfMonth()); } ",
        "test_tgt": "@Test(groups = { \"tck\" })public void now_Clock() { Instant instant = OffsetDateTime.of(2010, 12, 31, 0, 0, ZoneOffset.UTC).toInstant(); Clock clock = Clock.fixed(instant, ZoneId.UTC); YearMonth test = YearMonth.now(clock); assertEquals(test.getYear(), 2010); assertEquals(test.getMonth(), Month.DECEMBER); } "
    },
    {
        "test_src": "@Test public void testPutMetricData()throws Exception { CloudWatchClient client = createMock(CloudWatchClient.class); MetricClient metricClient = createMock(MetricClient.class); Set < MetricDatum > metrics = Sets.newLinkedHashSet(); String namespace = \"JCLOUDS/Test\"; for(int i = 0; i < 11; i ++ ) { metrics.add(MetricDatum.builder().build()); } expect(client.getMetricClientForRegion(EasyMock.eq(\"\"))).andReturn(metricClient).atLeastOnce(); metricClient.putMetricData(metrics, namespace); expectLastCall().times(2); EasyMock.replay(client, metricClient); CloudWatch.putMetricData(client, \"\", metrics, namespace); EasyMock.verify(metricClient); } ",
        "focal_tgt": "public static void putMetricData(CloudWatchClient cloudWatchClient, String region, Iterable < MetricDatum > metrics, String namespace) { MetricClient metricClient = cloudWatchClient.getMetricClientForRegion(region); for(List < MetricDatum > slice : Iterables.partition(metrics, 10)) { metricClient.putMetricData(slice, namespace); } } ",
        "focal_src": "public static void putMetricData(CloudWatchClient cloudWatchClient, String region, Iterable < MetricDatum > metrics, String namespace) { MetricClient metricClient = cloudWatchClient.getMetricClientForRegion(region); Iterator < MetricDatum > mIterator = metrics.iterator(); Set < MetricDatum > metricsData = Sets.newLinkedHashSet(); while(mIterator.hasNext()) { metricsData.add(mIterator.next()); if(metricsData.size() == 10 || ! mIterator.hasNext()) { metricClient.putMetricData(metrics, namespace); if(mIterator.hasNext()) { metricsData = Sets.newLinkedHashSet(); } } } } ",
        "test_tgt": "@Test public void testPutMetricData()throws Exception { CloudWatchClient client = createMock(CloudWatchClient.class); MetricClient metricClient = createMock(MetricClient.class); Set < MetricDatum > metrics = Sets.newLinkedHashSet(); String namespace = \"JCLOUDS/Test\"; for(int i = 0; i < 11; i ++ ) { metrics.add(MetricDatum.builder().metricName(\"foo\").build()); } expect(client.getMetricClientForRegion(EasyMock.eq(\"\"))).andReturn(metricClient).atLeastOnce(); for(List < MetricDatum > slice : Iterables.partition(metrics, 10)) { metricClient.putMetricData(slice, namespace); } EasyMock.replay(client, metricClient); CloudWatch.putMetricData(client, \"\", metrics, namespace); EasyMock.verify(metricClient); } "
    },
    {
        "test_src": "@Test public void matchUdpDstTest() { Criterion criterion = Criteria.matchUdpDst(40000); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result, matchesCriterion(criterion)); } ",
        "focal_tgt": "@Deprecated Builder matchUdpDst(short udpPort); ",
        "focal_src": "Builder matchUdpDst(short udpPort); ",
        "test_tgt": "@Test public void matchUdpDstTest() { Criterion criterion = Criteria.matchUdpDst(tpPort); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result, matchesCriterion(criterion)); } "
    },
    {
        "test_src": "@Test public final void set() { ok(new Set(MainOptions.CHOP, false)); ok(new Set(MainOptions.CHOP, true)); ok(new Set(\"chop\", true)); ok(new Set(\"runs\", 1)); no(new Set(\"runs\", true)); no(new Set(NAME2, NAME2)); } ",
        "focal_tgt": "private void set(final IndexType type, final ValueIndex index) { meta.dirty = true; switch(type) { case TEXT : textIndex = index; break; case ATTRIBUTE : attrIndex = index; break; case ATTTOKEN : attrTokenIndex = index; break; case FULLTEXT : ftxtIndex = index; break; default : break; } } ",
        "focal_src": "private void set(final IndexType type, final ValueIndex index) { meta.dirty = true; switch(type) { case TEXT : textIndex = index; break; case ATTRIBUTE : attrIndex = index; break; case FULLTEXT : ftxtIndex = index; break; default : break; } } ",
        "test_tgt": "@Test public final void set() { ok(new Set(MainOptions.CHOP, false)); ok(new Set(MainOptions.CHOP, true)); ok(new Set(\"chop\", true)); ok(new Set(\"runs\", 1)); ok(new Set(MainOptions.ATTRTOKENIZE, \"\")); ok(new Set(MainOptions.ATTRTOKENIZE, \"id\")); no(new Set(\"runs\", true)); no(new Set(NAME2, NAME2)); } "
    },
    {
        "test_src": "@Test public void testWaitForever() { BspEvent event = new PredicateLock(getStubProgressable()); Thread signalThread = new SignalThread(event); signalThread.start(); event.waitForever(); try { signalThread.join(); } catch(InterruptedException e) { } assertTrue(event.waitMsecs(0)); } ",
        "focal_tgt": "void waitForTimeoutOrFail(long timeout); ",
        "focal_src": "void waitForever(); ",
        "test_tgt": "@Test public void testWaitForever() { BspEvent event = new PredicateLock(getStubProgressable()); Thread signalThread = new SignalThread(event); signalThread.start(); event.waitForTimeoutOrFail(5 * 60_000); try { signalThread.join(); } catch(InterruptedException e) { } assertTrue(event.waitMsecs(0)); } "
    },
    {
        "test_src": "@Test public void testForwardAlgorithm() { double alphaExpectedA[][] = { { 0.02, 0.0392, 0.002438, 0.00035456, 0.0011554672, 7.158497e-04, 4.614927e-05 }, { 0.01, 0.0054, 0.001824, 0.00069486, 0.0007586904, 2.514137e-04, 1.721505e-05 }, { 0.32, 0.0262, 0.002542, 0.00038026, 0.0001360234, 3.002345e-05, 9.659608e-05 }, { 0.03, 0.0000, 0.013428, 0.00951084, 0.0000000000, 0.000000e+00, 2.428986e-05 }, }; Matrix alpha = HmmAlgorithms.forwardAlgorithm(model, sequence, false); Assert.assertNotNull(alpha); Assert.assertEquals(alpha.numCols(), 4); Assert.assertEquals(alpha.numRows(), 7); for(int i = 0; i < 4; ++ i)for(int j = 0; j < 7; ++ j)Assert.assertEquals(alphaExpectedA[i][j], alpha.get(j, i), 0.00001); } ",
        "focal_tgt": "public static Matrix forwardAlgorithm(HmmModel model, int[]observations, boolean scaled) { Matrix alpha = new DenseMatrix(observations.length, model.getNrOfHiddenStates()); forwardAlgorithm(alpha, model, observations, scaled); return alpha; } ",
        "focal_src": "public static Matrix forwardAlgorithm(HmmModel model, int[]observations, boolean scaled) { DenseMatrix alpha = new DenseMatrix(observations.length, model.getNrOfHiddenStates()); forwardAlgorithm(alpha, model, observations, scaled); return alpha; } ",
        "test_tgt": "@Test public void testForwardAlgorithm() { double[][]alphaExpectedA = { { 0.02, 0.0392, 0.002438, 0.00035456, 0.0011554672, 7.158497e-04, 4.614927e-05 }, { 0.01, 0.0054, 0.001824, 0.00069486, 0.0007586904, 2.514137e-04, 1.721505e-05 }, { 0.32, 0.0262, 0.002542, 0.00038026, 0.0001360234, 3.002345e-05, 9.659608e-05 }, { 0.03, 0.0000, 0.013428, 0.00951084, 0.0000000000, 0.000000e+00, 2.428986e-05 }, }; Matrix alpha = HmmAlgorithms.forwardAlgorithm(getModel(), getSequence(), false); assertNotNull(alpha); assertEquals(4, alpha.numCols()); assertEquals(7, alpha.numRows()); for(int i = 0; i < 4; ++ i) { for(int j = 0; j < 7; ++ j) { assertEquals(alphaExpectedA[i][j], alpha.get(j, i), EPSILON); } } } "
    },
    {
        "test_src": "@Test public void testIsEmpty() { assertTrue(instance.isEmpty(\"name\").getQueryCriterions().contains(new IsEmptyCriterion(\"name\"))); } ",
        "focal_tgt": "public CriteriaQuery isEmpty(String propName) { criterion = criterion.and(criterionBuilder.isEmpty(propName)); return this; } ",
        "focal_src": "public CriteriaQuery isEmpty(String propName) { addCriterion(criterionBuilder.isEmpty(propName)); return this; } ",
        "test_tgt": "@Test public void testIsEmpty() { assertEquals(new IsEmptyCriterion(\"name\"), instance.isEmpty(\"name\").getQueryCriterion()); } "
    },
    {
        "test_src": "@Test public void testUpdate() { final int count = 10000; val ds = new DataSource(); val index = defaultBuilder(ds).build(); index.initialize(TIMEOUT).join(); val entries = generate(count); sort(entries); index.put(entries, TIMEOUT).join(); val toDelete = new ArrayList < ByteArraySegment > (); val toUpdate = new ArrayList < PageEntry > (); val expectedEntries = new ArrayList < PageEntry > (entries); val rnd = new Random(0); for(int i = entries.size() - 1; i >= 0; i -- ) { PageEntry e = expectedEntries.get(i); boolean delete = i % 3 == 0; boolean update = i % 2 == 0; if(delete) { toDelete.add(expectedEntries.get(i).getKey()); if( ! update) { expectedEntries.remove(i); } } if(update) { val newValue = new byte[VALUE_LENGTH]; rnd.nextBytes(newValue); e = new PageEntry(e.getKey(), new ByteArraySegment(newValue)); toUpdate.add(e); expectedEntries.set(i, e); } } index.remove(toDelete, TIMEOUT).join(); index.put(toUpdate, TIMEOUT).join(); check(\"Unexpected index contents.\", index, expectedEntries, 0); } ",
        "focal_tgt": "void update(@NonNull List < PageEntry > entries) { if(entries.isEmpty()) { return; } val ci = applyUpdates(entries); if(ci.changes.isEmpty()) { return; } val newPage = applyInsertsAndRemovals(ci); this.header = newPage.header; this.data = newPage.data; this.contents = newPage.contents; this.footer = newPage.footer; this.count = newPage.count; } ",
        "focal_src": "void update(@NonNull Collection < PageEntry > entries) { if(entries.isEmpty()) { return; } val newEntries = applyUpdates(entries); if(newEntries.isEmpty()) { return; } val newPage = insertNewEntries(newEntries); this.header = newPage.header; this.data = newPage.data; this.contents = newPage.contents; this.footer = newPage.footer; this.count = newPage.count; } ",
        "test_tgt": "@Test public void testUpdate() { final int count = 10000; val ds = new DataSource(); val index = defaultBuilder(ds).build(); index.initialize(TIMEOUT).join(); val entries = generate(count); sort(entries); index.update(entries, TIMEOUT).join(); val toUpdate = new ArrayList < PageEntry > (); val expectedEntries = new ArrayList < PageEntry > (entries); val rnd = new Random(0); for(int i = entries.size() - 1; i >= 0; i -- ) { PageEntry e = expectedEntries.get(i); boolean delete = i % 3 == 0; boolean update = i % 2 == 0; if(delete && ! update) { toUpdate.add(PageEntry.noValue(expectedEntries.get(i).getKey())); expectedEntries.remove(i); } if(update) { val newValue = new byte[VALUE_LENGTH]; rnd.nextBytes(newValue); e = new PageEntry(e.getKey(), new ByteArraySegment(newValue)); toUpdate.add(e); expectedEntries.set(i, e); } } index.update(toUpdate, TIMEOUT).join(); check(\"Unexpected index contents.\", index, expectedEntries, 0); } "
    },
    {
        "test_src": "@Test public void findBatchOfConcepts_shouldNotReturnConceptByGivenIdIfClassnameIsNotIncluded()throws Exception { String phrase = \"1000\"; Concept expected = Context.getConceptService().getConcept(phrase); List < String > includeClassNames = new ArrayList < String > (); includeClassNames.add(\"test\"); List < Object > result = dwrConceptService.findBatchOfConcepts(phrase, Boolean.FALSE, includeClassNames, null, null, null, null, null); Assert.assertNotNull(result); Assert.assertFalse(isConceptFound(expected, result)); } ",
        "focal_tgt": "public List < Object > findBatchOfConcepts(String phrase, boolean includeRetired, List < String > includeClassNames, List < String > excludeClassNames, List < String > includeDatatypeNames, List < String > excludeDatatypeNames, Integer start, Integer length) { Vector < Object > objectList = new Vector < Object > (); Locale defaultLocale = Context.getLocale(); List < Locale > searchLocales = Context.getAdministrationService().getSearchLocales(); if(log.isDebugEnabled()) { StringBuffer searchLocalesString = new StringBuffer(); for(Locale loc : searchLocales) { searchLocalesString.append(loc.toString() + \" \"); } log.debug(\"searching locales: \" + searchLocalesString); } if(includeClassNames == null)includeClassNames = new Vector < String > (); if(excludeClassNames == null)excludeClassNames = new Vector < String > (); if(includeDatatypeNames == null)includeDatatypeNames = new Vector < String > (); if(excludeDatatypeNames == null)excludeDatatypeNames = new Vector < String > (); try { ConceptService cs = Context.getConceptService(); List < ConceptSearchResult > searchResults = new Vector < ConceptSearchResult > (); if(phrase.matches(\"\\\\d+\")) { Concept c = cs.getConcept(Integer.valueOf(phrase)); if(c != null && ( ! c.isRetired() || includeRetired)) { String conceptClassName = null; if(c.getConceptClass() != null) { conceptClassName = c.getConceptClass().getName(); } String conceptDatatypeName = null; if(c.getDatatype() != null) { conceptDatatypeName = c.getDatatype().getName(); } if((includeClassNames.isEmpty() || includeClassNames.contains(conceptClassName)) && (excludeClassNames.isEmpty() || ! excludeClassNames.contains(conceptClassName)) && (includeDatatypeNames.isEmpty() || includeDatatypeNames.contains(conceptDatatypeName)) && (excludeDatatypeNames.isEmpty() || ! excludeDatatypeNames.contains(conceptDatatypeName))) { ConceptName cn = c.getName(defaultLocale); ConceptSearchResult searchResult = new ConceptSearchResult(phrase, c, cn); searchResults.add(searchResult); } } } if( ! StringUtils.isBlank(phrase)) { List < ConceptClass > includeClasses = new Vector < ConceptClass > (); for(String name : includeClassNames)if( ! \"\".equals(name))includeClasses.add(cs.getConceptClassByName(name)); List < ConceptClass > excludeClasses = new Vector < ConceptClass > (); for(String name : excludeClassNames)if( ! \"\".equals(name))excludeClasses.add(cs.getConceptClassByName(name)); List < ConceptDatatype > includeDatatypes = new Vector < ConceptDatatype > (); for(String name : includeDatatypeNames)if( ! \"\".equals(name))includeDatatypes.add(cs.getConceptDatatypeByName(name)); List < ConceptDatatype > excludeDatatypes = new Vector < ConceptDatatype > (); for(String name : excludeDatatypeNames)if( ! \"\".equals(name))excludeDatatypes.add(cs.getConceptDatatypeByName(name)); searchResults.addAll(cs.getConcepts(phrase, searchLocales, includeRetired, includeClasses, excludeClasses, includeDatatypes, excludeDatatypes, null, start, length)); } if(searchResults.size() < 1) { objectList.add(Context.getMessageSourceService().getMessage(\"general.noMatchesFoundInLocale\", new Object[] { \"<b>\" + phrase + \"</b>\", OpenmrsUtil.join(searchLocales, \", \") }, Context.getLocale())); } else { for(ConceptSearchResult searchResult : searchResults)objectList.add(new ConceptListItem(searchResult)); } } catch(Exception e) { log.error(\"Error while finding concepts + \" + e.getMessage(), e); objectList.add(Context.getMessageSourceService().getMessage(\"Concept.search.error\") + \" - \" + e.getMessage()); } if(objectList.size() == 0)objectList.add(Context.getMessageSourceService().getMessage(\"general.noMatchesFoundInLocale\", new Object[] { \"<b>\" + phrase + \"</b>\", defaultLocale }, Context.getLocale())); return objectList; } ",
        "focal_src": "public List < Object > findBatchOfConcepts(String phrase, boolean includeRetired, List < String > includeClassNames, List < String > excludeClassNames, List < String > includeDatatypeNames, List < String > excludeDatatypeNames, Integer start, Integer length) { Vector < Object > objectList = new Vector < Object > (); User currentUser = Context.getAuthenticatedUser(); Locale defaultLocale = Context.getLocale(); List < Locale > localesToSearchOn = null; if(currentUser != null)localesToSearchOn = currentUser.getProficientLocales(); if(localesToSearchOn == null)localesToSearchOn = new Vector < Locale > (); if(localesToSearchOn.size() == 0) { localesToSearchOn.add(defaultLocale); if( ! \"\".equals(defaultLocale.getCountry())) { localesToSearchOn.add(new Locale(defaultLocale.getLanguage())); } } if(log.isDebugEnabled()) { StringBuffer searchLocalesString = new StringBuffer(); for(Locale loc : localesToSearchOn) { searchLocalesString.append(loc.toString() + \" \"); } log.debug(\"searching locales: \" + searchLocalesString); } if(includeClassNames == null)includeClassNames = new Vector < String > (); if(excludeClassNames == null)excludeClassNames = new Vector < String > (); if(includeDatatypeNames == null)includeDatatypeNames = new Vector < String > (); if(excludeDatatypeNames == null)excludeDatatypeNames = new Vector < String > (); try { ConceptService cs = Context.getConceptService(); List < ConceptSearchResult > searchResults = new Vector < ConceptSearchResult > (); if(phrase.matches(\"\\\\d+\")) { Concept c = cs.getConcept(Integer.valueOf(phrase)); if(c != null && ( ! c.isRetired() || includeRetired)) { String conceptClassName = null; if(c.getConceptClass() != null) { conceptClassName = c.getConceptClass().getName(); } String conceptDatatypeName = null; if(c.getDatatype() != null) { conceptDatatypeName = c.getDatatype().getName(); } if((includeClassNames.isEmpty() || includeClassNames.contains(conceptClassName)) && (excludeClassNames.isEmpty() || ! excludeClassNames.contains(conceptClassName)) && (includeDatatypeNames.isEmpty() || includeDatatypeNames.contains(conceptDatatypeName)) && (excludeDatatypeNames.isEmpty() || ! excludeDatatypeNames.contains(conceptDatatypeName))) { ConceptName cn = c.getName(defaultLocale); ConceptSearchResult searchResult = new ConceptSearchResult(phrase, c, cn); searchResults.add(searchResult); } } } if( ! StringUtils.isBlank(phrase)) { List < ConceptClass > includeClasses = new Vector < ConceptClass > (); for(String name : includeClassNames)if( ! \"\".equals(name))includeClasses.add(cs.getConceptClassByName(name)); List < ConceptClass > excludeClasses = new Vector < ConceptClass > (); for(String name : excludeClassNames)if( ! \"\".equals(name))excludeClasses.add(cs.getConceptClassByName(name)); List < ConceptDatatype > includeDatatypes = new Vector < ConceptDatatype > (); for(String name : includeDatatypeNames)if( ! \"\".equals(name))includeDatatypes.add(cs.getConceptDatatypeByName(name)); List < ConceptDatatype > excludeDatatypes = new Vector < ConceptDatatype > (); for(String name : excludeDatatypeNames)if( ! \"\".equals(name))excludeDatatypes.add(cs.getConceptDatatypeByName(name)); searchResults.addAll(cs.getConcepts(phrase, localesToSearchOn, includeRetired, includeClasses, excludeClasses, includeDatatypes, excludeDatatypes, null, start, length)); } if(searchResults.size() < 1) { objectList.add(Context.getMessageSourceService().getMessage(\"general.noMatchesFoundInLocale\", new Object[] { \"<b>\" + phrase + \"</b>\", OpenmrsUtil.join(localesToSearchOn, \", \") }, Context.getLocale())); } else { for(ConceptSearchResult searchResult : searchResults)objectList.add(new ConceptListItem(searchResult)); } } catch(Exception e) { log.error(\"Error while finding concepts + \" + e.getMessage(), e); objectList.add(Context.getMessageSourceService().getMessage(\"Concept.search.error\") + \" - \" + e.getMessage()); } if(objectList.size() == 0)objectList.add(Context.getMessageSourceService().getMessage(\"general.noMatchesFoundInLocale\", new Object[] { \"<b>\" + phrase + \"</b>\", defaultLocale }, Context.getLocale())); return objectList; } ",
        "test_tgt": "@Test public void findBatchOfConcepts_shouldNotReturnConceptByGivenIdIfClassnameIsNotIncluded()throws Exception { String phrase = \"1000\"; Concept expected = Context.getConceptService().getConcept(phrase); List < String > includeClassNames = new ArrayList < String > (); includeClassNames.add(\"test\"); List < Object > result = dwrConceptService.findBatchOfConcepts(phrase, Boolean.FALSE, includeClassNames, null, null, null, null, null); Assert.assertNotNull(result); Assert.assertFalse(isConceptFound(expected, result)); } "
    },
    {
        "test_src": "@Test public void testPutReferAntiLeech() { BucketReferAntiLeech leech = new BucketReferAntiLeech(); Response response; try { System.out.println(leech.asQueryString()); response = bucketManager.putReferAntiLeech(TestConfig.testBucket_z0, leech); Assert.assertEquals(200, response.statusCode); leech.setAllowEmptyReferer(false); System.out.println(leech.asQueryString()); response = bucketManager.putReferAntiLeech(TestConfig.testBucket_z0, leech); Assert.assertEquals(200, response.statusCode); leech.setAllowEmptyReferer(false); leech.setMode(1); leech.setPattern(\"www.qiniu.com\"); System.out.println(leech.asQueryString()); response = bucketManager.putReferAntiLeech(TestConfig.testBucket_z0, leech); Assert.assertEquals(200, response.statusCode); System.out.println(response.url()); System.out.println(response.reqId); } catch(Exception e) { if(e instanceof QiniuException) { QiniuException ex = (QiniuException)e; Assert.fail(ex.response.toString()); } } } ",
        "focal_tgt": "public Response putReferAntiLeech(String bucket, BucketReferAntiLeech antiLeech)throws QiniuException { String url = String.format(\"%s/referAntiLeech?bucket=%s&%s\", configuration.ucHost(), bucket, antiLeech.asQueryString()); Response res = post(url, null); if( ! res.isOK()) { throw new QiniuException(res); } return res; } ",
        "focal_src": "public Response putReferAntiLeech(String bucket, BucketReferAntiLeech antiLeech)throws QiniuException { String url = String.format(\"%s/referAntiLeech?bucket=%s&%s\", configuration.ucHost(), bucket, antiLeech.asQueryString()); Response res = post(url, null); if( ! res.isOK()) { throw new QiniuException(res); } res.close(); return res; } ",
        "test_tgt": "@Test public void testPutReferAntiLeech() { String[]buckets = new String[] { TestConfig.testBucket_z0, TestConfig.testBucket_na0 }; for(String bucket : buckets) { BucketReferAntiLeech leech = new BucketReferAntiLeech(); Response response; BucketInfo bucketInfo; try { leech.setMode(1); leech.setPattern(\"www.qiniu.com\"); leech.setAllowEmptyReferer(false); System.out.println(leech.asQueryString()); response = bucketManager.putReferAntiLeech(bucket, leech); Assert.assertEquals(200, response.statusCode); bucketInfo = bucketManager.getBucketInfo(bucket); Assert.assertEquals(1, bucketInfo.getAntiLeechMode()); Assert.assertArrayEquals((new String[] { \"www.qiniu.com\" }), bucketInfo.getReferWhite()); Assert.assertEquals(false, bucketInfo.isNoRefer()); leech.setMode(2); leech.setPattern(\"www.baidu.com\"); leech.setAllowEmptyReferer(true); System.out.println(leech.asQueryString()); response = bucketManager.putReferAntiLeech(bucket, leech); Assert.assertEquals(200, response.statusCode); bucketInfo = bucketManager.getBucketInfo(bucket); Assert.assertEquals(2, bucketInfo.getAntiLeechMode()); Assert.assertArrayEquals((new String[] { \"www.baidu.com\" }), bucketInfo.getReferBlack()); Assert.assertEquals(true, bucketInfo.isNoRefer()); leech = new BucketReferAntiLeech(); System.out.println(leech.asQueryString()); response = bucketManager.putReferAntiLeech(bucket, leech); Assert.assertEquals(200, response.statusCode); bucketInfo = bucketManager.getBucketInfo(bucket); Assert.assertEquals(0, bucketInfo.getAntiLeechMode()); Assert.assertNull(\"ReferBlack should be Null\", bucketInfo.getReferBlack()); Assert.assertNull(\"ReferWhtie should be Null\", bucketInfo.getReferWhite()); Assert.assertEquals(false, bucketInfo.isNoRefer()); } catch(Exception e) { if(e instanceof QiniuException) { QiniuException ex = (QiniuException)e; Assert.fail(ex.response.toString()); } } } } "
    },
    {
        "test_src": "@Test public void testGetCommunities()throws Exception { assertThat(\"testGetCommunities 0\", c.getCommunities(), notNullValue()); assertTrue(\"testGetCommunities 1\", c.getCommunities().length == 0); } ",
        "focal_tgt": "public List < Community > getCommunities()throws SQLException { return communities; } ",
        "focal_src": "public Community[]getCommunities()throws SQLException { TableRowIterator tri = DatabaseManager.queryTable(ourContext, \"community\", \"SELECT community.* FROM community, community2collection WHERE \" + \"community.community_id=community2collection.community_id \" + \"AND community2collection.collection_id= ? \", getID()); List < Community > communities = new ArrayList < Community > (); try { while(tri.hasNext()) { TableRow row = tri.next(); Community owner = (Community)ourContext.fromCache(Community.class, row.getIntColumn(\"community_id\")); if(owner == null) { owner = new Community(ourContext, row); } communities.add(owner); Community[]parents = owner.getAllParents(); communities.addAll(Arrays.asList(parents)); } } finally { if(tri != null) { tri.close(); } } Community[]communityArray = new Community[communities.size()]; communityArray = (Community[])communities.toArray(communityArray); return communityArray; } ",
        "test_tgt": "@Test public void testGetCommunities()throws Exception { assertThat(\"testGetCommunities 0\", collection.getCommunities(), notNullValue()); assertTrue(\"testGetCommunities 1\", collection.getCommunities().size() == 1); } "
    },
    {
        "test_src": "@Test public void testBoolsToHexDigit() { assertEquals('0', Conversion.boolsToHexDigit(new boolean[] { false, false, false, false })); assertEquals('1', Conversion.boolsToHexDigit(new boolean[] { true, false, false, false })); assertEquals('2', Conversion.boolsToHexDigit(new boolean[] { false, true, false, false })); assertEquals('3', Conversion.boolsToHexDigit(new boolean[] { true, true, false, false })); assertEquals('4', Conversion.boolsToHexDigit(new boolean[] { false, false, true, false })); assertEquals('5', Conversion.boolsToHexDigit(new boolean[] { true, false, true, false })); assertEquals('6', Conversion.boolsToHexDigit(new boolean[] { false, true, true, false })); assertEquals('7', Conversion.boolsToHexDigit(new boolean[] { true, true, true, false })); assertEquals('8', Conversion.boolsToHexDigit(new boolean[] { false, false, false, true })); assertEquals('9', Conversion.boolsToHexDigit(new boolean[] { true, false, false, true })); assertEquals('A', Conversion.boolsToHexDigit(new boolean[] { false, true, false, true })); assertEquals('B', Conversion.boolsToHexDigit(new boolean[] { true, true, false, true })); assertEquals('C', Conversion.boolsToHexDigit(new boolean[] { false, false, true, true })); assertEquals('D', Conversion.boolsToHexDigit(new boolean[] { true, false, true, true })); assertEquals('E', Conversion.boolsToHexDigit(new boolean[] { false, true, true, true })); assertEquals('F', Conversion.boolsToHexDigit(new boolean[] { true, true, true, true })); } ",
        "focal_tgt": "public static char boolsToHexDigit(boolean[]src, int srcPos) { if(src.length > srcPos + 3 && src[srcPos + 3]) { if(src.length > srcPos + 2 && src[srcPos + 2]) { if(src.length > srcPos + 1 && src[srcPos + 1]) { if(src[srcPos])return 'f'; else return 'e'; } else { if(src[srcPos])return 'd'; else return 'c'; } } else { if(src.length > srcPos + 1 && src[srcPos + 1]) { if(src[srcPos])return 'b'; else return 'a'; } else { if(src[srcPos])return '9'; else return '8'; } } } else { if(src.length > srcPos + 2 && src[srcPos + 2]) { if(src.length > srcPos + 1 && src[srcPos + 1]) { if(src[srcPos])return '7'; else return '6'; } else { if(src[srcPos])return '5'; else return '4'; } } else { if(src.length > srcPos + 1 && src[srcPos + 1]) { if(src[srcPos])return '3'; else return '2'; } else { if(src[srcPos])return '1'; else return '0'; } } } } ",
        "focal_src": "public static char boolsToHexDigit(boolean[]src, int srcPos) { if(src.length > srcPos + 3 && src[srcPos + 3]) { if(src.length > srcPos + 2 && src[srcPos + 2]) { if(src.length > srcPos + 1 && src[srcPos + 1]) { if(src[srcPos])return 'F'; else return 'E'; } else { if(src[srcPos])return 'D'; else return 'C'; } } else { if(src.length > srcPos + 1 && src[srcPos + 1]) { if(src[srcPos])return 'B'; else return 'A'; } else { if(src[srcPos])return '9'; else return '8'; } } } else { if(src.length > srcPos + 2 && src[srcPos + 2]) { if(src.length > srcPos + 1 && src[srcPos + 1]) { if(src[srcPos])return '7'; else return '6'; } else { if(src[srcPos])return '5'; else return '4'; } } else { if(src.length > srcPos + 1 && src[srcPos + 1]) { if(src[srcPos])return '3'; else return '2'; } else { if(src[srcPos])return '1'; else return '0'; } } } } ",
        "test_tgt": "@Test public void testBoolsToHexDigit() { assertEquals('0', Conversion.boolsToHexDigit(new boolean[] { false, false, false, false })); assertEquals('1', Conversion.boolsToHexDigit(new boolean[] { true, false, false, false })); assertEquals('2', Conversion.boolsToHexDigit(new boolean[] { false, true, false, false })); assertEquals('3', Conversion.boolsToHexDigit(new boolean[] { true, true, false, false })); assertEquals('4', Conversion.boolsToHexDigit(new boolean[] { false, false, true, false })); assertEquals('5', Conversion.boolsToHexDigit(new boolean[] { true, false, true, false })); assertEquals('6', Conversion.boolsToHexDigit(new boolean[] { false, true, true, false })); assertEquals('7', Conversion.boolsToHexDigit(new boolean[] { true, true, true, false })); assertEquals('8', Conversion.boolsToHexDigit(new boolean[] { false, false, false, true })); assertEquals('9', Conversion.boolsToHexDigit(new boolean[] { true, false, false, true })); assertEquals('a', Conversion.boolsToHexDigit(new boolean[] { false, true, false, true })); assertEquals('b', Conversion.boolsToHexDigit(new boolean[] { true, true, false, true })); assertEquals('c', Conversion.boolsToHexDigit(new boolean[] { false, false, true, true })); assertEquals('d', Conversion.boolsToHexDigit(new boolean[] { true, false, true, true })); assertEquals('e', Conversion.boolsToHexDigit(new boolean[] { false, true, true, true })); assertEquals('f', Conversion.boolsToHexDigit(new boolean[] { true, true, true, true })); assertEquals('1', Conversion.boolsToHexDigit(new boolean[] { true })); assertEquals('f', Conversion.boolsToHexDigit(new boolean[] { true, true, true, true, true })); try { assertEquals('0', Conversion.boolsToHexDigit(new boolean[] { })); fail(\"Thrown \" + ArrayIndexOutOfBoundsException.class.getName() + \" expected\"); } catch(final ArrayIndexOutOfBoundsException e) { } } "
    },
    {
        "test_src": "@Test public void testClassify() { Classification response = new Classification(); response.setId(\"testId\"); response.setText(\"is it sunny?\"); response.setUrl(\"http://www.ibm.com\"); response.setTopClass(\"class2\"); List < ClassifiedClass > classes = new ArrayList < ClassifiedClass > (); ClassifiedClass c1 = new ClassifiedClass(); c1.setConfidence(0.98189); c1.setName(\"class1\"); ClassifiedClass c2 = new ClassifiedClass(); c2.setConfidence(0.98188); c2.setName(\"class2\"); classes.add(c1); classes.add(c2); response.setClasses(classes); StringBuilder text = new StringBuilder().append(\"is it sunny?\"); JsonObject contentJson = new JsonObject(); contentJson.addProperty(\"text\", text.toString()); String path = String.format(CLASSIFY_PATH, classifierId); mockServer.when(request().withMethod(\"POST\").withPath(path).withBody(contentJson.toString())).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, MediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGson().toJson(response))); Classification c = service.classify(classifierId, text.toString()); assertNotNull(service.toString()); assertNotNull(c); assertEquals(c, response); } ",
        "focal_tgt": "public Classification classify(final String classifierId, final String text) { if(classifierId == null || classifierId.isEmpty())throw new IllegalArgumentException(\"classifierId cannot be null or empty\"); if(text == null || text.isEmpty())throw new IllegalArgumentException(\"text cannot be null or empty\"); final JsonObject contentJson = new JsonObject(); contentJson.addProperty(\"text\", text); final String path = String.format(\"/v1/classifiers/%s/classify\", classifierId); final Request request = RequestBuilder.post(path).withBodyJson(contentJson).build(); final Response response = execute(request); final Classification classification = ResponseUtil.getObject(response, Classification.class); for(final ClassifiedClass klass : classification.getClasses()) { if(klass.getName().equals(classification.getTopClass())) { classification.setTopConfidence(klass.getConfidence()); break; } } return classification; } ",
        "focal_src": "public Classification classify(final String classifierId, final String text) { if(classifierId == null || classifierId.isEmpty())throw new IllegalArgumentException(\"classifierId can not be null or empty\"); if(text == null || text.isEmpty())throw new IllegalArgumentException(\"text can not be null or empty\"); JsonObject contentJson = new JsonObject(); contentJson.addProperty(\"text\", text); String path = String.format(\"/v1/classifiers/%s/classify\", classifierId); HttpRequestBase request = Request.Post(path).withContent(contentJson).build(); try { HttpResponse response = execute(request); Classification classification = ResponseUtil.getObject(response, Classification.class); for(ClassifiedClass klass : classification.getClasses()) { if(klass.getName().equals(classification.getTopClass())) { classification.setTopConfidence(klass.getConfidence()); break; } } return classification; } catch(IOException e) { throw new RuntimeException(e); } } ",
        "test_tgt": "@Test public void testClassify() { final Classification response = new Classification(); response.setId(\"testId\"); response.setText(\"is it sunny?\"); response.setUrl(\"http://www.ibm.com\"); response.setTopClass(\"class2\"); final List < ClassifiedClass > classes = new ArrayList < ClassifiedClass > (); final ClassifiedClass c1 = new ClassifiedClass(); c1.setConfidence(0.98189); c1.setName(\"class1\"); final ClassifiedClass c2 = new ClassifiedClass(); c2.setConfidence(0.98188); c2.setName(\"class2\"); classes.add(c1); classes.add(c2); response.setClasses(classes); final StringBuilder text = new StringBuilder().append(\"is it sunny?\"); final JsonObject contentJson = new JsonObject(); contentJson.addProperty(\"text\", text.toString()); final String path = String.format(CLASSIFY_PATH, classifierId); mockServer.when(request().withMethod(\"POST\").withPath(path).withBody(contentJson.toString())).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGson().toJson(response))); final Classification c = service.classify(classifierId, text.toString()); assertNotNull(service.toString()); assertNotNull(c); assertEquals(c, response); } "
    },
    {
        "test_src": "@Test public void changeLocalFilePermissionTest()throws IOException { File tempFile = mTestFolder.newFile(\"perm.txt\"); FileUtils.changeLocalFilePermission(tempFile.getAbsolutePath(), \"000\"); Assert.assertFalse(tempFile.canRead() || tempFile.canWrite() || tempFile.canExecute()); FileUtils.changeLocalFilePermission(tempFile.getAbsolutePath(), \"777\"); Assert.assertTrue(tempFile.canRead() && tempFile.canWrite() && tempFile.canExecute()); FileUtils.changeLocalFilePermission(tempFile.getAbsolutePath(), \"444\"); Assert.assertTrue(tempFile.canRead()); Assert.assertFalse(tempFile.canWrite()); Assert.assertFalse(tempFile.canExecute()); mException.expect(IOException.class); @SuppressWarnings( { \"unused\", \"resource\" })FileWriter fw = new FileWriter(tempFile); Assert.fail(\"opening a read-only file for writing should have failed\"); } ",
        "focal_tgt": "public static void changeLocalFilePermission(String filePath, String perms)throws IOException { Files.setPosixFilePermissions(Paths.get(filePath), PosixFilePermissions.fromString(perms)); } ",
        "focal_src": "public static void changeLocalFilePermission(String filePath, String perms)throws IOException { ShellUtils.execCommand(ShellUtils.getSetPermissionCommand(perms, filePath)); } ",
        "test_tgt": "@Test public void changeLocalFilePermissionTest()throws IOException { File tempFile = mTestFolder.newFile(\"perm.txt\"); FileUtils.changeLocalFilePermission(tempFile.getAbsolutePath(), \"---------\"); Assert.assertFalse(tempFile.canRead() || tempFile.canWrite() || tempFile.canExecute()); FileUtils.changeLocalFilePermission(tempFile.getAbsolutePath(), \"rwxrwxrwx\"); Assert.assertTrue(tempFile.canRead() && tempFile.canWrite() && tempFile.canExecute()); FileUtils.changeLocalFilePermission(tempFile.getAbsolutePath(), \"r--r--r--\"); Assert.assertTrue(tempFile.canRead()); Assert.assertFalse(tempFile.canWrite()); Assert.assertFalse(tempFile.canExecute()); mException.expect(IOException.class); @SuppressWarnings( { \"unused\", \"resource\" })FileWriter fw = new FileWriter(tempFile); Assert.fail(\"opening a read-only file for writing should have failed\"); } "
    },
    {
        "test_src": "@Test public void testGetPasswordRequirements() { System.out.println(\"getPasswordRequirements\"); int minLength = 6; int maxLength = 0; List < CharacterRule > characterRules = PasswordValidatorUtil.getCharacterRules4dot0(); int numberOfCharacteristics = 2; int numberOfRepeatingCharactersAllowed = 4; int goodStrength = 21; boolean dictionaryEnabled = true; System.out.println(\"---Show all\"); String req1 = PasswordValidatorUtil.getPasswordRequirements(minLength, maxLength, characterRules, numberOfCharacteristics, numberOfRepeatingCharactersAllowed, goodStrength, dictionaryEnabled); System.out.println(HtmlPrinter.prettyPrint(req1)); System.out.println(\"---Hide all\"); String req2 = PasswordValidatorUtil.getPasswordRequirements(minLength, maxLength, characterRules, numberOfCharacteristics, 0, 0, false); System.out.println(HtmlPrinter.prettyPrint(req2)); System.out.println(\"---Show may not include sequence\"); String req3 = PasswordValidatorUtil.getPasswordRequirements(minLength, maxLength, characterRules, numberOfCharacteristics, numberOfRepeatingCharactersAllowed, goodStrength, false); System.out.println(HtmlPrinter.prettyPrint(req3)); System.out.println(\"---Show may not dictionary\"); String req4 = PasswordValidatorUtil.getPasswordRequirements(minLength, maxLength, characterRules, numberOfCharacteristics, 0, goodStrength, true); System.out.println(HtmlPrinter.prettyPrint(req4)); } ",
        "focal_tgt": "public static String getPasswordRequirements(int minLength, int maxLength, List < CharacterRule > characterRules, int numberOfCharacteristics, int numberOfRepeatingCharactersAllowed, int goodStrength, boolean dictionaryEnabled, List < String > errors) { logger.info(errors.toString()); String message = \"Your password must contain:\"; message += \"<ul>\"; String optionalGoodStrengthNote = \"\"; if(goodStrength > 0) { optionalGoodStrengthNote = \" (passwords of at least \" + goodStrength + \" characters are exempt from all other requirements)\"; } message += \"<li \" + getColor(errors, ErrorType.TOO_SHORT) + \">\" + getOkOrFail(errors, ErrorType.TOO_SHORT) + \"At least \" + minLength + \" characters\" + optionalGoodStrengthNote + \"</li>\"; message += \"<li \" + getColor(errors, ErrorType.INSUFFICIENT_CHARACTERISTICS) + \">\" + getOkOrFail(errors, ErrorType.INSUFFICIENT_CHARACTERISTICS) + \"At least \" + numberOfCharacteristics + \" of the following: \" + getRequiredCharacters(characterRules) + \"</li>\"; message += \"</ul>\"; boolean repeatingDigitRuleEnabled = numberOfRepeatingCharactersAllowed > 0; boolean showMayNotBlock = repeatingDigitRuleEnabled || dictionaryEnabled; if(showMayNotBlock) { message += \"It may not include:\"; message += \"<ul>\"; } if(repeatingDigitRuleEnabled) { message += \"<li>Number sequences of \" + numberOfRepeatingCharactersAllowed + \" or more numbers in a row</li>\"; } if(dictionaryEnabled) { message += \"<li>Dictionary words or common acronyms of 5 or more letters</li>\"; } if(showMayNotBlock) { message += \"</ul>\"; } return message; } ",
        "focal_src": "public static String getPasswordRequirements(int minLength, int maxLength, List < CharacterRule > characterRules, int numberOfCharacteristics, int numberOfRepeatingCharactersAllowed, int goodStrength, boolean dictionaryEnabled) { String message = \"Your password must contain:\"; message += \"<ul>\"; String optionalGoodStrengthNote = \"\"; if(goodStrength > 0) { optionalGoodStrengthNote = \"( passwords of at least \" + goodStrength + \" characters are exempt from all other requirements)\"; } message += \"<li>At least \" + minLength + \" characters\" + optionalGoodStrengthNote + \"</li>\"; message += \"<li>At least \" + numberOfCharacteristics + \" of the following: \" + getRequiredCharacters(characterRules) + \"</li>\"; message += \"</ul>\"; boolean repeatingDigitRuleEnabled = numberOfRepeatingCharactersAllowed > 0; boolean showMayNotBlock = repeatingDigitRuleEnabled || dictionaryEnabled; if(showMayNotBlock) { message += \"It may not include:\"; message += \"<ul>\"; } if(repeatingDigitRuleEnabled) { message += \"<li>Number sequences of \" + numberOfRepeatingCharactersAllowed + \" or more numbers in a row</li>\"; } if(dictionaryEnabled) { message += \"<li>Dictionary words or common acronyms of 5 or more letters</li>\"; } if(showMayNotBlock) { message += \"</ul>\"; } return message; } ",
        "test_tgt": "@Test public void testGetPasswordRequirements() { System.out.println(\"getPasswordRequirements\"); int minLength = 6; int maxLength = 0; List < CharacterRule > characterRules = PasswordValidatorUtil.getCharacterRules4dot0(); int numberOfCharacteristics = 2; int numberOfRepeatingCharactersAllowed = 4; int goodStrength = 21; boolean dictionaryEnabled = true; List < String > errors = new ArrayList < > (); System.out.println(\"---Show all\"); String req1 = PasswordValidatorUtil.getPasswordRequirements(minLength, maxLength, characterRules, numberOfCharacteristics, numberOfRepeatingCharactersAllowed, goodStrength, dictionaryEnabled, errors); System.out.println(HtmlPrinter.prettyPrint(req1)); System.out.println(\"---Hide all\"); String req2 = PasswordValidatorUtil.getPasswordRequirements(minLength, maxLength, characterRules, numberOfCharacteristics, 0, 0, false, errors); System.out.println(HtmlPrinter.prettyPrint(req2)); System.out.println(\"---Show may not include sequence\"); String req3 = PasswordValidatorUtil.getPasswordRequirements(minLength, maxLength, characterRules, numberOfCharacteristics, numberOfRepeatingCharactersAllowed, goodStrength, false, errors); System.out.println(HtmlPrinter.prettyPrint(req3)); System.out.println(\"---Show may not dictionary\"); String req4 = PasswordValidatorUtil.getPasswordRequirements(minLength, maxLength, characterRules, numberOfCharacteristics, 0, goodStrength, true, errors); System.out.println(HtmlPrinter.prettyPrint(req4)); } "
    },
    {
        "test_src": "@Test public void testChangeState() { StateVertix state2 = new StateVertix(\"state2\", \"<table><div>state2</div></table>\"); assertFalse(sm.changeState(state2)); assertNotSame(sm.getCurrentState(), state2); Eventable c = new Eventable(new Identification(How.xpath, \"/bla\"), EventType.click); assertTrue(sm.update(c, state2, dummyBrowser, new CrawlSession(dummyPool))); assertEquals(\"State name changed correctly\", \"state1\", state2.getName()); assertEquals(sm.getCurrentState(), state2); assertTrue(sm.changeState(index)); assertEquals(sm.getCurrentState(), index); } ",
        "focal_tgt": "public boolean changeState(StateVertex nextState) { if(nextState == null) { LOGGER.info(\"nextState given is null\"); return false; } LOGGER.debug(\"AFTER: sm.current: \" + currentState.getName() + \" hold.current: \" + nextState.getName()); if(stateFlowGraph.canGoTo(currentState, nextState)) { LOGGER.debug(\"Changed To state: \" + nextState.getName() + \" From: \" + currentState.getName()); this.previousState = this.currentState; currentState = nextState; LOGGER.info(\"StateMachine's Pointer changed to: \" + currentState); return true; } else { LOGGER.info(\"Cannot change To state: \" + nextState.getName() + \" From: \" + currentState.getName()); return false; } } ",
        "focal_src": "public boolean changeState(StateVertix nextState) { if(nextState == null) { LOGGER.info(\"nextState given is null\"); return false; } LOGGER.debug(\"AFTER: sm.current: \" + currentState.getName() + \" hold.current: \" + nextState.getName()); if(stateFlowGraph.canGoTo(currentState, nextState)) { LOGGER.debug(\"Changed To state: \" + nextState.getName() + \" From: \" + currentState.getName()); this.previousState = this.currentState; currentState = nextState; LOGGER.info(\"StateMachine's Pointer changed to: \" + currentState); return true; } else { LOGGER.info(\"Cannot change To state: \" + nextState.getName() + \" From: \" + currentState.getName()); return false; } } ",
        "test_tgt": "@Test public void testChangeState() { StateVertex state2 = new StateVertex(\"state2\", \"<table><div>state2</div></table>\"); assertFalse(sm.changeState(state2)); assertNotSame(sm.getCurrentState(), state2); Eventable c = new Eventable(new Identification(How.xpath, \"/bla\"), EventType.click); assertTrue(sm.update(c, state2, dummyBrowser, new CrawlSession(dummyPool))); assertEquals(\"State name changed correctly\", \"state1\", state2.getName()); assertEquals(sm.getCurrentState(), state2); assertTrue(sm.changeState(index)); assertEquals(sm.getCurrentState(), index); } "
    },
    {
        "test_src": "@Test public void testAggregate() { BinaryClassificationPointwiseMetricStatsAggregator < Double > aggregator = new BinaryClassificationPointwiseMetricStatsAggregator < > (); assertEquals(null, aggregator.getFalseLabel()); assertEquals(null, aggregator.getTruthLabel()); aggregator.initByContext(new BinaryClassificationEvaluationContext < > (0., 1.)); assertEquals(0., aggregator.getFalseLabel(), 0.); assertEquals(1., aggregator.getTruthLabel(), 0.); assertEquals(0, aggregator.getTrueNegative()); assertEquals(0, aggregator.getFalseNegative()); assertEquals(0, aggregator.getTruePositive()); assertEquals(0, aggregator.getFalsePositive()); aggregator.aggregate(model, VectorUtils.of(0.).labeled(0.)); aggregator.aggregate(model, VectorUtils.of(1.).labeled(0.)); aggregator.aggregate(model, VectorUtils.of(1.).labeled(1.)); aggregator.aggregate(model, VectorUtils.of(0.).labeled(1.)); assertEquals(1, aggregator.getTrueNegative()); assertEquals(1, aggregator.getFalseNegative()); assertEquals(1, aggregator.getTruePositive()); assertEquals(1, aggregator.getFalsePositive()); } ",
        "focal_tgt": "@Override public void aggregate(IgniteModel < Vector, L > mdl, LabeledVector < L > vector) { L modelAns = mdl.predict(vector.features()); L realAns = vector.label(); if(modelAns.equals(falseLabel) && realAns.equals(falseLabel))trueNegative += 1; else if(modelAns.equals(falseLabel) && realAns.equals(truthLabel))falseNegative += 1; else if(modelAns.equals(truthLabel) && realAns.equals(truthLabel))truePositive += 1; else if(modelAns.equals(truthLabel) && realAns.equals(falseLabel))falsePositive += 1; } ",
        "focal_src": "@Override public void aggregate(IgniteModel < Vector, L > model, LabeledVector < L > vector) { L modelAns = model.predict(vector.features()); L realAns = vector.label(); if(modelAns.equals(falseLabel) && realAns.equals(falseLabel))trueNegative += 1; else if(modelAns.equals(falseLabel) && realAns.equals(truthLabel))falseNegative += 1; else if(modelAns.equals(truthLabel) && realAns.equals(truthLabel))truePositive += 1; else if(modelAns.equals(truthLabel) && realAns.equals(falseLabel))falsePositive += 1; } ",
        "test_tgt": "@Test public void testAggregate() { BinaryClassificationPointwiseMetricStatsAggregator < Double > aggregator = new BinaryClassificationPointwiseMetricStatsAggregator < > (); assertEquals(null, aggregator.getFalseLabel()); assertEquals(null, aggregator.getTruthLabel()); aggregator.initByContext(new BinaryClassificationEvaluationContext < > (0., 1.)); assertEquals(0., aggregator.getFalseLabel(), 0.); assertEquals(1., aggregator.getTruthLabel(), 0.); assertEquals(0, aggregator.getTrueNegative()); assertEquals(0, aggregator.getFalseNegative()); assertEquals(0, aggregator.getTruePositive()); assertEquals(0, aggregator.getFalsePositive()); aggregator.aggregate(mdl, VectorUtils.of(0.).labeled(0.)); aggregator.aggregate(mdl, VectorUtils.of(1.).labeled(0.)); aggregator.aggregate(mdl, VectorUtils.of(1.).labeled(1.)); aggregator.aggregate(mdl, VectorUtils.of(0.).labeled(1.)); assertEquals(1, aggregator.getTrueNegative()); assertEquals(1, aggregator.getFalseNegative()); assertEquals(1, aggregator.getTruePositive()); assertEquals(1, aggregator.getFalsePositive()); } "
    },
    {
        "test_src": "@Test public void testRemoveAll() { list.add(asArray(0, 1, 0, 1, 0)); assertEquals(0, list.removeAll(k2)); assertEquals(3, list.removeAll(k0)); assertListEquals(list.toArray(), 1, 1); assertEquals(2, list.removeAll(k1)); assertTrue(list.isEmpty()); list.clear(); list.add(newArray(k0, null, k2, null, k0)); assertEquals(2, list.removeAll((KType)null)); assertEquals(0, list.removeAll((KType)null)); assertListEquals(list.toArray(), 0, 2, 0); } ",
        "focal_tgt": "@Override public int removeAll(KType e1) { int removed = 0; final int last = tail; final int bufLen = buffer.length; int from, to; for(from = to = head; from != last; from = oneRight(from, bufLen)) { if(Intrinsics.equals(this, e1, buffer[from])) { buffer[from] = Intrinsics.empty(); removed ++ ; continue; } if(to != from) { buffer[to] = buffer[from]; buffer[from] = Intrinsics.empty(); } to = oneRight(to, bufLen); } tail = to; return removed; } ",
        "focal_src": "@Override public int removeAll(KType e1) { int removed = 0; final int last = tail; final int bufLen = buffer.length; int from, to; for(from = to = head; from != last; from = oneRight(from, bufLen)) { if(Intrinsics.equalsKType(e1, buffer[from])) { buffer[from] = Intrinsics. < KType > defaultKTypeValue(); removed ++ ; continue; } if(to != from) { buffer[to] = buffer[from]; buffer[from] = Intrinsics. < KType > defaultKTypeValue(); } to = oneRight(to, bufLen); } tail = to; return removed; } ",
        "test_tgt": "@Test public void testRemoveAll() { list.add(asArray(0, 1, 0, 1, 0)); assertEquals(0, list.removeAll(k2)); assertEquals(3, list.removeAll(k0)); assertListEquals(list.toArray(), 1, 1); assertEquals(2, list.removeAll(k1)); assertTrue(list.isEmpty()); list.clear(); list.add(newArray(k0, null, k2, null, k0)); assertEquals(2, list.removeAll((KType)null)); assertEquals(0, list.removeAll((KType)null)); assertListEquals(list.toArray(), 0, 2, 0); } "
    },
    {
        "test_src": "@Test public void addBlobStoreTest()throws Exception { generateConfigs(true); MockDataNodeId localNode = clusterMap.getDataNodes().get(0); List < ReplicaId > localReplicas = clusterMap.getReplicaIds(localNode); int newMountPathIndex = 3; File f = File.createTempFile(\"ambry\", \".tmp\"); File mountFile = new File(f.getParent(), \"mountpathfile\" + MockClusterMap.PLAIN_TEXT_PORT_START_NUMBER + newMountPathIndex); MockClusterMap.deleteFileOrDirectory(mountFile); assertTrue(\"Couldn't create mount path directory\", mountFile.mkdir()); localNode.addMountPaths(Collections.singletonList(mountFile.getAbsolutePath())); PartitionId newPartition1 = new MockPartitionId(10L, MockClusterMap.DEFAULT_PARTITION_CLASS, clusterMap.getDataNodes(), newMountPathIndex); StorageManager storageManager = createStorageManager(localReplicas, metricRegistry, null); storageManager.start(); assertFalse(\"Add store which is already existing should fail\", storageManager.addBlobStore(localReplicas.get(0))); assertTrue(\"Add new store should succeed\", storageManager.addBlobStore(newPartition1.getReplicaIds().get(0))); assertNotNull(\"The store shouldn't be null because new store is successfully added\", storageManager.getStore(newPartition1, false)); PartitionId newPartition2 = new MockPartitionId(11L, MockClusterMap.DEFAULT_PARTITION_CLASS, clusterMap.getDataNodes(), 0); storageManager.getDiskManager(localReplicas.get(0).getPartitionId()).shutdown(); assertFalse(\"Add store onto the DiskManager which is not running should fail\", storageManager.addBlobStore(newPartition2.getReplicaIds().get(0))); storageManager.getDiskManager(localReplicas.get(0).getPartitionId()).start(); shutdownAndAssertStoresInaccessible(storageManager, localReplicas); List < String > mountPaths = localNode.getMountPaths(); String diskToFail = mountPaths.get(0); File reservePoolDir = new File(diskToFail, diskManagerConfig.diskManagerReserveFileDirName); File storeReserveDir = new File(reservePoolDir, DiskSpaceAllocator.STORE_DIR_PREFIX + newPartition2.toString()); StorageManager storageManager2 = createStorageManager(localReplicas, new MetricRegistry(), null); storageManager2.start(); Utils.deleteFileOrDirectory(storeReserveDir); assertTrue(\"File creation should succeed\", storeReserveDir.createNewFile()); assertFalse(\"Add store should fail if store couldn't start due to initializePool failure\", storageManager2.addBlobStore(newPartition2.getReplicaIds().get(0))); assertNull(\"New store shouldn't be in in-memory data structure\", storageManager2.getStore(newPartition2, false)); shutdownAndAssertStoresInaccessible(storageManager2, localReplicas); } ",
        "focal_tgt": "boolean addBlobStore(ReplicaId replica) { rwLock.writeLock().lock(); boolean succeed = false; try { if( ! running) { logger.error(\"Failed to add {} because disk manager is not running\", replica.getPartitionId()); } else { BlobStore store = new BlobStore(replica, storeConfig, scheduler, longLivedTaskScheduler, diskIOScheduler, diskSpaceAllocator, storeMainMetrics, storeUnderCompactionMetrics, keyFactory, recovery, hardDelete, replicaStatusDelegate, time); store.start(); List < DiskSpaceRequirements > storeRequirements = Collections.singletonList(store.getDiskSpaceRequirements()); diskSpaceAllocator.addRequiredSegments(diskSpaceAllocator.getOverallRequirements(storeRequirements), false); compactionManager.addBlobStore(store); stores.put(replica.getPartitionId(), store); partitionToReplicaMap.put(replica.getPartitionId(), replica); File bootstrapFile = new File(replica.getReplicaPath(), BlobStore.BOOTSTRAP_FILE_NAME); if( ! bootstrapFile.exists()) { bootstrapFile.createNewFile(); } logger.info(\"New store is successfully added into DiskManager.\"); succeed = true; } } catch(Exception e) { logger.error(\"Failed to start new added store {} or add requirements to disk allocator\", replica.getPartitionId()); } finally { rwLock.writeLock().unlock(); } return succeed; } ",
        "focal_src": "boolean addBlobStore(ReplicaId replica) { rwLock.writeLock().lock(); boolean succeed = false; try { if( ! running) { logger.error(\"Failed to add {} because disk manager is not running\", replica.getPartitionId()); } else { BlobStore store = new BlobStore(replica, storeConfig, scheduler, longLivedTaskScheduler, diskIOScheduler, diskSpaceAllocator, storeMainMetrics, storeUnderCompactionMetrics, keyFactory, recovery, hardDelete, replicaStatusDelegate, time); store.start(); List < DiskSpaceRequirements > storeRequirements = Collections.singletonList(store.getDiskSpaceRequirements()); diskSpaceAllocator.addRequiredSegments(diskSpaceAllocator.getOverallRequirements(storeRequirements), false); compactionManager.addBlobStore(store); stores.put(replica.getPartitionId(), store); partitionToReplicaMap.put(replica.getPartitionId(), replica); logger.info(\"New store is successfully added into DiskManager.\"); succeed = true; } } catch(Exception e) { logger.error(\"Failed to start new added store {} or add requirements to disk allocator\", replica.getPartitionId()); } finally { rwLock.writeLock().unlock(); } return succeed; } ",
        "test_tgt": "@Test public void addBlobStoreTest()throws Exception { generateConfigs(true); MockDataNodeId localNode = clusterMap.getDataNodes().get(0); List < ReplicaId > localReplicas = clusterMap.getReplicaIds(localNode); int newMountPathIndex = 3; File f = File.createTempFile(\"ambry\", \".tmp\"); File mountFile = new File(f.getParent(), \"mountpathfile\" + MockClusterMap.PLAIN_TEXT_PORT_START_NUMBER + newMountPathIndex); MockClusterMap.deleteFileOrDirectory(mountFile); assertTrue(\"Couldn't create mount path directory\", mountFile.mkdir()); localNode.addMountPaths(Collections.singletonList(mountFile.getAbsolutePath())); PartitionId newPartition1 = new MockPartitionId(10L, MockClusterMap.DEFAULT_PARTITION_CLASS, clusterMap.getDataNodes(), newMountPathIndex); StorageManager storageManager = createStorageManager(localNode, metricRegistry, null); storageManager.start(); assertFalse(\"Add store which is already existing should fail\", storageManager.addBlobStore(localReplicas.get(0))); assertTrue(\"Add new store should succeed\", storageManager.addBlobStore(newPartition1.getReplicaIds().get(0))); assertNotNull(\"The store shouldn't be null because new store is successfully added\", storageManager.getStore(newPartition1, false)); PartitionId newPartition2 = new MockPartitionId(11L, MockClusterMap.DEFAULT_PARTITION_CLASS, clusterMap.getDataNodes(), 0); storageManager.getDiskManager(localReplicas.get(0).getPartitionId()).shutdown(); assertFalse(\"Add store onto the DiskManager which is not running should fail\", storageManager.addBlobStore(newPartition2.getReplicaIds().get(0))); storageManager.getDiskManager(localReplicas.get(0).getPartitionId()).start(); shutdownAndAssertStoresInaccessible(storageManager, localReplicas); List < String > mountPaths = localNode.getMountPaths(); String diskToFail = mountPaths.get(0); File reservePoolDir = new File(diskToFail, diskManagerConfig.diskManagerReserveFileDirName); File storeReserveDir = new File(reservePoolDir, DiskSpaceAllocator.STORE_DIR_PREFIX + newPartition2.toString()); StorageManager storageManager2 = createStorageManager(localNode, new MetricRegistry(), null); storageManager2.start(); Utils.deleteFileOrDirectory(storeReserveDir); assertTrue(\"File creation should succeed\", storeReserveDir.createNewFile()); assertFalse(\"Add store should fail if store couldn't start due to initializePool failure\", storageManager2.addBlobStore(newPartition2.getReplicaIds().get(0))); assertNull(\"New store shouldn't be in in-memory data structure\", storageManager2.getStore(newPartition2, false)); shutdownAndAssertStoresInaccessible(storageManager2, localReplicas); } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void test_toEpochDay() { long date_0000_01_01 = - 678941 - 40587; LocalDate test = LocalDate.of(0, 1, 1); for(long i = date_0000_01_01; i < 700000; i ++ ) { assertEquals(test.toEpochDay(), i); test = next(test); } test = LocalDate.of(0, 1, 1); for(long i = date_0000_01_01; i > - 2000000; i -- ) { assertEquals(test.toEpochDay(), i); test = previous(test); } assertEquals(LocalDate.of(1858, 11, 17).toEpochDay(), - 40587); assertEquals(LocalDate.of(1, 1, 1).toEpochDay(), - 678575 - 40587); assertEquals(LocalDate.of(1995, 9, 27).toEpochDay(), 49987 - 40587); assertEquals(LocalDate.of(1970, 1, 1).toEpochDay(), 0); assertEquals(LocalDate.of( - 1, 12, 31).toEpochDay(), - 678942 - 40587); } ",
        "focal_tgt": "default long toEpochDay() { return getLong(EPOCH_DAY); } ",
        "focal_src": "public default long toEpochDay() { return getLong(EPOCH_DAY); } ",
        "test_tgt": "@Test public void test_toEpochDay() { long date_0000_01_01 = - 678941 - 40587; LocalDate test = LocalDate.of(0, 1, 1); for(long i = date_0000_01_01; i < 700000; i ++ ) { assertEquals(test.toEpochDay(), i); test = next(test); } test = LocalDate.of(0, 1, 1); for(long i = date_0000_01_01; i > - 2000000; i -- ) { assertEquals(test.toEpochDay(), i); test = previous(test); } assertEquals(LocalDate.of(1858, 11, 17).toEpochDay(), - 40587); assertEquals(LocalDate.of(1, 1, 1).toEpochDay(), - 678575 - 40587); assertEquals(LocalDate.of(1995, 9, 27).toEpochDay(), 49987 - 40587); assertEquals(LocalDate.of(1970, 1, 1).toEpochDay(), 0); assertEquals(LocalDate.of( - 1, 12, 31).toEpochDay(), - 678942 - 40587); } "
    },
    {
        "test_src": "@Test public void fullViewLeft_calibrated() { IntrinsicParameters param = new IntrinsicParameters(300, 320, 0, 150, 130, width, height, false, new double[] { 0.1, 1e-4 }); DenseMatrix64F rect1 = CommonOps.identity(3); DenseMatrix64F rect2 = CommonOps.identity(3); DenseMatrix64F rectK = UtilIntrinsic.calibrationMatrix(param, null); RectifyImageOps.fullViewLeft(param, rect1, rect2, rectK); PointTransform_F32 tran = RectifyImageOps.rectifyTransform(param, rect1); checkInside(tran); } ",
        "focal_tgt": "public static void fullViewLeft(IntrinsicParameters paramLeft, DenseMatrix64F rectifyLeft, DenseMatrix64F rectifyRight, DenseMatrix64F rectifyK) { paramLeft = new IntrinsicParameters(paramLeft); paramLeft.leftHanded = false; PointTransform_F32 tranLeft = rectifyTransform(paramLeft, rectifyLeft); Rectangle2D_F32 bound = DistortImageOps.boundBox_F32(paramLeft.width, paramLeft.height, new PointToPixelTransform_F32(tranLeft)); double scaleX = paramLeft.width / bound.width; double scaleY = paramLeft.height / bound.height; double scale = Math.min(scaleX, scaleY); adjustCalibrated(rectifyLeft, rectifyRight, rectifyK, bound, scale); } ",
        "focal_src": "public static void fullViewLeft(IntrinsicParameters paramLeft, DenseMatrix64F rectifyLeft, DenseMatrix64F rectifyRight, DenseMatrix64F rectifyK) { PointTransform_F32 tranLeft = rectifyTransform(paramLeft, rectifyLeft); Rectangle2D_F32 bound = DistortImageOps.boundBox_F32(paramLeft.width, paramLeft.height, new PointToPixelTransform_F32(tranLeft)); double scaleX = paramLeft.width / bound.width; double scaleY = paramLeft.height / bound.height; double scale = Math.min(scaleX, scaleY); adjustCalibrated(rectifyLeft, rectifyRight, rectifyK, bound, scale); } ",
        "test_tgt": "@Test public void fullViewLeft_calibrated() { fullViewLeft_calibrated(false); fullViewLeft_calibrated(true); } "
    },
    {
        "test_src": "@Test public void testParse()throws Exception { PiPipelineModel model = P4InfoParser.parse(p4InfoUrl); PiPipelineModel model2 = P4InfoParser.parse(p4InfoUrl); new EqualsTester().addEqualityGroup(model, model2).testEquals(); final P4Info p4info; try { p4info = getP4InfoMessage(p4InfoUrl); } catch(IOException e) { throw new P4InfoParserException(\"Unable to parse protobuf \" + p4InfoUrl.toString(), e); } List < Table > tableMsgs = p4info.getTablesList(); PiTableId table0Id = PiTableId.of(tableMsgs.get(0).getPreamble().getName()); PiTableId wcmpTableId = PiTableId.of(tableMsgs.get(1).getPreamble().getName()); PiTableModel table0Model = model.table(table0Id).orElse(null); PiTableModel wcmpTableModel = model.table(wcmpTableId).orElse(null); PiTableModel table0Model2 = model2.table(table0Id).orElse(null); PiTableModel wcmpTableModel2 = model2.table(wcmpTableId).orElse(null); new EqualsTester().addEqualityGroup(table0Model, table0Model2).addEqualityGroup(wcmpTableModel, wcmpTableModel2).testEquals(); assertThat(\"model parsed value is null\", table0Model, notNullValue()); assertThat(\"model parsed value is null\", wcmpTableModel, notNullValue()); assertThat(\"Incorrect size for table0 size\", table0Model.maxSize(), is(equalTo(DEFAULT_MAX_TABLE_SIZE))); assertThat(\"Incorrect size for wcmp_table size\", wcmpTableModel.maxSize(), is(equalTo(DEFAULT_MAX_TABLE_SIZE))); List < MatchField > matchFieldList = tableMsgs.get(0).getMatchFieldsList(); List < PiMatchFieldModel > piMatchFieldList = new ArrayList < > (); for(MatchField matchFieldIter : matchFieldList) { int matchTypeNumber = matchFieldIter.getMatchType().getNumber(); PiMatchType piMatchType = PiMatchType.VALID; switch(matchTypeNumber) { case 1 : piMatchType = PiMatchType.VALID; break; case 2 : piMatchType = PiMatchType.EXACT; break; case 3 : piMatchType = PiMatchType.LPM; break; case 4 : piMatchType = piMatchType.TERNARY; break; case 5 : piMatchType = piMatchType.RANGE; break; default : piMatchType = PiMatchType.VALID; break; } piMatchFieldList.add(new P4MatchFieldModel(PiMatchFieldId.of(matchFieldIter.getName()), matchFieldIter.getBitwidth(), piMatchType)); } assertThat(\"Incorrect size for matchFields\", table0Model.matchFields().size(), is(equalTo(9))); assertThat(\"Incorrect order for matchFields\", table0Model.matchFields(), IsIterableContainingInOrder.contains(piMatchFieldList.get(0), piMatchFieldList.get(1), piMatchFieldList.get(2), piMatchFieldList.get(3), piMatchFieldList.get(4), piMatchFieldList.get(5), piMatchFieldList.get(6), piMatchFieldList.get(7), piMatchFieldList.get(8))); assertThat(\"Incorrect size for matchFields\", wcmpTableModel.matchFields().size(), is(equalTo(1))); matchFieldList = tableMsgs.get(1).getMatchFieldsList(); assertThat(\"Incorrect order for matchFields\", wcmpTableModel.matchFields(), IsIterableContainingInOrder.contains(new P4MatchFieldModel(PiMatchFieldId.of(matchFieldList.get(0).getName()), matchFieldList.get(0).getBitwidth(), PiMatchType.EXACT))); List < ActionRef > actionRefList = tableMsgs.get(0).getActionRefsList(); assertThat(\"Incorrect size for actionRefs\", actionRefList.size(), is(equalTo(4))); PiActionId actionId = PiActionId.of(\"set_egress_port\"); PiActionParamId piActionParamId = PiActionParamId.of(\"port\"); int bitWitdth = 9; PiActionParamModel actionParamModel = new P4ActionParamModel(piActionParamId, bitWitdth); ImmutableMap < PiActionParamId, PiActionParamModel > params = new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().put(piActionParamId, actionParamModel).build(); PiActionModel setEgressPortAction = new P4ActionModel(actionId, params); actionId = PiActionId.of(\"send_to_cpu\"); PiActionModel sendToCpuAction = new P4ActionModel(actionId, new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().build()); actionId = PiActionId.of(\"_drop\"); PiActionModel dropAction = new P4ActionModel(actionId, new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().build()); actionId = PiActionId.of(\"NoAction\"); PiActionModel noAction = new P4ActionModel(actionId, new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().build()); actionId = PiActionId.of(\"table0_control.set_next_hop_id\"); piActionParamId = PiActionParamId.of(\"next_hop_id\"); bitWitdth = 16; actionParamModel = new P4ActionParamModel(piActionParamId, bitWitdth); params = new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().put(piActionParamId, actionParamModel).build(); PiActionModel setNextHopIdAction = new P4ActionModel(actionId, params); assertThat(\"action dose not match\", table0Model.actions(), IsIterableContainingInAnyOrder.containsInAnyOrder(setEgressPortAction, sendToCpuAction, setNextHopIdAction, dropAction)); assertThat(\"actions dose not match\", wcmpTableModel.actions(), IsIterableContainingInAnyOrder.containsInAnyOrder(setEgressPortAction, noAction)); PiActionModel table0DefaultAction = table0Model.defaultAction().orElse(null); new EqualsTester().addEqualityGroup(table0DefaultAction, dropAction).testEquals(); assertThat(\"model parsed value is null\", table0DefaultAction, notNullValue()); PiTableId tableId = PiTableId.of(\"wcmp_control.wcmp_table\"); ImmutableSet < PiTableId > tableIds = new ImmutableSet.Builder < PiTableId > ().add(tableId).build(); PiActionProfileId actionProfileId = PiActionProfileId.of(\"wcmp_control.wcmp_selector\"); PiActionProfileModel wcmpSelector3 = new P4ActionProfileModel(actionProfileId, tableIds, true, DEFAULT_MAX_ACTION_PROFILE_SIZE); PiActionProfileModel wcmpSelector = model.actionProfiles(actionProfileId).orElse(null); PiActionProfileModel wcmpSelector2 = model2.actionProfiles(actionProfileId).orElse(null); new EqualsTester().addEqualityGroup(wcmpSelector, wcmpSelector2, wcmpSelector3).testEquals(); assertThat(\"model parsed value is null\", wcmpSelector, notNullValue()); assertThat(\"Incorrect value for actions profiles\", model.actionProfiles(), containsInAnyOrder(wcmpSelector)); assertThat(\"Incorrect size for action profiles\", model.actionProfiles().size(), is(equalTo(1))); PiCounterModel ingressPortCounterModel = model.counter(PiCounterId.of(\"port_counters_ingress.ingress_port_counter\")).orElse(null); PiCounterModel egressPortCounterModel = model.counter(PiCounterId.of(\"port_counters_egress.egress_port_counter\")).orElse(null); PiCounterModel table0CounterModel = model.counter(PiCounterId.of(\"table0_control.table0_counter\")).orElse(null); PiCounterModel wcmpTableCounterModel = model.counter(PiCounterId.of(\"wcmp_control.wcmp_table_counter\")).orElse(null); PiCounterModel ingressPortCounterModel2 = model2.counter(PiCounterId.of(\"port_counters_ingress.ingress_port_counter\")).orElse(null); PiCounterModel egressPortCounterModel2 = model2.counter(PiCounterId.of(\"port_counters_egress.egress_port_counter\")).orElse(null); PiCounterModel table0CounterModel2 = model2.counter(PiCounterId.of(\"table0_control.table0_counter\")).orElse(null); PiCounterModel wcmpTableCounterModel2 = model2.counter(PiCounterId.of(\"wcmp_control.wcmp_table_counter\")).orElse(null); new EqualsTester().addEqualityGroup(ingressPortCounterModel, ingressPortCounterModel2).addEqualityGroup(egressPortCounterModel, egressPortCounterModel2).addEqualityGroup(table0CounterModel, table0CounterModel2).addEqualityGroup(wcmpTableCounterModel, wcmpTableCounterModel2).testEquals(); assertThat(\"model parsed value is null\", ingressPortCounterModel, notNullValue()); assertThat(\"model parsed value is null\", egressPortCounterModel, notNullValue()); assertThat(\"model parsed value is null\", table0CounterModel, notNullValue()); assertThat(\"model parsed value is null\", wcmpTableCounterModel, notNullValue()); Collection < PiMeterModel > meterModel = model.meters(); Collection < PiMeterModel > meterModel2 = model2.meters(); assertThat(\"model pased meter collaction should be empty\", meterModel.isEmpty(), is(true)); assertThat(\"model pased meter collaction should be empty\", meterModel2.isEmpty(), is(true)); PiPacketOperationModel packetInOperationalModel = model.packetOperationModel(PiPacketOperationType.PACKET_IN).orElse(null); PiPacketOperationModel packetOutOperationalModel = model.packetOperationModel(PiPacketOperationType.PACKET_OUT).orElse(null); PiPacketOperationModel packetInOperationalModel2 = model2.packetOperationModel(PiPacketOperationType.PACKET_IN).orElse(null); PiPacketOperationModel packetOutOperationalModel2 = model2.packetOperationModel(PiPacketOperationType.PACKET_OUT).orElse(null); new EqualsTester().addEqualityGroup(packetInOperationalModel, packetInOperationalModel2).addEqualityGroup(packetOutOperationalModel, packetOutOperationalModel2).testEquals(); assertThat(\"model parsed value is null\", packetInOperationalModel, notNullValue()); assertThat(\"model parsed value is null\", packetOutOperationalModel, notNullValue()); } ",
        "focal_tgt": "public static PiPipelineModel parse(URL p4InfoUrl)throws P4InfoParserException { final P4Info p4info; try { p4info = getP4InfoMessage(p4InfoUrl); } catch(IOException e) { throw new P4InfoParserException(\"Unable to parse protobuf \" + p4InfoUrl.toString(), e); } final Map < Integer, PiCounterModel > counterMap = Maps.newHashMap(); counterMap.putAll(parseCounters(p4info)); counterMap.putAll(parseDirectCounters(p4info)); final Map < Integer, PiMeterModel > meterMap = Maps.newHashMap(); meterMap.putAll(parseMeters(p4info)); meterMap.putAll(parseDirectMeters(p4info)); final Map < Integer, PiRegisterModel > registerMap = Maps.newHashMap(); registerMap.putAll(parseRegisters(p4info)); final Map < Integer, PiActionProfileModel > actProfileMap = parseActionProfiles(p4info); final Map < Integer, PiActionModel > actionMap = parseActions(p4info); final Map < PiPacketOperationType, PiPacketOperationModel > pktOpMap = parseCtrlPktMetadatas(p4info); final ImmutableMap.Builder < PiTableId, PiTableModel > tableImmMapBuilder = ImmutableMap.builder(); for(Table tableMsg : p4info.getTablesList()) { final PiTableId tableId = PiTableId.of(tableMsg.getPreamble().getName()); final ImmutableMap.Builder < PiMatchFieldId, PiMatchFieldModel > tableFieldMapBuilder = ImmutableMap.builder(); for(MatchField fieldMsg : tableMsg.getMatchFieldsList()) { final PiMatchFieldId fieldId = PiMatchFieldId.of(fieldMsg.getName()); tableFieldMapBuilder.put(fieldId, new P4MatchFieldModel(fieldId, fieldMsg.getBitwidth(), mapMatchFieldType(fieldMsg.getMatchType()))); } final ImmutableMap.Builder < PiActionId, PiActionModel > tableActionMapBuilder = ImmutableMap.builder(); tableMsg.getActionRefsList().stream().map(ActionRef :: getId).map(actionMap :: get).forEach(actionModel -> tableActionMapBuilder.put(actionModel.id(), actionModel)); final ImmutableMap.Builder < PiMeterId, PiMeterModel > tableMeterMapBuilder = ImmutableMap.builder(); tableMsg.getDirectResourceIdsList().stream().map(meterMap :: get).filter(Objects :: nonNull).forEach(meterModel -> tableMeterMapBuilder.put(meterModel.id(), meterModel)); final ImmutableMap.Builder < PiCounterId, PiCounterModel > tableCounterMapBuilder = ImmutableMap.builder(); tableMsg.getDirectResourceIdsList().stream().map(counterMap :: get).filter(Objects :: nonNull).forEach(counterModel -> tableCounterMapBuilder.put(counterModel.id(), counterModel)); tableImmMapBuilder.put(tableId, new P4TableModel(PiTableId.of(tableMsg.getPreamble().getName()), tableMsg.getImplementationId() == 0 ? PiTableType.DIRECT : PiTableType.INDIRECT, actProfileMap.get(tableMsg.getImplementationId()), tableMsg.getSize(), tableCounterMapBuilder.build(), tableMeterMapBuilder.build(), ! tableMsg.getIdleTimeoutBehavior().equals(Table.IdleTimeoutBehavior.NO_TIMEOUT), tableFieldMapBuilder.build(), tableActionMapBuilder.build(), actionMap.get(tableMsg.getConstDefaultActionId()), tableMsg.getConstDefaultActionHasMutableParams())); } ImmutableMap < PiCounterId, PiCounterModel > counterImmMap = ImmutableMap.copyOf(counterMap.values().stream().collect(Collectors.toMap(PiCounterModel :: id, c -> c))); ImmutableMap < PiMeterId, PiMeterModel > meterImmMap = ImmutableMap.copyOf(meterMap.values().stream().collect(Collectors.toMap(PiMeterModel :: id, m -> m))); ImmutableMap < PiRegisterId, PiRegisterModel > registerImmMap = ImmutableMap.copyOf(registerMap.values().stream().collect(Collectors.toMap(PiRegisterModel :: id, r -> r))); ImmutableMap < PiActionProfileId, PiActionProfileModel > actProfileImmMap = ImmutableMap.copyOf(actProfileMap.values().stream().collect(Collectors.toMap(PiActionProfileModel :: id, a -> a))); return new P4PipelineModel(tableImmMapBuilder.build(), counterImmMap, meterImmMap, registerImmMap, actProfileImmMap, ImmutableMap.copyOf(pktOpMap)); } ",
        "focal_src": "public static PiPipelineModel parse(URL p4InfoUrl)throws P4InfoParserException { final P4Info p4info; try { p4info = getP4InfoMessage(p4InfoUrl); } catch(IOException e) { throw new P4InfoParserException(\"Unable to parse protobuf \" + p4InfoUrl.toString(), e); } final Map < Integer, PiCounterModel > counterMap = Maps.newHashMap(); counterMap.putAll(parseCounters(p4info)); counterMap.putAll(parseDirectCounters(p4info)); final Map < Integer, PiMeterModel > meterMap = Maps.newHashMap(); meterMap.putAll(parseMeters(p4info)); meterMap.putAll(parseDirectMeters(p4info)); final Map < Integer, PiRegisterModel > registerMap = Maps.newHashMap(); registerMap.putAll(parseRegisters(p4info)); final Map < Integer, PiActionProfileModel > actProfileMap = parseActionProfiles(p4info); final Map < Integer, PiActionModel > actionMap = parseActions(p4info); final Map < PiPacketOperationType, PiPacketOperationModel > pktOpMap = parseCtrlPktMetadatas(p4info); final ImmutableMap.Builder < PiTableId, PiTableModel > tableImmMapBuilder = ImmutableMap.builder(); for(Table tableMsg : p4info.getTablesList()) { final PiTableId tableId = PiTableId.of(tableMsg.getPreamble().getName()); final ImmutableMap.Builder < PiMatchFieldId, PiMatchFieldModel > tableFieldMapBuilder = ImmutableMap.builder(); for(MatchField fieldMsg : tableMsg.getMatchFieldsList()) { final PiMatchFieldId fieldId = PiMatchFieldId.of(fieldMsg.getName()); tableFieldMapBuilder.put(fieldId, new P4MatchFieldModel(fieldId, fieldMsg.getBitwidth(), mapMatchFieldType(fieldMsg.getMatchType()))); } final ImmutableMap.Builder < PiActionId, PiActionModel > tableActionMapBuilder = ImmutableMap.builder(); tableMsg.getActionRefsList().stream().map(ActionRef :: getId).map(actionMap :: get).forEach(actionModel -> tableActionMapBuilder.put(actionModel.id(), actionModel)); final ImmutableMap.Builder < PiMeterId, PiMeterModel > tableMeterMapBuilder = ImmutableMap.builder(); tableMsg.getDirectResourceIdsList().stream().map(meterMap :: get).filter(Objects :: nonNull).forEach(meterModel -> tableMeterMapBuilder.put(meterModel.id(), meterModel)); final ImmutableMap.Builder < PiCounterId, PiCounterModel > tableCounterMapBuilder = ImmutableMap.builder(); tableMsg.getDirectResourceIdsList().stream().map(counterMap :: get).filter(Objects :: nonNull).forEach(counterModel -> tableCounterMapBuilder.put(counterModel.id(), counterModel)); tableImmMapBuilder.put(tableId, new P4TableModel(PiTableId.of(tableMsg.getPreamble().getName()), tableMsg.getImplementationId() == 0 ? PiTableType.DIRECT : PiTableType.INDIRECT, actProfileMap.get(tableMsg.getImplementationId()), tableMsg.getSize(), tableCounterMapBuilder.build(), tableMeterMapBuilder.build(), tableMsg.getWithEntryTimeout(), tableFieldMapBuilder.build(), tableActionMapBuilder.build(), actionMap.get(tableMsg.getConstDefaultActionId()), tableMsg.getConstDefaultActionHasMutableParams())); } ImmutableMap < PiCounterId, PiCounterModel > counterImmMap = ImmutableMap.copyOf(counterMap.values().stream().collect(Collectors.toMap(PiCounterModel :: id, c -> c))); ImmutableMap < PiMeterId, PiMeterModel > meterImmMap = ImmutableMap.copyOf(meterMap.values().stream().collect(Collectors.toMap(PiMeterModel :: id, m -> m))); ImmutableMap < PiRegisterId, PiRegisterModel > registerImmMap = ImmutableMap.copyOf(registerMap.values().stream().collect(Collectors.toMap(PiRegisterModel :: id, r -> r))); ImmutableMap < PiActionProfileId, PiActionProfileModel > actProfileImmMap = ImmutableMap.copyOf(actProfileMap.values().stream().collect(Collectors.toMap(PiActionProfileModel :: id, a -> a))); return new P4PipelineModel(tableImmMapBuilder.build(), counterImmMap, meterImmMap, registerImmMap, actProfileImmMap, ImmutableMap.copyOf(pktOpMap)); } ",
        "test_tgt": "@Test public void testParse()throws Exception { PiPipelineModel model = P4InfoParser.parse(p4InfoUrl); PiPipelineModel model2 = P4InfoParser.parse(p4InfoUrl); new EqualsTester().addEqualityGroup(model, model2).testEquals(); final P4Info p4info; try { p4info = getP4InfoMessage(p4InfoUrl); } catch(IOException e) { throw new P4InfoParserException(\"Unable to parse protobuf \" + p4InfoUrl.toString(), e); } List < Table > tableMsgs = p4info.getTablesList(); PiTableId table0Id = PiTableId.of(tableMsgs.get(0).getPreamble().getName()); PiTableId wcmpTableId = PiTableId.of(tableMsgs.get(1).getPreamble().getName()); PiTableModel table0Model = model.table(table0Id).orElse(null); PiTableModel wcmpTableModel = model.table(wcmpTableId).orElse(null); PiTableModel table0Model2 = model2.table(table0Id).orElse(null); PiTableModel wcmpTableModel2 = model2.table(wcmpTableId).orElse(null); new EqualsTester().addEqualityGroup(table0Model, table0Model2).addEqualityGroup(wcmpTableModel, wcmpTableModel2).testEquals(); assertThat(\"model parsed value is null\", table0Model, notNullValue()); assertThat(\"model parsed value is null\", wcmpTableModel, notNullValue()); assertThat(\"Incorrect size for table0 size\", table0Model.maxSize(), is(equalTo(DEFAULT_MAX_TABLE_SIZE))); assertThat(\"Incorrect size for wcmp_table size\", wcmpTableModel.maxSize(), is(equalTo(DEFAULT_MAX_TABLE_SIZE))); List < MatchField > matchFieldList = tableMsgs.get(0).getMatchFieldsList(); List < PiMatchFieldModel > piMatchFieldList = new ArrayList < > (); for(MatchField matchFieldIter : matchFieldList) { MatchField.MatchType matchType = matchFieldIter.getMatchType(); PiMatchType piMatchType; switch(matchType) { case EXACT : piMatchType = PiMatchType.EXACT; break; case LPM : piMatchType = PiMatchType.LPM; break; case TERNARY : piMatchType = PiMatchType.TERNARY; break; case RANGE : piMatchType = PiMatchType.RANGE; break; default : Assert.fail(); return; } piMatchFieldList.add(new P4MatchFieldModel(PiMatchFieldId.of(matchFieldIter.getName()), matchFieldIter.getBitwidth(), piMatchType)); } assertThat(\"Incorrect size for matchFields\", table0Model.matchFields().size(), is(equalTo(9))); assertThat(\"Incorrect order for matchFields\", table0Model.matchFields(), IsIterableContainingInOrder.contains(piMatchFieldList.get(0), piMatchFieldList.get(1), piMatchFieldList.get(2), piMatchFieldList.get(3), piMatchFieldList.get(4), piMatchFieldList.get(5), piMatchFieldList.get(6), piMatchFieldList.get(7), piMatchFieldList.get(8))); assertThat(\"Incorrect size for matchFields\", wcmpTableModel.matchFields().size(), is(equalTo(1))); matchFieldList = tableMsgs.get(1).getMatchFieldsList(); assertThat(\"Incorrect order for matchFields\", wcmpTableModel.matchFields(), IsIterableContainingInOrder.contains(new P4MatchFieldModel(PiMatchFieldId.of(matchFieldList.get(0).getName()), matchFieldList.get(0).getBitwidth(), PiMatchType.EXACT))); List < ActionRef > actionRefList = tableMsgs.get(0).getActionRefsList(); assertThat(\"Incorrect size for actionRefs\", actionRefList.size(), is(equalTo(4))); PiActionId actionId = PiActionId.of(\"set_egress_port\"); PiActionParamId piActionParamId = PiActionParamId.of(\"port\"); int bitWitdth = 9; PiActionParamModel actionParamModel = new P4ActionParamModel(piActionParamId, bitWitdth); ImmutableMap < PiActionParamId, PiActionParamModel > params = new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().put(piActionParamId, actionParamModel).build(); PiActionModel setEgressPortAction = new P4ActionModel(actionId, params); actionId = PiActionId.of(\"send_to_cpu\"); PiActionModel sendToCpuAction = new P4ActionModel(actionId, new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().build()); actionId = PiActionId.of(\"_drop\"); PiActionModel dropAction = new P4ActionModel(actionId, new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().build()); actionId = PiActionId.of(\"NoAction\"); PiActionModel noAction = new P4ActionModel(actionId, new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().build()); actionId = PiActionId.of(\"table0_control.set_next_hop_id\"); piActionParamId = PiActionParamId.of(\"next_hop_id\"); bitWitdth = 16; actionParamModel = new P4ActionParamModel(piActionParamId, bitWitdth); params = new ImmutableMap.Builder < PiActionParamId, PiActionParamModel > ().put(piActionParamId, actionParamModel).build(); PiActionModel setNextHopIdAction = new P4ActionModel(actionId, params); assertThat(\"action dose not match\", table0Model.actions(), IsIterableContainingInAnyOrder.containsInAnyOrder(setEgressPortAction, sendToCpuAction, setNextHopIdAction, dropAction)); assertThat(\"actions dose not match\", wcmpTableModel.actions(), IsIterableContainingInAnyOrder.containsInAnyOrder(setEgressPortAction, noAction)); PiActionModel table0DefaultAction = table0Model.defaultAction().orElse(null); new EqualsTester().addEqualityGroup(table0DefaultAction, dropAction).testEquals(); assertThat(\"model parsed value is null\", table0DefaultAction, notNullValue()); PiTableId tableId = PiTableId.of(\"wcmp_control.wcmp_table\"); ImmutableSet < PiTableId > tableIds = new ImmutableSet.Builder < PiTableId > ().add(tableId).build(); PiActionProfileId actionProfileId = PiActionProfileId.of(\"wcmp_control.wcmp_selector\"); PiActionProfileModel wcmpSelector3 = new P4ActionProfileModel(actionProfileId, tableIds, true, DEFAULT_MAX_ACTION_PROFILE_SIZE); PiActionProfileModel wcmpSelector = model.actionProfiles(actionProfileId).orElse(null); PiActionProfileModel wcmpSelector2 = model2.actionProfiles(actionProfileId).orElse(null); new EqualsTester().addEqualityGroup(wcmpSelector, wcmpSelector2, wcmpSelector3).testEquals(); assertThat(\"model parsed value is null\", wcmpSelector, notNullValue()); assertThat(\"Incorrect value for actions profiles\", model.actionProfiles(), containsInAnyOrder(wcmpSelector)); assertThat(\"Incorrect size for action profiles\", model.actionProfiles().size(), is(equalTo(1))); PiCounterModel ingressPortCounterModel = model.counter(PiCounterId.of(\"port_counters_ingress.ingress_port_counter\")).orElse(null); PiCounterModel egressPortCounterModel = model.counter(PiCounterId.of(\"port_counters_egress.egress_port_counter\")).orElse(null); PiCounterModel table0CounterModel = model.counter(PiCounterId.of(\"table0_control.table0_counter\")).orElse(null); PiCounterModel wcmpTableCounterModel = model.counter(PiCounterId.of(\"wcmp_control.wcmp_table_counter\")).orElse(null); PiCounterModel ingressPortCounterModel2 = model2.counter(PiCounterId.of(\"port_counters_ingress.ingress_port_counter\")).orElse(null); PiCounterModel egressPortCounterModel2 = model2.counter(PiCounterId.of(\"port_counters_egress.egress_port_counter\")).orElse(null); PiCounterModel table0CounterModel2 = model2.counter(PiCounterId.of(\"table0_control.table0_counter\")).orElse(null); PiCounterModel wcmpTableCounterModel2 = model2.counter(PiCounterId.of(\"wcmp_control.wcmp_table_counter\")).orElse(null); new EqualsTester().addEqualityGroup(ingressPortCounterModel, ingressPortCounterModel2).addEqualityGroup(egressPortCounterModel, egressPortCounterModel2).addEqualityGroup(table0CounterModel, table0CounterModel2).addEqualityGroup(wcmpTableCounterModel, wcmpTableCounterModel2).testEquals(); assertThat(\"model parsed value is null\", ingressPortCounterModel, notNullValue()); assertThat(\"model parsed value is null\", egressPortCounterModel, notNullValue()); assertThat(\"model parsed value is null\", table0CounterModel, notNullValue()); assertThat(\"model parsed value is null\", wcmpTableCounterModel, notNullValue()); Collection < PiMeterModel > meterModel = model.meters(); Collection < PiMeterModel > meterModel2 = model2.meters(); assertThat(\"model pased meter collaction should be empty\", meterModel.isEmpty(), is(true)); assertThat(\"model pased meter collaction should be empty\", meterModel2.isEmpty(), is(true)); PiPacketOperationModel packetInOperationalModel = model.packetOperationModel(PiPacketOperationType.PACKET_IN).orElse(null); PiPacketOperationModel packetOutOperationalModel = model.packetOperationModel(PiPacketOperationType.PACKET_OUT).orElse(null); PiPacketOperationModel packetInOperationalModel2 = model2.packetOperationModel(PiPacketOperationType.PACKET_IN).orElse(null); PiPacketOperationModel packetOutOperationalModel2 = model2.packetOperationModel(PiPacketOperationType.PACKET_OUT).orElse(null); new EqualsTester().addEqualityGroup(packetInOperationalModel, packetInOperationalModel2).addEqualityGroup(packetOutOperationalModel, packetOutOperationalModel2).testEquals(); assertThat(\"model parsed value is null\", packetInOperationalModel, notNullValue()); assertThat(\"model parsed value is null\", packetOutOperationalModel, notNullValue()); } "
    },
    {
        "test_src": "@Test public void forJavaName_fromLegacyEnumName() { assertNotEquals(forJavaName(\"TLS_RSA_EXPORT_WITH_RC4_40_MD5\"), forJavaName(\"SSL_RSA_EXPORT_WITH_RC4_40_MD5\")); assertNotEquals(forJavaName(\"TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA\"), forJavaName(\"SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA\")); assertNotEquals(forJavaName(\"TLS_FAKE_NEW_CIPHER\"), forJavaName(\"SSL_FAKE_NEW_CIPHER\")); } ",
        "focal_tgt": "public static synchronized CipherSuite forJavaName(String javaName) { CipherSuite result = INSTANCES.get(javaName); if(result == null) { result = new CipherSuite(javaName); INSTANCES.put(javaName, result); } return result; } ",
        "focal_src": "public static CipherSuite forJavaName(String javaName) { CipherSuite result = INSTANCES.get(javaName); if(result == null) { CipherSuite sample = new CipherSuite(javaName); CipherSuite canonical = INSTANCES.putIfAbsent(javaName, sample); result = (canonical == null) ? sample : canonical; } return result; } ",
        "test_tgt": "@Test public void forJavaName_fromLegacyEnumName() { assertEquals(forJavaName(\"TLS_RSA_EXPORT_WITH_RC4_40_MD5\"), forJavaName(\"SSL_RSA_EXPORT_WITH_RC4_40_MD5\")); assertEquals(forJavaName(\"TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA\"), forJavaName(\"SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA\")); assertEquals(forJavaName(\"TLS_FAKE_NEW_CIPHER\"), forJavaName(\"SSL_FAKE_NEW_CIPHER\")); } "
    },
    {
        "test_src": "@Test(dataProvider = \"ignoreOnWindows\", description = \"see http://code.google.com/p/jclouds/issues/detail?id=737\")public void testRemoveBlob_TwoComplexBlobKeys()throws IOException { final String BLOB_KEY1 = TestUtils.createRandomBlobKey(\"aa/bb/cc/dd/\", null); final String BLOB_KEY2 = TestUtils.createRandomBlobKey(\"aa/bb/ee/ff/\", null); boolean result; blobStore.createContainerInLocation(null, CONTAINER_NAME); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY1); assertFalse(result, \"Blob1 exists\"); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY2); assertFalse(result, \"Blob2 exists\"); TestUtils.createBlobsInContainer(CONTAINER_NAME, BLOB_KEY1, BLOB_KEY2); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY1); assertTrue(result, \"Blob \" + BLOB_KEY1 + \" doesn't exist\"); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY2); assertTrue(result, \"Blob \" + BLOB_KEY2 + \" doesn't exist\"); blobStore.removeBlob(CONTAINER_NAME, BLOB_KEY1); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY1); assertFalse(result, \"Blob still exists\"); TestUtils.fileExists(TARGET_CONTAINER_NAME + File.separator + BLOB_KEY1, false); TestUtils.fileExists(TARGET_CONTAINER_NAME + File.separator + BLOB_KEY2, true); TestUtils.directoryExists(TARGET_CONTAINER_NAME + \"/aa/bb/cc/dd\", false); TestUtils.directoryExists(TARGET_CONTAINER_NAME + \"/aa/bb\", true); blobStore.removeBlob(CONTAINER_NAME, BLOB_KEY2); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY2); assertFalse(result, \"Blob still exists\"); TestUtils.fileExists(TARGET_CONTAINER_NAME + File.separator + BLOB_KEY2, false); TestUtils.directoryExists(TARGET_CONTAINER_NAME + \"/aa\", false); } ",
        "focal_tgt": "@Override public ListenableFuture < Void > removeBlob(final String container, final String key) { storageStrategy.removeBlob(container, key); return immediateFuture(null); } ",
        "focal_src": "@Override public ListenableFuture < Void > removeBlob(final String container, final String key) { if(getContainerToBlobs().containsKey(container)) { getContainerToBlobs().get(container).remove(key); } return immediateFuture(null); } ",
        "test_tgt": "@Test(dataProvider = \"ignoreOnWindows\", description = \"see http://code.google.com/p/jclouds/issues/detail?id=737\")public void testRemoveBlob_TwoComplexBlobKeys()throws IOException { final String BLOB_KEY1 = TestUtils.createRandomBlobKey(\"aa/bb/cc/dd/\", null); final String BLOB_KEY2 = TestUtils.createRandomBlobKey(\"aa/bb/ee/ff/\", null); boolean result; blobStore.createContainerInLocation(null, CONTAINER_NAME); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY1); assertFalse(result, \"Blob1 exists\"); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY2); assertFalse(result, \"Blob2 exists\"); TestUtils.createBlobsInContainer(CONTAINER_NAME, BLOB_KEY1, BLOB_KEY2); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY1); assertTrue(result, \"Blob \" + BLOB_KEY1 + \" doesn't exist\"); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY2); assertTrue(result, \"Blob \" + BLOB_KEY2 + \" doesn't exist\"); blobStore.removeBlob(CONTAINER_NAME, BLOB_KEY1); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY1); assertFalse(result, \"Blob still exists\"); TestUtils.fileExists(TARGET_CONTAINER_NAME + File.separator + BLOB_KEY1, false); TestUtils.fileExists(TARGET_CONTAINER_NAME + File.separator + BLOB_KEY2, true); TestUtils.directoryExists(TARGET_CONTAINER_NAME + \"/aa/bb/cc/dd\", false); TestUtils.directoryExists(TARGET_CONTAINER_NAME + \"/aa/bb\", true); blobStore.removeBlob(CONTAINER_NAME, BLOB_KEY2); result = blobStore.blobExists(CONTAINER_NAME, BLOB_KEY2); assertFalse(result, \"Blob still exists\"); TestUtils.fileExists(TARGET_CONTAINER_NAME + File.separator + BLOB_KEY2, false); TestUtils.directoryExists(TARGET_CONTAINER_NAME + \"/aa\", false); } "
    },
    {
        "test_src": "@Test public void testReplaceAll_char_char() { StrBuilder sb = new StrBuilder(\"abcbccba\"); sb.replaceAll('x', 'y'); assertEquals(\"abcbccba\", sb.toString()); sb.replaceAll('a', 'd'); assertEquals(\"dbcbccbd\", sb.toString()); sb.replaceAll('b', 'e'); assertEquals(\"dececced\", sb.toString()); sb.replaceAll('c', 'f'); assertEquals(\"defeffed\", sb.toString()); sb.replaceAll('d', 'd'); assertEquals(\"defeffed\", sb.toString()); } ",
        "focal_tgt": "public StrBuilder replaceAll(final String searchStr, final String replaceStr) { final int searchLen = (searchStr == null ? 0 : searchStr.length()); if(searchLen > 0) { final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); int index = indexOf(searchStr, 0); while(index >= 0) { replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); index = indexOf(searchStr, index + replaceLen); } } return this; } ",
        "focal_src": "public StrBuilder replaceAll(final String searchStr, final String replaceStr) { int searchLen = (searchStr == null ? 0 : searchStr.length()); if(searchLen > 0) { int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); int index = indexOf(searchStr, 0); while(index >= 0) { replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); index = indexOf(searchStr, index + replaceLen); } } return this; } ",
        "test_tgt": "@Test public void testReplaceAll_char_char() { final StrBuilder sb = new StrBuilder(\"abcbccba\"); sb.replaceAll('x', 'y'); assertEquals(\"abcbccba\", sb.toString()); sb.replaceAll('a', 'd'); assertEquals(\"dbcbccbd\", sb.toString()); sb.replaceAll('b', 'e'); assertEquals(\"dececced\", sb.toString()); sb.replaceAll('c', 'f'); assertEquals(\"defeffed\", sb.toString()); sb.replaceAll('d', 'd'); assertEquals(\"defeffed\", sb.toString()); } "
    },
    {
        "test_src": "@Test public void testPersist()throws Exception { assumeTrue( ! ConnectionUtils.isJredis(template.getConnectionFactory())); populateBoundKey(); keyOps.persist(); assertEquals(keyOps.getClass().getName() + \" -> \" + keyOps.getKey(), Long.valueOf( - 1), keyOps.getExpire()); if(keyOps.expire(10, TimeUnit.SECONDS)) { assertTrue(keyOps.getExpire().longValue() > 0); } keyOps.persist(); assertEquals(keyOps.getClass().getName() + \" -> \" + keyOps.getKey(), - 1, keyOps.getExpire().longValue()); } ",
        "focal_tgt": "@Override public Boolean persist() { return operations.persist(key); } ",
        "focal_src": "public Boolean persist() { return operations.persist(key); } ",
        "test_tgt": "@Test public void testPersist()throws Exception { assumeTrue( ! ConnectionUtils.isJredis(template.getConnectionFactory())); keyOps.persist(); assertEquals(keyOps.getClass().getName() + \" -> \" + keyOps.getKey(), Long.valueOf( - 1), keyOps.getExpire()); if(keyOps.expire(10, TimeUnit.SECONDS)) { assertTrue(keyOps.getExpire().longValue() > 0); } keyOps.persist(); assertEquals(keyOps.getClass().getName() + \" -> \" + keyOps.getKey(), - 1, keyOps.getExpire().longValue()); } "
    },
    {
        "test_src": "protected void publishService(FrameworkMethod method) { version ++ ; try { TestingPolicy tp = method.getMethod().getAnnotation(TestingPolicy.class); if(tp == null) { tp = getTestClass().getJavaClass().getAnnotation(TestingPolicy.class); } if(tp == null) { throw new Exception(\"Missing test annotation @TestingPolicy.\"); } Class < ? extends IPolicy > policyUnderTest = tp.value(); Configuration config = method.getMethod().getAnnotation(Configuration.class); if(config == null) { config = getTestClass().getJavaClass().getAnnotation(Configuration.class); } if(config == null) { throw new Exception(\"Missing test annotation @Configuration.\"); } BackEndService backEnd = method.getMethod().getAnnotation(BackEndService.class); if(backEnd == null) { backEnd = getTestClass().getJavaClass().getAnnotation(BackEndService.class); } Class < ? extends IPolicyTestBackEndService > backEndService = null; if(backEnd == null) { backEndService = EchoBackEndService.class; } else { backEndService = backEnd.value(); } final Set < Throwable > errorHolder = new HashSet < > (); Policy policy = new Policy(); policy.setPolicyImpl(\"class:\" + policyUnderTest.getName()); policy.setPolicyJsonConfig(config.value()); Service service = new Service(); service.setEndpoint(backEndService.getName()); service.setEndpointType(\"TEST\"); service.setOrganizationId(orgId); service.setServiceId(serviceId); service.setVersion(String.valueOf(version)); service.setPublicService(true); service.setServicePolicies(Collections.singletonList(policy)); getEngine().getRegistry().publishService(service, new IAsyncResultHandler < Void > () { @Override public void handle(IAsyncResult < Void > result) { if(result.isError()) { errorHolder.add(result.getError()); } } }); if( ! errorHolder.isEmpty()) { throw errorHolder.iterator().next(); } } catch(Throwable e) { throw new RuntimeException(e); } } ",
        "focal_tgt": "public void publishApi(Api api, IAsyncResultHandler < Void > handler); ",
        "focal_src": "public void publishService(Service service, IAsyncResultHandler < Void > handler); ",
        "test_tgt": "protected void publishApi(FrameworkMethod method) { version ++ ; try { TestingPolicy tp = method.getMethod().getAnnotation(TestingPolicy.class); if(tp == null) { tp = getTestClass().getJavaClass().getAnnotation(TestingPolicy.class); } if(tp == null) { throw new Exception(\"Missing test annotation @TestingPolicy.\"); } Class < ? extends IPolicy > policyUnderTest = tp.value(); Configuration config = method.getMethod().getAnnotation(Configuration.class); if(config == null) { config = getTestClass().getJavaClass().getAnnotation(Configuration.class); } if(config == null) { throw new Exception(\"Missing test annotation @Configuration.\"); } BackEndApi backEnd = method.getMethod().getAnnotation(BackEndApi.class); if(backEnd == null) { backEnd = getTestClass().getJavaClass().getAnnotation(BackEndApi.class); } Class < ? extends IPolicyTestBackEndApi > backEndApi = null; if(backEnd == null) { backEndApi = EchoBackEndApi.class; } else { backEndApi = backEnd.value(); } final Set < Throwable > errorHolder = new HashSet < > (); Policy policy = new Policy(); policy.setPolicyImpl(\"class:\" + policyUnderTest.getName()); policy.setPolicyJsonConfig(config.value()); Api api = new Api(); api.setEndpoint(backEndApi.getName()); api.setEndpointType(\"TEST\"); api.setOrganizationId(orgId); api.setApiId(apiId); api.setVersion(String.valueOf(version)); api.setPublicAPI(true); api.setApiPolicies(Collections.singletonList(policy)); getEngine().getRegistry().publishApi(api, new IAsyncResultHandler < Void > () { @Override public void handle(IAsyncResult < Void > result) { if(result.isError()) { errorHolder.add(result.getError()); } } }); if( ! errorHolder.isEmpty()) { throw errorHolder.iterator().next(); } } catch(Throwable e) { throw new RuntimeException(e); } } "
    },
    {
        "test_src": "@Test public void testCalculate() { double[][]data = new double[][] { { 0, 1 }, { 1, 0 }, { 2, 2 }, { 3, 3 } }; double[]labels = new double[] { 0, 1, 1, 1 }; Map < Double, Integer > encoder = new HashMap < > (); encoder.put(0.0, 0); encoder.put(1.0, 1); GiniImpurityMeasureCalculator calculator = new GiniImpurityMeasureCalculator(encoder); StepFunction < GiniImpurityMeasure > []impurity = calculator.calculate(new DecisionTreeData(data, labels)); assertEquals(2, impurity.length); assertArrayEquals(new double[] { Double.NEGATIVE_INFINITY, 0, 1, 2, 3 }, impurity[0].getX(), 1e-10); assertEquals( - 2.500, impurity[0].getY()[0].impurity(), 1e-3); assertEquals( - 4.000, impurity[0].getY()[1].impurity(), 1e-3); assertEquals( - 3.000, impurity[0].getY()[2].impurity(), 1e-3); assertEquals( - 2.666, impurity[0].getY()[3].impurity(), 1e-3); assertEquals( - 2.500, impurity[0].getY()[4].impurity(), 1e-3); assertArrayEquals(new double[] { Double.NEGATIVE_INFINITY, 0, 1, 2, 3 }, impurity[1].getX(), 1e-10); assertEquals( - 2.500, impurity[1].getY()[0].impurity(), 1e-3); assertEquals( - 2.666, impurity[1].getY()[1].impurity(), 1e-3); assertEquals( - 3.000, impurity[1].getY()[2].impurity(), 1e-3); assertEquals( - 2.666, impurity[1].getY()[3].impurity(), 1e-3); assertEquals( - 2.500, impurity[1].getY()[4].impurity(), 1e-3); } ",
        "focal_tgt": "public abstract StepFunction < T > []calculate(DecisionTreeData data, TreeFilter filter, int depth); ",
        "focal_src": "public StepFunction < T > []calculate(DecisionTreeData data); ",
        "test_tgt": "@Test public void testCalculate() { double[][]data = new double[][] { { 0, 1 }, { 1, 0 }, { 2, 2 }, { 3, 3 } }; double[]labels = new double[] { 0, 1, 1, 1 }; Map < Double, Integer > encoder = new HashMap < > (); encoder.put(0.0, 0); encoder.put(1.0, 1); GiniImpurityMeasureCalculator calculator = new GiniImpurityMeasureCalculator(encoder, useIndex); StepFunction < GiniImpurityMeasure > []impurity = calculator.calculate(new DecisionTreeData(data, labels, useIndex), fs -> true, 0); assertEquals(2, impurity.length); assertArrayEquals(new double[] { Double.NEGATIVE_INFINITY, 0, 1, 2, 3 }, impurity[0].getX(), 1e-10); assertEquals( - 2.500, impurity[0].getY()[0].impurity(), 1e-3); assertEquals( - 4.000, impurity[0].getY()[1].impurity(), 1e-3); assertEquals( - 3.000, impurity[0].getY()[2].impurity(), 1e-3); assertEquals( - 2.666, impurity[0].getY()[3].impurity(), 1e-3); assertEquals( - 2.500, impurity[0].getY()[4].impurity(), 1e-3); assertArrayEquals(new double[] { Double.NEGATIVE_INFINITY, 0, 1, 2, 3 }, impurity[1].getX(), 1e-10); assertEquals( - 2.500, impurity[1].getY()[0].impurity(), 1e-3); assertEquals( - 2.666, impurity[1].getY()[1].impurity(), 1e-3); assertEquals( - 3.000, impurity[1].getY()[2].impurity(), 1e-3); assertEquals( - 2.666, impurity[1].getY()[3].impurity(), 1e-3); assertEquals( - 2.500, impurity[1].getY()[4].impurity(), 1e-3); } "
    },
    {
        "test_src": "@Test public void testLimit() { ew.where(\"name={0}\", \"'123'\").orderBy(\"id\", false); ew.limit(0, 3); String sqlSegment = ew.toString(); System.err.println(\"testLimit = \" + sqlSegment); Assert.assertEquals(\"WHERE (name=?)\\nORDER BY id DESC LIMIT 0, 3 \", sqlSegment); } ",
        "focal_tgt": "public Wrapper < T > last(String limit) { sql.LAST(limit); return this; } ",
        "focal_src": "public Wrapper < T > limit(int begin, int end) { sql.LIMIT(begin, end); return this; } ",
        "test_tgt": "@Test public void testLimit() { ew.where(\"name={0}\", \"'123'\").orderBy(\"id\", false); ew.last(\"limit 1,2\"); String sqlSegment = ew.toString(); System.err.println(\"testLimit = \" + sqlSegment); Assert.assertEquals(\"WHERE (name=?)\\nORDER BY id DESC limit 1,2\", sqlSegment); } "
    },
    {
        "test_src": "@Test public void testGetStream()throws ExecutionException, InterruptedException { String resourceURI = getURI() + \"v1/scopes/\" + scope1 + \"/streams/\" + stream1; String resourceURI2 = getURI() + \"v1/scopes/\" + scope1 + \"/streams/\" + stream2; when(mockControllerService.getStream(scope1, stream1)).thenReturn(streamConfigFuture); Response response = client.target(resourceURI).request().buildGet().invoke(); assertEquals(\"Get Stream Config Status\", 200, response.getStatus()); StreamProperty streamResponseActual = response.readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); response.close(); when(mockControllerService.getStream(scope1, stream2)).thenReturn(CompletableFuture.supplyAsync(() -> { throw new DataNotFoundException(\"Stream Not Found\"); })); response = client.target(resourceURI2).request().buildGet().invoke(); assertEquals(\"Get Stream Config Status\", 404, response.getStatus()); response.close(); } ",
        "focal_tgt": "@Override public void getStream(final String scopeName, final String streamName, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"getStream\"); controllerService.getStream(scopeName, streamName).thenApply(streamConfig -> Response.status(Status.OK).entity(ModelHelper.encodeStreamResponse(streamConfig)).build()).exceptionally(exception -> { if(exception.getCause()instanceof StoreException.DataNotFoundException || exception instanceof StoreException.DataNotFoundException) { log.warn(\"Stream: {}/{} not found\", scopeName, streamName); return Response.status(Status.NOT_FOUND).build(); } else { log.warn(\"getStream for {}/{} failed with exception: {}\", scopeName, streamName, exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).thenApply(asyncResponse :: resume).thenAccept(x -> LoggerHelpers.traceLeave(log, \"getStream\", traceId)); } ",
        "focal_src": "@Override public void getStream(final String scopeName, final String streamName, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"getStream\"); controllerService.getStream(scopeName, streamName).thenApply(streamConfig -> Response.status(Status.OK).entity(ModelHelper.encodeStreamResponse(streamConfig)).build()).exceptionally(exception -> { if(exception.getCause()instanceof DataNotFoundException || exception instanceof DataNotFoundException) { log.warn(\"Stream: {}/{} not found\", scopeName, streamName); return Response.status(Status.NOT_FOUND).build(); } else { log.warn(\"getStream for {}/{} failed with exception: {}\", scopeName, streamName, exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).thenApply(asyncResponse :: resume).thenAccept(x -> LoggerHelpers.traceLeave(log, \"getStream\", traceId)); } ",
        "test_tgt": "@Test public void testGetStream()throws ExecutionException, InterruptedException { String resourceURI = getURI() + \"v1/scopes/\" + scope1 + \"/streams/\" + stream1; String resourceURI2 = getURI() + \"v1/scopes/\" + scope1 + \"/streams/\" + stream2; when(mockControllerService.getStream(scope1, stream1)).thenReturn(streamConfigFuture); Response response = client.target(resourceURI).request().buildGet().invoke(); assertEquals(\"Get Stream Config Status\", 200, response.getStatus()); StreamProperty streamResponseActual = response.readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); response.close(); when(mockControllerService.getStream(scope1, stream2)).thenReturn(CompletableFuture.supplyAsync(() -> { throw StoreException.create(StoreException.Type.DATA_NOT_FOUND, stream2); })); response = client.target(resourceURI2).request().buildGet().invoke(); assertEquals(\"Get Stream Config Status\", 404, response.getStatus()); response.close(); } "
    },
    {
        "test_src": "@Test public void testRowKeys()throws Exception { int hoursAgo = 1; List < Object > groups = Collections.emptyList(); rowKeyBuilder = new SaltyRowKeyBuilder(saltDivisor, periodDuration, periodUnits); long oldest = System.currentTimeMillis() - TimeUnit.HOURS.toMillis(hoursAgo); ProfileMeasurement m = new ProfileMeasurement(\"profile\", \"entity\", oldest, periodDuration, periodUnits); m.setValue(22); List < byte[] > expectedKeys = new ArrayList < > (); for(int i = 0; i < (hoursAgo * 4) + 1; i ++ ) { byte[]rk = rowKeyBuilder.rowKey(m, groups); expectedKeys.add(rk); ProfilePeriod next = m.getPeriod().next(); m = new ProfileMeasurement(\"profile\", \"entity\", next.getStartTimeMillis(), periodDuration, periodUnits); } List < byte[] > actualKeys = rowKeyBuilder.rowKeys(measurement.getProfileName(), measurement.getEntity(), groups, hoursAgo, TimeUnit.HOURS); for(int i = 0; i < actualKeys.size(); i ++ ) { byte[]actual = actualKeys.get(i); byte[]expected = expectedKeys.get(i); assertThat(actual, equalTo(expected)); } } ",
        "focal_tgt": "@Override public List < byte[] > rowKeys(String profile, String entity, List < Object > groups, long start, long end) { List < byte[] > rowKeys = new ArrayList < > (); end = Math.max(start, end); start = Math.min(start, end); ProfilePeriod period = new ProfilePeriod(start, periodDurationMillis, TimeUnit.MILLISECONDS); while(period.getStartTimeMillis() <= end) { byte[]k = rowKey(profile, entity, period, groups); rowKeys.add(k); period = period.next(); } return rowKeys; } ",
        "focal_src": "@Override public List < byte[] > rowKeys(String profile, String entity, List < Object > groups, long durationAgo, TimeUnit unit) { List < byte[] > rowKeys = new ArrayList < > (); long endTime = System.currentTimeMillis(); long startTime = endTime - unit.toMillis(durationAgo); ProfilePeriod period = new ProfilePeriod(startTime, periodDurationMillis, TimeUnit.MILLISECONDS); while(period.getStartTimeMillis() <= endTime) { byte[]k = rowKey(profile, entity, period, groups); rowKeys.add(k); period = period.next(); } return rowKeys; } ",
        "test_tgt": "@Test public void testRowKeys()throws Exception { int hoursAgo = 1; List < Object > groups = Collections.emptyList(); rowKeyBuilder = new SaltyRowKeyBuilder(saltDivisor, periodDuration, periodUnits); long now = System.currentTimeMillis(); long oldest = now - TimeUnit.HOURS.toMillis(hoursAgo); ProfileMeasurement m = new ProfileMeasurement(\"profile\", \"entity\", oldest, periodDuration, periodUnits); m.setValue(22); List < byte[] > expectedKeys = new ArrayList < > (); for(int i = 0; i < (hoursAgo * 4) + 1; i ++ ) { byte[]rk = rowKeyBuilder.rowKey(m, groups); expectedKeys.add(rk); ProfilePeriod next = m.getPeriod().next(); m = new ProfileMeasurement(\"profile\", \"entity\", next.getStartTimeMillis(), periodDuration, periodUnits); } List < byte[] > actualKeys = rowKeyBuilder.rowKeys(measurement.getProfileName(), measurement.getEntity(), groups, oldest, now); for(int i = 0; i < actualKeys.size(); i ++ ) { byte[]actual = actualKeys.get(i); byte[]expected = expectedKeys.get(i); assertThat(actual, equalTo(expected)); } } "
    },
    {
        "test_src": "@Test public void down_2inputs()throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { Class input[] = new Class[] { ImageUInt8.class, ImageUInt16.class, ImageFloat32.class, ImageFloat64.class }; Class middle[] = new Class[] { ImageFloat32.class, ImageFloat32.class, ImageFloat32.class, ImageFloat64.class }; for(int i = 0; i < input.length; i ++ ) { ImageSingleBand in = GeneralizedImageOps.createSingleBand(input[i], 17, 14); ImageSingleBand mid = GeneralizedImageOps.createSingleBand(middle[i], 3, 14); ImageSingleBand found = GeneralizedImageOps.createSingleBand(input[i], 3, 4); ImageSingleBand expected = GeneralizedImageOps.createSingleBand(input[i], 3, 4); GImageMiscOps.fillUniform(in, rand, 0, 100); Method horizontal = ImplAverageDownSample.class.getDeclaredMethod(\"horizontal\", input[i], middle[i]); Method vertical = BoofTesting.findMethod(ImplAverageDownSample.class, \"vertical\", middle[i], input[i]); horizontal.invoke(null, in, mid); vertical.invoke(null, mid, expected); AverageDownSampleOps.down(in, found); BoofTesting.assertEquals(expected, found, 1e-4); } } ",
        "focal_tgt": "public static void down(GrayF32 input, int sampleWidth, GrayF32 output) { if(sampleWidth == 2) { ImplAverageDownSample2.down(input, output); } else { ImplAverageDownSampleN.down(input, sampleWidth, output); } } ",
        "focal_src": "public static void down(ImageFloat32 input, int sampleWidth, ImageFloat32 output) { if(sampleWidth == 2) { ImplAverageDownSample2.down(input, output); } else { ImplAverageDownSampleN.down(input, sampleWidth, output); } } ",
        "test_tgt": "@Test public void down_2inputs()throws NoSuchMethodException, InvocationTargetException, IllegalAccessException { Class input[] = new Class[] { GrayU8.class, GrayU16.class, GrayF32.class, GrayF64.class }; Class middle[] = new Class[] { GrayF32.class, GrayF32.class, GrayF32.class, GrayF64.class }; for(int i = 0; i < input.length; i ++ ) { ImageGray in = GeneralizedImageOps.createSingleBand(input[i], 17, 14); ImageGray mid = GeneralizedImageOps.createSingleBand(middle[i], 3, 14); ImageGray found = GeneralizedImageOps.createSingleBand(input[i], 3, 4); ImageGray expected = GeneralizedImageOps.createSingleBand(input[i], 3, 4); GImageMiscOps.fillUniform(in, rand, 0, 100); Method horizontal = ImplAverageDownSample.class.getDeclaredMethod(\"horizontal\", input[i], middle[i]); Method vertical = BoofTesting.findMethod(ImplAverageDownSample.class, \"vertical\", middle[i], input[i]); horizontal.invoke(null, in, mid); vertical.invoke(null, mid, expected); AverageDownSampleOps.down(in, found); BoofTesting.assertEquals(expected, found, 1e-4); } } "
    },
    {
        "test_src": "@Test public void testInstance() { String val1 = \"'''\"; String val2 = \"\\\\\"; String sqlPart = Condition.instance().between(\"test_type\", val1, val2).toString(); System.out.println(\"sql ==> \" + sqlPart); Assert.assertEquals(\"WHERE (test_type BETWEEN ? AND ?)\", sqlPart); } ",
        "focal_tgt": "@Deprecated public static Condition instance() { return Condition.create(); } ",
        "focal_src": "public static Condition instance() { return new Condition(); } ",
        "test_tgt": "@Test public void testInstance() { String val1 = \"'''\"; String val2 = \"\\\\\"; String sqlPart = Condition.create().between(\"test_type\", val1, val2).toString(); System.out.println(\"sql ==> \" + sqlPart); Assert.assertEquals(\"WHERE (test_type BETWEEN ? AND ?)\", sqlPart); } "
    },
    {
        "test_src": "@Test public void copy() { query(_FILE_WRITE.args(PATH1, \"A\")); query(_FILE_COPY.args(PATH1, PATH2)); query(_FILE_COPY.args(PATH1, PATH2)); query(_FILE_COPY.args(PATH2, PATH2)); query(_FILE_SIZE.args(PATH1), \"1\"); query(_FILE_SIZE.args(PATH2), \"1\"); error(_FILE_COPY.args(PATH1, PATH3), Err.FILE_NODIR); query(_FILE_DELETE.args(PATH1)); query(_FILE_DELETE.args(PATH2)); } ",
        "focal_tgt": "private synchronized void copy(final File src, final File trg)throws QueryException, IOException { if(src.isDirectory()) { if( ! trg.mkdir())throw FILE_IE_DIR.get(info, trg); final File[]files = src.listFiles(); if(files == null)throw FILE_IE_ACCESS.get(info, src); for(final File f : files)copy(f, new File(trg, f.getName())); } else { new IOFile(src).copyTo(new IOFile(trg)); } } ",
        "focal_src": "private synchronized void copy(final File src, final File trg)throws QueryException, IOException { if(src.isDirectory()) { if( ! trg.mkdir())throw FILE_CREATE.get(info, trg); final File[]files = src.listFiles(); if(files == null)throw FILE_LIST.get(info, src); for(final File f : files)copy(f, new File(trg, f.getName())); } else { new IOFile(src).copyTo(new IOFile(trg)); } } ",
        "test_tgt": "@Test public void copy() { query(_FILE_WRITE.args(PATH1, \"A\")); query(_FILE_COPY.args(PATH1, PATH2)); query(_FILE_COPY.args(PATH1, PATH2)); query(_FILE_COPY.args(PATH2, PATH2)); query(_FILE_SIZE.args(PATH1), \"1\"); query(_FILE_SIZE.args(PATH2), \"1\"); error(_FILE_COPY.args(PATH1, PATH3), Err.FILE_ND); query(_FILE_DELETE.args(PATH1)); query(_FILE_DELETE.args(PATH2)); } "
    },
    {
        "test_src": "@Test public void testEval()throws BaseXException { args(\"util:eval\", String.class); query(\"util:eval('1')\", \"1\"); query(\"util:eval('1 + 2')\", \"3\"); error(\"util:eval('1+')\", \"XPST0003\"); error(\"declare variable $a := 1; util:eval('$a')\", \"XPST0008\"); error(\"for $a in (1,2) return util:eval('$a')\", \"XPST0008\"); } ",
        "focal_tgt": "private Iter eval(final QueryContext ctx, final byte[]qu)throws QueryException { final QueryContext qt = new QueryContext(ctx.context); qt.parse(string(qu)); qt.compile(); return ItemIter.get(qt.iter()); } ",
        "focal_src": "private Iter eval(final QueryContext ctx, final byte[]qu)throws QueryException { final QueryContext qt = new QueryContext(ctx.resource.context); qt.parse(string(qu)); qt.compile(); return ItemIter.get(qt.iter()); } ",
        "test_tgt": "@Test public void testEval()throws BaseXException { final String fun = check(FunDef.EVAL, String.class); query(fun + \"('1')\", \"1\"); query(fun + \"('1 + 2')\", \"3\"); error(fun + \"('1+')\", Err.INCOMPLETE); error(\"declare variable $a := 1; \" + fun + \"('$a')\", Err.VARUNDEF); error(\"for $a in (1,2) return \" + fun + \"('$a')\", Err.VARUNDEF); } "
    },
    {
        "test_src": "@Test public void liftM2() { Streamable < String > stream1 = Streamable.of(\"ALL UPPER\", \"MiXed Case\"); Streamable < String > stream2 = Streamable.of(\"MixedCase\", \"all lower\"); AnyM < String > responses = LiftMFunctions.liftM2(this :: response).apply(anyM(stream1), anyM(stream2)); assertThat(responses.traversable().toList(), equalTo(Arrays.asList(\"all upper::MIXEDCASE\", \"all upper::ALL LOWER\", \"mixed case::MIXEDCASE\", \"mixed case::ALL LOWER\"))); } ",
        "focal_tgt": "public static < U1, U2, R > BiFunction < AnyM < U1 > , AnyM < U2 > , AnyM < R > > liftM2(BiFunction < U1, U2, R > fn) { return AnyMonads.liftM2(fn); } ",
        "focal_src": "public static < U1, U2, R > BiFunction < AnyM < U1 > , AnyM < U2 > , AnyM < R > > liftM2(BiFunction < U1, U2, R > fn) { return Monads.liftM2(fn); } ",
        "test_tgt": "@Test public void liftM2() { Streamable < String > stream1 = Streamable.of(\"ALL UPPER\", \"MiXed Case\"); Streamable < String > stream2 = Streamable.of(\"MixedCase\", \"all lower\"); AnyM < String > responses = LiftMFunctions.liftM2(this :: response).apply(anyM(stream1), anyM(stream2)); assertThat(responses.toSequence().toList(), equalTo(Arrays.asList(\"all upper::MIXEDCASE\", \"all upper::ALL LOWER\", \"mixed case::MIXEDCASE\", \"mixed case::ALL LOWER\"))); } "
    },
    {
        "test_src": "@Test public void testCopy_String() { System.out.println(\"\\n+++ copy\"); RunTable instance = createHorizontalInstance(); RunTable expResult = createHorizontalInstance(); RunTable result = instance.copy(\"hori\"); if( ! expResult.isIdentical(result) || ! expResult.getName().equals(result.getName())) { fail(\"Copy not identical to original\"); } } ",
        "focal_tgt": "public RunTable copy() { RunTable clone = new RunTable(orientation, width, height); for(int i = 0; i < sequences.length; i ++ ) { short[]seq = getSequence(i); if(seq != null) { short[]rle = new short[seq.length]; System.arraycopy(seq, 0, rle, 0, seq.length); clone.sequences[i] = rle; } } return clone; } ",
        "focal_src": "public RunTable copy() { return copy(name + \"(copy)\"); } ",
        "test_tgt": "@Test public void testCopy_String() { System.out.println(\"\\n+++ copy\"); RunTable instance = createHorizontalInstance(); RunTable expResult = createHorizontalInstance(); RunTable result = instance.copy(); if( ! expResult.isIdentical(result)) { fail(\"Copy not identical to original\"); } } "
    },
    {
        "test_src": "@Test public void checkMerge_merge() { int original[] = new int[] { 1, - 1, - 1, 2, 2, 3, 5 }; MergeRegionMeanShift alg = new MergeRegionMeanShift(1, 1); alg.mergeList.resize(7); alg.mergeList.data = original.clone(); alg.checkMerge(1, 2); assertEquals( - 1, alg.mergeList.data[1]); assertEquals(1, alg.mergeList.data[2]); alg.mergeList.data = original.clone(); alg.checkMerge(0, 3); int expected[] = new int[] { 1, - 1, 1, 1, 2, 3, 5 }; for(int i = 0; i < expected.length; i ++ )assertEquals(expected[i], alg.mergeList.data[i]); alg.mergeList.data = original.clone(); alg.checkMerge(3, 6); expected = new int[] { 1, - 1, - 1, 2, 2, 3, 2 }; for(int i = 0; i < expected.length; i ++ )assertEquals(expected[i], alg.mergeList.data[i]); alg.mergeList.data = original.clone(); alg.checkMerge(6, 3); for(int i = 0; i < expected.length; i ++ )assertEquals(expected[i], alg.mergeList.data[i]); } ",
        "focal_tgt": "protected static float distanceSq(float[]a, float[]b) { float distanceSq = 0; for(int i = 0; i < a.length; i ++ ) { float d = a[i] - b[i]; distanceSq += d * d; } return distanceSq; } ",
        "focal_src": "protected void checkMerge(int regionA, int regionB) { int dA = mergeList.data[regionA]; int dB = mergeList.data[regionB]; if(dA != - 1 && dB != - 1) { if(dA == dB)return; } else if(dA != - 1) { if(dA == regionB)return; } else if(dB != - 1) { if(dB == regionA)return; } int rootA = regionA; while(dA != - 1) { rootA = dA; dA = mergeList.data[rootA]; } int rootB = regionB; while(dB != - 1) { rootB = dB; dB = mergeList.data[rootB]; } if(rootA != rootB) { mergeList.data[rootB] = rootA; } if(regionB != rootA) { mergeList.data[regionB] = rootA; } if(mergeList.data[regionA] != - 1) { mergeList.data[regionA] = rootA; } } ",
        "test_tgt": "@Test public void stuff() { fail(\"Update for new code\"); } "
    },
    {
        "test_src": "@Test public void regionPixelId_to_Compact() { ImageSInt32 graph = new ImageSInt32(4, 5); ImageSInt32 output = new ImageSInt32(4, 5); regionPixelId_to_Compact(graph, output); regionPixelId_to_Compact(BoofTesting.createSubImageOf(graph), output); regionPixelId_to_Compact(graph, BoofTesting.createSubImageOf(output)); } ",
        "focal_tgt": "public static void regionPixelId_to_Compact(GrayS32 graph, GrowQueue_I32 segmentId, GrayS32 output) { InputSanityCheck.checkSameShape(graph, output); for(int i = 0; i < segmentId.size; i ++ ) { graph.data[segmentId.data[i]] = i; } for(int y = 0; y < output.height; y ++ ) { int indexGraph = graph.startIndex + y * graph.stride; int indexOut = output.startIndex + y * output.stride; for(int x = 0; x < output.width; x ++ , indexGraph ++ , indexOut ++ ) { output.data[indexOut] = graph.data[graph.data[indexGraph]]; } } for(int i = 0; i < segmentId.size; i ++ ) { int indexGraph = segmentId.data[i] - graph.startIndex; int x = indexGraph % graph.stride; int y = indexGraph / graph.stride; output.data[output.startIndex + y * output.stride + x] = i; } } ",
        "focal_src": "public static void regionPixelId_to_Compact(ImageSInt32 graph, GrowQueue_I32 segmentId, ImageSInt32 output) { InputSanityCheck.checkSameShape(graph, output); for(int i = 0; i < segmentId.size; i ++ ) { graph.data[segmentId.data[i]] = i; } for(int y = 0; y < output.height; y ++ ) { int indexGraph = graph.startIndex + y * graph.stride; int indexOut = output.startIndex + y * output.stride; for(int x = 0; x < output.width; x ++ , indexGraph ++ , indexOut ++ ) { output.data[indexOut] = graph.data[graph.data[indexGraph]]; } } for(int i = 0; i < segmentId.size; i ++ ) { int indexGraph = segmentId.data[i] - graph.startIndex; int x = indexGraph % graph.stride; int y = indexGraph / graph.stride; output.data[output.startIndex + y * output.stride + x] = i; } } ",
        "test_tgt": "@Test public void regionPixelId_to_Compact() { GrayS32 graph = new GrayS32(4, 5); GrayS32 output = new GrayS32(4, 5); regionPixelId_to_Compact(graph, output); regionPixelId_to_Compact(BoofTesting.createSubImageOf(graph), output); regionPixelId_to_Compact(graph, BoofTesting.createSubImageOf(output)); } "
    },
    {
        "test_src": "@Test public void testClear() { cacheManager.putFeature(new Feature(\"ff\", false, \"Description\")); cacheManager.putFeature(new Feature(\"ff2\", false, \"Description\")); cacheManager.putFeature(new Feature(\"ff3\", false, \"Description\")); Assert.assertEquals(3, cacheManager.listCachedFeatureNames().size()); cacheManager.clearFeatures(); Assert.assertTrue(cacheManager.listCachedFeatureNames().isEmpty()); } ",
        "focal_tgt": "@SuppressWarnings(\"resource\")public void clear() { Connection sqlConn = null; PreparedStatement ps = null; try { sqlConn = dataSource.getConnection(); ps = sqlConn.prepareStatement(SQL_DELETE_ALL_CUSTOMPROPERTIES); ps.executeUpdate(); ps = sqlConn.prepareStatement(SQL_DELETE_ALL_ROLES); ps.executeUpdate(); ps = sqlConn.prepareStatement(SQL_DELETE_ALL_FEATURES); ps.executeUpdate(); } catch(SQLException sqlEX) { throw new FeatureAccessException(CANNOT_CHECK_FEATURE_EXISTENCE_ERROR_RELATED_TO_DATABASE, sqlEX); } finally { closeStatement(ps); closeConnection(sqlConn); } } ",
        "focal_src": "@SuppressWarnings(\"resource\")public void clear() { Connection sqlConn = null; PreparedStatement ps = null; try { sqlConn = dataSource.getConnection(); ps = sqlConn.prepareStatement(SQL_DELETE_ALL_CUSTOMPROPERTIES); ps.executeUpdate(); ps = sqlConn.prepareStatement(SQL_DELETE_ALL_ROLES); ps.executeUpdate(); ps = sqlConn.prepareStatement(SQL_DELETE_ALL_FEATURES); ps.executeUpdate(); } catch(SQLException sqlEX) { throw new FeatureAccessException(\"Cannot check feature existence, error related to database\", sqlEX); } finally { closeStatement(ps); closeConnection(sqlConn); } } ",
        "test_tgt": "@Test public void testClear() { cacheManager.putFeature(new Feature(\"ff\", false, DESCRIPTION)); cacheManager.putFeature(new Feature(\"ff2\", false, DESCRIPTION)); cacheManager.putFeature(new Feature(\"ff3\", false, DESCRIPTION)); Assert.assertEquals(3, cacheManager.listCachedFeatureNames().size()); cacheManager.clearFeatures(); Assert.assertTrue(cacheManager.listCachedFeatureNames().isEmpty()); } "
    },
    {
        "test_src": "@Test public void functionTest()throws Exception { createColl(); final String doc = _DB_OPEN.args(NAME); check(\"declare function local:x() {\" + doc + \"//text()[. = '1'] }; local:x()\", \"1\"); check(\"declare function local:x($x as xs:string) {\" + doc + \"//text()[. = $x] }; local:x('1')\", \"1\"); check(\"declare function local:x() {\" + doc + \"//text()[. contains text '1'] }; local:x()\", \"1\"); check(\"declare function local:x($x) {\" + doc + \"//text()[. contains text { $x }] }; local:x('1')\", \"1\"); } ",
        "focal_tgt": "private Item function(final QueryContext ctx)throws QueryException { final FItem fn = checkFunc(exprs[0], ctx); final QNm name = fn.funcName(); final StaticFunc sf = name == null ? null : ctx.funcs.get(name, fn.arity(), null, false); return new PlainDoc(ctx, info).function(name, sf, fn.funcType(), fn.annotations(), null); } ",
        "focal_src": "private Item function(final QueryContext ctx)throws QueryException { final FItem func = checkFunc(expr[0], ctx); final QNm name = func.funcName(); final StaticFunc sf = name == null ? null : ctx.funcs.get(name, func.arity(), null, false); return new PlainDoc(ctx, info).function(name, sf, func.funcType(), func.annotations(), null); } ",
        "test_tgt": "@Test public void functionTest()throws Exception { createColl(); check(\"declare function local:x($d) { collection($d)//text()[. = '1'] };\" + \"local:x('\" + NAME + \"')\", \"1\"); check(\"declare function local:x($d, $s) { collection($d)//text()[. = $s] };\" + \"local:x('\" + NAME + \"', '1')\", \"1\"); final String doc = _DB_OPEN.args(NAME); check(\"declare function local:x() {\" + doc + \"//text()[. = '1'] }; local:x()\", \"1\"); check(\"declare function local:x($x as xs:string) {\" + doc + \"//text()[. = $x] }; local:x('1')\", \"1\"); check(\"declare function local:x() {\" + doc + \"//text()[. contains text '1'] }; local:x()\", \"1\"); check(\"declare function local:x($x) {\" + doc + \"//text()[. contains text { $x }] }; local:x('1')\", \"1\"); } "
    },
    {
        "test_src": "@Test(groups = \"samples\", timeOut = TIMEOUT)public void createDatabase_toBlocking() { Flux < ResourceResponse < Database > > createDatabaseObservable = client.createDatabase(getDatabaseDefinition(), null); createDatabaseObservable.single().block(); } ",
        "focal_tgt": "Mono < ResourceResponse < Database > > createDatabase(Database database, RequestOptions options); ",
        "focal_src": "Flux < ResourceResponse < Database > > createDatabase(Database database, RequestOptions options); ",
        "test_tgt": "@Test(groups = \"samples\", timeOut = TIMEOUT)public void createDatabase_toBlocking() { Mono < ResourceResponse < Database > > createDatabaseObservable = client.createDatabase(getDatabaseDefinition(), null); createDatabaseObservable.single().block(); } "
    },
    {
        "test_src": "@Test public void testAddView()throws IOException, URISyntaxException, AnnotatorException { SimpleGazetteerAnnotator sga = new SimpleGazetteerAnnotator(6, \"/testgazetteers/\", false); assertTrue(\"Wrong number of dictionaries loaded.\", sga.dictionaries.size() == 1); assertTrue(\"Wrong number of dictionaries loaded.\", sga.dictionariesIgnoreCase.size() == 1); TextAnnotation ta = tab.createTextAnnotation(\"I hail from the university of illinois at champaign urbana.\"); sga.addView(ta); SpanLabelView view = (SpanLabelView)ta.getView(ViewNames.TREE_GAZETTEER); List < Constituent > entities = view.getConstituents(); Constituent c1 = entities.get(0); assertEquals(c1.toString(), \"university of illinois\"); Constituent c2 = entities.get(1); assertEquals(c2.toString(), \"university of illinois at champaign urbana\"); Constituent c3 = entities.get(2); assertEquals(c3.toString(), \"illinois\"); Constituent c4 = entities.get(3); assertEquals(c4.toString(), \"champaign\"); Constituent c5 = entities.get(4); assertEquals(c5.toString(), \"urbana\"); assertEquals(c1.getLabel(), \"organizations(IC)\"); assertEquals(c2.getLabel(), \"organizations(IC)\"); assertEquals(c3.getLabel(), \"places(IC)\"); assertEquals(c4.getLabel(), \"places(IC)\"); assertEquals(c5.getLabel(), \"places(IC)\"); sga = new SimpleGazetteerAnnotator(4, \"/testgazetteers\", false); assertTrue(\"Wrong number of dictionaries loaded.\", sga.dictionaries.size() == 1); assertTrue(\"Wrong number of dictionaries loaded.\", sga.dictionariesIgnoreCase.size() == 1); ta = tab.createTextAnnotation(\"I hail from the university of illinois at champaign urbana.\"); sga.addView(ta); view = (SpanLabelView)ta.getView(ViewNames.TREE_GAZETTEER); entities = view.getConstituents(); c1 = entities.get(0); assertEquals(c1.toString(), \"university of illinois\"); c2 = entities.get(1); assertEquals(c2.toString(), \"illinois\"); c3 = entities.get(2); assertEquals(c3.toString(), \"champaign\"); c4 = entities.get(3); assertEquals(c4.toString(), \"urbana\"); assertEquals(c1.getLabel(), \"organizations(IC)\"); assertEquals(c2.getLabel(), \"places(IC)\"); assertEquals(c3.getLabel(), \"places(IC)\"); assertEquals(c4.getLabel(), \"places(IC)\"); ta = tab.createTextAnnotation(\"I hail from the University of Illinois at champaign urbana.\"); sga.addView(ta); view = (SpanLabelView)ta.getView(ViewNames.TREE_GAZETTEER); entities = view.getConstituents(); c1 = entities.get(0); assertEquals(c1.toString(), \"University of Illinois\"); assertEquals(c1.getLabel(), \"organizations\"); c2 = entities.get(1); assertEquals(c1.toString(), \"University of Illinois\"); assertEquals(c1.getLabel(), \"organizations\"); } ",
        "focal_tgt": "protected abstract void addView(TextAnnotation ta)throws AnnotatorException; ",
        "focal_src": "public abstract void addView(TextAnnotation ta)throws AnnotatorException; ",
        "test_tgt": "@Test public void testAddView()throws IOException, URISyntaxException, AnnotatorException { SimpleGazetteerAnnotator sga = new SimpleGazetteerAnnotator(defaultRm); assertTrue(\"Wrong number of dictionaries loaded.\", sga.dictionaries.size() == 1); assertTrue(\"Wrong number of dictionaries loaded.\", sga.dictionariesIgnoreCase.size() == 1); TextAnnotation ta = tab.createTextAnnotation(\"I hail from the university of illinois at champaign urbana.\"); sga.addView(ta); SpanLabelView view = (SpanLabelView)ta.getView(ViewNames.TREE_GAZETTEER); List < Constituent > entities = view.getConstituents(); Constituent c1 = entities.get(0); assertEquals(c1.toString(), \"university of illinois\"); Constituent c2 = entities.get(1); assertEquals(c2.toString(), \"university of illinois at champaign urbana\"); Constituent c3 = entities.get(2); assertEquals(c3.toString(), \"illinois\"); Constituent c4 = entities.get(3); assertEquals(c4.toString(), \"champaign\"); Constituent c5 = entities.get(4); assertEquals(c5.toString(), \"urbana\"); assertEquals(c1.getLabel(), \"organizations(IC)\"); assertEquals(c2.getLabel(), \"organizations(IC)\"); assertEquals(c3.getLabel(), \"places(IC)\"); assertEquals(c4.getLabel(), \"places(IC)\"); assertEquals(c5.getLabel(), \"places(IC)\"); Properties props = new Properties(); props.setProperty(SimpleGazetteerAnnotatorConfigurator.PHRASE_LENGTH.key, \"4\"); props.setProperty(SimpleGazetteerAnnotatorConfigurator.PATH_TO_DICTIONARIES.key, \"/testgazetteers/\"); props.setProperty(SimpleGazetteerAnnotatorConfigurator.IS_LAZILY_INITIALIZED.key, SimpleGazetteerAnnotatorConfigurator.FALSE); sga = new SimpleGazetteerAnnotator(new ResourceManager(props)); assertTrue(\"Wrong number of dictionaries loaded.\", sga.dictionaries.size() == 1); assertTrue(\"Wrong number of dictionaries loaded.\", sga.dictionariesIgnoreCase.size() == 1); ta = tab.createTextAnnotation(\"I hail from the university of illinois at champaign urbana.\"); sga.addView(ta); view = (SpanLabelView)ta.getView(ViewNames.TREE_GAZETTEER); entities = view.getConstituents(); c1 = entities.get(0); assertEquals(c1.toString(), \"university of illinois\"); c2 = entities.get(1); assertEquals(c2.toString(), \"illinois\"); c3 = entities.get(2); assertEquals(c3.toString(), \"champaign\"); c4 = entities.get(3); assertEquals(c4.toString(), \"urbana\"); assertEquals(c1.getLabel(), \"organizations(IC)\"); assertEquals(c2.getLabel(), \"places(IC)\"); assertEquals(c3.getLabel(), \"places(IC)\"); assertEquals(c4.getLabel(), \"places(IC)\"); ta = tab.createTextAnnotation(\"I hail from the University of Illinois at champaign urbana.\"); sga.addView(ta); view = (SpanLabelView)ta.getView(ViewNames.TREE_GAZETTEER); entities = view.getConstituents(); c1 = entities.get(0); assertEquals(c1.toString(), \"University of Illinois\"); assertEquals(c1.getLabel(), \"organizations\"); c2 = entities.get(1); assertEquals(c1.toString(), \"University of Illinois\"); assertEquals(c1.getLabel(), \"organizations\"); } "
    },
    {
        "test_src": "@Test public void testCreateStream()throws ExecutionException, InterruptedException { when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest)); assertEquals(\"Create Stream Status\", 201, response.get().getStatus()); streamResponseActual = response.get().readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus2); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest)); assertEquals(\"Create Stream Status\", 409, response.get().getStatus()); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus3); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest2)); assertEquals(\"Create Stream Status\", 500, response.get().getStatus()); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus4); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest3)); assertEquals(\"Create Stream Status for non-existent scope\", 404, response.get().getStatus()); } ",
        "focal_tgt": "@Override public void createStream(final String scopeName, final CreateStreamRequest createStreamRequest, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"createStream\"); StreamConfiguration streamConfiguration = ModelHelper.getCreateStreamConfig(createStreamRequest, scopeName); controllerService.createStream(streamConfiguration, System.currentTimeMillis()).thenApply(streamStatus -> { if(streamStatus == CreateStreamStatus.SUCCESS) { log.info(\"Successfully created stream: {}/{}\", scopeName, streamConfiguration.getStreamName()); return Response.status(Status.CREATED).entity(ModelHelper.encodeStreamResponse(streamConfiguration)).build(); } else if(streamStatus == CreateStreamStatus.STREAM_EXISTS) { log.warn(\"Stream already exists: {}/{}\", scopeName, streamConfiguration.getStreamName()); return Response.status(Status.CONFLICT).build(); } else if(streamStatus == CreateStreamStatus.SCOPE_NOT_FOUND) { return Response.status(Status.NOT_FOUND).build(); } else { log.warn(\"createStream failed for : {}/{}\", scopeName, streamConfiguration.getStreamName()); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).exceptionally(exception -> { log.warn(\"createStream for {}/{} failed {}: \", scopeName, streamConfiguration.getStreamName(), exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); }).thenApply(asyncResponse :: resume); LoggerHelpers.traceLeave(log, \"createStream\", traceId); } ",
        "focal_src": "@Override public void createStream(final String scope, final CreateStreamRequest createStreamRequest, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"createStream\"); StreamConfiguration streamConfiguration = ModelHelper.getCreateStreamConfig(createStreamRequest, scope); CompletableFuture < CreateStreamStatus > createStreamStatus = controllerService.createStream(streamConfiguration, System.currentTimeMillis()); createStreamStatus.thenApply(streamStatus -> { if(streamStatus == CreateStreamStatus.SUCCESS) { return Response.status(Status.CREATED).entity(ModelHelper.encodeStreamResponse(streamConfiguration)).build(); } else if(streamStatus == CreateStreamStatus.STREAM_EXISTS) { return Response.status(Status.CONFLICT).build(); } else if(streamStatus == CreateStreamStatus.SCOPE_NOT_FOUND) { return Response.status(Status.NOT_FOUND).build(); } else { return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).exceptionally(exception -> { log.debug(\"Exception occurred while executing createStream: \" + exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); }).thenApply(response -> asyncResponse.resume(response)); LoggerHelpers.traceLeave(log, \"createStream\", traceId); } ",
        "test_tgt": "@Test public void testCreateStream()throws ExecutionException, InterruptedException { when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest)); assertEquals(\"Create Stream Status\", 201, response.get().getStatus()); streamResponseActual = response.get().readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus2); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest)); assertEquals(\"Create Stream Status\", 409, response.get().getStatus()); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus3); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest2)); assertEquals(\"Create Stream Status\", 500, response.get().getStatus()); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus4); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest3)); assertEquals(\"Create Stream Status for non-existent scope\", 404, response.get().getStatus()); } "
    },
    {
        "test_src": "@Test public void testListLogFiles()throws IOException { FileAttribute[]attrs = new FileAttribute[0]; String rootPath = Files.createTempDirectory(\"workers-artifacts\", attrs).toFile().getCanonicalPath(); File file1 = new File(String.join(File.separator, rootPath, \"topoA\", \"1111\"), \"worker.log\"); File file2 = new File(String.join(File.separator, rootPath, \"topoA\", \"2222\"), \"worker.log\"); File file3 = new File(String.join(File.separator, rootPath, \"topoB\", \"1111\"), \"worker.log\"); file1.getParentFile().mkdirs(); file2.getParentFile().mkdirs(); file3.getParentFile().mkdirs(); file1.createNewFile(); file2.createNewFile(); file3.createNewFile(); String origin = \"www.origin.server.net\"; Map < String, Object > stormConf = Utils.readStormConfig(); LogviewerLogPageHandler handler = new LogviewerLogPageHandler(rootPath, null, new WorkerLogs(stormConf, new File(rootPath)), new ResourceAuthorizer(stormConf)); final Response expectedAll = LogviewerResponseBuilder.buildSuccessJsonResponse(Lists.newArrayList(\"topoA/port1/worker.log\", \"topoA/port2/worker.log\", \"topoB/port1/worker.log\"), null, origin); final Response expectedFilterPort = LogviewerResponseBuilder.buildSuccessJsonResponse(Lists.newArrayList(\"topoA/port1/worker.log\", \"topoB/port1/worker.log\"), null, origin); final Response expectedFilterTopoId = LogviewerResponseBuilder.buildSuccessJsonResponse(Lists.newArrayList(\"topoB/port1/worker.log\"), null, origin); final Response returnedAll = handler.listLogFiles(\"user\", null, null, null, origin); final Response returnedFilterPort = handler.listLogFiles(\"user\", 1111, null, null, origin); final Response returnedFilterTopoId = handler.listLogFiles(\"user\", null, \"topoB\", null, origin); Utils.forceDelete(rootPath); assertEqualsJsonResponse(expectedAll, returnedAll, List.class); assertEqualsJsonResponse(expectedFilterPort, returnedFilterPort, List.class); assertEqualsJsonResponse(expectedFilterTopoId, returnedFilterTopoId, List.class); } ",
        "focal_tgt": "public Response listLogFiles(String user, Integer port, String topologyId, String callback, String origin)throws IOException { List < File > fileResults = null; if(topologyId == null) { if(port == null) { fileResults = workerLogs.getAllLogsForRootDir(); } else { fileResults = new ArrayList < > (); File[]logRootFiles = new File(logRoot).listFiles(); if(logRootFiles != null) { for(File topoDir : logRootFiles) { File[]topoDirFiles = topoDir.listFiles(); if(topoDirFiles != null) { for(File portDir : topoDirFiles) { if(portDir.getName().equals(port.toString())) { fileResults.addAll(directoryCleaner.getFilesForDir(portDir)); } } } } } } } else { if(port == null) { fileResults = new ArrayList < > (); File topoDir = new File(logRoot, topologyId); if(topoDir.exists()) { File[]topoDirFiles = topoDir.listFiles(); if(topoDirFiles != null) { for(File portDir : topoDirFiles) { fileResults.addAll(directoryCleaner.getFilesForDir(portDir)); } } } } else { File portDir = ConfigUtils.getWorkerDirFromRoot(logRoot, topologyId, port); if(portDir.exists()) { fileResults = directoryCleaner.getFilesForDir(portDir); } } } List < String > files; if(fileResults != null) { files = fileResults.stream().map(WorkerLogs :: getTopologyPortWorkerLog).sorted().collect(toList()); } else { files = new ArrayList < > (); } return LogviewerResponseBuilder.buildSuccessJsonResponse(files, callback, origin); } ",
        "focal_src": "public Response listLogFiles(String user, Integer port, String topologyId, String callback, String origin)throws IOException { List < File > fileResults = null; if(topologyId == null) { if(port == null) { fileResults = workerLogs.getAllLogsForRootDir(); } else { fileResults = new ArrayList < > (); File[]logRootFiles = new File(logRoot).listFiles(); if(logRootFiles != null) { for(File topoDir : logRootFiles) { File[]topoDirFiles = topoDir.listFiles(); if(topoDirFiles != null) { for(File portDir : topoDirFiles) { if(portDir.getName().equals(port.toString())) { fileResults.addAll(DirectoryCleaner.getFilesForDir(portDir)); } } } } } } } else { if(port == null) { fileResults = new ArrayList < > (); File topoDir = new File(logRoot, topologyId); if(topoDir.exists()) { File[]topoDirFiles = topoDir.listFiles(); if(topoDirFiles != null) { for(File portDir : topoDirFiles) { fileResults.addAll(DirectoryCleaner.getFilesForDir(portDir)); } } } } else { File portDir = ConfigUtils.getWorkerDirFromRoot(logRoot, topologyId, port); if(portDir.exists()) { fileResults = DirectoryCleaner.getFilesForDir(portDir); } } } List < String > files; if(fileResults != null) { files = fileResults.stream().map(WorkerLogs :: getTopologyPortWorkerLog).sorted().collect(toList()); } else { files = new ArrayList < > (); } return LogviewerResponseBuilder.buildSuccessJsonResponse(files, callback, origin); } ",
        "test_tgt": "@Test public void testListLogFiles()throws IOException { FileAttribute[]attrs = new FileAttribute[0]; String rootPath = Files.createTempDirectory(\"workers-artifacts\", attrs).toFile().getCanonicalPath(); File file1 = new File(String.join(File.separator, rootPath, \"topoA\", \"1111\"), \"worker.log\"); File file2 = new File(String.join(File.separator, rootPath, \"topoA\", \"2222\"), \"worker.log\"); File file3 = new File(String.join(File.separator, rootPath, \"topoB\", \"1111\"), \"worker.log\"); file1.getParentFile().mkdirs(); file2.getParentFile().mkdirs(); file3.getParentFile().mkdirs(); file1.createNewFile(); file2.createNewFile(); file3.createNewFile(); String origin = \"www.origin.server.net\"; Map < String, Object > stormConf = Utils.readStormConfig(); StormMetricsRegistry metricsRegistry = new StormMetricsRegistry(); LogviewerLogPageHandler handler = new LogviewerLogPageHandler(rootPath, null, new WorkerLogs(stormConf, new File(rootPath), metricsRegistry), new ResourceAuthorizer(stormConf), metricsRegistry); final Response expectedAll = LogviewerResponseBuilder.buildSuccessJsonResponse(Lists.newArrayList(\"topoA/port1/worker.log\", \"topoA/port2/worker.log\", \"topoB/port1/worker.log\"), null, origin); final Response expectedFilterPort = LogviewerResponseBuilder.buildSuccessJsonResponse(Lists.newArrayList(\"topoA/port1/worker.log\", \"topoB/port1/worker.log\"), null, origin); final Response expectedFilterTopoId = LogviewerResponseBuilder.buildSuccessJsonResponse(Lists.newArrayList(\"topoB/port1/worker.log\"), null, origin); final Response returnedAll = handler.listLogFiles(\"user\", null, null, null, origin); final Response returnedFilterPort = handler.listLogFiles(\"user\", 1111, null, null, origin); final Response returnedFilterTopoId = handler.listLogFiles(\"user\", null, \"topoB\", null, origin); Utils.forceDelete(rootPath); assertEqualsJsonResponse(expectedAll, returnedAll, List.class); assertEqualsJsonResponse(expectedFilterPort, returnedFilterPort, List.class); assertEqualsJsonResponse(expectedFilterTopoId, returnedFilterTopoId, List.class); } "
    },
    {
        "test_src": "@Test public void testMakeAppSecretProof() { System.out.println(\"Testing make App Secret Proof\"); DefaultFacebookClient facebookClient = new DefaultFacebookClient(\"test\", \"test\"); String test = facebookClient.makeAppSecretProof(); String php_result = \"88cd2108b5347d973cf39cdf9053d7dd42704876d8c9a9bd8e2d168259d3ddf7\"; assertEquals(php_result, test); String php_result2 = \"cb064987988fcd658470d6a24f1c68f6d7982c80ab9efb08cb8c84ef88fd03e1\"; DefaultFacebookClient facebookClient2 = new DefaultFacebookClient(\"helloWorld\", \"PRIE7$oG2uS-Yf17kEnUEpi5hvW/#AFo\"); String test2 = facebookClient2.makeAppSecretProof(); assertEquals(php_result2, test2); String php_result3 = \"75d686df7a1e937b61b9d062c5fbad9a933fe70c15be0fec96dcb158fdada663\"; DefaultFacebookClient facebookClient3 = new DefaultFacebookClient(\"CAAAAMXGpQQgBACydRTLJiIG7qh0J9pWvzlZAXZCI4XZAzfuAdzadxVekKiO6dypZBoq8OdZA2pRgKXcAGnu1ht0vZCsswxsGscroRMIaZCtLMN5lRbyZAmxM59vdZB2oZBfggMP576SOJSCZAVo3Kd4FFerfYKl7X7mZCW0jMmquwM6wElZCEfcF2R0Yd\", \"e17b62bbbf5e1c5f5a45e10efcc31fa6\"); String test3 = facebookClient3.makeAppSecretProof(); System.out.println(test3); assertEquals(php_result3, test3); } ",
        "focal_tgt": "public String makeAppSecretProof() { try { byte[]key = this.appSecret.getBytes(); SecretKeySpec signingKey = new SecretKeySpec(key, \"HmacSHA256\"); Mac mac = Mac.getInstance(\"HmacSHA256\"); mac.init(signingKey); byte[]raw = mac.doFinal(this.accessToken.getBytes()); byte[]hex = encodeHex(raw); String out = new String(hex, \"UTF-8\"); return out; } catch(NoSuchAlgorithmException e) { logger.info(\"Appsecret_proof creation fialed: \" + e); } catch(InvalidKeyException e) { logger.warning(\"Appsecret_proof creation fialed: \" + e); } catch(UnsupportedEncodingException e) { logger.info(\"Appsecret_proof creation fialed: \" + e); } throw new NullPointerException(\"AppSecretProof creation has failed\"); } ",
        "focal_src": "public String makeAppSecretProof() { try { byte[]key = this.appSecret.getBytes(); SecretKeySpec signingKey = new SecretKeySpec(key, \"HmacSHA256\"); Mac mac = Mac.getInstance(\"HmacSHA256\"); mac.init(signingKey); byte[]raw = mac.doFinal(this.accessToken.getBytes()); byte[]hex = encodeHex(raw); String out = new String(hex, \"UTF-8\"); return out; } catch(NoSuchAlgorithmException e) { System.out.println(e); } catch(InvalidKeyException e) { System.out.println(e); } catch(UnsupportedEncodingException e) { System.out.println(e); } throw new NullPointerException(\"AppSecretProof creation has failed\"); } ",
        "test_tgt": "@Test public void testMakeAppSecretProof() { System.out.println(\"Testing make App Secret Proof\"); DefaultFacebookClient facebookClient = new DefaultFacebookClient(\"test\", \"test\"); String test = facebookClient.makeAppSecretProof(); String php_result = \"88cd2108b5347d973cf39cdf9053d7dd42704876d8c9a9bd8e2d168259d3ddf7\"; assertEquals(php_result, test); String php_result2 = \"cb064987988fcd658470d6a24f1c68f6d7982c80ab9efb08cb8c84ef88fd03e1\"; DefaultFacebookClient facebookClient2 = new DefaultFacebookClient(\"helloWorld\", \"PRIE7$oG2uS-Yf17kEnUEpi5hvW/#AFo\"); String test2 = facebookClient2.makeAppSecretProof(); assertEquals(php_result2, test2); } "
    },
    {
        "test_src": "@Test public void testParseQuery()throws Exception { String searchString = \"product:(resteasy) AND vendor:(red hat)\"; String expResult = \"+product:resteasy +(vendor:red vendor:redhat vendor:hat)\"; Query result = instance.parseQuery(searchString); assertEquals(expResult, result.toString()); instance.close(); } ",
        "focal_tgt": "public synchronized Query parseQuery(String searchString)throws ParseException, IndexException { if(searchString == null || searchString.trim().isEmpty()) { throw new ParseException(\"Query is null or empty\"); } LOGGER.debug(searchString); final Query query = queryParser.parse(searchString); try { resetAnalyzers(); } catch(IOException ex) { throw new IndexException(\"Unable to reset the analyzer after parsing\", ex); } return query; } ",
        "focal_src": "protected Query parseQuery(String searchString)throws ParseException { if(searchString == null || searchString.trim().isEmpty()) { throw new ParseException(\"Query is null or empty\"); } LOGGER.debug(searchString); final Query query = queryParser.parse(searchString); return query; } ",
        "test_tgt": "@Test public void testParseQuery()throws Exception { String searchString = \"product:(resteasy) AND vendor:(red hat)\"; String expResult = \"+product:resteasy +(vendor:red vendor:redhat vendor:hat)\"; Query result = instance.parseQuery(searchString); assertEquals(expResult, result.toString()); instance.resetAnalyzers(); searchString = \"product:(struts2\\\\-core^2 struts^3 core) AND vendor:(apache.struts apache^3 foundation)\"; expResult = \"+((product:struts product:strutsstruts2 product:struts2 product:struts2core product:core)^2.0 (product:corestruts product:struts)^3.0 (product:strutscore product:core)) +((vendor:apache vendor:apachestruts vendor:struts) (vendor:strutsapache vendor:apache)^3.0)\"; result = instance.parseQuery(searchString); assertEquals(expResult, result.toString()); instance.close(); } "
    },
    {
        "test_src": "@Test public void testProcessOutput()throws Exception { Random rng = RandomUtils.getRandom(); String descriptor = Utils.randomDescriptor(rng, NUM_ATTRIBUTES); double[][]source = Utils.randomDoubles(rng, descriptor, NUM_INSTANCES); int labelId = Utils.findLabel(descriptor); for(int index = 0; index < NUM_INSTANCES; index ++ ) { source[index][labelId] = index; } String[]sData = Utils.double2String(source); Path dataPath = Utils.writeDataToTestFile(sData); Dataset dataset = DataLoader.generateDataset(descriptor, sData); Data data = DataLoader.loadData(dataset, sData); Configuration conf = new Configuration(); Step0JobTest.setMaxSplitSize(conf, dataPath, NUM_MAPS); TreeBuilder treeBuilder = new MockTreeBuilder(); PartialBuilder.setStep2(conf, false); long seed = 1L; Builder builder = new PartialSequentialBuilder(treeBuilder, dataPath, dataset, seed, conf); Path outputPath = builder.getOutputPath(conf); HadoopUtil.overwriteOutput(outputPath); builder.build(NUM_TREES, new MockCallback(data)); } ",
        "focal_tgt": "protected static void processOutput(JobContext job, Path outputPath, int[]firstIds, TreeID[]keys, Node[]trees, PredictionCallback callback)throws IOException { Preconditions.checkArgument((keys == null && trees == null) || (keys != null && trees != null), \"if keys is null, trees should also be null\"); Preconditions.checkArgument(keys == null || keys.length == trees.length, \"keys.length != trees.length\"); Configuration conf = job.getConfiguration(); FileSystem fs = outputPath.getFileSystem(conf); Path[]outfiles = DFUtils.listOutputFiles(fs, outputPath); int index = 0; for(Path path : outfiles) { for(Pair < TreeID, MapredOutput > record : new SequenceFileIterable < TreeID, MapredOutput > (path, conf)) { TreeID key = record.getFirst(); MapredOutput value = record.getSecond(); if(keys != null) { keys[index] = key; } if(trees != null) { trees[index] = value.getTree(); } processOutput(firstIds, key, value, callback); index ++ ; } } if(keys != null && index != keys.length) { throw new IllegalStateException(\"Some key/values are missing from the output\"); } } ",
        "focal_src": "protected static void processOutput(JobContext job, Path outputPath, int[]firstIds, TreeID[]keys, Node[]trees, PredictionCallback callback)throws IOException { Preconditions.checkArgument((keys == null && trees == null) || (keys != null && trees != null), \"if keys is null, trees should also be null\"); Preconditions.checkArgument(keys == null || keys.length == trees.length, \"keys.length != trees.length\"); Configuration conf = job.getConfiguration(); FileSystem fs = outputPath.getFileSystem(conf); Path[]outfiles = DFUtils.listOutputFiles(fs, outputPath); TreeID key = new TreeID(); MapredOutput value = new MapredOutput(); int index = 0; for(Path path : outfiles) { Reader reader = new Reader(fs, path, conf); try { while(reader.next(key, value)) { if(keys != null) { keys[index] = key.clone(); } if(trees != null) { trees[index] = value.getTree(); } processOutput(firstIds, key, value, callback); index ++ ; } } finally { reader.close(); } } if((keys != null) && (index != keys.length)) { throw new IllegalStateException(\"Some key/values are missing from the output\"); } } ",
        "test_tgt": "@Test public void testProcessOutput()throws Exception { Random rng = RandomUtils.getRandom(); String descriptor = Utils.randomDescriptor(rng, NUM_ATTRIBUTES); double[][]source = Utils.randomDoubles(rng, descriptor, NUM_INSTANCES); int labelId = Utils.findLabel(descriptor); for(int index = 0; index < NUM_INSTANCES; index ++ ) { source[index][labelId] = index; } String[]sData = Utils.double2String(source); Path dataPath = Utils.writeDataToTestFile(sData); Dataset dataset = DataLoader.generateDataset(descriptor, sData); Data data = DataLoader.loadData(dataset, sData); Configuration conf = new Configuration(); Step0JobTest.setMaxSplitSize(conf, dataPath, NUM_MAPS); TreeBuilder treeBuilder = new MockTreeBuilder(); PartialBuilder.setStep2(conf, false); long seed = 1L; Builder builder = new PartialSequentialBuilder(treeBuilder, dataPath, dataset, seed, conf); Path outputPath = builder.getOutputPath(conf); HadoopUtil.delete(conf, outputPath); builder.build(NUM_TREES, new MockCallback(data)); } "
    },
    {
        "test_src": "@Test public void completeUfsFileTest()throws Exception { long id = mManager.createFile(SESSION_ID, mUri, new PermissionStatus(\"\", \"\", Constants.DEFAULT_FS_FULL_PERMISSION)); mManager.completeFile(SESSION_ID, id, new PermissionStatus(\"\", \"\", Constants.DEFAULT_FS_FULL_PERMISSION)); Mockito.verify(mMockUfs).rename(Mockito.contains(mUri.toString()), Mockito.eq(mUri.toString())); } ",
        "focal_tgt": "public long completeUfsFile(long sessionId, long tempUfsFileId, Permission perm)throws FileDoesNotExistException, IOException { return mUnderFileSystemManager.completeFile(sessionId, tempUfsFileId, perm); } ",
        "focal_src": "public long completeUfsFile(long sessionId, long tempUfsFileId, PermissionStatus ps)throws FileDoesNotExistException, IOException { return mUnderFileSystemManager.completeFile(sessionId, tempUfsFileId, ps); } ",
        "test_tgt": "@Test public void completeUfsFileTest()throws Exception { long id = mManager.createFile(SESSION_ID, mUri, new Permission(\"\", \"\", Constants.DEFAULT_FILE_SYSTEM_MODE)); mManager.completeFile(SESSION_ID, id, new Permission(\"\", \"\", Constants.DEFAULT_FILE_SYSTEM_MODE)); Mockito.verify(mMockUfs).rename(Mockito.contains(mUri.toString()), Mockito.eq(mUri.toString())); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should ignore voided patients\", method = \"isIdentifierInUseByAnotherPatient(PatientIdentifier)\")public void isIdentifierInUseByAnotherPatient_shouldIgnoreVoidedPatients()throws Exception { { Patient p = patientService.getPatient(999); Assert.assertNotNull(p); Assert.assertTrue(p.isVoided()); boolean found = false; for(PatientIdentifier id : p.getIdentifiers()) { if(id.getIdentifier().equals(\"XYZ\") && id.getIdentifierType().getId() == 2) { found = true; break; } } Assert.assertTrue(found); } PatientIdentifierType pit = patientService.getPatientIdentifierType(2); PatientIdentifier patientIdentifier = new PatientIdentifier(\"XYZ\", pit, null); Assert.assertFalse(patientService.isIdentifierInUseByAnotherPatient(patientIdentifier)); } ",
        "focal_tgt": "@Authorized(PrivilegeConstants.GET_PATIENTS)public boolean isIdentifierInUseByAnotherPatient(PatientIdentifier patientIdentifier); ",
        "focal_src": "@Authorized(PrivilegeConstants.VIEW_PATIENTS)public boolean isIdentifierInUseByAnotherPatient(PatientIdentifier patientIdentifier); ",
        "test_tgt": "@Test@Verifies(value = \"should ignore voided patients\", method = \"isIdentifierInUseByAnotherPatient(PatientIdentifier)\")public void isIdentifierInUseByAnotherPatient_shouldIgnoreVoidedPatients()throws Exception { { Patient p = patientService.getPatient(999); Assert.assertNotNull(p); Assert.assertTrue(p.isVoided()); boolean found = false; for(PatientIdentifier id : p.getIdentifiers()) { if(id.getIdentifier().equals(\"XYZ\") && id.getIdentifierType().getId() == 2) { found = true; break; } } Assert.assertTrue(found); } PatientIdentifierType pit = patientService.getPatientIdentifierType(2); PatientIdentifier patientIdentifier = new PatientIdentifier(\"XYZ\", pit, null); Assert.assertFalse(patientService.isIdentifierInUseByAnotherPatient(patientIdentifier)); } "
    },
    {
        "test_src": "@Test public void testToString() { assertEquals(\"1 bytes\", Bytes.bytes(1).toString()); assertEquals(\"1K\", Bytes.bytes(1024).toString()); assertEquals(\"1M\", Bytes.bytes(1024 * 1024L).toString()); assertEquals(\"1G\", Bytes.bytes(1024 * 1024 * 1024L).toString()); assertEquals(\"1T\", Bytes.bytes(1024 * 1024 * 1024 * 1024L).toString()); assertEquals(\"1.5K\", Bytes.bytes(1024 * 1.5).toString()); assertEquals(\"1 bytes\", Bytes.bytes(1).toString(Locale.GERMAN)); } ",
        "focal_tgt": "public String toString(final Locale locale) { if(terabytes() >= 1.0) { return unitString(terabytes(), \"TB\", locale); } if(gigabytes() >= 1.0) { return unitString(gigabytes(), \"GB\", locale); } if(megabytes() >= 1.0) { return unitString(megabytes(), \"MB\", locale); } if(kilobytes() >= 1.0) { return unitString(kilobytes(), \"KB\", locale); } return Long.toString(value) + \" bytes\"; } ",
        "focal_src": "public String toString(final Locale locale) { if(terabytes() >= 1.0) { return unitString(terabytes(), \"T\", locale); } if(gigabytes() >= 1.0) { return unitString(gigabytes(), \"G\", locale); } if(megabytes() >= 1.0) { return unitString(megabytes(), \"M\", locale); } if(kilobytes() >= 1.0) { return unitString(kilobytes(), \"K\", locale); } return Long.toString(value) + \" bytes\"; } ",
        "test_tgt": "@Test public void testToString() { assertEquals(\"1 bytes\", Bytes.bytes(1).toString()); assertEquals(\"1KB\", Bytes.bytes(1024).toString()); assertEquals(\"1MB\", Bytes.bytes(1024 * 1024L).toString()); assertEquals(\"1GB\", Bytes.bytes(1024 * 1024 * 1024L).toString()); assertEquals(\"1TB\", Bytes.bytes(1024 * 1024 * 1024 * 1024L).toString()); assertEquals(\"1.5KB\", Bytes.bytes(1024 * 1.5).toString()); assertEquals(\"1 bytes\", Bytes.bytes(1).toString(Locale.GERMAN)); } "
    },
    {
        "test_src": "@Test public void testCreateMissingMacByteVectors() { } ",
        "focal_tgt": "List < PaddingVector > createMissingMacByteVectors(CipherSuite suite, ProtocolVersion version) { List < PaddingVector > vectorList = new LinkedList < > (); int macSize = AlgorithmResolver.getMacAlgorithm(version, suite).getSize(); byte[]padding = createPaddingBytes(DEFAULT_CIPHERTEXT_LENGTH - macSize); vectorList.add(new TrippleVector(new ByteArrayExplicitValueModification(new byte[0]), new ByteArrayDeleteModification(0, 1), new ByteArrayExplicitValueModification(padding))); vectorList.add(new TrippleVector(new ByteArrayExplicitValueModification(new byte[0]), new ByteArrayDeleteModification((macSize - 1), 1), new ByteArrayExplicitValueModification(padding))); return vectorList; } ",
        "focal_src": "List < PaddingVector > createMissingMacByteVectors(CipherSuite suite, ProtocolVersion version) { List < PaddingVector > vectorList = new LinkedList < > (); int macSize = AlgorithmResolver.getMacAlgorithm(version, suite).getSize(); byte[]padding = createPaddingBytes(DEFAULT_CIPHERTEXT_LENGTH - macSize + 1 - 1); vectorList.add(new TrippleVector(new ByteArrayExplicitValueModification(new byte[0]), new ByteArrayDeleteModification(0, 1), new ByteArrayExplicitValueModification(padding))); padding = createPaddingBytes(DEFAULT_CIPHERTEXT_LENGTH - macSize + 1 - 1); padding[0] ^= 0x80; vectorList.add(new TrippleVector(new ByteArrayExplicitValueModification(new byte[0]), new ByteArrayDeleteModification(0, 1), new ByteArrayExplicitValueModification(padding))); padding = createPaddingBytes(DEFAULT_CIPHERTEXT_LENGTH - macSize + 1 - 1); padding[(DEFAULT_CIPHERTEXT_LENGTH - macSize + 1) / 2] ^= 0x8; vectorList.add(new TrippleVector(new ByteArrayExplicitValueModification(new byte[0]), new ByteArrayDeleteModification(0, 1), new ByteArrayExplicitValueModification(padding))); padding = createPaddingBytes(DEFAULT_CIPHERTEXT_LENGTH - macSize + 1 - 1); padding[(DEFAULT_CIPHERTEXT_LENGTH - macSize + 1 - 1)] ^= 0x01; vectorList.add(new TrippleVector(new ByteArrayExplicitValueModification(new byte[0]), new ByteArrayDeleteModification(0, 1), new ByteArrayExplicitValueModification(padding))); return vectorList; } ",
        "test_tgt": "@Test public void testCreateMissingMacByteVectors() { List < PaddingVector > vectors = generator.createMissingMacByteVectors(CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, ProtocolVersion.TLS12); assertEquals(2, vectors.size()); int macSize = AlgorithmResolver.getMacAlgorithm(ProtocolVersion.TLS12, CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA).getSize(); VariableModification modification = ((TrippleVector)vectors.get(0)).getCleanModification(); ModifiableByteArray array = new ModifiableByteArray(); array.setModification(modification); assertArrayEquals(\"Validation of clean bytes\", new byte[0], array.getValue()); modification = ((TrippleVector)vectors.get(0)).getPaddingModification(); array = new ModifiableByteArray(); array.setModification(modification); byte[]expectedPadding = generator.createPaddingBytes(ShortPaddingGenerator.DEFAULT_CIPHERTEXT_LENGTH - macSize); assertArrayEquals(\"Validation of used padding\", expectedPadding, array.getValue()); byte[]macToModify = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }; modification = ((TrippleVector)vectors.get(0)).getMacModification(); array = new ModifiableByteArray(); array.setOriginalValue(macToModify); array.setModification(modification); byte[]expectedMac = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19 }; assertArrayEquals(\"Validation of the deleted first byte in MAC\", expectedMac, array.getValue()); modification = ((TrippleVector)vectors.get(1)).getMacModification(); array = new ModifiableByteArray(); array.setOriginalValue(macToModify); array.setModification(modification); expectedMac = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 }; assertArrayEquals(\"Validation of the deleted last byte in MAC\", expectedMac, array.getValue()); } "
    },
    {
        "test_src": "@Test@Order(order = 3)public void testInsertKnowledge()throws Exception { LOG.info(\"\u8a18\u4e8b\u6295\u7a3f\"); LoginedUser loginUser = getLoginUser(\"integration-test-user-01\"); DBUserPool.get().setUser(loginUser.getUserId()); KnowledgesEntity knowledge = super.insertKnowledge(\"integration-test-knowledge-01\", loginUser); knowledgeId = knowledge.getKnowledgeId(); NotifyQueuesEntity notify = NotifyQueuesDao.get().selectOnTypeAndId(QueueNotification.TYPE_KNOWLEDGE_INSERT, knowledgeId); Assert.assertNotNull(notify); NotifyMailBat.main(null); notify = NotifyQueuesDao.get().selectOnTypeAndId(QueueNotification.TYPE_KNOWLEDGE_INSERT, knowledgeId); Assert.assertNull(notify); NotificationsEntity notification = NotificationsDao.get().selectOnKey(new Long(1)); Assert.assertNotNull(notification); UsersEntity user = UsersDao.get().selectOnUserKey(\"integration-test-user-01\"); UserNotificationsEntity userNotification = UserNotificationsDao.get().selectOnKey(notification.getNo(), user.getUserId()); Assert.assertNotNull(userNotification); user = UsersDao.get().selectOnUserKey(\"integration-test-user-02\"); userNotification = UserNotificationsDao.get().selectOnKey(notification.getNo(), user.getUserId()); Assert.assertNotNull(userNotification); int count = MailsDao.get().selectCountAll(); Assert.assertEquals(2, count); } ",
        "focal_tgt": "protected KnowledgesEntity insertKnowledge(String title, AccessUser loginedUser)throws Exception { int publicFlag = KnowledgeLogic.PUBLIC_FLAG_PUBLIC; int typeId = TemplateLogic.TYPE_ID_KNOWLEDGE; return insertKnowledge(title, loginedUser, typeId, publicFlag); } ",
        "focal_src": "protected KnowledgesEntity insertKnowledge(String title, LoginedUser loginedUser)throws Exception { int publicFlag = KnowledgeLogic.PUBLIC_FLAG_PUBLIC; int typeId = TemplateLogic.TYPE_ID_KNOWLEDGE; return insertKnowledge(title, loginedUser, typeId, publicFlag); } ",
        "test_tgt": "@Test@Order(order = 3)public void testInsertKnowledge()throws Exception { LOG.info(\"\u8a18\u4e8b\u6295\u7a3f\"); AccessUser loginUser = getLoginUser(\"integration-test-user-01\"); DBUserPool.get().setUser(loginUser.getUserId()); KnowledgesEntity knowledge = super.insertKnowledge(\"integration-test-knowledge-01\", loginUser); knowledgeId = knowledge.getKnowledgeId(); NotifyQueuesEntity notify = NotifyQueuesDao.get().selectOnTypeAndId(QueueNotification.TYPE_KNOWLEDGE_INSERT, knowledgeId); Assert.assertNotNull(notify); NotifyMailBat.main(null); notify = NotifyQueuesDao.get().selectOnTypeAndId(QueueNotification.TYPE_KNOWLEDGE_INSERT, knowledgeId); Assert.assertNull(notify); NotificationsEntity notification = NotificationsDao.get().selectOnKey(new Long(1)); Assert.assertNotNull(notification); UsersEntity user = UsersDao.get().selectOnUserKey(\"integration-test-user-01\"); UserNotificationsEntity userNotification = UserNotificationsDao.get().selectOnKey(notification.getNo(), user.getUserId()); Assert.assertNotNull(userNotification); user = UsersDao.get().selectOnUserKey(\"integration-test-user-02\"); userNotification = UserNotificationsDao.get().selectOnKey(notification.getNo(), user.getUserId()); Assert.assertNotNull(userNotification); int count = MailsDao.get().selectCountAll(); Assert.assertEquals(2, count); } "
    },
    {
        "test_src": "@Test public void testApplyDelegate() { Config config = Config.createConfig(); config.clearConnectionEnds(); args = new String[2]; args[0] = \"-port\"; args[1] = \"1234\"; jcommander.parse(args); delegate.applyDelegate(config); ConnectionEnd newConEnd = config.getConnectionEnd(); assertNotNull(newConEnd); assertTrue(newConEnd.getPort() == 1234); assertTrue(newConEnd.getConnectionEndType() == ConnectionEndType.SERVER); } ",
        "focal_tgt": "@Override public void applyDelegate(Config config) { if((inboundConnectionStr == null) || (outboundConnectionStr == null)) { throw new ParameterException(\"{inbound|outbound}ConnectionStr is empty!\"); } InboundConnection inboundConnection = config.getDefaultServerConnection(); if(inboundConnection == null) { inboundConnection = new InboundConnection(); config.setDefaultServerConnection(inboundConnection); } String[]parsedPort = inboundConnectionStr.split(\":\"); switch(parsedPort.length) { case 1 : inboundConnection.setAlias(\"accept:\" + parsedPort[0]); inboundConnection.setPort(parsePort(parsedPort[0])); break; case 2 : inboundConnection.setAlias(parsedPort[0]); inboundConnection.setPort(parsePort(parsedPort[1])); break; default : throw new ConfigurationException(\"Could not parse provided accepting connection\" + \" end: \" + inboundConnectionStr + \". Expected [CONNECTION_ALIAS:]<PORT>\"); } config.setDefaultServerConnection(inboundConnection); OutboundConnection outboundConnection = config.getDefaultClientConnection(); if(outboundConnection == null) { outboundConnection = new OutboundConnection(); config.setDefaultClientConnection(outboundConnection); } String[]parsedHost = outboundConnectionStr.split(\":\"); switch(parsedHost.length) { case 2 : outboundConnection.setHostname(parsedHost[0]); outboundConnection.setPort(parsePort(parsedHost[1])); outboundConnection.setAlias(outboundConnectionStr); break; case 3 : outboundConnection.setAlias(parsedHost[0]); outboundConnection.setHostname(parsedHost[1]); outboundConnection.setPort(parsePort(parsedHost[2])); break; default : throw new ConfigurationException(\"Could not parse provided server address: \" + outboundConnectionStr + \". Expected [CONNECTION_ALIAS:]<HOSTNAME>:<PORT>\"); } config.setDefaultClientConnection(outboundConnection); } ",
        "focal_src": "@Override public void applyDelegate(Config config) { if((acceptingConnectionEnds == null) || (connectingConnectionEnds == null)) { throw new ParameterException(\"{accepting|connecting}ConnectionEnds is empty!\"); } config.clearConnectionEnds(); for(String conEndStr : acceptingConnectionEnds) { ServerConnectionEnd serverConEnd = new ServerConnectionEnd(); String[]parsedPort = conEndStr.split(\":\"); switch(parsedPort.length) { case 1 : serverConEnd.setAlias(\"accept:\" + parsedPort[0]); serverConEnd.setPort(parsePort(parsedPort[0])); break; case 2 : serverConEnd.setAlias(parsedPort[0]); serverConEnd.setPort(parsePort(parsedPort[1])); break; default : throw new ConfigurationException(\"Could not parse provided accepting connection\" + \" end: \" + conEndStr + \". Expected [CONNECTION_ALIAS:]<PORT>\"); } config.addConnectionEnd(serverConEnd); } for(String conEndStr : connectingConnectionEnds) { ClientConnectionEnd clientConEnd = new ClientConnectionEnd(); String[]parsedHost = conEndStr.split(\":\"); switch(parsedHost.length) { case 2 : clientConEnd.setHostname(parsedHost[0]); clientConEnd.setPort(parsePort(parsedHost[1])); clientConEnd.setAlias(conEndStr); break; case 3 : clientConEnd.setAlias(parsedHost[0]); clientConEnd.setHostname(parsedHost[1]); clientConEnd.setPort(parsePort(parsedHost[2])); break; default : throw new ConfigurationException(\"Could not parse provided server address: \" + conEndStr + \". Expected [CONNECTION_ALIAS:]<HOSTNAME>:<PORT>\"); } config.addConnectionEnd(clientConEnd); } } ",
        "test_tgt": "@Test public void testApplyDelegate() { Config config = Config.createConfig(); int expectedDefaultTimeout = 390121; config.getDefaultServerConnection().setTimeout(expectedDefaultTimeout); args = new String[2]; args[0] = \"-port\"; args[1] = \"1234\"; jcommander.parse(args); delegate.applyDelegate(config); AliasedConnection actual = config.getDefaultServerConnection(); assertNotNull(actual); assertThat(actual.getPort(), equalTo(1234)); assertThat(actual.getLocalConnectionEndType(), equalTo(ConnectionEndType.SERVER)); assertThat(actual.getTimeout(), equalTo(expectedDefaultTimeout)); } "
    },
    {
        "test_src": "@Test public void substring() { LOGGER.info(StringUtil.substring(TEXT, \"jinxin\".length())); String text1 = \"Index: src/main/java/com/jumbo/shop/web/command/PageCacheCommand.java\"; LOGGER.info(StringUtil.substring(text1, \"Index: \".length())); } ",
        "focal_tgt": "public static String substring(final String text, final String startString, final String endString) { if(Validator.isNullOrEmpty(text)) { return StringUtils.EMPTY; } if(Validator.isNullOrEmpty(startString)) { return text.substring(0, text.indexOf(endString)); } int beginIndex = text.indexOf(startString); int endIndex = text.indexOf(endString); return text.substring(beginIndex, endIndex); } ",
        "focal_src": "public static String substring(String text, String startString, String endString) { if(Validator.isNullOrEmpty(text)) { return StringUtils.EMPTY; } if(Validator.isNullOrEmpty(startString)) { return text.substring(0, text.indexOf(endString)); } int beginIndex = text.indexOf(startString); int endIndex = text.indexOf(endString); return text.substring(beginIndex, endIndex); } ",
        "test_tgt": "@Test public void substring() { assertEquals(\"src/main/java/com/jumbo/shop/web/command/PageCacheCommand.java\", StringUtil.substring(\"Index: src/main/java/com/jumbo/shop/web/command/PageCacheCommand.java\", \"Index: \".length())); assertEquals(\".feilong\", StringUtil.substring(TEXT, \"jinxin\".length())); assertEquals(\".feilong\", StringUtil.substring(TEXT, 6)); assertEquals(\"ng\", StringUtil.substring(TEXT, - 2)); } "
    },
    {
        "test_src": "@Test public void testTrainAndValidate() { logger.info(\"testTrainAndValidate\"); Configuration conf = Configuration.getConfiguration(); Dataframe[]data = Datasets.carsNumeric(conf); Dataframe trainingData = data[0]; Dataframe validationData = data[1]; String dbName = this.getClass().getSimpleName(); Modeler.TrainingParameters trainingParameters = new Modeler.TrainingParameters(); MultinomialNaiveBayes.TrainingParameters modelTrainingParameters = new MultinomialNaiveBayes.TrainingParameters(); modelTrainingParameters.setMultiProbabilityWeighted(true); trainingParameters.setModelerTrainingParameters(modelTrainingParameters); DummyXMinMaxNormalizer.TrainingParameters dtParams = new DummyXMinMaxNormalizer.TrainingParameters(); trainingParameters.setDataTransformerTrainingParameters(dtParams); trainingParameters.setFeatureSelectorTrainingParameters(null); Modeler instance = MLBuilder.create(trainingParameters, conf); instance.fit(trainingData); instance.save(dbName); instance.close(); instance = MLBuilder.load(Modeler.class, dbName, conf); instance.predict(trainingData); ClassificationMetrics vm = new ClassificationMetrics(trainingData); double expResult2 = 0.8; assertEquals(expResult2, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); trainingData.close(); instance.close(); instance = MLBuilder.load(Modeler.class, dbName, conf); instance.predict(validationData); Map < Integer, Object > expResult = new HashMap < > (); Map < Integer, Object > result = new HashMap < > (); for(Map.Entry < Integer, Record > e : validationData.entries()) { Integer rId = e.getKey(); Record r = e.getValue(); expResult.put(rId, r.getY()); result.put(rId, r.getYPredicted()); } assertEquals(expResult, result); instance.delete(); validationData.close(); } ",
        "focal_tgt": "private < ML extends AbstractClassifier, FS extends AbstractFeatureSelector > void trainAndValidate(ML.AbstractTrainingParameters modelerTrainingParameters, FS.AbstractTrainingParameters featureSelectorTrainingParameters, double expectedF1score) { Configuration conf = Configuration.getConfiguration(); String storageName = this.getClass().getSimpleName(); Map < Object, URI > dataset = new HashMap < > (); try { dataset.put(\"negative\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.neg.txt\").toURI()); dataset.put(\"positive\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.pos.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } TextClassifier.TrainingParameters trainingParameters = new TextClassifier.TrainingParameters(); trainingParameters.setModelerTrainingParameters(modelerTrainingParameters); trainingParameters.setDataTransformerTrainingParameters(null); trainingParameters.setFeatureSelectorTrainingParameters(featureSelectorTrainingParameters); NgramsExtractor.Parameters exParams = new NgramsExtractor.Parameters(); exParams.setMaxDistanceBetweenKwds(2); exParams.setExaminationWindowLength(6); trainingParameters.setTextExtractorParameters(exParams); TextClassifier instance = MLBuilder.create(trainingParameters, conf); instance.fit(dataset); instance.save(storageName); ClassificationMetrics vm = instance.validate(dataset); assertEquals(expectedF1score, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); instance.close(); instance = MLBuilder.load(TextClassifier.class, storageName, conf); Dataframe validationData; try { validationData = instance.predict(this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.unlabelled.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } List < Object > expResult = Arrays.asList(\"negative\", \"positive\"); int i = 0; for(Record r : validationData.values()) { assertEquals(expResult.get(i), r.getYPredicted()); ++ i; } instance.delete(); validationData.close(); } ",
        "focal_src": "private < ML extends AbstractClassifier, FS extends AbstractFeatureSelector > void trainAndValidate(ML.AbstractTrainingParameters modelerTrainingParameters, FS.AbstractTrainingParameters featureSelectorTrainingParameters, double expectedF1score) { Configuration conf = Configuration.getConfiguration(); String dbName = this.getClass().getSimpleName(); Map < Object, URI > dataset = new HashMap < > (); try { dataset.put(\"negative\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.neg.txt\").toURI()); dataset.put(\"positive\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.pos.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } TextClassifier.TrainingParameters trainingParameters = new TextClassifier.TrainingParameters(); trainingParameters.setModelerTrainingParameters(modelerTrainingParameters); trainingParameters.setDataTransformerTrainingParameters(null); trainingParameters.setFeatureSelectorTrainingParameters(featureSelectorTrainingParameters); NgramsExtractor.Parameters exParams = new NgramsExtractor.Parameters(); exParams.setMaxDistanceBetweenKwds(2); exParams.setExaminationWindowLength(6); trainingParameters.setTextExtractorParameters(exParams); TextClassifier instance = MLBuilder.create(trainingParameters, conf); instance.fit(dataset); instance.save(dbName); ClassificationMetrics vm = instance.validate(dataset); assertEquals(expectedF1score, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); instance.close(); instance = MLBuilder.load(TextClassifier.class, dbName, conf); Dataframe validationData; try { validationData = instance.predict(this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.unlabelled.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } List < Object > expResult = Arrays.asList(\"negative\", \"positive\"); int i = 0; for(Record r : validationData.values()) { assertEquals(expResult.get(i), r.getYPredicted()); ++ i; } instance.delete(); validationData.close(); } ",
        "test_tgt": "@Test public void testTrainAndValidate() { logger.info(\"testTrainAndValidate\"); Configuration conf = Configuration.getConfiguration(); Dataframe[]data = Datasets.carsNumeric(conf); Dataframe trainingData = data[0]; Dataframe validationData = data[1]; String storageName = this.getClass().getSimpleName(); Modeler.TrainingParameters trainingParameters = new Modeler.TrainingParameters(); MultinomialNaiveBayes.TrainingParameters modelTrainingParameters = new MultinomialNaiveBayes.TrainingParameters(); modelTrainingParameters.setMultiProbabilityWeighted(true); trainingParameters.setModelerTrainingParameters(modelTrainingParameters); DummyXMinMaxNormalizer.TrainingParameters dtParams = new DummyXMinMaxNormalizer.TrainingParameters(); trainingParameters.setDataTransformerTrainingParameters(dtParams); trainingParameters.setFeatureSelectorTrainingParameters(null); Modeler instance = MLBuilder.create(trainingParameters, conf); instance.fit(trainingData); instance.save(storageName); instance.close(); instance = MLBuilder.load(Modeler.class, storageName, conf); instance.predict(trainingData); ClassificationMetrics vm = new ClassificationMetrics(trainingData); double expResult2 = 0.8; assertEquals(expResult2, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); trainingData.close(); instance.close(); instance = MLBuilder.load(Modeler.class, storageName, conf); instance.predict(validationData); Map < Integer, Object > expResult = new HashMap < > (); Map < Integer, Object > result = new HashMap < > (); for(Map.Entry < Integer, Record > e : validationData.entries()) { Integer rId = e.getKey(); Record r = e.getValue(); expResult.put(rId, r.getY()); result.put(rId, r.getYPredicted()); } assertEquals(expResult, result); instance.delete(); validationData.close(); } "
    },
    {
        "test_src": "@Test public void computeNormalization_two() { List < AssociatedPair > list = new ArrayList < > (); for(int i = 0; i < 12; i ++ ) { AssociatedPair p = new AssociatedPair(); p.p2.set(rand.nextDouble() * 5, rand.nextDouble() * 5); p.p1.set(rand.nextDouble() * 5, rand.nextDouble() * 5); list.add(p); } List < Point2D_F64 > list1 = new ArrayList < > (); List < Point2D_F64 > list2 = new ArrayList < > (); PerspectiveOps.splitAssociated(list, list1, list2); DMatrixRMaj expected1 = new DMatrixRMaj(3, 3); DMatrixRMaj expected2 = new DMatrixRMaj(3, 3); LowLevelMultiViewOps.computeNormalization(list1, expected1); LowLevelMultiViewOps.computeNormalization(list2, expected2); DMatrixRMaj found1 = new DMatrixRMaj(3, 3); DMatrixRMaj found2 = new DMatrixRMaj(3, 3); LowLevelMultiViewOps.computeNormalization(list, found1, found2); assertTrue(MatrixFeatures_DDRM.isIdentical(expected1, found1, 1e-8)); assertTrue(MatrixFeatures_DDRM.isIdentical(expected2, found2, 1e-8)); } ",
        "focal_tgt": "public static void computeNormalization(List < Point2D_F64 > points, NormalizationPoint2D normalize) { double meanX = 0; double meanY = 0; for(Point2D_F64 p : points) { meanX += p.x; meanY += p.y; } meanX /= points.size(); meanY /= points.size(); double stdX = 0; double stdY = 0; for(Point2D_F64 p : points) { double dx = p.x - meanX; double dy = p.y - meanY; stdX += dx * dx; stdY += dy * dy; } normalize.meanX = meanX; normalize.meanY = meanY; normalize.stdX = Math.sqrt(stdX / points.size()); normalize.stdY = Math.sqrt(stdY / points.size()); } ",
        "focal_src": "public static void computeNormalization(List < Point2D_F64 > points, DMatrixRMaj N) { double meanX1 = 0; double meanY1 = 0; for(Point2D_F64 p : points) { meanX1 += p.x; meanY1 += p.y; } meanX1 /= points.size(); meanY1 /= points.size(); double stdX1 = 0; double stdY1 = 0; for(Point2D_F64 p : points) { double dx = p.x - meanX1; double dy = p.y - meanY1; stdX1 += dx * dx; stdY1 += dy * dy; } stdX1 = Math.sqrt(stdX1 / points.size()); stdY1 = Math.sqrt(stdY1 / points.size()); N.zero(); N.set(0, 0, 1.0 / stdX1); N.set(1, 1, 1.0 / stdY1); N.set(0, 2, - meanX1 / stdX1); N.set(1, 2, - meanY1 / stdY1); N.set(2, 2, 1.0); } ",
        "test_tgt": "@Test public void computeNormalization_two() { List < AssociatedPair > list = new ArrayList < > (); for(int i = 0; i < 12; i ++ ) { AssociatedPair p = new AssociatedPair(); p.p2.set(rand.nextDouble() * 5, rand.nextDouble() * 5); p.p1.set(rand.nextDouble() * 5, rand.nextDouble() * 5); list.add(p); } List < Point2D_F64 > list1 = new ArrayList < > (); List < Point2D_F64 > list2 = new ArrayList < > (); PerspectiveOps.splitAssociated(list, list1, list2); NormalizationPoint2D expected1 = new NormalizationPoint2D(); NormalizationPoint2D expected2 = new NormalizationPoint2D(); LowLevelMultiViewOps.computeNormalization(list1, expected1); LowLevelMultiViewOps.computeNormalization(list2, expected2); NormalizationPoint2D found1 = new NormalizationPoint2D(); NormalizationPoint2D found2 = new NormalizationPoint2D(); LowLevelMultiViewOps.computeNormalization(list, found1, found2); assertTrue(expected1.isEquals(found1, 1e-8)); assertTrue(expected2.isEquals(found2, 1e-8)); } "
    },
    {
        "test_src": "@Test public void decodeString() { query(_BIN_DECODE_STRING.args(base64(\"3132\"), \"US-ASCII\"), \"12\"); query(_BIN_DECODE_STRING.args(base64(\"3132\"), \"UTF-8\"), \"12\"); query(_BIN_DECODE_STRING.args(base64(\"313233\"), \"UTF-8\", 1, 1), \"2\"); error(_BIN_DECODE_STRING.args(base64(\"\"), \"UTF-8\", - 1), BIN_NO_X); error(_BIN_DECODE_STRING.args(base64(\"\"), \"UTF-8\", 0, - 1), BIN_NS_X); error(_BIN_DECODE_STRING.args(base64(\"\"), \"UTF-8\", 1, 0), BIN_OBE_X_X); error(_BIN_DECODE_STRING.args(base64(\"\"), \"UTF-8\", 0, 1), BIN_OBE_X_X_X); error(_BIN_DECODE_STRING.args(base64(\"\"), \"X\"), BIN_UE_X); error(_BIN_DECODE_STRING.args(base64(\"FF\"), \"UTF-8\"), BIN_DE); } ",
        "focal_tgt": "private Str decodeString(final QueryContext ctx)throws QueryException { final B64 b64 = b64(expr[0], true, ctx); final String enc = encoding(1, BIN_UE_X, ctx); final Long off = expr.length > 2 ? checkItr(expr[2], ctx) : null; final Long len = expr.length > 3 ? checkItr(expr[3], ctx) : null; if(b64 == null)return null; byte[]bytes = b64.binary(info); final int bl = bytes.length; final int[]bounds = bounds(off, len, bl); if(bounds[0] > 0 || bounds[1] < bl) { final byte[]tmp = new byte[bounds[1]]; System.arraycopy(bytes, bounds[0], tmp, 0, bounds[1]); bytes = tmp; } try { return Str.get(FNConvert.toString(new IOContent(bytes).inputStream(), enc, true)); } catch(final IOException ex) { throw BIN_CE.get(info, ex); } } ",
        "focal_src": "private Str decodeString(final QueryContext ctx)throws QueryException { final B64 b64 = b64(expr[0], true, ctx); final String enc = encoding(1, BIN_UE_X, ctx); final Long off = expr.length > 2 ? checkItr(expr[2], ctx) : null; final Long len = expr.length > 3 ? checkItr(expr[3], ctx) : null; if(b64 == null)return null; byte[]bytes = b64.binary(info); final int bl = bytes.length; final int[]bounds = bounds(off, len, bl); if(bounds[0] > 0 || bounds[1] < bl) { final byte[]tmp = new byte[bounds[1]]; System.arraycopy(bytes, bounds[0], tmp, 0, bounds[1]); bytes = tmp; } try { return Str.get(FNConvert.toString(new IOContent(bytes).inputStream(), enc, true)); } catch(final IOException ex) { throw BIN_DE.get(info, ex); } } ",
        "test_tgt": "@Test public void decodeString() { query(_BIN_DECODE_STRING.args(base64(\"31\")), \"1\"); query(_BIN_DECODE_STRING.args(base64(\"31\"), \"US-ASCII\"), \"1\"); query(_BIN_DECODE_STRING.args(base64(\"31\"), \"UTF-8\"), \"1\"); query(_BIN_DECODE_STRING.args(base64(\"3132\"), \"UTF-8\", 1, 1), \"2\"); error(_BIN_DECODE_STRING.args(base64(\"\"), \"UTF-8\", - 1), BIN_IOOR_X_X); error(_BIN_DECODE_STRING.args(base64(\"\"), \"UTF-8\", 0, - 1), BIN_NS_X); error(_BIN_DECODE_STRING.args(base64(\"\"), \"UTF-8\", 1, 0), BIN_IOOR_X_X); error(_BIN_DECODE_STRING.args(base64(\"\"), \"UTF-8\", 0, 1), BIN_IOOR_X_X); error(_BIN_DECODE_STRING.args(base64(\"\"), \"X\"), BIN_UE_X); error(_BIN_DECODE_STRING.args(base64(\"FF\"), \"UTF-8\"), BIN_CE); error(_BIN_DECODE_STRING.args(_BIN_HEX.args(\"03\")), BIN_CE); } "
    },
    {
        "test_src": "@Test public void testFormatDisplayText() { assertEquals(\"SDSU Transit Center\", UIUtils.formatDisplayText(\"SDSU Transit Center\")); assertEquals(\"VA Hospital\", UIUtils.formatDisplayText(\"VA Hospital\")); assertEquals(\"SDSU\", UIUtils.formatDisplayText(\"SDSU\")); assertEquals(\"UTC Transit Center\", UIUtils.formatDisplayText(\"UTC Transit Center\")); assertEquals(\"North to University Area TC\", UIUtils.formatDisplayText(\"North to University Area TC\")); assertEquals(\"North To University Area Tc\", UIUtils.formatDisplayText(\"NORTH TO UNIVERSITY AREA TC\")); assertEquals(\"SDSU\", UIUtils.formatDisplayText(\"SDSU\")); assertEquals(\"Downtown San Diego - UTC via Old Town\", UIUtils.formatDisplayText(\"Downtown San Diego - UTC via Old Town\")); assertEquals(\"UTC/VA Med CTR Express\", UIUtils.formatDisplayText(\"UTC/VA Med CTR Express\")); } ",
        "focal_tgt": "public static String formatDisplayText(String displayText) { if(displayText == null) { return null; } if(MyTextUtils.isAllCaps(displayText) && displayText.contains(\" \") && ! displayText.contains(\"SPLC\")) { return MyTextUtils.toTitleCase(displayText); } else { return displayText; } } ",
        "focal_src": "public static String formatDisplayText(String displayText) { if(displayText == null) { return null; } if(MyTextUtils.isAllCaps(displayText) && displayText.contains(\" \")) { return MyTextUtils.toTitleCase(displayText); } else { return displayText; } } ",
        "test_tgt": "@Test public void testFormatDisplayText() { assertEquals(\"SDSU Transit Center\", UIUtils.formatDisplayText(\"SDSU Transit Center\")); assertEquals(\"VA Hospital\", UIUtils.formatDisplayText(\"VA Hospital\")); assertEquals(\"SDSU\", UIUtils.formatDisplayText(\"SDSU\")); assertEquals(\"UTC Transit Center\", UIUtils.formatDisplayText(\"UTC Transit Center\")); assertEquals(\"SPLC / SR 513\", UIUtils.formatDisplayText(\"SPLC / SR 513\")); assertEquals(\"North to University Area TC\", UIUtils.formatDisplayText(\"North to University Area TC\")); assertEquals(\"North To University Area Tc\", UIUtils.formatDisplayText(\"NORTH TO UNIVERSITY AREA TC\")); assertEquals(\"SDSU\", UIUtils.formatDisplayText(\"SDSU\")); assertEquals(\"Hospital via SPLC Parking\", UIUtils.formatDisplayText(\"Hospital via SPLC Parking\")); assertEquals(\"SPLC Parking via 70th\", UIUtils.formatDisplayText(\"SPLC Parking via 70th\")); assertEquals(\"Downtown San Diego - UTC via Old Town\", UIUtils.formatDisplayText(\"Downtown San Diego - UTC via Old Town\")); assertEquals(\"UTC/VA Med CTR Express\", UIUtils.formatDisplayText(\"UTC/VA Med CTR Express\")); } "
    },
    {
        "test_src": "@Test public final void export() { final IO io = IO.get(\"export.xml\"); no(new Export(io.path())); ok(new CreateDB(NAME, FILE)); ok(new Export(\".\", io.name())); ok(io.exists()); ok(io.delete()); } ",
        "focal_tgt": "public static void export(final Context context, final Data data)throws IOException { export(context.prop, data, data.meta.file.path()); } ",
        "focal_src": "public static void export(final Context context, final Data data)throws IOException { export(context.prop, data, data.meta.file.path(), null); } ",
        "test_tgt": "@Test public final void export() { final IO io = IO.get(\"input.xml\"); no(new Export(io.path())); ok(new CreateDB(NAME, FILE)); ok(new Export(\".\")); ok(io.exists()); ok(io.delete()); } "
    },
    {
        "test_src": "@Test public void testFindByProperties() { Map < String, Object > params = new HashMap < String, Object > (); params.put(\"category\", education); params.put(\"code\", \"02\"); List < Dictionary > results = repository.findByProperties(Dictionary.class, params); assertTrue(results.contains(graduate)); assertFalse(results.contains(undergraduate)); assertFalse(results.contains(male)); } ",
        "focal_tgt": " < T extends Entity > List < T > findByProperties(Class < T > clazz, MapParameters properties); ",
        "focal_src": " < T extends Entity > List < T > findByProperties(Class < T > clazz, Map < String, Object > properties); ",
        "test_tgt": "@Test public void testFindByProperties() { MapParameters params = MapParameters.create().add(\"category\", education).add(\"code\", \"02\"); List < Dictionary > results = repository.findByProperties(Dictionary.class, params); assertTrue(results.contains(graduate)); assertFalse(results.contains(undergraduate)); assertFalse(results.contains(male)); } "
    },
    {
        "test_src": "@Test public void contentType()throws Exception { assertMediaType(contentType(\"?query=1\"), MediaType.APPLICATION_XML); assertMediaType(contentType(\"?command=info\"), MediaType.TEXT_PLAIN); assertMediaType(contentType(\"?query=1&method=xml\"), MediaType.APPLICATION_XML); assertMediaType(contentType(\"?query=1&method=xhtml\"), MediaType.TEXT_HTML); assertMediaType(contentType(\"?query=1&method=html\"), MediaType.TEXT_HTML); assertMediaType(contentType(\"?query=1&method=text\"), MediaType.TEXT_PLAIN); assertMediaType(contentType(\"?query=1&method=raw\"), MediaType.APPLICATION_OCTET_STREAM); assertMediaType(contentType(\"?query=<json+type='object'/>&method=json\"), MediaType.APPLICATION_JSON); assertMediaType(contentType(\"?query=1&media-type=application/xml\"), MediaType.APPLICATION_XML); assertMediaType(contentType(\"?query=1&media-type=text/html\"), MediaType.TEXT_HTML); assertMediaType(contentType(\"?query=1&media-type=xxx\"), new MediaType(\"xxx\")); } ",
        "focal_tgt": "protected static MediaType mediaType(final String query)throws IOException { final IOUrl url = new IOUrl(REST_ROOT + query); final HttpURLConnection conn = (HttpURLConnection)url.connection(); try { read(conn.getInputStream()); return new MediaType(conn.getContentType()); } catch(final IOException ex) { throw error(conn, ex); } finally { conn.disconnect(); } } ",
        "focal_src": "protected static MediaType contentType(final String query)throws IOException { final IOUrl url = new IOUrl(REST_ROOT + query); final HttpURLConnection conn = (HttpURLConnection)url.connection(); try { read(conn.getInputStream()); return new MediaType(conn.getContentType()); } catch(final IOException ex) { throw error(conn, ex); } finally { conn.disconnect(); } } ",
        "test_tgt": "@Test public void contentType()throws Exception { assertMediaType(mediaType(\"?query=1\"), MediaType.APPLICATION_XML); assertMediaType(mediaType(\"?command=info\"), MediaType.TEXT_PLAIN); assertMediaType(mediaType(\"?query=1&method=xml\"), MediaType.APPLICATION_XML); assertMediaType(mediaType(\"?query=1&method=xhtml\"), MediaType.TEXT_HTML); assertMediaType(mediaType(\"?query=1&method=html\"), MediaType.TEXT_HTML); assertMediaType(mediaType(\"?query=1&method=text\"), MediaType.TEXT_PLAIN); assertMediaType(mediaType(\"?query=1&method=raw\"), MediaType.APPLICATION_OCTET_STREAM); assertMediaType(mediaType(\"?query=<json+type='object'/>&method=json\"), MediaType.APPLICATION_JSON); assertMediaType(mediaType(\"?query=1&media-type=application/xml\"), MediaType.APPLICATION_XML); assertMediaType(mediaType(\"?query=1&media-type=text/html\"), MediaType.TEXT_HTML); assertMediaType(mediaType(\"?query=1&media-type=xxx\"), new MediaType(\"xxx\")); } "
    },
    {
        "test_src": "@Test(dataProvider = \"sampleDates\")public void test_toCalendrical(int year, int month, int day, ZoneOffset offset) { OffsetDate t = OffsetDate.date(year, month, day, offset); assertEquals(t.toCalendrical(), Calendrical.calendrical(t.getDate(), null, t.getOffset(), null)); } ",
        "focal_tgt": "public Calendrical toCalendrical() { return new Calendrical(this); } ",
        "focal_src": "public Calendrical toCalendrical() { return Calendrical.calendrical(this, null, null); } ",
        "test_tgt": "@Test(dataProvider = \"sampleDates\")public void test_toCalendrical(int year, int month, int day, ZoneOffset offset) { OffsetDate t = OffsetDate.date(year, month, day, offset); assertEquals(t.toCalendrical(), new Calendrical(t.getDate(), null, t.getOffset(), null)); } "
    },
    {
        "test_src": "@Test public void testFlatten() { assert \"a b c\".equals(StringUtils.flatten(new String[] { \"a\", \"b\", \"c\" })); assert \"a b c\".equals(StringUtils.flatten(new String[] { \"a\", \"b\", \"c\" }, \" \")); assert \"a*b*c\".equals(StringUtils.flatten(new String[] { \"a\", \"b\", \"c\" }, \"*\")); assert \"a*c\".equals(StringUtils.flatten(new String[] { \"a\", \"\", \"c\" }, \"*\")); assert \"a*c\".equals(StringUtils.flatten(new String[] { \"a\", null, \"c\" }, \"*\")); assert \"b\".equals(StringUtils.flatten(new String[] { null, \"b\", null }, \"*\")); assert \"\".equals(StringUtils.flatten(new String[] { null, null, null }, \"*\")); assert null == StringUtils.flatten(null, \"*\"); } ",
        "focal_tgt": "public static String flatten(String s[], String separator) { if(s == null)return null; StringBuilder sb = new StringBuilder(); int sLen = s.length; boolean first = true; String el; for(int i = 0; i < sLen; i ++ ) { el = s[i]; if(el == null || el.equals(\"\"))continue; if(first)first = false; else sb.append(separator); sb.append(el); } return sb.toString(); } ",
        "focal_src": "public static String flatten(String s[], String separator) { if(s == null)return null; StringBuffer sb = new StringBuffer(); int sLen = s.length; boolean first = true; String el; for(int i = 0; i < sLen; i ++ ) { el = s[i]; if(el == null || el.equals(\"\"))continue; if(first)first = false; else sb.append(separator); sb.append(el); } return sb.toString(); } ",
        "test_tgt": "@Test public void testFlatten() { assert null == StringUtils.flatten(null, \"*\"); assert null == StringUtils.flatten(null); } "
    },
    {
        "test_src": "@Test public void testAddPaths() { assertEquals(\"null+null\", URIUtil.addPaths(null, null), null); assertEquals(\"null+\", URIUtil.addPaths(null, \"\"), \"\"); assertEquals(\"null+bbb\", URIUtil.addPaths(null, \"bbb\"), \"bbb\"); assertEquals(\"null+/\", URIUtil.addPaths(null, \"/\"), \"/\"); assertEquals(\"null+/bbb\", URIUtil.addPaths(null, \"/bbb\"), \"/bbb\"); assertEquals(\"+null\", URIUtil.addPaths(\"\", null), \"\"); assertEquals(\"+\", URIUtil.addPaths(\"\", \"\"), \"\"); assertEquals(\"+bbb\", URIUtil.addPaths(\"\", \"bbb\"), \"bbb\"); assertEquals(\"+/\", URIUtil.addPaths(\"\", \"/\"), \"/\"); assertEquals(\"+/bbb\", URIUtil.addPaths(\"\", \"/bbb\"), \"/bbb\"); assertEquals(\"aaa+null\", URIUtil.addPaths(\"aaa\", null), \"aaa\"); assertEquals(\"aaa+\", URIUtil.addPaths(\"aaa\", \"\"), \"aaa\"); assertEquals(\"aaa+bbb\", URIUtil.addPaths(\"aaa\", \"bbb\"), \"aaa/bbb\"); assertEquals(\"aaa+/\", URIUtil.addPaths(\"aaa\", \"/\"), \"aaa/\"); assertEquals(\"aaa+/bbb\", URIUtil.addPaths(\"aaa\", \"/bbb\"), \"aaa/bbb\"); assertEquals(\"/+null\", URIUtil.addPaths(\"/\", null), \"/\"); assertEquals(\"/+\", URIUtil.addPaths(\"/\", \"\"), \"/\"); assertEquals(\"/+bbb\", URIUtil.addPaths(\"/\", \"bbb\"), \"/bbb\"); assertEquals(\"/+/\", URIUtil.addPaths(\"/\", \"/\"), \"/\"); assertEquals(\"/+/bbb\", URIUtil.addPaths(\"/\", \"/bbb\"), \"/bbb\"); assertEquals(\"aaa/+null\", URIUtil.addPaths(\"aaa/\", null), \"aaa/\"); assertEquals(\"aaa/+\", URIUtil.addPaths(\"aaa/\", \"\"), \"aaa/\"); assertEquals(\"aaa/+bbb\", URIUtil.addPaths(\"aaa/\", \"bbb\"), \"aaa/bbb\"); assertEquals(\"aaa/+/\", URIUtil.addPaths(\"aaa/\", \"/\"), \"aaa/\"); assertEquals(\"aaa/+/bbb\", URIUtil.addPaths(\"aaa/\", \"/bbb\"), \"aaa/bbb\"); assertEquals(\";JS+null\", URIUtil.addPaths(\";JS\", null), \";JS\"); assertEquals(\";JS+\", URIUtil.addPaths(\";JS\", \"\"), \";JS\"); assertEquals(\";JS+bbb\", URIUtil.addPaths(\";JS\", \"bbb\"), \"bbb;JS\"); assertEquals(\";JS+/\", URIUtil.addPaths(\";JS\", \"/\"), \"/;JS\"); assertEquals(\";JS+/bbb\", URIUtil.addPaths(\";JS\", \"/bbb\"), \"/bbb;JS\"); assertEquals(\"aaa;JS+null\", URIUtil.addPaths(\"aaa;JS\", null), \"aaa;JS\"); assertEquals(\"aaa;JS+\", URIUtil.addPaths(\"aaa;JS\", \"\"), \"aaa;JS\"); assertEquals(\"aaa;JS+bbb\", URIUtil.addPaths(\"aaa;JS\", \"bbb\"), \"aaa/bbb;JS\"); assertEquals(\"aaa;JS+/\", URIUtil.addPaths(\"aaa;JS\", \"/\"), \"aaa/;JS\"); assertEquals(\"aaa;JS+/bbb\", URIUtil.addPaths(\"aaa;JS\", \"/bbb\"), \"aaa/bbb;JS\"); assertEquals(\"aaa;JS+null\", URIUtil.addPaths(\"aaa/;JS\", null), \"aaa/;JS\"); assertEquals(\"aaa;JS+\", URIUtil.addPaths(\"aaa/;JS\", \"\"), \"aaa/;JS\"); assertEquals(\"aaa;JS+bbb\", URIUtil.addPaths(\"aaa/;JS\", \"bbb\"), \"aaa/bbb;JS\"); assertEquals(\"aaa;JS+/\", URIUtil.addPaths(\"aaa/;JS\", \"/\"), \"aaa/;JS\"); assertEquals(\"aaa;JS+/bbb\", URIUtil.addPaths(\"aaa/;JS\", \"/bbb\"), \"aaa/bbb;JS\"); assertEquals(\"?A=1+null\", URIUtil.addPaths(\"?A=1\", null), \"?A=1\"); assertEquals(\"?A=1+\", URIUtil.addPaths(\"?A=1\", \"\"), \"?A=1\"); assertEquals(\"?A=1+bbb\", URIUtil.addPaths(\"?A=1\", \"bbb\"), \"bbb?A=1\"); assertEquals(\"?A=1+/\", URIUtil.addPaths(\"?A=1\", \"/\"), \"/?A=1\"); assertEquals(\"?A=1+/bbb\", URIUtil.addPaths(\"?A=1\", \"/bbb\"), \"/bbb?A=1\"); assertEquals(\"aaa?A=1+null\", URIUtil.addPaths(\"aaa?A=1\", null), \"aaa?A=1\"); assertEquals(\"aaa?A=1+\", URIUtil.addPaths(\"aaa?A=1\", \"\"), \"aaa?A=1\"); assertEquals(\"aaa?A=1+bbb\", URIUtil.addPaths(\"aaa?A=1\", \"bbb\"), \"aaa/bbb?A=1\"); assertEquals(\"aaa?A=1+/\", URIUtil.addPaths(\"aaa?A=1\", \"/\"), \"aaa/?A=1\"); assertEquals(\"aaa?A=1+/bbb\", URIUtil.addPaths(\"aaa?A=1\", \"/bbb\"), \"aaa/bbb?A=1\"); assertEquals(\"aaa?A=1+null\", URIUtil.addPaths(\"aaa/?A=1\", null), \"aaa/?A=1\"); assertEquals(\"aaa?A=1+\", URIUtil.addPaths(\"aaa/?A=1\", \"\"), \"aaa/?A=1\"); assertEquals(\"aaa?A=1+bbb\", URIUtil.addPaths(\"aaa/?A=1\", \"bbb\"), \"aaa/bbb?A=1\"); assertEquals(\"aaa?A=1+/\", URIUtil.addPaths(\"aaa/?A=1\", \"/\"), \"aaa/?A=1\"); assertEquals(\"aaa?A=1+/bbb\", URIUtil.addPaths(\"aaa/?A=1\", \"/bbb\"), \"aaa/bbb?A=1\"); assertEquals(\";JS?A=1+null\", URIUtil.addPaths(\";JS?A=1\", null), \";JS?A=1\"); assertEquals(\";JS?A=1+\", URIUtil.addPaths(\";JS?A=1\", \"\"), \";JS?A=1\"); assertEquals(\";JS?A=1+bbb\", URIUtil.addPaths(\";JS?A=1\", \"bbb\"), \"bbb;JS?A=1\"); assertEquals(\";JS?A=1+/\", URIUtil.addPaths(\";JS?A=1\", \"/\"), \"/;JS?A=1\"); assertEquals(\";JS?A=1+/bbb\", URIUtil.addPaths(\";JS?A=1\", \"/bbb\"), \"/bbb;JS?A=1\"); assertEquals(\"aaa;JS?A=1+null\", URIUtil.addPaths(\"aaa;JS?A=1\", null), \"aaa;JS?A=1\"); assertEquals(\"aaa;JS?A=1+\", URIUtil.addPaths(\"aaa;JS?A=1\", \"\"), \"aaa;JS?A=1\"); assertEquals(\"aaa;JS?A=1+bbb\", URIUtil.addPaths(\"aaa;JS?A=1\", \"bbb\"), \"aaa/bbb;JS?A=1\"); assertEquals(\"aaa;JS?A=1+/\", URIUtil.addPaths(\"aaa;JS?A=1\", \"/\"), \"aaa/;JS?A=1\"); assertEquals(\"aaa;JS?A=1+/bbb\", URIUtil.addPaths(\"aaa;JS?A=1\", \"/bbb\"), \"aaa/bbb;JS?A=1\"); assertEquals(\"aaa;JS?A=1+null\", URIUtil.addPaths(\"aaa/;JS?A=1\", null), \"aaa/;JS?A=1\"); assertEquals(\"aaa;JS?A=1+\", URIUtil.addPaths(\"aaa/;JS?A=1\", \"\"), \"aaa/;JS?A=1\"); assertEquals(\"aaa;JS?A=1+bbb\", URIUtil.addPaths(\"aaa/;JS?A=1\", \"bbb\"), \"aaa/bbb;JS?A=1\"); assertEquals(\"aaa;JS?A=1+/\", URIUtil.addPaths(\"aaa/;JS?A=1\", \"/\"), \"aaa/;JS?A=1\"); assertEquals(\"aaa;JS?A=1+/bbb\", URIUtil.addPaths(\"aaa/;JS?A=1\", \"/bbb\"), \"aaa/bbb;JS?A=1\"); } ",
        "focal_tgt": "public static String addPaths(String p1, String p2) { if(p1 == null || p1.length() == 0) { if(p1 != null && p2 == null)return p1; return p2; } if(p2 == null || p2.length() == 0)return p1; boolean p1EndsWithSlash = p1.endsWith(SLASH); boolean p2StartsWithSlash = p2.startsWith(SLASH); if(p1EndsWithSlash && p2StartsWithSlash) { if(p2.length() == 1)return p1; if(p1.length() == 1)return p2; } StringBuilder buf = new StringBuilder(p1.length() + p2.length() + 2); buf.append(p1); if(p1.endsWith(SLASH)) { if(p2.startsWith(SLASH))buf.setLength(buf.length() - 1); } else { if( ! p2.startsWith(SLASH))buf.append(SLASH); } buf.append(p2); return buf.toString(); } ",
        "focal_src": "public static String addPaths(String p1, String p2) { if(p1 == null || p1.length() == 0) { if(p1 != null && p2 == null)return p1; return p2; } if(p2 == null || p2.length() == 0)return p1; int split = p1.indexOf(';'); if(split < 0)split = p1.indexOf('?'); if(split == 0)return p2 + p1; if(split < 0)split = p1.length(); StringBuilder buf = new StringBuilder(p1.length() + p2.length() + 2); buf.append(p1); if(buf.charAt(split - 1) == '/') { if(p2.startsWith(URIUtil.SLASH)) { buf.deleteCharAt(split - 1); buf.insert(split - 1, p2); } else buf.insert(split, p2); } else { if(p2.startsWith(URIUtil.SLASH))buf.insert(split, p2); else { buf.insert(split, '/'); buf.insert(split + 1, p2); } } return buf.toString(); } ",
        "test_tgt": "@Test public void testAddDecodedPaths() { assertEquals(\"null+null\", URIUtil.addPaths(null, null), null); assertEquals(\"null+\", URIUtil.addPaths(null, \"\"), \"\"); assertEquals(\"null+bbb\", URIUtil.addPaths(null, \"bbb\"), \"bbb\"); assertEquals(\"null+/\", URIUtil.addPaths(null, \"/\"), \"/\"); assertEquals(\"null+/bbb\", URIUtil.addPaths(null, \"/bbb\"), \"/bbb\"); assertEquals(\"+null\", URIUtil.addPaths(\"\", null), \"\"); assertEquals(\"+\", URIUtil.addPaths(\"\", \"\"), \"\"); assertEquals(\"+bbb\", URIUtil.addPaths(\"\", \"bbb\"), \"bbb\"); assertEquals(\"+/\", URIUtil.addPaths(\"\", \"/\"), \"/\"); assertEquals(\"+/bbb\", URIUtil.addPaths(\"\", \"/bbb\"), \"/bbb\"); assertEquals(\"aaa+null\", URIUtil.addPaths(\"aaa\", null), \"aaa\"); assertEquals(\"aaa+\", URIUtil.addPaths(\"aaa\", \"\"), \"aaa\"); assertEquals(\"aaa+bbb\", URIUtil.addPaths(\"aaa\", \"bbb\"), \"aaa/bbb\"); assertEquals(\"aaa+/\", URIUtil.addPaths(\"aaa\", \"/\"), \"aaa/\"); assertEquals(\"aaa+/bbb\", URIUtil.addPaths(\"aaa\", \"/bbb\"), \"aaa/bbb\"); assertEquals(\"/+null\", URIUtil.addPaths(\"/\", null), \"/\"); assertEquals(\"/+\", URIUtil.addPaths(\"/\", \"\"), \"/\"); assertEquals(\"/+bbb\", URIUtil.addPaths(\"/\", \"bbb\"), \"/bbb\"); assertEquals(\"/+/\", URIUtil.addPaths(\"/\", \"/\"), \"/\"); assertEquals(\"/+/bbb\", URIUtil.addPaths(\"/\", \"/bbb\"), \"/bbb\"); assertEquals(\"aaa/+null\", URIUtil.addPaths(\"aaa/\", null), \"aaa/\"); assertEquals(\"aaa/+\", URIUtil.addPaths(\"aaa/\", \"\"), \"aaa/\"); assertEquals(\"aaa/+bbb\", URIUtil.addPaths(\"aaa/\", \"bbb\"), \"aaa/bbb\"); assertEquals(\"aaa/+/\", URIUtil.addPaths(\"aaa/\", \"/\"), \"aaa/\"); assertEquals(\"aaa/+/bbb\", URIUtil.addPaths(\"aaa/\", \"/bbb\"), \"aaa/bbb\"); assertEquals(\";JS+null\", URIUtil.addPaths(\";JS\", null), \";JS\"); assertEquals(\";JS+\", URIUtil.addPaths(\";JS\", \"\"), \";JS\"); assertEquals(\";JS+bbb\", URIUtil.addPaths(\";JS\", \"bbb\"), \";JS/bbb\"); assertEquals(\";JS+/\", URIUtil.addPaths(\";JS\", \"/\"), \";JS/\"); assertEquals(\";JS+/bbb\", URIUtil.addPaths(\";JS\", \"/bbb\"), \";JS/bbb\"); assertEquals(\"aaa;JS+null\", URIUtil.addPaths(\"aaa;JS\", null), \"aaa;JS\"); assertEquals(\"aaa;JS+\", URIUtil.addPaths(\"aaa;JS\", \"\"), \"aaa;JS\"); assertEquals(\"aaa;JS+bbb\", URIUtil.addPaths(\"aaa;JS\", \"bbb\"), \"aaa;JS/bbb\"); assertEquals(\"aaa;JS+/\", URIUtil.addPaths(\"aaa;JS\", \"/\"), \"aaa;JS/\"); assertEquals(\"aaa;JS+/bbb\", URIUtil.addPaths(\"aaa;JS\", \"/bbb\"), \"aaa;JS/bbb\"); assertEquals(\"aaa;JS+null\", URIUtil.addPaths(\"aaa/;JS\", null), \"aaa/;JS\"); assertEquals(\"aaa;JS+\", URIUtil.addPaths(\"aaa/;JS\", \"\"), \"aaa/;JS\"); assertEquals(\"aaa;JS+bbb\", URIUtil.addPaths(\"aaa/;JS\", \"bbb\"), \"aaa/;JS/bbb\"); assertEquals(\"aaa;JS+/\", URIUtil.addPaths(\"aaa/;JS\", \"/\"), \"aaa/;JS/\"); assertEquals(\"aaa;JS+/bbb\", URIUtil.addPaths(\"aaa/;JS\", \"/bbb\"), \"aaa/;JS/bbb\"); assertEquals(\"?A=1+null\", URIUtil.addPaths(\"?A=1\", null), \"?A=1\"); assertEquals(\"?A=1+\", URIUtil.addPaths(\"?A=1\", \"\"), \"?A=1\"); assertEquals(\"?A=1+bbb\", URIUtil.addPaths(\"?A=1\", \"bbb\"), \"?A=1/bbb\"); assertEquals(\"?A=1+/\", URIUtil.addPaths(\"?A=1\", \"/\"), \"?A=1/\"); assertEquals(\"?A=1+/bbb\", URIUtil.addPaths(\"?A=1\", \"/bbb\"), \"?A=1/bbb\"); assertEquals(\"aaa?A=1+null\", URIUtil.addPaths(\"aaa?A=1\", null), \"aaa?A=1\"); assertEquals(\"aaa?A=1+\", URIUtil.addPaths(\"aaa?A=1\", \"\"), \"aaa?A=1\"); assertEquals(\"aaa?A=1+bbb\", URIUtil.addPaths(\"aaa?A=1\", \"bbb\"), \"aaa?A=1/bbb\"); assertEquals(\"aaa?A=1+/\", URIUtil.addPaths(\"aaa?A=1\", \"/\"), \"aaa?A=1/\"); assertEquals(\"aaa?A=1+/bbb\", URIUtil.addPaths(\"aaa?A=1\", \"/bbb\"), \"aaa?A=1/bbb\"); assertEquals(\"aaa?A=1+null\", URIUtil.addPaths(\"aaa/?A=1\", null), \"aaa/?A=1\"); assertEquals(\"aaa?A=1+\", URIUtil.addPaths(\"aaa/?A=1\", \"\"), \"aaa/?A=1\"); assertEquals(\"aaa?A=1+bbb\", URIUtil.addPaths(\"aaa/?A=1\", \"bbb\"), \"aaa/?A=1/bbb\"); assertEquals(\"aaa?A=1+/\", URIUtil.addPaths(\"aaa/?A=1\", \"/\"), \"aaa/?A=1/\"); assertEquals(\"aaa?A=1+/bbb\", URIUtil.addPaths(\"aaa/?A=1\", \"/bbb\"), \"aaa/?A=1/bbb\"); } "
    },
    {
        "test_src": "@Test public void bug15375_2() { bug15375(1000); } ",
        "focal_tgt": "public final void bug15375(int num)throws Exception { Workbook wb1 = _testDataProvider.createWorkbook(); Sheet sheet = wb1.createSheet(); CreationHelper factory = wb1.getCreationHelper(); String tmp1 = null; String tmp2 = null; String tmp3 = null; for(int i = 0; i < num; i ++ ) { tmp1 = \"Test1\" + i; tmp2 = \"Test2\" + i; tmp3 = \"Test3\" + i; Row row = sheet.createRow(i); Cell cell = row.createCell(0); cell.setCellValue(factory.createRichTextString(tmp1)); cell = row.createCell(1); cell.setCellValue(factory.createRichTextString(tmp2)); cell = row.createCell(2); cell.setCellValue(factory.createRichTextString(tmp3)); } Workbook wb2 = _testDataProvider.writeOutAndReadBack(wb1); wb1.close(); sheet = wb2.getSheetAt(0); for(int i = 0; i < num; i ++ ) { tmp1 = \"Test1\" + i; tmp2 = \"Test2\" + i; tmp3 = \"Test3\" + i; Row row = sheet.getRow(i); assertEquals(tmp1, row.getCell(0).getStringCellValue()); assertEquals(tmp2, row.getCell(1).getStringCellValue()); assertEquals(tmp3, row.getCell(2).getStringCellValue()); } wb2.close(); } ",
        "focal_src": "public final void bug15375(int num) { Workbook wb = _testDataProvider.createWorkbook(); Sheet sheet = wb.createSheet(); CreationHelper factory = wb.getCreationHelper(); String tmp1 = null; String tmp2 = null; String tmp3 = null; for(int i = 0; i < num; i ++ ) { tmp1 = \"Test1\" + i; tmp2 = \"Test2\" + i; tmp3 = \"Test3\" + i; Row row = sheet.createRow(i); Cell cell = row.createCell(0); cell.setCellValue(factory.createRichTextString(tmp1)); cell = row.createCell(1); cell.setCellValue(factory.createRichTextString(tmp2)); cell = row.createCell(2); cell.setCellValue(factory.createRichTextString(tmp3)); } wb = _testDataProvider.writeOutAndReadBack(wb); for(int i = 0; i < num; i ++ ) { tmp1 = \"Test1\" + i; tmp2 = \"Test2\" + i; tmp3 = \"Test3\" + i; Row row = sheet.getRow(i); assertEquals(tmp1, row.getCell(0).getStringCellValue()); assertEquals(tmp2, row.getCell(1).getStringCellValue()); assertEquals(tmp3, row.getCell(2).getStringCellValue()); } } ",
        "test_tgt": "@Test public void bug15375_2()throws Exception { bug15375(1000); } "
    },
    {
        "test_src": "@Test public void process() { List < Polygon2D_F64 > squares = new ArrayList < Polygon2D_F64 > (); double width = 1; for(int i = 0; i < 3; i ++ ) { for(int j = 0; j < 4; j ++ ) { squares.add(createSquare(i * 2 * width, j * 2 * width, 0, width)); squares.add(createSquare(i * 2 * width + 100, j * 2 * width, 0, width)); } } SquaresIntoClusters alg = new SquaresIntoClusters(1.0); List < List < SquareNode > > clusters = alg.process(squares); assertEquals(2, clusters.size()); clusters = alg.process(squares); assertEquals(2, clusters.size()); } ",
        "focal_tgt": "public boolean process(T input, ImageUInt8 binary) { boundPolygon.vertexes.reset(); detectorSquare.process(input, binary); FastQueue < Polygon2D_F64 > found = detectorSquare.getFound(); List < List < SquareNode > > clusters = s2c.process(found.toList()); c2g.process(clusters); List < SquareGrid > grids = c2g.getGrids(); SquareGrid inner = null; SquareGrid outer = null; for(int i = 0; i < grids.size(); i ++ ) { SquareGrid g = grids.get(i); if(inner == null && ((g.columns == innerCols && g.rows == innerRows) || (g.columns == innerRows && g.rows == innerCols))) { inner = g; } else if(outer == null && ((g.columns == outerCols && g.rows == outerRows) || (g.columns == outerRows && g.rows == outerCols))) { outer = g; } } if(inner == null || outer == null)return false; if(inner.columns != innerCols) { tools.transpose(inner); } if(outer.columns != outerCols) { tools.transpose(outer); } if(tools.checkFlip(inner)) { tools.flipRows(inner); } if(tools.checkFlip(outer)) { tools.flipRows(outer); } tools.boundingPolygon(inner, innerPolygon); selectZeroSeed(inner, outer, innerPolygon); forceToZero(seedInner, inner); forceToZero(seedOuter, outer); createUber(inner, outer, uberGrid); putIntoCanonical(uberGrid); orderUberCorners(uberGrid); return computeCalibrationPoints(uberGrid); } ",
        "focal_src": "public boolean process(T input, ImageUInt8 binary) { boundPolygon.vertexes.reset(); detectorSquare.process(input, binary); FastQueue < Polygon2D_F64 > found = detectorSquare.getFound(); List < List < SquareNode > > clusters = s2c.process(found.toList()); c2g.process(clusters); List < SquareGrid > grids = c2g.getGrids(); SquareGrid inner = null; SquareGrid outer = null; for(int i = 0; i < grids.size(); i ++ ) { SquareGrid g = grids.get(i); if((g.columns == innerCols && g.rows == innerRows) || (g.columns == innerRows && g.rows == innerCols)) { if(inner != null)return false; inner = g; } else if((g.columns == outerCols && g.rows == outerRows) || (g.columns == outerRows && g.rows == outerCols)) { if(outer != null)return false; outer = g; } } if(inner == null || outer == null)return false; if(inner.columns != innerCols) { tools.transpose(inner); } if(outer.columns != outerCols) { tools.transpose(outer); } tools.boundingPolygon(inner, innerPolygon); outerOrigins.clear(); listPossibleZeroNodes(outer, outerOrigins); selectSeedZero(outerOrigins, inner, innerPolygon); forceToZero(seedInner, inner); forceToZero(seedOuter, outer); createUber(outer, inner, uberGrid); putIntoCanonical(uberGrid, inner, outer); tools.orderSquareCorners(inner); tools.orderSquareCorners(outer); return getCalibrationPoints(uberGrid); } ",
        "test_tgt": "@Test public void process() { List < Polygon2D_F64 > squares = new ArrayList < Polygon2D_F64 > (); double width = 1; for(int i = 0; i < 3; i ++ ) { for(int j = 0; j < 4; j ++ ) { squares.add(createSquare(i * 2 * width, j * 2 * width, 0, width)); squares.add(createSquare(i * 2 * width + 100, j * 2 * width, 0, width)); } } SquaresIntoClusters alg = new SquaresIntoClusters(1.0, 6); List < List < SquareNode > > clusters = alg.process(squares); assertEquals(2, clusters.size()); clusters = alg.process(squares); assertEquals(2, clusters.size()); } "
    },
    {
        "test_src": "@Test public void delete() { for(final byte[]t : LIST)set.delete(t); for(final byte[]t : LIST)assertFalse(\"Token exists.\", set.contains(t)); } ",
        "focal_tgt": "private Expr delete()throws QueryException { final int p = pos; if( ! wsConsumeWs(DELETE) || ! wsConsumeWs(NODES) && ! wsConsumeWs(NODE)) { pos = p; return null; } qc.updating(); return new Delete(sc, info(), check(single(), INCOMPLETE)); } ",
        "focal_src": "private Expr delete()throws QueryException { final int i = pos; if( ! wsConsumeWs(DELETE) || ! wsConsumeWs(NODES) && ! wsConsumeWs(NODE)) { pos = i; return null; } qc.updating(); return new Delete(sc, info(), check(single(), INCOMPLETE)); } ",
        "test_tgt": "@Test public void delete() { for(final byte[]token : LIST)set.delete(token); for(final byte[]token : LIST)assertFalse(\"Token exists.\", set.contains(token)); } "
    },
    {
        "test_src": "@Test public void libraries()throws Exception { final HashSet < String > libs = new HashSet < String > (); for(final String s : new String[] { \"lib\" }) { final int l = libs.size(); for(final IOFile f : new IOFile(s).children())libs.add(f.name()); if(l == libs.size())Util.errln(Util.name(this) + \": test skipped (no library files found)\"); } for(final IOFile f : new IOFile(\"etc\").children()) { final String n = f.name(); final StringList missing = new StringList(); final StringList obsolete = new StringList(); if(n.endsWith(\".bat\"))libraries(n, libs, missing, obsolete); if( ! missing.isEmpty()) { final StringBuilder sb = new StringBuilder(); for(final String l : missing)sb.append(\";%LIB%\").append(l); fail(\"Library not found in '\" + n + \"':\\n\" + sb.substring(1)); } if( ! obsolete.isEmpty()) { final StringBuilder sb = new StringBuilder(); for(final String l : obsolete)sb.append(\";%LIB%\").append(l); fail(\"Library obsolete in '\" + n + \"':\\n\" + sb.substring(1)); } } } ",
        "focal_tgt": "private boolean libraries(final String name, final HashSet < String > libs)throws Exception { final HashSet < String > sl = new HashSet < String > (); final NewlineInput nli = new NewlineInput(IO.get(\"etc/\" + name)); try { for(String s; (s = nli.readLine()) != null; ) { for(final String p : s.split(\";\")) { if(p.contains(\"%LIB%\"))sl.add(p.replace(\"%LIB%/\", \"\")); } } } finally { nli.close(); } final StringList mis = new StringList(); for(final String l : libs) { if( ! l.contains(\"basex\") && ! sl.remove(l))mis.add(l); } final StringList obs = new StringList(); for(final String l : sl) { if(l.endsWith(\".jar\"))obs.add(l); } if( ! mis.isEmpty())Util.errln(\"Missing: \" + Arrays.toString(mis.toArray())); if( ! obs.isEmpty())Util.errln(\"Obsolete: \" + Arrays.toString(obs.toArray())); return mis.isEmpty() && obs.isEmpty(); } ",
        "focal_src": "private void libraries(final String name, final HashSet < String > libs, final StringList missing, final StringList obsolete)throws Exception { final HashSet < String > sl = new HashSet < String > (); final NewlineInput nli = new NewlineInput(IO.get(\"etc/\" + name)); try { for(String s; (s = nli.readLine()) != null; ) { for(final String p : s.split(\";\")) { if(p.contains(\"%LIB%\"))sl.add(p.replace(\"%LIB%/\", \"\")); } } } finally { nli.close(); } for(final String l : libs) { if(l.contains(\"basex\"))continue; if( ! sl.remove(l))missing.add(l); } for(final String l : sl) { if(l.endsWith(\".jar\"))obsolete.add(l); } } ",
        "test_tgt": "@Test public void libraries()throws Exception { final HashSet < String > libs = new HashSet < String > (); for(final String s : new String[] { \"lib\" }) { final int l = libs.size(); for(final IOFile f : new IOFile(s).children())libs.add(f.name()); if(l == libs.size())Util.errln(Util.name(this) + \": test skipped (no library files found)\"); } for(final IOFile f : new IOFile(\"etc\").children()) { final String n = f.name(); if(n.endsWith(\".bat\") && ! libraries(n, libs)) { final TokenBuilder tb = new TokenBuilder(\"set CP=%CP%\"); for(final IOFile l : new IOFile(\"lib\").children()) { if( ! l.name().contains(\"basex\"))tb.add(\";%LIB%/\").add(l.name()); } Util.errln(tb.toString()); fail(n + \": see STDERR output\"); } } } "
    },
    {
        "test_src": "@Test public void labelInSortedOrderTest() { assertEquals(features.length, index.rowsCount()); assertEquals(features[0].length, index.columnsCount()); for(int k = 0; k < index.rowsCount(); k ++ ) { for(int featureId = 0; featureId < index.columnsCount(); featureId ++ )assertEquals(labelsInSortedOrder[k][featureId], index.labelInSortedOrder(k, featureId), 0.01); } } ",
        "focal_tgt": "public double labelInSortedOrder(int k, int featureId) { return labels[idx[k][featureId]]; } ",
        "focal_src": "public double labelInSortedOrder(int k, int featureId) { return labels[index[k][featureId]]; } ",
        "test_tgt": "@Test public void labelInSortedOrderTest() { assertEquals(features.length, idx.rowsCount()); assertEquals(features[0].length, idx.columnsCount()); for(int k = 0; k < idx.rowsCount(); k ++ ) { for(int featureId = 0; featureId < idx.columnsCount(); featureId ++ )assertEquals(labelsInSortedOrder[k][featureId], idx.labelInSortedOrder(k, featureId), 0.01); } } "
    },
    {
        "test_src": "@Test public void testOnUpdateAuditable()throws InterruptedException { final BaseEntity a = new BaseEntity(); Assert.assertNull(a.getId()); Assert.assertNotNull(a.getCreated()); Assert.assertNotNull(a.getUpdated()); a.onCreateAuditable(); final Date originalCreate = a.getCreated(); final Date originalUpdate = a.getUpdated(); Thread.sleep(1); a.onUpdateAuditable(); Assert.assertEquals(originalCreate, a.getCreated()); Assert.assertNotEquals(originalUpdate, a.getUpdated()); } ",
        "focal_tgt": "@PreUpdate protected void onUpdateBaseEntity() { this.updated = new Date(); } ",
        "focal_src": "@PreUpdate protected void onUpdateAuditable() { this.updated = new Date(); } ",
        "test_tgt": "@Test public void testOnUpdateBaseEntity()throws InterruptedException { final BaseEntity a = new BaseEntity(); Assert.assertNull(a.getId()); Assert.assertNotNull(a.getCreated()); Assert.assertNotNull(a.getUpdated()); a.onCreateBaseEntity(); final Date originalCreate = a.getCreated(); final Date originalUpdate = a.getUpdated(); Thread.sleep(1); a.onUpdateBaseEntity(); Assert.assertEquals(originalCreate, a.getCreated()); Assert.assertNotEquals(originalUpdate, a.getUpdated()); } "
    },
    {
        "test_src": "@Test public final void testGetId() { ShowMissingDiskStoresFunction smdsFunc = new ShowMissingDiskStoresFunction(); assertEquals(ShowMissingDiskStoresFunction.class.getName(), smdsFunc.getId()); } ",
        "focal_tgt": "public int getId() { return this.id; } ",
        "focal_src": "public final int getId() { return this.id; } ",
        "test_tgt": "@Test public void testGetId() { ShowMissingDiskStoresFunction smdsFunc = new ShowMissingDiskStoresFunction(); assertEquals(ShowMissingDiskStoresFunction.class.getName(), smdsFunc.getId()); } "
    },
    {
        "test_src": "@Test public void getCookieValue_existingCookieDifferentCase() { String name = \"cookieName\"; String value = \"cookieValue\"; Cookie[]cookies = new Cookie[] { new Cookie(name, value) }; assertEquals(value, CookieHelper.getCookieValue(cookies, \"COOKIENAME\")); } ",
        "focal_tgt": "@Sensitive public static String getCookieValue(Cookie[]cookies, String cookieName) { if(cookies == null) { return null; } String retVal = null; for(int i = 0; i < cookies.length; ++ i) { if(cookieName.equalsIgnoreCase(cookies[i].getName())) { retVal = cookies[i].getValue(); break; } } return retVal; } ",
        "focal_src": "@Sensitive public static String getCookieValue(Cookie[]cookies, String cookieName) { if(cookies == null)return null; String retVal = null; for(int i = 0; i < cookies.length; ++ i) { if(cookieName.equalsIgnoreCase(cookies[i].getName())) { retVal = cookies[i].getValue(); break; } } return retVal; } ",
        "test_tgt": "@Test public void getCookieValue_existingCookieDifferentCase() { String name = \"cookieName\"; String value = \"cookieValue\"; Cookie[]cookies = new Cookie[] { new Cookie(name, value) }; assertEquals(value, CookieHelper.getCookieValue(cookies, \"COOKIENAME\")); assertTrue(CookieHelper.hasCookie(cookies, \"COOKIENAME\")); } "
    },
    {
        "test_src": "@Test public void testGroupByBucket() { int bucketCount = 5; int hashesPerBucket = 5; val hashToBuckets = new HashMap < UUID, TableBucket > (); val bucketsToKeys = new HashMap < TableBucket, ArrayList < BucketUpdate.KeyUpdate > > (); val rnd = new Random(0); for(int i = 0; i < bucketCount; i ++ ) { val bucket = new TableBucket(UUID.randomUUID(), i); val keyUpdates = new ArrayList < BucketUpdate.KeyUpdate > (); bucketsToKeys.put(bucket, keyUpdates); for(int j = 0; j < hashesPerBucket; j ++ ) { byte[]key = new byte[KeyHasher.HASH_SIZE_BYTES * 4]; keyUpdates.add(new BucketUpdate.KeyUpdate(new HashedArray(key), i * hashesPerBucket + j, true)); rnd.nextBytes(key); hashToBuckets.put(KeyHashers.DEFAULT_HASHER.hash(key), bucket); } } val w = new CustomLocateBucketIndexer(KeyHashers.DEFAULT_HASHER, executorService(), hashToBuckets); val allKeyUpdates = new ArrayList < BucketUpdate.KeyUpdate > (); bucketsToKeys.values().forEach(allKeyUpdates :: addAll); val bucketUpdates = w.groupByBucket(null, allKeyUpdates, new TimeoutTimer(TIMEOUT)).join(); Assert.assertEquals(\"Unexpected number of Bucket Updates.\", bucketCount, bucketUpdates.size()); for(BucketUpdate bu : bucketUpdates) { Assert.assertTrue(\"Not expecting Existing Keys to be populated.\", bu.getExistingKeys().isEmpty()); val expected = bucketsToKeys.get(bu.getBucket()); Assert.assertNotNull(\"Found extra bucket.\", expected); AssertExtensions.assertContainsSameElements(\"Unexpected updates grouped.\", expected, bu.getKeyUpdates(), (u1, u2) -> u1.getKey().equals(u2.getKey()) && u1.getOffset() == u2.getOffset() ? 0 : 1); } } ",
        "focal_tgt": "CompletableFuture < Collection < BucketUpdate.Builder > > groupByBucket(DirectSegmentAccess segment, Collection < BucketUpdate.KeyUpdate > keyUpdates, TimeoutTimer timer) { val updatesByHash = keyUpdates.stream().collect(Collectors.groupingBy(k -> this.hasher.hash(k.getKey()))); return locateBuckets(segment, updatesByHash.keySet(), timer).thenApplyAsync(buckets -> { val result = new HashMap < TableBucket, BucketUpdate.Builder > (); buckets.forEach((keyHash, bucket) -> { BucketUpdate.Builder bu = result.computeIfAbsent(bucket, BucketUpdate :: forBucket); updatesByHash.get(keyHash).forEach(bu :: withKeyUpdate); }); return result.values(); }, this.executor); } ",
        "focal_src": "CompletableFuture < Collection < BucketUpdate > > groupByBucket(DirectSegmentAccess segment, Collection < BucketUpdate.KeyUpdate > keyUpdates, TimeoutTimer timer) { val updatesByHash = keyUpdates.stream().collect(Collectors.groupingBy(k -> this.hasher.hash(k.getKey()))); return locateBuckets(segment, updatesByHash.keySet(), timer).thenApplyAsync(buckets -> { val result = new HashMap < TableBucket, BucketUpdate > (); buckets.forEach((keyHash, bucket) -> { BucketUpdate bu = result.computeIfAbsent(bucket, BucketUpdate :: new); updatesByHash.get(keyHash).forEach(bu :: withKeyUpdate); }); return result.values(); }, this.executor); } ",
        "test_tgt": "@Test public void testGroupByBucket() { int bucketCount = 5; int hashesPerBucket = 5; val hashToBuckets = new HashMap < UUID, TableBucket > (); val bucketsToKeys = new HashMap < TableBucket, ArrayList < BucketUpdate.KeyUpdate > > (); val rnd = new Random(0); for(int i = 0; i < bucketCount; i ++ ) { val bucket = new TableBucket(UUID.randomUUID(), i); val keyUpdates = new ArrayList < BucketUpdate.KeyUpdate > (); bucketsToKeys.put(bucket, keyUpdates); for(int j = 0; j < hashesPerBucket; j ++ ) { byte[]key = new byte[KeyHasher.HASH_SIZE_BYTES * 4]; long offset = i * hashesPerBucket + j; keyUpdates.add(new BucketUpdate.KeyUpdate(new HashedArray(key), offset, offset, true)); rnd.nextBytes(key); hashToBuckets.put(KeyHashers.DEFAULT_HASHER.hash(key), bucket); } } val w = new CustomLocateBucketIndexer(KeyHashers.DEFAULT_HASHER, executorService(), hashToBuckets); val allKeyUpdates = new ArrayList < BucketUpdate.KeyUpdate > (); bucketsToKeys.values().forEach(allKeyUpdates :: addAll); val bucketUpdates = w.groupByBucket(null, allKeyUpdates, new TimeoutTimer(TIMEOUT)).join().stream().map(BucketUpdate.Builder :: build).collect(Collectors.toList()); Assert.assertEquals(\"Unexpected number of Bucket Updates.\", bucketCount, bucketUpdates.size()); for(BucketUpdate bu : bucketUpdates) { Assert.assertTrue(\"Not expecting Existing Keys to be populated.\", bu.getExistingKeys().isEmpty()); val expected = bucketsToKeys.get(bu.getBucket()); Assert.assertNotNull(\"Found extra bucket.\", expected); AssertExtensions.assertContainsSameElements(\"Unexpected updates grouped.\", expected, bu.getKeyUpdates(), (u1, u2) -> u1.getKey().equals(u2.getKey()) && u1.getOffset() == u2.getOffset() ? 0 : 1); } } "
    },
    {
        "test_src": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"readResolve\", args = { })@KnownFailure(\"readResolve does not work properly\")public void test_readResolve() { ObjectOutputStream out = null; ObjectInputStream in = null; try { ByteArrayOutputStream bytes = new ByteArrayOutputStream(); out = new ObjectOutputStream(bytes); DateFormat.Field dfield, dfield2; MyField field; dfield = DateFormat.Field.MILLISECOND; field = new MyField(null, Calendar.AM_PM); out.writeObject(dfield); out.writeObject(field); in = new ObjectInputStream(new ByteArrayInputStream(bytes.toByteArray())); try { dfield2 = (Field)in.readObject(); assertSame(\"resolved incorrectly\", dfield, dfield2); } catch(IllegalArgumentException e) { fail(\"Unexpected IllegalArgumentException: \" + e); } try { in.readObject(); fail(\"Expected InvalidObjectException for subclass instance with null name\"); } catch(InvalidObjectException e) { } } catch(IOException e) { fail(\"unexpected IOException\" + e); } catch(ClassNotFoundException e) { fail(\"unexpected ClassNotFoundException\" + e); } finally { try { if(out != null)out.close(); if(in != null)in.close(); } catch(IOException e) { } } } ",
        "focal_tgt": "protected Object readResolve()throws InvalidObjectException { if(this.getClass() != Attribute.class) { throw new InvalidObjectException(Messages.getString(\"text.0C\")); } String name = this.getName(); if(name.equals(INPUT_METHOD_SEGMENT.getName())) { return INPUT_METHOD_SEGMENT; } if(name.equals(LANGUAGE.getName())) { return LANGUAGE; } if(name.equals(READING.getName())) { return READING; } throw new InvalidObjectException(Messages.getString(\"text.02\")); } ",
        "focal_src": "protected Object readResolve()throws InvalidObjectException { if(this.getClass() != Attribute.class) { throw new InvalidObjectException(Messages.getString(\"text.0C\")); } if(this.name.equals(INPUT_METHOD_SEGMENT.name)) { return INPUT_METHOD_SEGMENT; } if(this.name.equals(LANGUAGE.name)) { return LANGUAGE; } if(this.name.equals(READING.name)) { return READING; } throw new InvalidObjectException(Messages.getString(\"text.02\")); } ",
        "test_tgt": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"readResolve\", args = { })public void test_readResolve() { ObjectOutputStream out = null; ObjectInputStream in = null; try { ByteArrayOutputStream bytes = new ByteArrayOutputStream(); out = new ObjectOutputStream(bytes); DateFormat.Field dfield, dfield2; MyField field; dfield = DateFormat.Field.MILLISECOND; field = new MyField(null, Calendar.AM_PM); out.writeObject(dfield); out.writeObject(field); in = new ObjectInputStream(new ByteArrayInputStream(bytes.toByteArray())); try { dfield2 = (Field)in.readObject(); assertSame(\"resolved incorrectly\", dfield, dfield2); } catch(IllegalArgumentException e) { fail(\"Unexpected IllegalArgumentException: \" + e); } try { in.readObject(); fail(\"Expected InvalidObjectException for subclass instance with null name\"); } catch(InvalidObjectException e) { } } catch(IOException e) { fail(\"unexpected IOException\" + e); } catch(ClassNotFoundException e) { fail(\"unexpected ClassNotFoundException\" + e); } finally { try { if(out != null)out.close(); if(in != null)in.close(); } catch(IOException e) { } } } "
    },
    {
        "test_src": "@Test public void testGetDialogNode() { String dialogNodeName = \"Test\" + UUID.randomUUID().toString(); String dialogNodeDescription = \"Description of \" + dialogNodeName; Date start = new Date(); CreateDialogNodeOptions createOptions = new CreateDialogNodeOptions.Builder(workspaceId, dialogNodeName).description(dialogNodeDescription).build(); service.createDialogNode(createOptions).execute(); try { GetDialogNodeOptions getOptions = new GetDialogNodeOptions.Builder().workspaceId(workspaceId).dialogNode(dialogNodeName).build(); DialogNode response = service.getDialogNode(getOptions).execute(); assertNotNull(response); assertNotNull(response.getDialogNodeId()); assertEquals(response.getDialogNodeId(), dialogNodeName); assertNotNull(response.getDescription()); assertEquals(response.getDescription(), dialogNodeDescription); assertNotNull(response.getCreated()); assertNotNull(response.getUpdated()); Date now = new Date(); assertTrue(fuzzyBefore(response.getCreated(), now)); assertTrue(fuzzyAfter(response.getCreated(), start)); assertTrue(fuzzyBefore(response.getUpdated(), now)); assertTrue(fuzzyAfter(response.getUpdated(), start)); } catch(Exception ex) { fail(ex.getMessage()); } finally { DeleteDialogNodeOptions deleteOptions = new DeleteDialogNodeOptions.Builder(workspaceId, dialogNodeName).build(); service.deleteDialogNode(deleteOptions).execute(); } } ",
        "focal_tgt": "public ServiceCall < DialogNode > getDialogNode(GetDialogNodeOptions getDialogNodeOptions) { Validator.notNull(getDialogNodeOptions, \"getDialogNodeOptions cannot be null\"); RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/workspaces/%s/dialog_nodes/%s\", getDialogNodeOptions.workspaceId(), getDialogNodeOptions.dialogNode())); builder.query(VERSION, versionDate); if(getDialogNodeOptions.includeAudit() != null) { builder.query(\"include_audit\", String.valueOf(getDialogNodeOptions.includeAudit())); } return createServiceCall(builder.build(), ResponseConverterUtils.getObject(DialogNode.class)); } ",
        "focal_src": "public ServiceCall < DialogNode > getDialogNode(GetDialogNodeOptions getDialogNodeOptions) { Validator.notNull(getDialogNodeOptions, \"getDialogNodeOptions cannot be null\"); RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/workspaces/%s/dialog_nodes/%s\", getDialogNodeOptions.workspaceId(), getDialogNodeOptions.dialogNode())); builder.query(VERSION, versionDate); return createServiceCall(builder.build(), ResponseConverterUtils.getObject(DialogNode.class)); } ",
        "test_tgt": "@Test public void testGetDialogNode() { String dialogNodeName = \"Test\" + UUID.randomUUID().toString(); String dialogNodeDescription = \"Description of \" + dialogNodeName; Date start = new Date(); CreateDialogNodeOptions createOptions = new CreateDialogNodeOptions.Builder(workspaceId, dialogNodeName).description(dialogNodeDescription).build(); service.createDialogNode(createOptions).execute(); try { GetDialogNodeOptions getOptions = new GetDialogNodeOptions.Builder().workspaceId(workspaceId).dialogNode(dialogNodeName).includeAudit(true).build(); DialogNode response = service.getDialogNode(getOptions).execute(); assertNotNull(response); assertNotNull(response.getDialogNodeId()); assertEquals(response.getDialogNodeId(), dialogNodeName); assertNotNull(response.getDescription()); assertEquals(response.getDescription(), dialogNodeDescription); assertNotNull(response.getCreated()); assertNotNull(response.getUpdated()); Date now = new Date(); assertTrue(fuzzyBefore(response.getCreated(), now)); assertTrue(fuzzyAfter(response.getCreated(), start)); assertTrue(fuzzyBefore(response.getUpdated(), now)); assertTrue(fuzzyAfter(response.getUpdated(), start)); } catch(Exception ex) { fail(ex.getMessage()); } finally { DeleteDialogNodeOptions deleteOptions = new DeleteDialogNodeOptions.Builder(workspaceId, dialogNodeName).build(); service.deleteDialogNode(deleteOptions).execute(); } } "
    },
    {
        "test_src": "@Test public void list() { query(_FILE_WRITE.args(PATH1, \"abcd\")); error(_FILE_LIST.args(PATH1), Err.FILE_NO_DIR); error(_FILE_LIST.args(PATH1 + NAME), Err.FILE_NOT_FOUND); query(_FILE_WRITE.args(PATH1, \"()\")); error(_FILE_LIST.args(PATH1), Err.FILE_NO_DIR); query(_FILE_LIST.args(PATH), NAME); contains(_FILE_LIST.args(PATH, \"false()\"), NAME); contains(_FILE_LIST.args(PATH, \"false()\", NAME), NAME); query(_FILE_LIST.args(PATH, \"false()\", \"XXX\"), \"\"); query(_FILE_DELETE.args(PATH1)); query(_FILE_CREATE_DIR.args(PATH1)); query(_FILE_CREATE_DIR.args(PATH3)); query(_FILE_WRITE.args(PATH4, \"()\")); contains(_FILE_LIST.args(PATH1, \"true()\"), \"y\"); query(_FILE_LIST.args(PATH1, \"true()\", \"x\"), 'x' + File.separator); } ",
        "focal_tgt": "private Iter list(final QueryContext qc)throws QueryException, IOException { final Path dir = toPath(0, qc).toRealPath(); final boolean rec = optionalBool(1, qc); final Pattern pat = exprs.length == 3 ? Pattern.compile(IOFile.regex(string(toToken(exprs[2], qc))), Prop.CASE ? 0 : Pattern.CASE_INSENSITIVE) : null; final TokenList list = new TokenList(); list(dir.getNameCount(), dir, list, rec, pat); return StrSeq.get(list).iter(); } ",
        "focal_src": "private Iter list(final QueryContext qc)throws QueryException, IOException { final Path dir = checkPath(0, qc).toRealPath(); final boolean rec = optionalBool(1, qc); final Pattern pat = exprs.length == 3 ? Pattern.compile(IOFile.regex(string(checkStr(exprs[2], qc))), Prop.CASE ? 0 : Pattern.CASE_INSENSITIVE) : null; final TokenList list = new TokenList(); list(dir.getNameCount(), dir, list, rec, pat); return StrSeq.get(list).iter(); } ",
        "test_tgt": "@Test public void list() { query(_FILE_WRITE.args(PATH1, \"abcd\")); error(_FILE_LIST.args(PATH1), Err.FILE_NO_DIR_X); error(_FILE_LIST.args(PATH1 + NAME), Err.FILE_NOT_FOUND_X); query(_FILE_WRITE.args(PATH1, \"()\")); error(_FILE_LIST.args(PATH1), Err.FILE_NO_DIR_X); query(_FILE_LIST.args(PATH), NAME); contains(_FILE_LIST.args(PATH, \"false()\"), NAME); contains(_FILE_LIST.args(PATH, \"false()\", NAME), NAME); query(_FILE_LIST.args(PATH, \"false()\", \"XXX\"), \"\"); query(_FILE_DELETE.args(PATH1)); query(_FILE_CREATE_DIR.args(PATH1)); query(_FILE_CREATE_DIR.args(PATH3)); query(_FILE_WRITE.args(PATH4, \"()\")); contains(_FILE_LIST.args(PATH1, \"true()\"), \"y\"); query(_FILE_LIST.args(PATH1, \"true()\", \"x\"), 'x' + File.separator); } "
    },
    {
        "test_src": "@Test public void trigger()throws BaseXException { cs.execute(\"create trigger \" + TRIGGER_NAME); for(int i = ccs.length / 2; i < ccs.length; i ++ ) { ccs[i].attachTrigger(TRIGGER_NAME, new TriggerNotification() { @Override public void update(final String data) { assertEquals(RETURN_VALUE, data); } }); } cs.trigger(\"1 to 10\", TRIGGER_NAME, RETURN_VALUE); for(int i = ccs.length / 2; i < ccs.length; i ++ ) { ccs[i].detachTrigger(TRIGGER_NAME); } cs.execute(\"drop trigger \" + TRIGGER_NAME); } ",
        "focal_tgt": "private Iter trigger(final QueryContext ctx)throws QueryException { String msg = expr[3].toString().equals(\"m\") ? expr[2].toString() : null; Value v = expr[0].value(ctx); if(msg == null) { ctx.updating = true; msg = ItemCache.get(v.iter()).toString(); } ctx.context.triggers.notify(ctx.context.session, expr[1].toString(), msg); return v.iter(); } ",
        "focal_src": "private Iter trigger(final QueryContext ctx)throws QueryException { ctx.updating = true; Value v = expr[0].value(ctx); ctx.context.triggers.notify(ctx.context.session, expr[1].toString(), checkStr(expr[2], ctx)); return v.iter(); } ",
        "test_tgt": "@Test public void trigger()throws BaseXException { cs.execute(\"create trigger \" + TRIGGER_NAME); for(int i = ccs.length / 2; i < ccs.length; i ++ ) { ccs[i].attachTrigger(TRIGGER_NAME, new TriggerEvent() { @Override public void update(final String data) { assertEquals(RETURN_VALUE, data); } }); } cs.trigger(\"1 to 10\", TRIGGER_NAME, RETURN_VALUE, \"m\"); for(int i = ccs.length / 2; i < ccs.length; i ++ ) { ccs[i].detachTrigger(TRIGGER_NAME); } cs.execute(\"drop trigger \" + TRIGGER_NAME); } "
    },
    {
        "test_src": "@Test public void testExtractColumnValues() { TestUtils.log(this.getClass(), \"extractColumnValues\"); RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); Object column = \"height\"; Dataset instance = new Dataset(dbConf); AssociativeArray xData1 = new AssociativeArray(); xData1.put(\"height\", 188.0); xData1.put(\"weight\", 88.0); instance.add(new Record(xData1, null)); AssociativeArray xData2 = new AssociativeArray(); xData2.put(\"height\", 189.0); xData2.put(\"weight\", 89.0); instance.add(new Record(xData2, null)); AssociativeArray xData3 = new AssociativeArray(); xData3.put(\"height\", 190.0); xData3.put(\"weight\", null); instance.add(new Record(xData3, null)); FlatDataList expResult = new FlatDataList(Arrays.asList(new Object[] { 188.0, 189.0, 190.0 })); FlatDataList result = instance.extractColumnValues(column); assertEquals(expResult, result); } ",
        "focal_tgt": "public FlatDataList extractXColumnValues(Object column) { FlatDataList flatDataList = new FlatDataList(); for(Integer rId : this) { Record r = recordList.get(rId); flatDataList.add(r.getX().get(column)); } return flatDataList; } ",
        "focal_src": "public FlatDataList extractColumnValues(Object column) { FlatDataList flatDataList = new FlatDataList(); for(Integer rId : this) { Record r = recordList.get(rId); flatDataList.add(r.getX().get(column)); } return flatDataList; } ",
        "test_tgt": "@Test public void testExtractColumnValues() { TestUtils.log(this.getClass(), \"extractColumnValues\"); RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); Object column = \"height\"; Dataset instance = new Dataset(dbConf); AssociativeArray xData1 = new AssociativeArray(); xData1.put(\"height\", 188.0); xData1.put(\"weight\", 88.0); instance.add(new Record(xData1, null)); AssociativeArray xData2 = new AssociativeArray(); xData2.put(\"height\", 189.0); xData2.put(\"weight\", 89.0); instance.add(new Record(xData2, null)); AssociativeArray xData3 = new AssociativeArray(); xData3.put(\"height\", 190.0); xData3.put(\"weight\", null); instance.add(new Record(xData3, null)); FlatDataList expResult = new FlatDataList(Arrays.asList(new Object[] { 188.0, 189.0, 190.0 })); FlatDataList result = instance.extractXColumnValues(column); assertEquals(expResult, result); } "
    },
    {
        "test_src": "@Test public final void format()throws ParseException { LOGGER.info(MessageFormatUtil.format(\"name=\u5f20\u4e09{0}a{1}\", \"jin\", \"xin\")); LOGGER.info(MessageFormatUtil.format(\"name=\u5f20\u4e09{0,number}a{1}\", 5, \"xin\")); LOGGER.info(MessageFormatUtil.format(\"name=\u5f20\u4e09{0,date}a{1}\", 15, \"xin\")); } ",
        "focal_tgt": "public static String format(Number value, String numberPattern) { RoundingMode roundingMode = RoundingMode.HALF_UP; return format(value, numberPattern, roundingMode); } ",
        "focal_src": "public static String format(Number value, String numberPattern)throws NullPointerException { RoundingMode roundingMode = RoundingMode.HALF_UP; return format(value, numberPattern, roundingMode); } ",
        "test_tgt": "@Test public final void format() { LOGGER.info(MessageFormatUtil.format(\"name=\u5f20\u4e09{0}a{1}\", \"jin\", \"xin\")); LOGGER.info(MessageFormatUtil.format(\"name=\u5f20\u4e09{0,number}a{1}\", 5, \"xin\")); LOGGER.info(MessageFormatUtil.format(\"name=\u5f20\u4e09{0,date}a{1}\", 15, \"xin\")); } "
    },
    {
        "test_src": "@Test public void testGetCache() { Cache cache = cachingService.getCache(\"org.dspace.caching.MemOnly\", null); assertNotNull(cache); assertEquals(\"org.dspace.caching.MemOnly\", cache.getName()); Cache sampleCache = cachingService.getCache(\"org.sakaiproject.caching.test.SampleCache\", null); assertNotNull(sampleCache); assertEquals(\"org.sakaiproject.caching.test.SampleCache\", sampleCache.getName()); Cache c1 = cachingService.getCache(\"org.dspace.aztest\", null); assertNotNull(c1); assertEquals(\"org.dspace.aztest\", c1.getName()); assertEquals(CacheScope.INSTANCE, c1.getConfig().getCacheScope()); assertTrue(c1 instanceof EhcacheCache); Cache rc1 = cachingService.getCache(\"org.dspace.request.cache1\", new CacheConfig(CacheScope.REQUEST)); assertNotNull(rc1); assertEquals(\"org.dspace.request.cache1\", rc1.getName()); assertEquals(CacheScope.REQUEST, rc1.getConfig().getCacheScope()); assertTrue(rc1 instanceof MapCache); Cache c2 = cachingService.getCache(\"org.dspace.aztest\", null); assertNotNull(c2); assertEquals(c1, c2); } ",
        "focal_tgt": "public Cache getCache(String cacheName, CacheConfig cacheConfig) { Cache cache = null; if(cacheName == null || \"\".equals(cacheName)) { throw new IllegalArgumentException(\"cacheName cannot be null or empty string\"); } if(cacheConfig != null && CacheScope.REQUEST.equals(cacheConfig.getCacheScope())) { Map < String, MapCache > caches = getRequestCaches(); if(caches != null) { cache = caches.get(cacheName); } if(cache == null) { cache = instantiateMapCache(cacheName, cacheConfig); } } else { cache = this.cacheRecord.get(cacheName); if(cache == null) { if(getCacheProvider() != null) { try { cache = getCacheProvider().getCache(cacheName, cacheConfig); } catch(Exception e) { log.warn(\"Failure in provider (\" + getCacheProvider() + \"): \" + e.getMessage()); } } } if(cache == null) { cache = instantiateEhCache(cacheName, cacheConfig); } } return cache; } ",
        "focal_src": "public Cache getCache(String cacheName, CacheConfig cacheConfig) { if(cacheName == null || \"\".equals(cacheName)) { throw new IllegalArgumentException(\"cacheName cannot be null or empty string\"); } Cache cache = this.cacheRecord.get(cacheName); if(cache == null) { cache = this.getRequestMap().get(cacheName); } if(getCacheProvider() != null) { if(cache == null && cacheConfig != null && ! CacheScope.REQUEST.equals(cacheConfig.getCacheScope())) { try { cache = getCacheProvider().getCache(cacheName, cacheConfig); } catch(Exception e) { log.warn(\"Failure in provider (\" + getCacheProvider() + \"): \" + e.getMessage()); } } } if(cache == null) { if(cacheConfig != null && CacheScope.REQUEST.equals(cacheConfig.getCacheScope())) { cache = instantiateMapCache(cacheName, cacheConfig); } else { cache = instantiateEhCache(cacheName, cacheConfig); } } return cache; } ",
        "test_tgt": "@Test public void testGetCache() { Cache cache = cachingService.getCache(\"org.dspace.caching.MemOnly\", null); assertNotNull(cache); assertEquals(\"org.dspace.caching.MemOnly\", cache.getName()); Cache sampleCache = cachingService.getCache(\"org.sakaiproject.caching.test.SampleCache\", null); assertNotNull(sampleCache); assertEquals(\"org.sakaiproject.caching.test.SampleCache\", sampleCache.getName()); Cache c1 = cachingService.getCache(\"org.dspace.aztest\", null); assertNotNull(c1); assertEquals(\"org.dspace.aztest\", c1.getName()); assertEquals(CacheScope.INSTANCE, c1.getConfig().getCacheScope()); assertTrue(c1 instanceof EhcacheCache); requestService.startRequest(); Cache rc1 = cachingService.getCache(\"org.dspace.request.cache1\", new CacheConfig(CacheScope.REQUEST)); assertNotNull(rc1); assertEquals(\"org.dspace.request.cache1\", rc1.getName()); assertEquals(CacheScope.REQUEST, rc1.getConfig().getCacheScope()); assertTrue(rc1 instanceof MapCache); requestService.endRequest(null); Cache c2 = cachingService.getCache(\"org.dspace.aztest\", null); assertNotNull(c2); assertEquals(c1, c2); } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void test_withEarlierOffsetAtOverlap() { OffsetDateTime odt = OffsetDateTime.of(2008, 10, 26, 2, 30, OFFSET_0100); ZonedDateTime base = ZonedDateTime.of(odt, ZONE_PARIS); ZonedDateTime test = base.withEarlierOffsetAtOverlap(); assertEquals(test.getOffset(), OFFSET_0200); } ",
        "focal_tgt": "@Override public ChronoZonedDateTime < C > withEarlierOffsetAtOverlap() { ZoneOffsetTransition trans = getZone().getRules().getTransition(LocalDateTime.from(this)); if(trans != null && trans.isOverlap()) { ZoneOffset earlierOffset = trans.getOffsetBefore(); if(earlierOffset.equals(offset) == false) { return new ChronoZonedDateTimeImpl < C > (dateTime, earlierOffset, zoneId); } } return this; } ",
        "focal_src": "@Override public ChronoZonedDateTime < C > withEarlierOffsetAtOverlap() { ZoneOffsetTransition trans = getZone().getRules().getTransition(LocalDateTime.from(this)); if(trans != null) { ZoneOffset offset = trans.getOffsetBefore(); if(offset.equals(getOffset()) == false) { ChronoOffsetDateTimeImpl < C > newDT = dateTime.withOffsetSameLocal(offset); return new ChronoZonedDateTimeImpl < C > (newDT, zone); } } return this; } ",
        "test_tgt": "@Test(groups = { \"tck\" })public void test_withEarlierOffsetAtOverlap() { ZonedDateTime base = ZonedDateTime.ofStrict(TEST_PARIS_OVERLAP_2008_10_26_02_30, OFFSET_0100, ZONE_PARIS); ZonedDateTime test = base.withEarlierOffsetAtOverlap(); assertEquals(test.getOffset(), OFFSET_0200); assertEquals(test.getDateTime(), base.getDateTime()); } "
    },
    {
        "test_src": "@Test public void testGetDocumentProcessingState() { Map < String, Object > params = new HashMap < String, Object > (); params.put(ConceptInsights.ACCOUNT_ID, \"public\"); params.put(ConceptInsights.CORPUS, \"ibmresearcher\"); params.put(ConceptInsights.DOCUMENT, \"il-AHARONA\"); DocumentProcessingStatus documentProcessingState = service.getDocumentProcessingState(\"public\", \"ibmresearcher\", \"il-AHARONA\"); Assert.assertNotNull(documentProcessingState); } ",
        "focal_tgt": "public DocumentProcessingStatus getDocumentProcessingState(final Document document) { String documentId = IDValidator.getDocumentId(document); return executeRequest(API_VERSION + documentId + PROCESSING_STATE_PATH, null, DocumentProcessingStatus.class); } ",
        "focal_src": "public DocumentProcessingStatus getDocumentProcessingState(final Document document, final String corpusName) { ConceptInsightsId.validateGenarate(document, getAccountId(), corpusName); return executeRequest(version + document.getId() + PROCESSING_STATE_PATH, null, DocumentProcessingStatus.class); } ",
        "test_tgt": "@Test public void testGetDocumentProcessingState() { DocumentProcessingStatus documentProcessingState = service.getDocumentProcessingState(EXAMPLE_DOCUMENT); Assert.assertNotNull(documentProcessingState); } "
    },
    {
        "test_src": "@Test public void testStartGatewayReceiver_MultipleGroup() { VM puneLocator = Host.getLocator(); int punePort = (Integer)puneLocator.invoke(() -> getLocatorPort()); Properties props = getDistributedSystemProperties(); props.setProperty(MCAST_PORT, \"0\"); props.setProperty(LOCATORS, \"localhost[\" + punePort + \"]\"); setUpJmxManagerOnVm0ThenConnect(props); Integer nyPort = (Integer)vm2.invoke(() -> createFirstRemoteLocator(2, punePort)); vm3.invoke(() -> createReceiverWithGroup(punePort, \"RG1\")); vm4.invoke(() -> createReceiverWithGroup(punePort, \"RG1\")); vm5.invoke(() -> createReceiverWithGroup(punePort, \"RG1, RG2\")); vm6.invoke(() -> createReceiverWithGroup(punePort, \"RG1, RG2\")); vm7.invoke(() -> createReceiverWithGroup(punePort, \"RG3\")); vm3.invoke(() -> verifyReceiverState(false)); vm4.invoke(() -> verifyReceiverState(false)); vm5.invoke(() -> verifyReceiverState(false)); vm6.invoke(() -> verifyReceiverState(false)); vm7.invoke(() -> verifyReceiverState(false)); pause(10000); String command = CliStrings.START_GATEWAYRECEIVER + \" --\" + CliStrings.START_GATEWAYRECEIVER__GROUP + \"=RG1,RG2\"; CommandResult cmdResult = executeCommand(command); if(cmdResult != null) { String strCmdResult = commandResultToString(cmdResult); getLogWriter().info(\"testStartGatewayReceiver_Group stringResult : \" + strCmdResult + \">>>>\"); assertEquals(Result.Status.OK, cmdResult.getStatus()); TabularResultData resultData = (TabularResultData)cmdResult.getResultData(); List < String > status = resultData.retrieveAllValues(\"Result\"); assertEquals(4, status.size()); assertFalse(status.contains(\"Error\")); assertTrue(status.contains(\"OK\")); } else { fail(\"testStartGatewayReceiver failed as did not get CommandResult\"); } vm3.invoke(() -> verifyReceiverState(true)); vm4.invoke(() -> verifyReceiverState(true)); vm5.invoke(() -> verifyReceiverState(true)); vm6.invoke(() -> verifyReceiverState(true)); vm7.invoke(() -> verifyReceiverState(false)); } ",
        "focal_tgt": "@RequestMapping(method = RequestMethod.POST, value = \"/gateways/receivers\", params = \"op=start\")@ResponseBody public String startGatewayReceiver(@RequestParam(value = CliStrings.GROUP, required = false)final String[]groups, @RequestParam(value = CliStrings.MEMBER, required = false)final String[]members) { CommandStringBuilder command = new CommandStringBuilder(CliStrings.START_GATEWAYRECEIVER); if(hasValue(groups)) { command.addOption(CliStrings.GROUP, StringUtils.join(groups, StringUtils.COMMA_DELIMITER)); } if(hasValue(members)) { command.addOption(CliStrings.MEMBER, StringUtils.join(members, StringUtils.COMMA_DELIMITER)); } return processCommand(command.toString()); } ",
        "focal_src": "@RequestMapping(method = RequestMethod.POST, value = \"/gateways/receivers\", params = \"op=start\")@ResponseBody public String startGatewayReceiver(@RequestParam(value = CliStrings.START_GATEWAYRECEIVER__GROUP, required = false)final String[]groups, @RequestParam(value = CliStrings.START_GATEWAYRECEIVER__MEMBER, required = false)final String[]members) { CommandStringBuilder command = new CommandStringBuilder(CliStrings.START_GATEWAYRECEIVER); if(hasValue(groups)) { command.addOption(CliStrings.START_GATEWAYRECEIVER__GROUP, StringUtils.join(groups, StringUtils.COMMA_DELIMITER)); } if(hasValue(members)) { command.addOption(CliStrings.START_GATEWAYRECEIVER__MEMBER, StringUtils.join(members, StringUtils.COMMA_DELIMITER)); } return processCommand(command.toString()); } ",
        "test_tgt": "@Test public void testStartGatewayReceiver_MultipleGroup() { VM puneLocator = Host.getLocator(); int punePort = puneLocator.invoke(() -> getLocatorPort()); Properties props = getDistributedSystemProperties(); props.setProperty(MCAST_PORT, \"0\"); props.setProperty(LOCATORS, \"localhost[\" + punePort + \"]\"); setUpJmxManagerOnVm0ThenConnect(props); Integer nyPort = vm2.invoke(() -> createFirstRemoteLocator(2, punePort)); vm3.invoke(() -> createReceiverWithGroup(punePort, \"RG1\")); vm4.invoke(() -> createReceiverWithGroup(punePort, \"RG1\")); vm5.invoke(() -> createReceiverWithGroup(punePort, \"RG1, RG2\")); vm6.invoke(() -> createReceiverWithGroup(punePort, \"RG1, RG2\")); vm7.invoke(() -> createReceiverWithGroup(punePort, \"RG3\")); vm3.invoke(() -> verifyReceiverState(false)); vm4.invoke(() -> verifyReceiverState(false)); vm5.invoke(() -> verifyReceiverState(false)); vm6.invoke(() -> verifyReceiverState(false)); vm7.invoke(() -> verifyReceiverState(false)); pause(10000); String command = CliStrings.START_GATEWAYRECEIVER + \" --\" + CliStrings.GROUP + \"=RG1,RG2\"; CommandResult cmdResult = executeCommand(command); if(cmdResult != null) { String strCmdResult = commandResultToString(cmdResult); getLogWriter().info(\"testStartGatewayReceiver_Group stringResult : \" + strCmdResult + \">>>>\"); assertEquals(Result.Status.OK, cmdResult.getStatus()); TabularResultData resultData = (TabularResultData)cmdResult.getResultData(); List < String > status = resultData.retrieveAllValues(\"Result\"); assertEquals(4, status.size()); assertFalse(status.contains(\"Error\")); assertTrue(status.contains(\"OK\")); } else { fail(\"testStartGatewayReceiver failed as did not get CommandResult\"); } vm3.invoke(() -> verifyReceiverState(true)); vm4.invoke(() -> verifyReceiverState(true)); vm5.invoke(() -> verifyReceiverState(true)); vm6.invoke(() -> verifyReceiverState(true)); vm7.invoke(() -> verifyReceiverState(false)); } "
    },
    {
        "test_src": "@Test public void testAddTripParameters() { TripParameters tp = new TripParameters(); tp.addToAllowed_modes(TravelMode.WALK); tp.addToAllowed_modes(TravelMode.CAR); LatLng originLatLng = new LatLng(1.0, 2.5); Location origin = new Location(originLatLng); LatLng destLatLng = new LatLng( - 3.0, 9.7); Location dest = new Location(destLatLng); tp.setOrigin(origin); tp.setDestination(dest); RoutingRequest rr = (new RoutingRequestBuilder()).addTripParameters(tp).build(); assertEquals(\"1.0000000,2.5000000\", rr.getFrom()); assertEquals(\"-3.0000000,9.7000000\", rr.getTo()); for(TravelMode tm : tp.getAllowed_modes()) { TraverseModeSet modeSet = rr.getModes(); TraverseMode traverseMode = (new TravelModeWrapper(tm)).toTraverseMode(); assertTrue(modeSet.contains(traverseMode)); } } ",
        "focal_tgt": "public RoutingRequestBuilder addTripParameters(TripParameters tripParams) { if(tripParams.isSetAllowed_modes()) { Set < TravelMode > allowedModes = tripParams.getAllowed_modes(); setTravelModes(new TravelModeSet(allowedModes)); } if(tripParams.isSetStart_time()) { setStartTime(tripParams.getStart_time()); } else if(tripParams.isSetArrive_by()) { setArriveBy(tripParams.getArrive_by()); } setOrigin(tripParams.getOrigin().getLat_lng()); setDestination(tripParams.getDestination().getLat_lng()); return this; } ",
        "focal_src": "public RoutingRequestBuilder addTripParameters(TripParameters tripParams) { if(tripParams.isSetAllowed_modes()) { Set < TravelMode > allowedModes = tripParams.getAllowed_modes(); setTravelModes(new TravelModeSet(allowedModes)); } setOrigin(tripParams.getOrigin().getLat_lng()); setDestination(tripParams.getDestination().getLat_lng()); return this; } ",
        "test_tgt": "@Test public void testAddTripParameters() { TripParameters tp = new TripParameters(); tp.addToAllowed_modes(TravelMode.WALK); tp.addToAllowed_modes(TravelMode.CAR); LatLng originLatLng = new LatLng(1.0, 2.5); Location origin = new Location(); origin.setLat_lng(originLatLng); LatLng destLatLng = new LatLng( - 3.0, 9.7); Location dest = new Location(); dest.setLat_lng(destLatLng); tp.setOrigin(origin); tp.setDestination(dest); RoutingRequest rr = (new RoutingRequestBuilder()).addTripParameters(tp).build(); assertEquals(\"1.0000000,2.5000000\", rr.getFrom()); assertEquals(\"-3.0000000,9.7000000\", rr.getTo()); for(TravelMode tm : tp.getAllowed_modes()) { TraverseModeSet modeSet = rr.getModes(); TraverseMode traverseMode = (new TravelModeWrapper(tm)).toTraverseMode(); assertTrue(modeSet.contains(traverseMode)); } } "
    },
    {
        "test_src": "@Test public void testPutValues_VarArgs() { MultiMap mm = new MultiMap(); String key = \"formats\"; mm.putValues(key, \"gzip\", \"jar\", \"pack200\"); assertMapSize(mm, 1); assertValues(mm, key, \"gzip\", \"jar\", \"pack200\"); } ",
        "focal_tgt": "@SafeVarargs public final List < V > putValues(String name, V ... values) { List < V > list = new ArrayList < > (); list.addAll(Arrays.asList(values)); return super.put(name, list); } ",
        "focal_src": "public Object putValues(String name, String ... values) { Object list = null; for(int i = 0; i < values.length; i ++ )list = LazyList.add(list, values[i]); return put(name, list); } ",
        "test_tgt": "@Test public void testPutValues_VarArgs() { MultiMap < String > mm = new MultiMap < > (); String key = \"formats\"; mm.putValues(key, \"gzip\", \"jar\", \"pack200\"); assertMapSize(mm, 1); assertValues(mm, key, \"gzip\", \"jar\", \"pack200\"); } "
    },
    {
        "test_src": "@Test public void testInitialize() { Weld weld = new Weld().initialize(); MainTestBean mainTestBean = weld.instance().select(MainTestBean.class).get(); Assert.assertNotNull(mainTestBean); ParametersTestBean paramsBean = mainTestBean.getParametersTestBean(); Assert.assertNotNull(paramsBean); Assert.assertNotNull(paramsBean.getParameters()); shutdownManager(weld.getBeanManager()); } ",
        "focal_tgt": "public WeldContainer initialize() { SEWeldDeployment deployment = new SEWeldDeployment() { }; bootstrap.startContainer(Environments.SE, deployment, this.applicationBeanStore); final BeanDeploymentArchive mainBeanDepArch = deployment.getBeanDeploymentArchives().get(0); this.manager = bootstrap.getManager(mainBeanDepArch); bootstrap.startInitialization(); bootstrap.deployBeans(); WeldManagerUtils.getInstanceByType(manager, ShutdownManager.class).setBootstrap(bootstrap); bootstrap.validateBeans(); bootstrap.endInitialization(); InstanceManager instanceManager = WeldManagerUtils.getInstanceByType(manager, InstanceManager.class); return new WeldContainer(instanceManager, manager); } ",
        "focal_src": "public Weld initialize() { SEWeldDeployment deployment = new SEWeldDeployment() { }; bootstrap.startContainer(Environments.SE, deployment, this.applicationBeanStore); final BeanDeploymentArchive mainBeanDepArch = deployment.getBeanDeploymentArchives().get(0); this.manager = bootstrap.getManager(mainBeanDepArch); bootstrap.startInitialization(); bootstrap.deployBeans(); WeldManagerUtils.getInstanceByType(manager, ShutdownManager.class).setBootstrap(bootstrap); bootstrap.validateBeans(); bootstrap.endInitialization(); instanceManager = WeldManagerUtils.getInstanceByType(manager, InstanceManager.class); return this; } ",
        "test_tgt": "@Test public void testInitialize() { WeldContainer weld = new Weld().initialize(); MainTestBean mainTestBean = weld.instance().select(MainTestBean.class).get(); Assert.assertNotNull(mainTestBean); ParametersTestBean paramsBean = mainTestBean.getParametersTestBean(); Assert.assertNotNull(paramsBean); Assert.assertNotNull(paramsBean.getParameters()); shutdownManager(weld.getBeanManager()); } "
    },
    {
        "test_src": "@Test(description = \"PUT /vApp/{id}/media/action/insertMedia\", dependsOnMethods = { \"testGetVm\" })public void testInsertMedia() { MediaInsertOrEjectParams params = MediaInsertOrEjectParams.builder().media(Reference.builder().href(mediaURI).type(MEDIA).build()).build(); Task insertMedia = vmApi.insertMedia(vm.getHref(), params); assertTrue(retryTaskSuccess.apply(insertMedia), String.format(TASK_COMPLETE_TIMELY, \"insertMedia\")); } ",
        "focal_tgt": "Task insertMedia(URI vmHref, MediaInsertOrEjectParams mediaParams); ",
        "focal_src": "Task insertMedia(URI vmURI, MediaInsertOrEjectParams mediaParams); ",
        "test_tgt": "@Test(description = \"PUT /vApp/{id}/media/action/insertMedia\", dependsOnMethods = { \"testGetVm\" })public void testInsertMedia() { MediaInsertOrEjectParams params = MediaInsertOrEjectParams.builder().media(Reference.builder().href(mediaURI).type(MEDIA).build()).build(); Task insertMedia = vmApi.insertMedia(vmUrn, params); assertTrue(retryTaskSuccess.apply(insertMedia), String.format(TASK_COMPLETE_TIMELY, \"insertMedia\")); } "
    },
    {
        "test_src": "@Test public void testGetInput() { final Operator input1 = new OpImpl(0); final Operator input2 = new OpImpl(1); final Operator fixture = new OpImpl(0).withInputs(input1, input2); assertSame(input1.getOutput(0), fixture.getInput(0)); assertSame(input2.getOutput(0), fixture.getInput(1)); } ",
        "focal_tgt": "public Operator < ? > .Output getInput(final int index) { return this.inputs.get(index); } ",
        "focal_src": "public Output getInput(final int index) { return this.inputs.get(index); } ",
        "test_tgt": "@Test public void testGetInput() { final Operator < ? > input1 = new OpImpl(0); final Operator < ? > input2 = new OpImpl(1); final Operator < ? > fixture = new OpImpl(0).withInputs(input1, input2); assertSame(input1.getOutput(0), fixture.getInput(0)); assertSame(input2.getOutput(0), fixture.getInput(1)); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should pass if the concept has atleast one fully specified name added to it\", method = \"validate(Object,Errors)\")public void validate_shouldPassIfTheConceptHasAtleastOneFullySpecifiedNameAddedToIt()throws Exception { Concept concept = new Concept(); concept.addName(new ConceptName(\"one name\", Context.getLocale())); Errors errors = new BindException(concept, \"concept\"); new ConceptValidator().validate(concept, errors); Assert.assertEquals(false, errors.hasErrors()); } ",
        "focal_tgt": "public void validate(Object obj, Errors errors)throws APIException, DuplicateConceptNameException { if(obj == null || ! (obj instanceof Concept)) { throw new IllegalArgumentException(\"The parameter obj should not be null and must be of type\" + Concept.class); } Concept conceptToValidate = (Concept)obj; if(conceptToValidate.getNames().size() == 0) { errors.reject(\"Concept.name.atLeastOneRequired\"); return; } ValidationUtils.rejectIfEmpty(errors, \"datatype\", \"Concept.datatype.empty\"); ValidationUtils.rejectIfEmpty(errors, \"conceptClass\", \"Concept.conceptClass.empty\"); boolean hasFullySpecifiedName = false; for(Locale conceptNameLocale : conceptToValidate.getAllConceptNameLocales()) { boolean fullySpecifiedNameForLocaleFound = false; boolean preferredNameForLocaleFound = false; boolean shortNameForLocaleFound = false; Set < String > validNamesFoundInLocale = new HashSet < String > (); Collection < ConceptName > namesInLocale = conceptToValidate.getNames(conceptNameLocale); for(ConceptName nameInLocale : namesInLocale) { if(StringUtils.isBlank(nameInLocale.getName())) { log.debug(\"Name in locale '\" + conceptNameLocale.toString() + \"' cannot be an empty string or white space\"); errors.reject(\"Concept.name.empty\"); } if(nameInLocale.isLocalePreferred() != null) { if(nameInLocale.isLocalePreferred() && ! preferredNameForLocaleFound) { if(nameInLocale.isIndexTerm()) { log.warn(\"Preferred name in locale '\" + conceptNameLocale.toString() + \"' shouldn't be an index term\"); errors.reject(\"Concept.error.preferredName.is.indexTerm\"); } else if(nameInLocale.isShort()) { log.warn(\"Preferred name in locale '\" + conceptNameLocale.toString() + \"' shouldn't be a short name\"); errors.reject(\"Concept.error.preferredName.is.shortName\"); } else if(nameInLocale.isVoided()) { log.warn(\"Preferred name in locale '\" + conceptNameLocale.toString() + \"' shouldn't be a voided name\"); errors.reject(\"Concept.error.preferredName.is.voided\"); } preferredNameForLocaleFound = true; } else if(nameInLocale.isLocalePreferred() && preferredNameForLocaleFound) { log.warn(\"Found multiple preferred names in locale '\" + conceptNameLocale.toString() + \"'\"); errors.reject(\"Concept.error.multipleLocalePreferredNames\"); } } if(nameInLocale.isFullySpecifiedName()) { if( ! hasFullySpecifiedName) { hasFullySpecifiedName = true; } if( ! fullySpecifiedNameForLocaleFound) { fullySpecifiedNameForLocaleFound = true; } else { log.warn(\"Found multiple fully specified names in locale '\" + conceptNameLocale.toString() + \"'\"); errors.reject(\"Concept.error.multipleFullySpecifiedNames\"); } if(nameInLocale.isVoided()) { log.warn(\"Fully Specified name in locale '\" + conceptNameLocale.toString() + \"' shouldn't be a voided name\"); errors.reject(\"Concept.error.fullySpecifiedName.is.voided\"); } } if(nameInLocale.isShort()) { if( ! shortNameForLocaleFound) { shortNameForLocaleFound = true; } else { log.warn(\"Found multiple short names in locale '\" + conceptNameLocale.toString() + \"'\"); errors.reject(\"Concept.error.multipleShortNames\"); } } if(Context.getConceptService().isConceptNameDuplicate(nameInLocale)) { throw new DuplicateConceptNameException(\"'\" + nameInLocale.getName() + \"' is a duplicate name in locale '\" + conceptNameLocale.toString() + \"'\"); } if(errors.hasErrors()) { log.debug(\"Concept name '\" + nameInLocale.getName() + \"' for locale '\" + conceptNameLocale + \"' is invalid\"); return; } if( ! nameInLocale.isShort()) { if( ! validNamesFoundInLocale.add(nameInLocale.getName().toLowerCase())) { throw new DuplicateConceptNameException(\"'\" + nameInLocale.getName() + \"' is a duplicate name in locale '\" + conceptNameLocale.toString() + \"' for the same concept\"); } } if(log.isDebugEnabled()) { log.debug(\"Valid name found: \" + nameInLocale.getName()); } } } if( ! hasFullySpecifiedName) { log.debug(\"Concept has no fully specified name\"); errors.reject(\"Concept.error.no.FullySpecifiedName\"); } if(CollectionUtils.isNotEmpty(conceptToValidate.getConceptMappings())) { int index = 0; Set < Integer > mappedTermIds = null; for(ConceptMap map : conceptToValidate.getConceptMappings()) { if(map.getConceptReferenceTerm().getConceptReferenceTermId() == null) { try { errors.pushNestedPath(\"conceptMappings[\" + index + \"].conceptReferenceTerm\"); ValidationUtils.invokeValidator(new ConceptReferenceTermValidator(), map.getConceptReferenceTerm(), errors); } finally { errors.popNestedPath(); } } if(errors.hasErrors()) { return; } if(mappedTermIds == null) { mappedTermIds = new HashSet < Integer > (); } if(map.getConceptReferenceTerm().getId() != null) { if( ! mappedTermIds.add(map.getConceptReferenceTerm().getId())) { errors.rejectValue(\"conceptMappings[\" + index + \"]\", \"ConceptReferenceTerm.term.alreadyMapped\", \"Cannot map a reference term multiple times to the same concept\"); } } index ++ ; } } } ",
        "focal_src": "public void validate(Object obj, Errors errors)throws APIException, DuplicateConceptNameException { if(obj == null || ! (obj instanceof Concept)) { throw new IllegalArgumentException(\"The parameter obj should not be null and must be of type\" + Concept.class); } Concept conceptToValidate = (Concept)obj; if(conceptToValidate.getNames().size() == 0) { errors.reject(\"Concept.name.atLeastOneRequired\"); return; } boolean hasFullySpecifiedName = false; for(Locale conceptNameLocale : conceptToValidate.getAllConceptNameLocales()) { boolean fullySpecifiedNameForLocaleFound = false; boolean preferredNameForLocaleFound = false; boolean shortNameForLocaleFound = false; Set < String > validNamesFoundInLocale = new HashSet < String > (); Collection < ConceptName > namesInLocale = conceptToValidate.getNames(conceptNameLocale); for(ConceptName nameInLocale : namesInLocale) { if(StringUtils.isBlank(nameInLocale.getName())) { log.debug(\"Name in locale '\" + conceptNameLocale.toString() + \"' cannot be an empty string or white space\"); errors.reject(\"Concept.name.empty\"); } if(nameInLocale.isLocalePreferred() != null) { if(nameInLocale.isLocalePreferred() && ! preferredNameForLocaleFound) { if(nameInLocale.isIndexTerm()) { log.warn(\"Preferred name in locale '\" + conceptNameLocale.toString() + \"' shouldn't be an index term\"); errors.reject(\"Concept.error.preferredName.is.indexTerm\"); } else if(nameInLocale.isShort()) { log.warn(\"Preferred name in locale '\" + conceptNameLocale.toString() + \"' shouldn't be a short name\"); errors.reject(\"Concept.error.preferredName.is.shortName\"); } else if(nameInLocale.isVoided()) { log.warn(\"Preferred name in locale '\" + conceptNameLocale.toString() + \"' shouldn't be a voided name\"); errors.reject(\"Concept.error.preferredName.is.voided\"); } preferredNameForLocaleFound = true; } else if(nameInLocale.isLocalePreferred() && preferredNameForLocaleFound) { log.warn(\"Found multiple preferred names in locale '\" + conceptNameLocale.toString() + \"'\"); errors.reject(\"Concept.error.multipleLocalePreferredNames\"); } } if(nameInLocale.isFullySpecifiedName()) { if( ! hasFullySpecifiedName) { hasFullySpecifiedName = true; } if( ! fullySpecifiedNameForLocaleFound) { fullySpecifiedNameForLocaleFound = true; } else { log.warn(\"Found multiple fully specified names in locale '\" + conceptNameLocale.toString() + \"'\"); errors.reject(\"Concept.error.multipleFullySpecifiedNames\"); } if(nameInLocale.isVoided()) { log.warn(\"Fully Specified name in locale '\" + conceptNameLocale.toString() + \"' shouldn't be a voided name\"); errors.reject(\"Concept.error.fullySpecifiedName.is.voided\"); } } if(nameInLocale.isShort()) { if( ! shortNameForLocaleFound) { shortNameForLocaleFound = true; } else { log.warn(\"Found multiple short names in locale '\" + conceptNameLocale.toString() + \"'\"); errors.reject(\"Concept.error.multipleShortNames\"); } } if(Context.getConceptService().isConceptNameDuplicate(nameInLocale)) { throw new DuplicateConceptNameException(\"'\" + nameInLocale.getName() + \"' is a duplicate name in locale '\" + conceptNameLocale.toString() + \"'\"); } if(errors.hasErrors()) { log.debug(\"Concept name '\" + nameInLocale.getName() + \"' for locale '\" + conceptNameLocale + \"' is invalid\"); return; } if( ! nameInLocale.isShort()) { if( ! validNamesFoundInLocale.add(nameInLocale.getName().toLowerCase())) { throw new DuplicateConceptNameException(\"'\" + nameInLocale.getName() + \"' is a duplicate name in locale '\" + conceptNameLocale.toString() + \"' for the same concept\"); } } if(log.isDebugEnabled()) { log.debug(\"Valid name found: \" + nameInLocale.getName()); } } } if( ! hasFullySpecifiedName) { log.debug(\"Concept has no fully specified name\"); errors.reject(\"Concept.error.no.FullySpecifiedName\"); } if(CollectionUtils.isNotEmpty(conceptToValidate.getConceptMappings())) { int index = 0; Set < Integer > mappedTermIds = null; for(ConceptMap map : conceptToValidate.getConceptMappings()) { if(map.getConceptReferenceTerm().getConceptReferenceTermId() == null) { try { errors.pushNestedPath(\"conceptMappings[\" + index + \"].conceptReferenceTerm\"); ValidationUtils.invokeValidator(new ConceptReferenceTermValidator(), map.getConceptReferenceTerm(), errors); } finally { errors.popNestedPath(); } } if(errors.hasErrors()) { return; } if(mappedTermIds == null) { mappedTermIds = new HashSet < Integer > (); } if(map.getConceptReferenceTerm().getId() != null) { if( ! mappedTermIds.add(map.getConceptReferenceTerm().getId())) { errors.rejectValue(\"conceptMappings[\" + index + \"]\", \"ConceptReferenceTerm.term.alreadyMapped\", \"Cannot map a reference term multiple times to the same concept\"); } } index ++ ; } } } ",
        "test_tgt": "@Test@Verifies(value = \"should pass if the concept has atleast one fully specified name added to it\", method = \"validate(Object,Errors)\")public void validate_shouldPassIfTheConceptHasAtleastOneFullySpecifiedNameAddedToIt()throws Exception { Concept concept = new Concept(); concept.addName(new ConceptName(\"one name\", Context.getLocale())); concept.setConceptClass(new ConceptClass()); concept.setDatatype(new ConceptDatatype()); Errors errors = new BindException(concept, \"concept\"); new ConceptValidator().validate(concept, errors); Assert.assertEquals(false, errors.hasErrors()); } "
    },
    {
        "test_src": "@Test public void testCompletion_object()throws Exception { ICompilationUnit unit = getWorkingCopy(\"src/java/Foo.java\", \"public class Foo {\\n\" + \" void foo() {\\n\" + \" Objec\\n\" + \" }\\n\" + \"}\\n\"); int[]loc = findCompletionLocation(unit, \"Objec\"); CompletionList list = server.completion(JsonMessageHelper.getParams(createCompletionRequest(unit, loc[0], loc[1]))).join().getRight(); assertNotNull(list); assertFalse(\"No proposals were found\", list.getItems().isEmpty()); List < CompletionItem > items = list.getItems(); for(CompletionItem item : items) { assertTrue(isNotBlank(item.getLabel())); assertNotNull(item.getKind()); assertTrue(isNotBlank(item.getSortText())); assertNull(item.getTextEdit()); assertTrue(isNotBlank(item.getInsertText())); assertNotNull(item.getFilterText()); assertFalse(item.getFilterText().contains(\" \")); assertTrue(item.getLabel().startsWith(item.getFilterText())); @SuppressWarnings(\"unchecked\")Map < String, String > data = (Map < String, String > )item.getData(); assertNotNull(data); assertTrue(isNotBlank(data.get(CompletionResolveHandler.DATA_FIELD_URI))); assertTrue(isNotBlank(data.get(CompletionResolveHandler.DATA_FIELD_PROPOSAL_ID))); assertTrue(isNotBlank(data.get(CompletionResolveHandler.DATA_FIELD_REQUEST_ID))); } } ",
        "focal_tgt": "@Override public CompletableFuture < Either < List < CompletionItem > , CompletionList > > completion(CompletionParams position) { logInfo(\">> document/completion\"); CompletionHandler handler = new CompletionHandler(preferenceManager); final IProgressMonitor[]monitors = new IProgressMonitor[1]; CompletableFuture < Either < List < CompletionItem > , CompletionList > > result = computeAsync((monitor) -> { monitors[0] = monitor; if(Boolean.getBoolean(JAVA_LSP_JOIN_ON_COMPLETION)) { waitForLifecycleJobs(monitor); } return handler.completion(position, monitor); }); result.join(); if(monitors[0].isCanceled()) { result.cancel(true); } return result; } ",
        "focal_src": "@Override public CompletableFuture < Either < List < CompletionItem > , CompletionList > > completion(CompletionParams position) { logInfo(\">> document/completion\"); CompletionHandler handler = new CompletionHandler(); final IProgressMonitor[]monitors = new IProgressMonitor[1]; CompletableFuture < Either < List < CompletionItem > , CompletionList > > result = computeAsync((monitor) -> { monitors[0] = monitor; if(Boolean.getBoolean(JAVA_LSP_JOIN_ON_COMPLETION)) { waitForLifecycleJobs(monitor); } return handler.completion(position, monitor); }); result.join(); if(monitors[0].isCanceled()) { result.cancel(true); } return result; } ",
        "test_tgt": "@Test public void testCompletion_object()throws Exception { ICompilationUnit unit = getWorkingCopy(\"src/java/Foo.java\", \"public class Foo {\\n\" + \" void foo() {\\n\" + \" Objec\\n\" + \" }\\n\" + \"}\\n\"); int[]loc = findCompletionLocation(unit, \"Objec\"); CompletionList list = server.completion(JsonMessageHelper.getParams(createCompletionRequest(unit, loc[0], loc[1]))).join().getRight(); assertNotNull(list); assertFalse(\"No proposals were found\", list.getItems().isEmpty()); List < CompletionItem > items = list.getItems(); for(CompletionItem item : items) { assertTrue(isNotBlank(item.getLabel())); assertNotNull(item.getKind()); assertTrue(isNotBlank(item.getSortText())); assertNotNull(item.getTextEdit()); assertTrue(isNotBlank(item.getInsertText())); assertNotNull(item.getFilterText()); assertFalse(item.getFilterText().contains(\" \")); assertTrue(item.getLabel().startsWith(item.getFilterText())); @SuppressWarnings(\"unchecked\")Map < String, String > data = (Map < String, String > )item.getData(); assertNotNull(data); assertTrue(isNotBlank(data.get(CompletionResolveHandler.DATA_FIELD_URI))); assertTrue(isNotBlank(data.get(CompletionResolveHandler.DATA_FIELD_PROPOSAL_ID))); assertTrue(isNotBlank(data.get(CompletionResolveHandler.DATA_FIELD_REQUEST_ID))); } } "
    },
    {
        "test_src": "@Test public void noProxySelected() { when(proxySelector.select(argThat(u -> u.getHost().equals(HOSTNAME)))).thenReturn(Collections.singletonList(PROXY)); final WebSocketsProxyConnectionHandler handler = new WebSocketsProxyConnectionHandler(CONNECTION_ID, HOSTNAME, PROXY_CONFIGURATION); Assert.assertEquals(PROXY_ADDRESS.getHostName(), handler.getHostname()); Assert.assertEquals(PROXY_ADDRESS.getPort(), handler.getProtocolPort()); } ",
        "focal_tgt": "@ParameterizedTest@MethodSource(\"getProxyConfigurations\")public void noProxySelected(ProxyConfiguration configuration) { final String hostname = \"foo.eventhubs.azure.com\"; when(proxySelector.select(argThat(u -> u.getHost().equals(hostname)))).thenReturn(Collections.singletonList(PROXY)); final ConnectionHandler handler = provider.createConnectionHandler(CONNECTION_ID, hostname, TransportType.AMQP_WEB_SOCKETS, configuration); Assertions.assertEquals(PROXY_ADDRESS.getHostName(), handler.getHostname()); Assertions.assertEquals(PROXY_ADDRESS.getPort(), handler.getProtocolPort()); } ",
        "focal_src": "@Theory public void noProxySelected(@FromDataPoints(\"configurations\")ProxyConfiguration configuration) { final String hostname = \"foo.eventhubs.azure.com\"; when(proxySelector.select(argThat(u -> u.getHost().equals(hostname)))).thenReturn(Collections.singletonList(PROXY)); final ConnectionHandler handler = provider.createConnectionHandler(CONNECTION_ID, hostname, TransportType.AMQP_WEB_SOCKETS, configuration); Assert.assertEquals(PROXY_ADDRESS.getHostName(), handler.getHostname()); Assert.assertEquals(PROXY_ADDRESS.getPort(), handler.getProtocolPort()); } ",
        "test_tgt": "@Test public void noProxySelected() { when(proxySelector.select(argThat(u -> u.getHost().equals(HOSTNAME)))).thenReturn(Collections.singletonList(PROXY)); final WebSocketsProxyConnectionHandler handler = new WebSocketsProxyConnectionHandler(CONNECTION_ID, HOSTNAME, PROXY_CONFIGURATION); Assertions.assertEquals(PROXY_ADDRESS.getHostName(), handler.getHostname()); Assertions.assertEquals(PROXY_ADDRESS.getPort(), handler.getProtocolPort()); } "
    },
    {
        "test_src": "@Test public void fullView() { IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05); PointTransform_F32 adjusted = LensDistortionOps.fullView(param, null, true); checkBorderOutside(adjusted); param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial( - 0.1, - 0.05); adjusted = LensDistortionOps.fullView(param, null, true); checkBorderOutside(adjusted); } ",
        "focal_tgt": "public static PointTransform_F32 fullView(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean adjToDistorted) { PointTransform_F32 remove_p_to_p = distortTransform(param).undistort_F32(true, true); RectangleLength2D_F32 bound = DistortImageOps.boundBox_F32(param.width, param.height, new PointToPixelTransform_F32(remove_p_to_p)); double scaleX = bound.width / param.width; double scaleY = bound.height / param.height; double scale = Math.max(scaleX, scaleY); double deltaX = bound.x0; double deltaY = bound.y0; DenseMatrix64F A = new DenseMatrix64F(3, 3, true, scale, 0, deltaX, 0, scale, deltaY, 0, 0, 1); return adjustmentTransform(param, paramAdj, adjToDistorted, remove_p_to_p, A); } ",
        "focal_src": "public static PointTransform_F32 fullView(IntrinsicParameters param, IntrinsicParameters paramAdj, boolean inputUndistorted) { PointTransform_F32 remove_p_to_p = distortTransform(param).undistort_F32(true, true); RectangleLength2D_F32 bound = DistortImageOps.boundBox_F32(param.width, param.height, new PointToPixelTransform_F32(remove_p_to_p)); double scaleX = bound.width / param.width; double scaleY = bound.height / param.height; double scale = Math.max(scaleX, scaleY); double deltaX = bound.x0; double deltaY = bound.y0; DenseMatrix64F A = new DenseMatrix64F(3, 3, true, scale, 0, deltaX, 0, scale, deltaY, 0, 0, 1); if(inputUndistorted) { PointTransform_F32 add_p_to_p = distortTransform(param).distort_F32(true, true); return PerspectiveOps.adjustIntrinsic_F32(add_p_to_p, false, param, A, paramAdj); } else { CommonOps.invert(A); return PerspectiveOps.adjustIntrinsic_F32(remove_p_to_p, true, param, A, paramAdj); } } ",
        "test_tgt": "@Test public void fullView_Transform() { IntrinsicParameters param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial(0.1, 0.05); PointTransform_F32 adjToDist = LensDistortionOps.fullView(param, null, true); PointTransform_F32 distToAdj = LensDistortionOps.fullView(param, null, false); checkBorderOutside(adjToDist, distToAdj); param = new IntrinsicParameters().fsetK(300, 320, 0, 150, 130, width, height).fsetRadial( - 0.1, - 0.05); adjToDist = LensDistortionOps.fullView(param, null, true); distToAdj = LensDistortionOps.fullView(param, null, false); checkBorderOutside(adjToDist, distToAdj); } "
    },
    {
        "test_src": "@Test public void delete()throws BaseXException { try { new RepoManager(context).delete(token(\"xyz\")); fail(\"Not installed package not detected.\"); } catch(final QueryException ex) { check(null, ex, Err.BXRE_WHICH); } new RepoInstall(REPO + \"pkg3.xar\", null).execute(context); assertTrue(context.repo.pkgDict().contains(token(PKG3ID))); final String pkg3Dir = normalize(PKG3ID); assertTrue(dir(pkg3Dir)); assertTrue(file(pkg3Dir + \"/expath-pkg.xml\")); assertTrue(dir(pkg3Dir + \"/pkg3\")); assertTrue(dir(pkg3Dir + \"/pkg3/mod\")); assertTrue(file(pkg3Dir + \"/pkg3/mod/pkg3mod1.xql\")); new RepoInstall(REPO + \"pkg4.xar\", null).execute(context); assertTrue(context.repo.pkgDict().contains(token(PKG4ID))); final String pkg4Dir = normalize(PKG4ID); assertTrue(dir(pkg4Dir)); assertTrue(file(pkg4Dir + \"/expath-pkg.xml\")); assertTrue(dir(pkg4Dir + \"/pkg4\")); assertTrue(dir(pkg4Dir + \"/pkg4/mod\")); assertTrue(file(pkg4Dir + \"/pkg4/mod/pkg4mod1.xql\")); try { new RepoManager(context).delete(token(PKG3ID)); fail(\"Package involved in a dependency was deleted.\"); } catch(final QueryException ex) { check(null, ex, Err.BXRE_DEP); } new RepoDelete(PKG4, null).execute(context); assertFalse(context.repo.pkgDict().contains(token(PKG4ID))); assertTrue( ! dir(pkg4Dir)); new RepoDelete(PKG3ID, null).execute(context); assertFalse(context.repo.pkgDict().contains(token(PKG3ID))); assertTrue( ! dir(pkg3Dir)); } ",
        "focal_tgt": "private Item delete(final QueryContext ctx)throws QueryException { final Data data = checkWrite(data(0, ctx), ctx); final String path = path(1, ctx); final IntList docs = data.resources.docs(path); final int is = docs.size(); for(int i = 0; i < is; i ++ ) { ctx.updates.add(new DeleteNode(docs.get(i), data, info), ctx); } if( ! data.inMemory()) { final IOFile bin = data.meta.binary(path); if(bin == null)UPDBDELERR.thrw(info, path); ctx.updates.add(new DBDelete(data, path, info), ctx); } return null; } ",
        "focal_src": "private Item delete(final QueryContext ctx)throws QueryException { final Data data = checkWrite(data(0, ctx), ctx); final String path = path(1, ctx); final IntList docs = data.resources.docs(path); for(int i = 0, is = docs.size(); i < is; i ++ ) { ctx.updates.add(new DeleteNode(docs.get(i), data, info), ctx); } if( ! data.inMemory()) { final IOFile bin = data.meta.binary(path); if(bin == null)UPDBDELERR.thrw(info, path); ctx.updates.add(new DBDelete(data, path, info), ctx); } return null; } ",
        "test_tgt": "@Test public void delete()throws BaseXException { try { new RepoManager(context).delete(token(\"xyz\")); fail(\"Not installed package not detected.\"); } catch(final QueryException ex) { check(null, ex, Err.BXRE_WHICH); } new RepoInstall(REPO + \"pkg3.xar\", null).execute(context); assertTrue(context.repo.pkgDict().contains(token(PKG3ID))); final String pkg3Dir = normalize(PKG3ID); assertTrue(dir(pkg3Dir)); assertTrue(file(pkg3Dir + \"/expath-pkg.xml\")); assertTrue(dir(pkg3Dir + \"/pkg3\")); assertTrue(dir(pkg3Dir + \"/pkg3/mod\")); assertTrue(file(pkg3Dir + \"/pkg3/mod/pkg3mod1.xql\")); new RepoInstall(REPO + \"pkg4.xar\", null).execute(context); assertTrue(context.repo.pkgDict().contains(token(PKG4ID))); final String pkg4Dir = normalize(PKG4ID); assertTrue(dir(pkg4Dir)); assertTrue(file(pkg4Dir + \"/expath-pkg.xml\")); assertTrue(dir(pkg4Dir + \"/pkg4\")); assertTrue(dir(pkg4Dir + \"/pkg4/mod\")); assertTrue(file(pkg4Dir + \"/pkg4/mod/pkg4mod1.xql\")); try { new RepoManager(context).delete(token(PKG3ID)); fail(\"Package involved in a dependency was deleted.\"); } catch(final QueryException ex) { check(null, ex, Err.BXRE_DEP); } new RepoDelete(PKG4, null).execute(context); assertFalse(context.repo.pkgDict().contains(token(PKG4ID))); assertFalse(dir(pkg4Dir)); new RepoDelete(PKG3ID, null).execute(context); assertFalse(context.repo.pkgDict().contains(token(PKG3ID))); assertFalse(dir(pkg3Dir)); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should close all unvoided active visit matching the specified visit types\", method = \"stopVisits()\")public void stopVisits_shouldCloseAllUnvoidedActiveVisitMatchingTheSpecifiedVisitTypes()throws Exception { executeDataSet(\"org/openmrs/api/include/VisitServiceTest-includeVisitsAndTypeToAutoClose.xml\"); String[]visitTypeNames = StringUtils.split(Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GP_VISIT_TYPES_TO_AUTO_CLOSE), \",\"); String openVisitsQuery = \"SELECT visit_id FROM visit WHERE voided = 0 AND date_stopped IS NULL AND visit_type_id IN (SELECT visit_type_id FROM visit_type WHERE NAME IN ('\" + StringUtils.join(visitTypeNames, \"','\") + \"'))\"; int activeVisitCount = Context.getAdministrationService().executeSQL(openVisitsQuery, true).size(); Assert.assertTrue(\"There should be some active visits for this test to be valid\", activeVisitCount > 0); service.stopVisits(); activeVisitCount = Context.getAdministrationService().executeSQL(openVisitsQuery, true).size(); Assert.assertTrue(\"Not all active unvoided vists were closed\", activeVisitCount == 0); } ",
        "focal_tgt": "@Authorized(PrivilegeConstants.EDIT_VISITS)public void stopVisits(Date maximumStartDate); ",
        "focal_src": "public void stopVisits(); ",
        "test_tgt": "@Test@Verifies(value = \"should close all unvoided active visit matching the specified visit types\", method = \"stopVisits()\")public void stopVisits_shouldCloseAllUnvoidedActiveVisitMatchingTheSpecifiedVisitTypes()throws Exception { executeDataSet(\"org/openmrs/api/include/VisitServiceTest-includeVisitsAndTypeToAutoClose.xml\"); String[]visitTypeNames = StringUtils.split(Context.getAdministrationService().getGlobalProperty(OpenmrsConstants.GP_VISIT_TYPES_TO_AUTO_CLOSE), \",\"); String openVisitsQuery = \"SELECT visit_id FROM visit WHERE voided = 0 AND date_stopped IS NULL AND visit_type_id IN (SELECT visit_type_id FROM visit_type WHERE NAME IN ('\" + StringUtils.join(visitTypeNames, \"','\") + \"'))\"; int activeVisitCount = Context.getAdministrationService().executeSQL(openVisitsQuery, true).size(); Assert.assertTrue(\"There should be some active visits for this test to be valid\", activeVisitCount > 0); service.stopVisits(null); activeVisitCount = Context.getAdministrationService().executeSQL(openVisitsQuery, true).size(); Assert.assertTrue(\"Not all active unvoided vists were closed\", activeVisitCount == 0); } "
    },
    {
        "test_src": "@Test public void testGetFileNameWithRewriting()throws Exception { assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S12E03.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 1203\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02E03.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102-103\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02.EXTENDED.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02.Mysterious.Wordplay.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102 - Mysterious Wordplay\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02.Extended.Cut.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102 (Extended Cut)\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.2015.01.23.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 2015/01/23\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.2015.01.23.Mysterious.Wordplay.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 2015/01/23 - Mysterious Wordplay\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.2015.720p.mkv\", null)).isEqualTo(\"Universal Media Server (2015)\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.Special.Edition.2015.720p.mkv\", null)).isEqualTo(\"Universal Media Server (Special Edition) (2015)\"); } ",
        "focal_tgt": "public static String getFileNameWithRewriting(String f, File file) { String fileNameWithoutExtension; String formattedName; String formattedNameTemp; String searchFormattedName; String edition = \"\"; boolean loopedOnce = false; boolean isEpisodeToLookup = false; boolean isMovieToLookup = false; fileNameWithoutExtension = getFileNameWithoutExtension(f); formattedName = fileNameWithoutExtension; searchFormattedName = \"\"; String commonFileEnds = \"[\\\\s\\\\.]AC3.*|[\\\\s\\\\.]REPACK.*|[\\\\s\\\\.]480p.*|[\\\\s\\\\.]720p.*|[\\\\s\\\\.]m-720p.*|[\\\\s\\\\.]900p.*|[\\\\s\\\\.]1080p.*|[\\\\s\\\\.]2160p.*|[\\\\s\\\\.]WEB-DL.*|[\\\\s\\\\.]HDTV.*|[\\\\s\\\\.]DSR.*|[\\\\s\\\\.]PDTV.*|[\\\\s\\\\.]WS.*|[\\\\s\\\\.]HQ.*|[\\\\s\\\\.]DVDRip.*|[\\\\s\\\\.]TVRiP.*|[\\\\s\\\\.]BDRip.*|[\\\\s\\\\.]BRRip.*|[\\\\s\\\\.]WEBRip.*|[\\\\s\\\\.]BluRay.*|[\\\\s\\\\.]Blu-ray.*|[\\\\s\\\\.]SUBBED.*|[\\\\s\\\\.]x264.*|[\\\\s\\\\.]Dual[\\\\s\\\\.]Audio.*|[\\\\s\\\\.]HSBS.*|[\\\\s\\\\.]H-SBS.*|[\\\\s\\\\.]RERiP.*|[\\\\s\\\\.]DIRFIX.*|[\\\\s\\\\.]READNFO.*|[\\\\s\\\\.]60FPS.*\"; String commonFileEndsMatch = \".*[\\\\s\\\\.]AC3.*|.*[\\\\s\\\\.]REPACK.*|.*[\\\\s\\\\.]480p.*|.*[\\\\s\\\\.]720p.*|.*[\\\\s\\\\.]m-720p.*|.*[\\\\s\\\\.]900p.*|.*[\\\\s\\\\.]1080p.*|.*[\\\\s\\\\.]2160p.*|.*[\\\\s\\\\.]WEB-DL.*|.*[\\\\s\\\\.]HDTV.*|.*[\\\\s\\\\.]DSR.*|.*[\\\\s\\\\.]PDTV.*|.*[\\\\s\\\\.]WS.*|.*[\\\\s\\\\.]HQ.*|.*[\\\\s\\\\.]DVDRip.*|.*[\\\\s\\\\.]TVRiP.*|.*[\\\\s\\\\.]BDRip.*|.*[\\\\s\\\\.]BRRip.*|.*[\\\\s\\\\.]WEBRip.*|.*[\\\\s\\\\.]BluRay.*|.*[\\\\s\\\\.]Blu-ray.*|.*[\\\\s\\\\.]SUBBED.*|.*[\\\\s\\\\.]x264.*|.*[\\\\s\\\\.]Dual[\\\\s\\\\.]Audio.*|.*[\\\\s\\\\.]HSBS.*|.*[\\\\s\\\\.]H-SBS.*|.*[\\\\s\\\\.]RERiP.*|.*[\\\\s\\\\.]DIRFIX.*|.*[\\\\s\\\\.]READNFO.*|.*[\\\\s\\\\.]60FPS.*\"; String commonFileEndsCaseSensitive = \"[\\\\s\\\\.]PROPER[\\\\s\\\\.].*|[\\\\s\\\\.]iNTERNAL[\\\\s\\\\.].*|[\\\\s\\\\.]LIMITED[\\\\s\\\\.].*|[\\\\s\\\\.]LiMiTED[\\\\s\\\\.].*|[\\\\s\\\\.]FESTiVAL[\\\\s\\\\.].*|[\\\\s\\\\.]NORDIC[\\\\s\\\\.].*|[\\\\s\\\\.]REAL[\\\\s\\\\.].*|[\\\\s\\\\.]SUBBED[\\\\s\\\\.].*|[\\\\s\\\\.]RETAIL[\\\\s\\\\.].*|[\\\\s\\\\.]EXTENDED[\\\\s\\\\.].*|[\\\\s\\\\.]NEWEDIT[\\\\s\\\\.].*\"; String commonFileMiddle = \"(?i)(?!\\\\()(Special[\\\\s\\\\.]Edition|Unrated|Final[\\\\s\\\\.]Cut|Remastered|Extended[\\\\s\\\\.]Cut|IMAX[\\\\s\\\\.]Edition|Uncensored|Directors[\\\\s\\\\.]Cut|Uncut)(?!\\\\))\"; if(formattedName.matches(\".*[sS]0\\\\d[eE]\\\\d\\\\d[eE]\\\\d\\\\d.*\")) { formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEnds + \")\", \" - $1$2$3-$1$4$5\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2$3-$1$4$5\"); Pattern r = Pattern.compile(commonFileMiddle); Matcher m = r.matcher(formattedName); if(m.find()) { edition = m.group().replaceAll(\"\\\\.\", \" \"); edition = \" (\" + WordUtils.capitalizeFully(edition) + \")\"; formattedName = formattedName.replaceAll(\" - \" + commonFileMiddle, \"\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"\"); } formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)[\\\\s\\\\.]\", \" - $1$2$3-$1$4$5 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp; formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[sS][1-9]\\\\d[eE]\\\\d\\\\d[eE]\\\\d\\\\d.*\")) { formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEnds + \")\", \" - $1$2$3-$1$4$5\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2$3-$1$4$5\"); Pattern r = Pattern.compile(commonFileMiddle); Matcher m = r.matcher(formattedName); if(m.find()) { edition = m.group().replaceAll(\"\\\\.\", \" \"); edition = \"(\" + WordUtils.capitalizeFully(edition) + \")\"; formattedName = formattedName.replaceAll(\" - \" + commonFileMiddle, \"\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"\"); } formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)[\\\\s\\\\.]\", \" - $1$2$3-$1$4$5 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp; formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[sS]0\\\\d[eE]\\\\d\\\\d.*\")) { Pattern r = Pattern.compile(commonFileMiddle); Matcher m = r.matcher(formattedName); if(m.find()) { edition = m.group().replaceAll(\"\\\\.\", \" \"); edition = \"(\" + WordUtils.capitalizeFully(edition) + \")\"; formattedName = formattedName.replaceAll(\" - \" + commonFileMiddle, \"\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"\"); } formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEnds + \")\", \" - $1$2$3\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2$3\"); formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)[\\\\s\\\\.]\", \" - $1$2$3 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp; formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[sS][1-9]\\\\d[eE]\\\\d\\\\d.*\")) { formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEnds + \")\", \" - $1$2$3\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2$3\"); Pattern r = Pattern.compile(commonFileMiddle); Matcher m = r.matcher(formattedName); if(m.find()) { edition = m.group().replaceAll(\"\\\\.\", \" \"); edition = \"(\" + WordUtils.capitalizeFully(edition) + \")\"; formattedName = formattedName.replaceAll(\" - \" + commonFileMiddle, \"\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"\"); } formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)[\\\\s\\\\.]\", \" - $1$2$3 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp; formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[\\\\s\\\\.](19|20)\\\\d\\\\d[\\\\s\\\\.][0-1]\\\\d[\\\\s\\\\.][0-3]\\\\d[\\\\s\\\\.].*\")) { formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.](19|20)(\\\\d\\\\d)[\\\\s\\\\.]([0-1]\\\\d)[\\\\s\\\\.]([0-3]\\\\d)(\" + commonFileEnds + \")\", \" - $1$2/$3/$4\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.](19|20)(\\\\d\\\\d)[\\\\s\\\\.]([0-1]\\\\d)[\\\\s\\\\.]([0-3]\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2/$3/$4\"); Pattern r = Pattern.compile(commonFileMiddle); Matcher m = r.matcher(formattedName); if(m.find()) { edition = m.group().replaceAll(\"\\\\.\", \" \"); edition = \"(\" + WordUtils.capitalizeFully(edition) + \")\"; formattedName = formattedName.replaceAll(\" - \" + commonFileMiddle, \"\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"\"); } formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.](19|20)(\\\\d\\\\d)[\\\\s\\\\.]([0-1]\\\\d)[\\\\s\\\\.]([0-3]\\\\d)[\\\\s\\\\.]\", \" - $1$2/$3/$4 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp; formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[\\\\s\\\\.](19|20)\\\\d\\\\d[\\\\s\\\\.].*\")) { formattedName = formattedName.replaceAll(\"[\\\\s\\\\.](19|20)(\\\\d\\\\d)\", \" ($1$2)\"); formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); Pattern r = Pattern.compile(commonFileMiddle); Matcher m = r.matcher(formattedName); if(m.find()) { edition = m.group().replaceAll(\"\\\\.\", \" \"); edition = \"(\" + WordUtils.capitalizeFully(edition) + \")\"; formattedName = formattedName.replaceAll(\" - \" + commonFileMiddle, \"\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"\"); } formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\[(19|20)\\\\d\\\\d\\\\].*\")) { formattedName = formattedName.replaceAll(\"(?i)\\\\[(19|20)(\\\\d\\\\d)\\\\].*\", \" ($1$2)\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\((19|20)\\\\d\\\\d\\\\).*\")) { formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\((19|20)\\\\d\\\\d\\\\).*\")) { formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(commonFileEndsMatch)) { isMovieToLookup = true; formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); Pattern r = Pattern.compile(commonFileMiddle); Matcher m = r.matcher(formattedName); if(m.find()) { edition = m.group().replaceAll(\"\\\\.\", \" \"); edition = \"(\" + WordUtils.capitalizeFully(edition) + \")\"; formattedName = formattedName.replaceAll(\" - \" + commonFileMiddle, \"\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"\"); } formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\[[0-9a-zA-Z]{8}\\\\]$\")) { formattedName = formattedName.replaceAll(\"_\", \" \"); formattedName = formattedName.replaceAll(\"(?i)\\\\s\\\\(1280x720.*|\\\\s\\\\(1920x1080.*|\\\\s\\\\(720x400.*|\\\\[720p.*|\\\\[1080p.*|\\\\[480p.*|\\\\s\\\\(BD.*|\\\\s\\\\[Blu-Ray.*|\\\\s\\\\[DVD.*|\\\\.DVD.*|\\\\[[0-9a-zA-Z]{8}\\\\]$|\\\\[h264.*|R1DVD.*|\\\\[BD.*\", \"\"); if( ! \"\".equals(formattedName)) { if(formattedName.substring(0, 1).matches(\"\\\\[\")) { int closingBracketIndex = formattedName.indexOf(']'); if(closingBracketIndex != - 1) { formattedName = formattedName.substring(closingBracketIndex + 1); } if(formattedName.substring(0, 1).matches(\"\\\\s\")) { formattedName = formattedName.substring(1); } } } else { formattedName = fileNameWithoutExtension; } if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.substring(formattedName.length() - 3).matches(\"[\\\\s\\\\._]\\\\d\\\\d\")) { isEpisodeToLookup = true; searchFormattedName = formattedName.substring(0, formattedName.length() - 2) + \"S01E\" + formattedName.substring(formattedName.length() - 2); } if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\[BD\\\\].*|.*\\\\[720p\\\\].*|.*\\\\[1080p\\\\].*|.*\\\\[480p\\\\].*|.*\\\\[Blu-Ray.*|.*\\\\[h264.*\")) { formattedName = formattedName.replaceAll(\"_\", \" \"); formattedName = formattedName.replaceAll(\"(?i)\\\\[BD\\\\].*|\\\\[720p.*|\\\\[1080p.*|\\\\[480p.*|\\\\[Blu-Ray.*\\\\[h264.*\", \"\"); if( ! \"\".equals(formattedName)) { if(formattedName.substring(0, 1).matches(\"\\\\[\")) { int closingBracketIndex = formattedName.indexOf(']'); if(closingBracketIndex != - 1) { formattedName = formattedName.substring(closingBracketIndex + 1); } if(formattedName.substring(0, 1).matches(\"\\\\s\")) { formattedName = formattedName.substring(1); } } } else { formattedName = fileNameWithoutExtension; } if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.substring(formattedName.length() - 3).matches(\"[\\\\s\\\\._]\\\\d\\\\d\")) { isEpisodeToLookup = true; searchFormattedName = formattedName.substring(0, formattedName.length() - 2) + \"S01E\" + formattedName.substring(formattedName.length() - 2); } if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } formattedName = formattedName.replaceAll(\" \", \" \"); if(file != null && (isEpisodeToLookup || isMovieToLookup)) { InfoDb.InfoDbData info = PMS.get().infoDb().get(file); if(info == null) { PMS.get().infoDbAdd(file, searchFormattedName); } else if(isEpisodeToLookup && StringUtils.isNotEmpty(info.ep_name)) { formattedName += \" - \" + info.ep_name; } else if(isMovieToLookup && StringUtils.isNotEmpty(info.year)) { formattedName += \" (\" + info.year + \")\"; } } if( ! edition.isEmpty()) { formattedName = formattedName.trim(); String substr = formattedName.substring(Math.max(0, formattedName.length() - 2)); if(\" -\".equals(substr)) { formattedName = formattedName.substring(0, formattedName.length() - 2); } formattedName += \" \" + edition; } return formattedName; } ",
        "focal_src": "public static String getFileNameWithRewriting(String f, File file) { String fileNameWithoutExtension; String formattedName; String formattedNameTemp; String searchFormattedName; boolean loopedOnce = false; boolean isEpisodeToLookup = false; boolean isMovieToLookup = false; fileNameWithoutExtension = getFileNameWithoutExtension(f); formattedName = fileNameWithoutExtension; searchFormattedName = \"\"; String commonFileEnds = \"[\\\\s\\\\.]AC3.*|[\\\\s\\\\.]REPACK.*|[\\\\s\\\\.]480p.*|[\\\\s\\\\.]720p.*|[\\\\s\\\\.]m-720p.*|[\\\\s\\\\.]900p.*|[\\\\s\\\\.]1080p.*|[\\\\s\\\\.]2160p.*|[\\\\s\\\\.]WEB-DL.*|[\\\\s\\\\.]HDTV.*|[\\\\s\\\\.]DSR.*|[\\\\s\\\\.]PDTV.*|[\\\\s\\\\.]WS.*|[\\\\s\\\\.]HQ.*|[\\\\s\\\\.]DVDRip.*|[\\\\s\\\\.]TVRiP.*|[\\\\s\\\\.]BDRip.*|[\\\\s\\\\.]BRRip.*|[\\\\s\\\\.]WEBRip.*|[\\\\s\\\\.]BluRay.*|[\\\\s\\\\.]Blu-ray.*|[\\\\s\\\\.]SUBBED.*|[\\\\s\\\\.]x264.*|[\\\\s\\\\.]Dual[\\\\s\\\\.]Audio.*|[\\\\s\\\\.]HSBS.*|[\\\\s\\\\.]H-SBS.*|[\\\\s\\\\.]RERiP.*|[\\\\s\\\\.]DIRFIX.*|[\\\\s\\\\.]READNFO.*|[\\\\s\\\\.]60FPS.*\"; String commonFileEndsMatch = \".*[\\\\s\\\\.]AC3.*|.*[\\\\s\\\\.]REPACK.*|.*[\\\\s\\\\.]480p.*|.*[\\\\s\\\\.]720p.*|.*[\\\\s\\\\.]m-720p.*|.*[\\\\s\\\\.]900p.*|.*[\\\\s\\\\.]1080p.*|.*[\\\\s\\\\.]2160p.*|.*[\\\\s\\\\.]WEB-DL.*|.*[\\\\s\\\\.]HDTV.*|.*[\\\\s\\\\.]DSR.*|.*[\\\\s\\\\.]PDTV.*|.*[\\\\s\\\\.]WS.*|.*[\\\\s\\\\.]HQ.*|.*[\\\\s\\\\.]DVDRip.*|.*[\\\\s\\\\.]TVRiP.*|.*[\\\\s\\\\.]BDRip.*|.*[\\\\s\\\\.]BRRip.*|.*[\\\\s\\\\.]WEBRip.*|.*[\\\\s\\\\.]BluRay.*|.*[\\\\s\\\\.]Blu-ray.*|.*[\\\\s\\\\.]SUBBED.*|.*[\\\\s\\\\.]x264.*|.*[\\\\s\\\\.]Dual[\\\\s\\\\.]Audio.*|.*[\\\\s\\\\.]HSBS.*|.*[\\\\s\\\\.]H-SBS.*|.*[\\\\s\\\\.]RERiP.*|.*[\\\\s\\\\.]DIRFIX.*|.*[\\\\s\\\\.]READNFO.*|.*[\\\\s\\\\.]60FPS.*\"; String commonFileEndsCaseSensitive = \"[\\\\s\\\\.]PROPER[\\\\s\\\\.].*|[\\\\s\\\\.]iNTERNAL[\\\\s\\\\.].*|[\\\\s\\\\.]LIMITED[\\\\s\\\\.].*|[\\\\s\\\\.]LiMiTED[\\\\s\\\\.].*|[\\\\s\\\\.]FESTiVAL[\\\\s\\\\.].*|[\\\\s\\\\.]NORDIC[\\\\s\\\\.].*|[\\\\s\\\\.]REAL[\\\\s\\\\.].*|[\\\\s\\\\.]SUBBED[\\\\s\\\\.].*|[\\\\s\\\\.]RETAIL[\\\\s\\\\.].*|[\\\\s\\\\.]EXTENDED[\\\\s\\\\.].*\"; String commonFileMiddle = \"(?i)(?!\\\\()(Special[\\\\s\\\\.]Edition|Unrated|Final[\\\\s\\\\.]Cut|Remastered|Extended[\\\\s\\\\.]Cut|IMAX[\\\\s\\\\.]Edition|Uncensored|Directors[\\\\s\\\\.]Cut)(?!\\\\))\"; if(formattedName.matches(\".*[sS]0\\\\d[eE]\\\\d\\\\d[eE]\\\\d\\\\d.*\")) { formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEnds + \")\", \" - $1$2$3-$1$4$5\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2$3-$1$4$5\"); formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)[\\\\s\\\\.]\", \" - $1$2$3-$1$4$5 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp.replaceAll(\" - \" + commonFileMiddle, \" ($1)\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"($1)\"); formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[sS][1-9]\\\\d[eE]\\\\d\\\\d[eE]\\\\d\\\\d.*\")) { formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEnds + \")\", \" - $1$2$3-$1$4$5\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2$3-$1$4$5\"); formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)E(\\\\d)(\\\\d)[\\\\s\\\\.]\", \" - $1$2$3-$1$4$5 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp.replaceAll(\" - \" + commonFileMiddle, \" ($1)\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"($1)\"); formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[sS]0\\\\d[eE]\\\\d\\\\d.*\")) { formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEnds + \")\", \" - $1$2$3\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2$3\"); formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S0(\\\\d)E(\\\\d)(\\\\d)[\\\\s\\\\.]\", \" - $1$2$3 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp.replaceAll(\" - \" + commonFileMiddle, \" ($1)\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"($1)\"); formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[sS][1-9]\\\\d[eE]\\\\d\\\\d.*\")) { formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEnds + \")\", \" - $1$2$3\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2$3\"); formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.]S([1-9]\\\\d)E(\\\\d)(\\\\d)[\\\\s\\\\.]\", \" - $1$2$3 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp.replaceAll(\" - \" + commonFileMiddle, \" ($1)\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"($1)\"); formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[\\\\s\\\\.](19|20)\\\\d\\\\d[\\\\s\\\\.][0-1]\\\\d[\\\\s\\\\.][0-3]\\\\d[\\\\s\\\\.].*\")) { formattedName = formattedName.replaceAll(\"(?i)[\\\\s\\\\.](19|20)(\\\\d\\\\d)[\\\\s\\\\.]([0-1]\\\\d)[\\\\s\\\\.]([0-3]\\\\d)(\" + commonFileEnds + \")\", \" - $1$2/$3/$4\"); formattedName = formattedName.replaceAll(\"[\\\\s\\\\.](19|20)(\\\\d\\\\d)[\\\\s\\\\.]([0-1]\\\\d)[\\\\s\\\\.]([0-3]\\\\d)(\" + commonFileEndsCaseSensitive + \")\", \" - $1$2/$3/$4\"); formattedNameTemp = formattedName.replaceAll(\"(?i)[\\\\s\\\\.](19|20)(\\\\d\\\\d)[\\\\s\\\\.]([0-1]\\\\d)[\\\\s\\\\.]([0-3]\\\\d)[\\\\s\\\\.]\", \" - $1$2/$3/$4 - \"); if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.equals(formattedNameTemp)) { isEpisodeToLookup = true; } formattedName = formattedNameTemp.replaceAll(\" - \" + commonFileMiddle, \" ($1)\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"($1)\"); formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedNameTemp = \"\"; for(String part : formattedName.split(\" - \")) { if(loopedOnce) { formattedNameTemp += \" - \" + convertLowerCaseStringToTitleCase(part); } else { formattedNameTemp += convertLowerCaseStringToTitleCase(part); } loopedOnce = true; } formattedName = formattedNameTemp; } } else if(formattedName.matches(\".*[\\\\s\\\\.](19|20)\\\\d\\\\d[\\\\s\\\\.].*\")) { formattedName = formattedName.replaceAll(\"[\\\\s\\\\.](19|20)(\\\\d\\\\d)\", \" ($1$2)\"); formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"($1)\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\[(19|20)\\\\d\\\\d\\\\].*\")) { formattedName = formattedName.replaceAll(\"(?i)\\\\[(19|20)(\\\\d\\\\d)\\\\].*\", \" ($1$2)\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\((19|20)\\\\d\\\\d\\\\).*\")) { formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\((19|20)\\\\d\\\\d\\\\).*\")) { formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(commonFileEndsMatch)) { isMovieToLookup = true; formattedName = formattedName.replaceAll(commonFileEndsCaseSensitive, \"\"); formattedName = formattedName.replaceAll(\"(?i)\" + commonFileEnds, \"\"); formattedName = formattedName.replaceAll(commonFileMiddle, \"($1)\"); formattedName = formattedName.replaceAll(\"\\\\.\", \" \"); if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\[[0-9a-zA-Z]{8}\\\\]$\")) { formattedName = formattedName.replaceAll(\"_\", \" \"); formattedName = formattedName.replaceAll(\"(?i)\\\\s\\\\(1280x720.*|\\\\s\\\\(1920x1080.*|\\\\s\\\\(720x400.*|\\\\[720p.*|\\\\[1080p.*|\\\\[480p.*|\\\\s\\\\(BD.*|\\\\s\\\\[Blu-Ray.*|\\\\s\\\\[DVD.*|\\\\.DVD.*|\\\\[[0-9a-zA-Z]{8}\\\\]$|\\\\[h264.*|R1DVD.*|\\\\[BD.*\", \"\"); if( ! \"\".equals(formattedName)) { if(formattedName.substring(0, 1).matches(\"\\\\[\")) { int closingBracketIndex = formattedName.indexOf(']'); if(closingBracketIndex != - 1) { formattedName = formattedName.substring(closingBracketIndex + 1); } if(formattedName.substring(0, 1).matches(\"\\\\s\")) { formattedName = formattedName.substring(1); } } } else { formattedName = fileNameWithoutExtension; } if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.substring(formattedName.length() - 3).matches(\"[\\\\s\\\\._]\\\\d\\\\d\")) { isEpisodeToLookup = true; searchFormattedName = formattedName.substring(0, formattedName.length() - 2) + \"S01E\" + formattedName.substring(formattedName.length() - 2); } if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } else if(formattedName.matches(\".*\\\\[BD\\\\].*|.*\\\\[720p\\\\].*|.*\\\\[1080p\\\\].*|.*\\\\[480p\\\\].*|.*\\\\[Blu-Ray.*|.*\\\\[h264.*\")) { formattedName = formattedName.replaceAll(\"_\", \" \"); formattedName = formattedName.replaceAll(\"(?i)\\\\[BD\\\\].*|\\\\[720p.*|\\\\[1080p.*|\\\\[480p.*|\\\\[Blu-Ray.*\\\\[h264.*\", \"\"); if( ! \"\".equals(formattedName)) { if(formattedName.substring(0, 1).matches(\"\\\\[\")) { int closingBracketIndex = formattedName.indexOf(']'); if(closingBracketIndex != - 1) { formattedName = formattedName.substring(closingBracketIndex + 1); } if(formattedName.substring(0, 1).matches(\"\\\\s\")) { formattedName = formattedName.substring(1); } } } else { formattedName = fileNameWithoutExtension; } if(PMS.getConfiguration().isUseInfoFromIMDB() && formattedName.substring(formattedName.length() - 3).matches(\"[\\\\s\\\\._]\\\\d\\\\d\")) { isEpisodeToLookup = true; searchFormattedName = formattedName.substring(0, formattedName.length() - 2) + \"S01E\" + formattedName.substring(formattedName.length() - 2); } if(formattedName.equals(formattedName.toLowerCase())) { formattedName = convertLowerCaseStringToTitleCase(formattedName); } } if(file != null && (isEpisodeToLookup || isMovieToLookup)) { InfoDb.InfoDbData info = PMS.get().infoDb().get(file); if(info == null) { PMS.get().infoDbAdd(file, searchFormattedName); } else if(isEpisodeToLookup && StringUtils.isNotEmpty(info.ep_name)) { formattedName += \" - \" + info.ep_name; } else if(isMovieToLookup && StringUtils.isNotEmpty(info.year)) { formattedName += \" (\" + info.year + \")\"; } } return formattedName; } ",
        "test_tgt": "@Test public void testGetFileNameWithRewriting()throws Exception { assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S12E03.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 1203\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02E03.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102-103\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02.EXTENDED.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02.Mysterious.Wordplay.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102 - Mysterious Wordplay\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02.UNCUT.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102 (Uncut)\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.S01E02.Extended.Cut.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 102 (Extended Cut)\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.2015.01.23.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 2015/01/23\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.2015.01.23.Mysterious.Wordplay.720p.mkv\", null)).isEqualTo(\"Universal Media Server - 2015/01/23 - Mysterious Wordplay\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.2015.720p.mkv\", null)).isEqualTo(\"Universal Media Server (2015)\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.Special.Edition.2015.720p.mkv\", null)).isEqualTo(\"Universal Media Server (2015) (Special Edition)\"); assertThat(FileUtil.getFileNameWithRewriting(\"Universal.Media.Server.2015.Special.Edition.720p.mkv\", null)).isEqualTo(\"Universal Media Server (2015) (Special Edition)\"); } "
    },
    {
        "test_src": "@Test(dataProvider = \"parseText\")public void test_parse_strict_caseSensitive_parseUpper(DateTimeFieldRule rule, TextStyle style, int dow, String input)throws Exception { DateTimeParseContext context = new DateTimeParseContext(symbols); context.setCaseSensitive(true); TextPrinterParser pp = new TextPrinterParser(rule, style); int newPos = pp.parse(context, input.toUpperCase(), 0); assertEquals(newPos, ~ 0); assertEquals(context.toCalendrical().getFieldMap().contains(RULE_DOW), false); } ",
        "focal_tgt": "public static LocalDate parse(String text) { return DateTimeFormatters.isoLocalDate().parse(text, rule()); } ",
        "focal_src": "public static LocalDate parse(String text) { ISOChronology.checkNotNull(text, \"Text to parse must not be null\"); return DateTimeFormatters.isoLocalDate().parse(text).mergeStrict().toLocalDate(); } ",
        "test_tgt": "@Test(dataProvider = \"parseText\")public void test_parse_strict_caseSensitive_parseUpper(DateTimeFieldRule < ? > rule, TextStyle style, int dow, String input)throws Exception { DateTimeParseContext context = new DateTimeParseContext(symbols); context.setCaseSensitive(true); TextPrinterParser pp = new TextPrinterParser(rule, style); int newPos = pp.parse(context, input.toUpperCase(), 0); assertEquals(newPos, ~ 0); assertEquals(context.toCalendricalMerger().getInputMap().containsKey(RULE_DOW), false); } "
    },
    {
        "test_src": "@Test public final void testGoToUrl()throws CrawljaxException, MalformedURLException { browser.goToUrl(new URL(\"http://non.exsisting.domain\")); } ",
        "focal_tgt": "void goToUrl(URI url); ",
        "focal_src": "void goToUrl(URL url); ",
        "test_tgt": "@Test public final void testGoToUrl()throws CrawljaxException, MalformedURLException { browser.goToUrl(URI.create(\"http://non.exsisting.domain\")); } "
    },
    {
        "test_src": "@Test public void testGetTotalRunCount() { System.out.println(\"getTotalRunCount\"); RunTable instance = createHorizontalInstance(); int expResult = 11; int result = instance.getTotalRunCount(); assertEquals(expResult, result); instance = createVerticalInstance(); expResult = 19; result = instance.getTotalRunCount(); assertEquals(expResult, result); } ",
        "focal_tgt": "public int getTotalRunCount() { int total = 0; for(short[]seq : sequences) { total += sequenceSize(seq); } return total; } ",
        "focal_src": "public int getTotalRunCount() { int total = 0; for(RunSequence seq : sequences) { total += seq.size(); } return total; } ",
        "test_tgt": "@Test public void testGetTotalRunCount() { System.out.println(\"\\n+++ getTotalRunCount\"); RunTable instance = createHorizontalInstance(); int expResult = 9; int result = instance.getTotalRunCount(); assertEquals(expResult, result); instance = createVerticalInstance(); expResult = 16; result = instance.getTotalRunCount(); assertEquals(expResult, result); } "
    },
    {
        "test_src": "@Test public void testGetWorkspace() { GetWorkspaceOptions getOptions = new GetWorkspaceOptions.Builder(workspaceId).export(false).build(); WorkspaceExport response = service.getWorkspace(getOptions).execute(); try { assertNotNull(response); assertNotNull(response.getWorkspaceId()); assertEquals(response.getWorkspaceId(), workspaceId); assertNotNull(response.getName()); assertNotNull(response.getDescription()); assertNotNull(response.getLanguage()); Date now = new Date(); assertNotNull(response.getCreated()); assertNotNull(response.getUpdated()); assertTrue(fuzzyBefore(response.getCreated(), now)); assertTrue(fuzzyBefore(response.getUpdated(), now)); } catch(Exception ex) { fail(ex.getMessage()); } } ",
        "focal_tgt": "public ServiceCall < WorkspaceExport > getWorkspace(GetWorkspaceOptions getWorkspaceOptions) { Validator.notNull(getWorkspaceOptions, \"getWorkspaceOptions cannot be null\"); RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/workspaces/%s\", getWorkspaceOptions.workspaceId())); builder.query(VERSION, versionDate); if(getWorkspaceOptions.export() != null) { builder.query(\"export\", String.valueOf(getWorkspaceOptions.export())); } if(getWorkspaceOptions.includeAudit() != null) { builder.query(\"include_audit\", String.valueOf(getWorkspaceOptions.includeAudit())); } return createServiceCall(builder.build(), ResponseConverterUtils.getObject(WorkspaceExport.class)); } ",
        "focal_src": "public ServiceCall < WorkspaceExport > getWorkspace(GetWorkspaceOptions getWorkspaceOptions) { Validator.notNull(getWorkspaceOptions, \"getWorkspaceOptions cannot be null\"); RequestBuilder builder = RequestBuilder.get(String.format(\"/v1/workspaces/%s\", getWorkspaceOptions.workspaceId())); builder.query(VERSION, versionDate); if(getWorkspaceOptions.export() != null) { builder.query(\"export\", String.valueOf(getWorkspaceOptions.export())); } return createServiceCall(builder.build(), ResponseConverterUtils.getObject(WorkspaceExport.class)); } ",
        "test_tgt": "@Test public void testGetWorkspace() { GetWorkspaceOptions getOptions = new GetWorkspaceOptions.Builder(workspaceId).export(false).includeAudit(true).build(); WorkspaceExport response = service.getWorkspace(getOptions).execute(); try { assertNotNull(response); assertNotNull(response.getWorkspaceId()); assertEquals(response.getWorkspaceId(), workspaceId); assertNotNull(response.getName()); assertNotNull(response.getDescription()); assertNotNull(response.getLanguage()); Date now = new Date(); assertNotNull(response.getCreated()); assertNotNull(response.getUpdated()); assertTrue(fuzzyBefore(response.getCreated(), now)); assertTrue(fuzzyBefore(response.getUpdated(), now)); } catch(Exception ex) { fail(ex.getMessage()); } } "
    },
    {
        "test_src": "@Test public void testGetSynonyms() { Map < String, Object > params = new HashMap < String, Object > (); params.put(ToneAnalyzer.WORDS, new String[] { \"difficult\", \"inferior\" }); params.put(ToneAnalyzer.LIMIT, 3); final SynonymResult synonymResult1 = new SynonymResult(); synonymResult1.setTrait(\"openness\"); synonymResult1.setHeadword(\"difficult\"); final Synonym synonym10 = new Synonym(); synonym10.setWord(\"petrified\"); synonym10.setSense(\"difficult\"); synonym10.setMeaning(\"not easy\"); synonym10.setHops(0); synonym10.setSemanticType(\"adj-all\"); synonym10.setWeight( - 0.028989519600000006); final Synonym synonym11 = new Synonym(); synonym11.setWord(\"embarrassing\"); synonym11.setSense(\"difficult\"); synonym11.setMeaning(\"not easy\"); synonym11.setHops(0); synonym11.setSemanticType(\"adj-all\"); synonym11.setWeight( - 0.028989519600000); final Synonym synonym12 = new Synonym(); synonym12.setWord(\"tough\"); synonym12.setSense(\"difficult\"); synonym12.setMeaning(\"not easy\"); synonym12.setHops(0); synonym12.setSemanticType(\"adj-all\"); synonym12.setWeight( - 0.0289895196000009); synonymResult1.setSynonyms(new ArrayList < Synonym > () { { add(synonym10); add(synonym11); add(synonym12); } }); final SynonymResult synonymResult2 = new SynonymResult(); synonymResult2.setTrait(\"conscientious\"); synonymResult2.setHeadword(\"difficult\"); final Synonym synonym20 = new Synonym(); synonym20.setWord(\"trying\"); synonym20.setSense(\"difficult\"); synonym20.setMeaning(\"not easy\"); synonym20.setHops(0); synonym20.setSemanticType(\"adj-all\"); synonym20.setWeight( - 0.02898951960000002); final Synonym synonym21 = new Synonym(); synonym21.setWord(\"challenging\"); synonym21.setSense(\"difficult\"); synonym21.setMeaning(\"not easy\"); synonym21.setHops(0); synonym21.setSemanticType(\"adj-all\"); synonym21.setWeight( - 0.0289895196007); final Synonym synonym22 = new Synonym(); synonym22.setWord(\"tough\"); synonym22.setSense(\"difficult\"); synonym22.setMeaning(\"not easy\"); synonym22.setHops(0); synonym22.setSemanticType(\"adj-all\"); synonym22.setWeight( - 0.0289895196000099); synonymResult2.setSynonyms(new ArrayList < Synonym > () { { add(synonym20); add(synonym21); add(synonym22); } }); final SynonymResult synonymResult3 = new SynonymResult(); synonymResult3.setTrait(\"confident\"); synonymResult3.setHeadword(\"difficult\"); final Synonym synonym30 = new Synonym(); synonym30.setWord(\"firm\"); synonym30.setSense(\"difficult\"); synonym30.setMeaning(\"not easy\"); synonym30.setHops(0); synonym30.setSemanticType(\"adj-all\"); synonym30.setWeight( - 0.02898951960000112); synonymResult3.setSynonyms(new ArrayList < Synonym > () { { add(synonym30); } }); List < SynonymResult > response = new ArrayList < SynonymResult > (); response.add(synonymResult1); response.add(synonymResult1); response.add(synonymResult1); JsonObject contentJson = new JsonObject(); JsonArray wordsJson = new JsonArray(); for(String word : (String[])params.get(ToneAnalyzer.WORDS)) { wordsJson.add(new JsonPrimitive(word)); } contentJson.add(ToneAnalyzer.WORDS, wordsJson); if(params.containsKey(ToneAnalyzer.LIMIT))contentJson.addProperty(ToneAnalyzer.LIMIT, (Integer)params.get(ToneAnalyzer.LIMIT)); mockServer.when(request().withMethod(\"POST\").withPath(SYNONYM_PATH).withBody(contentJson.toString())).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, MediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGson().toJson(response))); List < SynonymResult > synonyms = service.getSynonyms(params); Assert.assertNotNull(synonyms); Assert.assertFalse(synonyms.isEmpty()); Assert.assertEquals(synonyms, response); } ",
        "focal_tgt": "public List < SynonymResult > getSynonyms(Map < String, Object > params) { final String[]words = (String[])params.get(WORDS); final String[]traits = (String[])params.get(TRAITS); final String[]contexts = (String[])params.get(CONTEXT); if(words == null || words.length == 0)throw new IllegalArgumentException(\"words cannot be null or empty\"); final JsonObject contentJson = new JsonObject(); final JsonArray wordsJson = new JsonArray(); for(final String word : words) { wordsJson.add(new JsonPrimitive(word)); } contentJson.add(WORDS, wordsJson); if(traits != null && traits.length > 0) { final JsonArray traisJson = new JsonArray(); for(final String trait : traits) { traisJson.add(new JsonPrimitive(trait)); } contentJson.add(TRAITS, traisJson); } if(contexts != null && contexts.length > 0) { final JsonArray contextsJson = new JsonArray(); for(final String context : contexts) { contextsJson.add(new JsonPrimitive(context)); } contentJson.add(CONTEXT, contextsJson); } if(params.containsKey(LIMIT))contentJson.addProperty(LIMIT, (Integer)params.get(LIMIT)); if(params.containsKey(HOPS))contentJson.addProperty(HOPS, (Integer)params.get(HOPS)); final Request request = RequestBuilder.post(PATH_SYNONYM).withBodyJson(contentJson).build(); final Response response = execute(request); final String synonymResultJson = ResponseUtil.getString(response); final List < SynonymResult > synonyms = GsonSingleton.getGson().fromJson(synonymResultJson, synonymListType); return synonyms; } ",
        "focal_src": "public List < SynonymResult > getSynonyms(Map < String, Object > params) { String[]words = (String[])params.get(WORDS); String[]traits = (String[])params.get(TRAITS); String[]contexts = (String[])params.get(CONTEXT); if(words == null || words.length == 0)throw new IllegalArgumentException(\"words can not be null or empty\"); JsonObject contentJson = new JsonObject(); JsonArray wordsJson = new JsonArray(); for(String word : words) { wordsJson.add(new JsonPrimitive(word)); } contentJson.add(WORDS, wordsJson); if(traits != null && traits.length > 0) { JsonArray traisJson = new JsonArray(); for(String trait : traits) { traisJson.add(new JsonPrimitive(trait)); } contentJson.add(TRAITS, traisJson); } if(contexts != null && contexts.length > 0) { JsonArray contextsJson = new JsonArray(); for(String context : contexts) { contextsJson.add(new JsonPrimitive(context)); } contentJson.add(CONTEXT, contextsJson); } if(params.containsKey(LIMIT))contentJson.addProperty(LIMIT, (Integer)params.get(LIMIT)); if(params.containsKey(HOPS))contentJson.addProperty(HOPS, (Integer)params.get(HOPS)); HttpRequestBase request = Request.Post(\"/v1/synonym\").withContent(contentJson).build(); HttpResponse response = execute(request); try { String synonymResultJson = ResponseUtil.getString(response); List < SynonymResult > synonyms = GsonSingleton.getGson().fromJson(synonymResultJson, synonymListType); return synonyms; } catch(IOException e) { throw new RuntimeException(e); } } ",
        "test_tgt": "@Test public void testGetSynonyms() { final Map < String, Object > params = new HashMap < String, Object > (); params.put(ToneAnalyzer.WORDS, new String[] { \"difficult\", \"inferior\" }); params.put(ToneAnalyzer.LIMIT, 3); final SynonymResult synonymResult1 = new SynonymResult(); synonymResult1.setTrait(\"openness\"); synonymResult1.setHeadword(\"difficult\"); final Synonym synonym10 = new Synonym(); synonym10.setWord(\"petrified\"); synonym10.setSense(\"difficult\"); synonym10.setMeaning(\"not easy\"); synonym10.setHops(0); synonym10.setSemanticType(\"adj-all\"); synonym10.setWeight( - 0.028989519600000006); final Synonym synonym11 = new Synonym(); synonym11.setWord(\"embarrassing\"); synonym11.setSense(\"difficult\"); synonym11.setMeaning(\"not easy\"); synonym11.setHops(0); synonym11.setSemanticType(\"adj-all\"); synonym11.setWeight( - 0.028989519600000); final Synonym synonym12 = new Synonym(); synonym12.setWord(\"tough\"); synonym12.setSense(\"difficult\"); synonym12.setMeaning(\"not easy\"); synonym12.setHops(0); synonym12.setSemanticType(\"adj-all\"); synonym12.setWeight( - 0.0289895196000009); synonymResult1.setSynonyms(new ArrayList < Synonym > () { { add(synonym10); add(synonym11); add(synonym12); } }); final SynonymResult synonymResult2 = new SynonymResult(); synonymResult2.setTrait(\"conscientious\"); synonymResult2.setHeadword(\"difficult\"); final Synonym synonym20 = new Synonym(); synonym20.setWord(\"trying\"); synonym20.setSense(\"difficult\"); synonym20.setMeaning(\"not easy\"); synonym20.setHops(0); synonym20.setSemanticType(\"adj-all\"); synonym20.setWeight( - 0.02898951960000002); final Synonym synonym21 = new Synonym(); synonym21.setWord(\"challenging\"); synonym21.setSense(\"difficult\"); synonym21.setMeaning(\"not easy\"); synonym21.setHops(0); synonym21.setSemanticType(\"adj-all\"); synonym21.setWeight( - 0.0289895196007); final Synonym synonym22 = new Synonym(); synonym22.setWord(\"tough\"); synonym22.setSense(\"difficult\"); synonym22.setMeaning(\"not easy\"); synonym22.setHops(0); synonym22.setSemanticType(\"adj-all\"); synonym22.setWeight( - 0.0289895196000099); synonymResult2.setSynonyms(new ArrayList < Synonym > () { { add(synonym20); add(synonym21); add(synonym22); } }); final SynonymResult synonymResult3 = new SynonymResult(); synonymResult3.setTrait(\"confident\"); synonymResult3.setHeadword(\"difficult\"); final Synonym synonym30 = new Synonym(); synonym30.setWord(\"firm\"); synonym30.setSense(\"difficult\"); synonym30.setMeaning(\"not easy\"); synonym30.setHops(0); synonym30.setSemanticType(\"adj-all\"); synonym30.setWeight( - 0.02898951960000112); synonymResult3.setSynonyms(new ArrayList < Synonym > () { { add(synonym30); } }); final List < SynonymResult > response = new ArrayList < SynonymResult > (); response.add(synonymResult1); response.add(synonymResult1); response.add(synonymResult1); final JsonObject contentJson = new JsonObject(); final JsonArray wordsJson = new JsonArray(); for(final String word : (String[])params.get(ToneAnalyzer.WORDS)) { wordsJson.add(new JsonPrimitive(word)); } contentJson.add(ToneAnalyzer.WORDS, wordsJson); if(params.containsKey(ToneAnalyzer.LIMIT))contentJson.addProperty(ToneAnalyzer.LIMIT, (Integer)params.get(ToneAnalyzer.LIMIT)); mockServer.when(request().withMethod(\"POST\").withPath(SYNONYM_PATH).withBody(contentJson.toString())).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGson().toJson(response))); final List < SynonymResult > synonyms = service.getSynonyms(params); Assert.assertNotNull(synonyms); Assert.assertFalse(synonyms.isEmpty()); Assert.assertEquals(synonyms, response); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should not fail validation if drug is null\", method = \"validate(Object,Errors)\")public void validate_shouldNotFailValidationIfDrugIsNull()throws Exception { DrugOrder order = new DrugOrder(); Errors errors = new BindException(order, \"order\"); new DrugOrderValidator().validate(order, errors); Assert.assertFalse(errors.hasFieldErrors(\"drug\")); } ",
        "focal_tgt": "public void validate(Object obj, Errors errors) { super.validate(obj, errors); DrugOrder order = (DrugOrder)obj; if(order == null) { errors.rejectValue(\"order\", \"error.general\"); } else { ValidationUtils.rejectIfEmpty(errors, \"prn\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"complex\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"drug\", \"error.null\"); if(order.getDrug() != null) { ValidationUtils.rejectIfEmpty(errors, \"drug.concept\", \"error.null\"); } if(order.getDose() != null || order.getEquivalentDailyDose() != null || order.getQuantity() != null) { ValidationUtils.rejectIfEmpty(errors, \"units\", \"DrugOrder.error.unitsNotSetWhenDoseOrQuantitySpecified\"); } } } ",
        "focal_src": "public void validate(Object obj, Errors errors) { super.validate(obj, errors); DrugOrder order = (DrugOrder)obj; if(order == null) { errors.rejectValue(\"order\", \"error.general\"); } else { ValidationUtils.rejectIfEmpty(errors, \"prn\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"complex\", \"error.null\"); } } ",
        "test_tgt": "@Test@Verifies(value = \"should fail validation if drug is null\", method = \"validate(Object,Errors)\")public void validate_shouldFailValidationIfDrugIsNull()throws Exception { DrugOrder order = new DrugOrder(); Errors errors = new BindException(order, \"order\"); new DrugOrderValidator().validate(order, errors); Assert.assertTrue(errors.hasFieldErrors(\"drug\")); } "
    },
    {
        "test_src": "@Test public void testGetSplits()throws Exception { Connector conn = getConnector(); String table = getUniqueNames(1)[0]; conn.tableOperations().create(table); insertData(table, currentTimeMillis()); ClientConfiguration clientConf = cluster.getClientConfig(); AccumuloConfiguration clusterClientConf = new ConfigurationCopy(new DefaultConfiguration()); boolean sslEnabled = Boolean.valueOf(clusterClientConf.get(Property.INSTANCE_RPC_SSL_ENABLED)); if(sslEnabled) { ClientProperty[]sslProperties = new ClientProperty[] { ClientProperty.INSTANCE_RPC_SSL_ENABLED, ClientProperty.INSTANCE_RPC_SSL_CLIENT_AUTH, ClientProperty.RPC_SSL_KEYSTORE_PATH, ClientProperty.RPC_SSL_KEYSTORE_TYPE, ClientProperty.RPC_SSL_KEYSTORE_PASSWORD, ClientProperty.RPC_SSL_TRUSTSTORE_PATH, ClientProperty.RPC_SSL_TRUSTSTORE_TYPE, ClientProperty.RPC_SSL_TRUSTSTORE_PASSWORD, ClientProperty.RPC_USE_JSSE, ClientProperty.GENERAL_SECURITY_CREDENTIAL_PROVIDER_PATHS }; for(ClientProperty prop : sslProperties) { clientConf.setProperty(prop, clusterClientConf.get(prop.getKey())); } } Job job = Job.getInstance(); AccumuloInputFormat.setInputTableName(job, table); AccumuloInputFormat.setZooKeeperInstance(job, clientConf); AccumuloInputFormat.setConnectorInfo(job, getAdminPrincipal(), getAdminToken()); TreeSet < Text > splitsToAdd = new TreeSet < Text > (); for(int i = 0; i < 10000; i += 1000)splitsToAdd.add(new Text(String.format(\"%09d\", i))); conn.tableOperations().addSplits(table, splitsToAdd); UtilWaitThread.sleep(500); Collection < Text > actualSplits = conn.tableOperations().listSplits(table); List < InputSplit > splits = inputFormat.getSplits(job); assertEquals(actualSplits.size() + 1, splits.size()); List < Range > ranges = new ArrayList < Range > (); for(Text text : actualSplits)ranges.add(new Range(text)); AccumuloInputFormat.setRanges(job, ranges); splits = inputFormat.getSplits(job); assertEquals(actualSplits.size(), splits.size()); AccumuloInputFormat.setOfflineTableScan(job, true); try { inputFormat.getSplits(job); fail(\"An exception should have been thrown\"); } catch(IOException e) { } conn.tableOperations().offline(table, true); splits = inputFormat.getSplits(job); assertEquals(actualSplits.size(), splits.size()); ranges = new ArrayList < Range > (); for(int i = 0; i < 5; i ++ )ranges.add(new Range(String.format(\"%09d\", i), String.format(\"%09d\", i + 2))); AccumuloInputFormat.setRanges(job, ranges); splits = inputFormat.getSplits(job); assertEquals(2, splits.size()); AccumuloInputFormat.setAutoAdjustRanges(job, false); splits = inputFormat.getSplits(job); assertEquals(ranges.size(), splits.size()); AccumuloInputFormat.setBatchScan(job, true); AccumuloInputFormat.setAutoAdjustRanges(job, true); AccumuloInputFormat.setOfflineTableScan(job, true); try { inputFormat.getSplits(job); fail(\"An exception should have been thrown\"); } catch(IllegalArgumentException e) { } conn.tableOperations().online(table, true); AccumuloInputFormat.setOfflineTableScan(job, false); splits = inputFormat.getSplits(job); assertEquals(2, splits.size()); AccumuloInputFormat.setScanIsolation(job, true); try { inputFormat.getSplits(job); fail(\"An exception should have been thrown\"); } catch(IllegalArgumentException e) { } AccumuloInputFormat.setScanIsolation(job, false); splits = inputFormat.getSplits(job); assertEquals(2, splits.size()); AccumuloInputFormat.setLocalIterators(job, true); try { inputFormat.getSplits(job); fail(\"An exception should have been thrown\"); } catch(IllegalArgumentException e) { } AccumuloInputFormat.setLocalIterators(job, false); conn.tableOperations().online(table); splits = inputFormat.getSplits(job); for(InputSplit split : splits)assert(split instanceof BatchInputSplit); assertEquals(2, splits.size()); } ",
        "focal_tgt": "@Override public InputSplit[]getSplits(JobConf job, int numSplits)throws IOException { Level logLevel = getLogLevel(job); log.setLevel(logLevel); validateOptions(job); Random random = new Random(); LinkedList < InputSplit > splits = new LinkedList < > (); Map < String, InputTableConfig > tableConfigs = getInputTableConfigs(job); for(Map.Entry < String, InputTableConfig > tableConfigEntry : tableConfigs.entrySet()) { String tableName = tableConfigEntry.getKey(); InputTableConfig tableConfig = tableConfigEntry.getValue(); Instance instance = getInstance(job); String tableId; if(instance instanceof MockInstance) { tableId = \"\"; } else { try { tableId = Tables.getTableId(instance, tableName); } catch(TableNotFoundException e) { throw new IOException(e); } } Authorizations auths = getScanAuthorizations(job); String principal = getPrincipal(job); AuthenticationToken token = getAuthenticationToken(job); boolean batchScan = InputConfigurator.isBatchScan(CLASS, job); boolean supportBatchScan = ! (tableConfig.isOfflineScan() || tableConfig.shouldUseIsolatedScanners() || tableConfig.shouldUseLocalIterators()); if(batchScan && ! supportBatchScan)throw new IllegalArgumentException(\"BatchScanner optimization not available for offline scan, isolated, or local iterators\"); boolean autoAdjust = tableConfig.shouldAutoAdjustRanges(); if(batchScan && ! autoAdjust)throw new IllegalArgumentException(\"AutoAdjustRanges must be enabled when using BatchScanner optimization\"); List < Range > ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges(); if(ranges.isEmpty()) { ranges = new ArrayList < > (1); ranges.add(new Range()); } Map < String, Map < KeyExtent, List < Range > > > binnedRanges = new HashMap < > (); TabletLocator tl; try { if(tableConfig.isOfflineScan()) { binnedRanges = binOfflineTable(job, tableId, ranges); while(binnedRanges == null) { UtilWaitThread.sleep(100 + random.nextInt(100)); binnedRanges = binOfflineTable(job, tableId, ranges); } } else { tl = InputConfigurator.getTabletLocator(CLASS, job, tableId); tl.invalidateCache(); ClientContext context = new ClientContext(getInstance(job), new Credentials(getPrincipal(job), getAuthenticationToken(job)), getClientConfiguration(job)); while( ! tl.binRanges(context, ranges, binnedRanges).isEmpty()) { if( ! (instance instanceof MockInstance)) { if( ! Tables.exists(instance, tableId))throw new TableDeletedException(tableId); if(Tables.getTableState(instance, tableId) == TableState.OFFLINE)throw new TableOfflineException(instance, tableId); } binnedRanges.clear(); log.warn(\"Unable to locate bins for specified ranges. Retrying.\"); UtilWaitThread.sleep(100 + random.nextInt(100)); tl.invalidateCache(); } } } catch(Exception e) { throw new IOException(e); } HashMap < Range, ArrayList < String > > splitsToAdd = null; if( ! autoAdjust)splitsToAdd = new HashMap < > (); HashMap < String, String > hostNameCache = new HashMap < > (); for(Map.Entry < String, Map < KeyExtent, List < Range > > > tserverBin : binnedRanges.entrySet()) { String ip = tserverBin.getKey().split(\":\", 2)[0]; String location = hostNameCache.get(ip); if(location == null) { InetAddress inetAddress = InetAddress.getByName(ip); location = inetAddress.getCanonicalHostName(); hostNameCache.put(ip, location); } for(Map.Entry < KeyExtent, List < Range > > extentRanges : tserverBin.getValue().entrySet()) { Range ke = extentRanges.getKey().toDataRange(); if(batchScan) { ArrayList < Range > clippedRanges = new ArrayList < > (); for(Range r : extentRanges.getValue())clippedRanges.add(ke.clip(r)); BatchInputSplit split = new BatchInputSplit(tableName, tableId, clippedRanges, new String[] { location }); SplitUtils.updateSplit(split, instance, tableConfig, principal, token, auths, logLevel); splits.add(split); } else { for(Range r : extentRanges.getValue()) { if(autoAdjust) { RangeInputSplit split = new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }); SplitUtils.updateSplit(split, instance, tableConfig, principal, token, auths, logLevel); split.setOffline(tableConfig.isOfflineScan()); split.setIsolatedScan(tableConfig.shouldUseIsolatedScanners()); split.setUsesLocalIterators(tableConfig.shouldUseLocalIterators()); splits.add(split); } else { ArrayList < String > locations = splitsToAdd.get(r); if(locations == null)locations = new ArrayList < > (1); locations.add(location); splitsToAdd.put(r, locations); } } } } } if( ! autoAdjust)for(Map.Entry < Range, ArrayList < String > > entry : splitsToAdd.entrySet()) { RangeInputSplit split = new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])); SplitUtils.updateSplit(split, instance, tableConfig, principal, token, auths, logLevel); split.setOffline(tableConfig.isOfflineScan()); split.setIsolatedScan(tableConfig.shouldUseIsolatedScanners()); split.setUsesLocalIterators(tableConfig.shouldUseLocalIterators()); splits.add(split); } } return splits.toArray(new InputSplit[splits.size()]); } ",
        "focal_src": "@Override public InputSplit[]getSplits(JobConf job, int numSplits)throws IOException { Level logLevel = getLogLevel(job); log.setLevel(logLevel); validateOptions(job); Random random = new Random(); LinkedList < InputSplit > splits = new LinkedList < InputSplit > (); Map < String, InputTableConfig > tableConfigs = getInputTableConfigs(job); for(Map.Entry < String, InputTableConfig > tableConfigEntry : tableConfigs.entrySet()) { String tableName = tableConfigEntry.getKey(); InputTableConfig tableConfig = tableConfigEntry.getValue(); Instance instance = getInstance(job); String tableId; if(instance instanceof MockInstance) { tableId = \"\"; } else { try { tableId = Tables.getTableId(instance, tableName); } catch(TableNotFoundException e) { throw new IOException(e); } } Authorizations auths = getScanAuthorizations(job); String principal = getPrincipal(job); AuthenticationToken token = getAuthenticationToken(job); boolean batchScan = InputConfigurator.isBatchScan(CLASS, job); boolean supportBatchScan = ! (tableConfig.isOfflineScan() || tableConfig.shouldUseIsolatedScanners() || tableConfig.shouldUseLocalIterators()); if(batchScan && ! supportBatchScan)throw new IllegalArgumentException(\"BatchScanner optimization not available for offline scan, isolated, or local iterators\"); boolean autoAdjust = tableConfig.shouldAutoAdjustRanges(); if(batchScan && ! autoAdjust)throw new IllegalArgumentException(\"AutoAdjustRanges must be enabled when using BatchScanner optimization\"); List < Range > ranges = autoAdjust ? Range.mergeOverlapping(tableConfig.getRanges()) : tableConfig.getRanges(); if(ranges.isEmpty()) { ranges = new ArrayList < Range > (1); ranges.add(new Range()); } Map < String, Map < KeyExtent, List < Range > > > binnedRanges = new HashMap < String, Map < KeyExtent, List < Range > > > (); TabletLocator tl; try { if(tableConfig.isOfflineScan()) { binnedRanges = binOfflineTable(job, tableId, ranges); while(binnedRanges == null) { UtilWaitThread.sleep(100 + random.nextInt(100)); binnedRanges = binOfflineTable(job, tableId, ranges); } } else { tl = InputConfigurator.getTabletLocator(CLASS, job, tableId); tl.invalidateCache(); ClientContext context = new ClientContext(getInstance(job), new Credentials(getPrincipal(job), getAuthenticationToken(job)), getClientConfiguration(job)); while( ! tl.binRanges(context, ranges, binnedRanges).isEmpty()) { if( ! (instance instanceof MockInstance)) { if( ! Tables.exists(instance, tableId))throw new TableDeletedException(tableId); if(Tables.getTableState(instance, tableId) == TableState.OFFLINE)throw new TableOfflineException(instance, tableId); } binnedRanges.clear(); log.warn(\"Unable to locate bins for specified ranges. Retrying.\"); UtilWaitThread.sleep(100 + random.nextInt(100)); tl.invalidateCache(); } } } catch(Exception e) { throw new IOException(e); } HashMap < Range, ArrayList < String > > splitsToAdd = null; if( ! autoAdjust)splitsToAdd = new HashMap < Range, ArrayList < String > > (); HashMap < String, String > hostNameCache = new HashMap < String, String > (); for(Map.Entry < String, Map < KeyExtent, List < Range > > > tserverBin : binnedRanges.entrySet()) { String ip = tserverBin.getKey().split(\":\", 2)[0]; String location = hostNameCache.get(ip); if(location == null) { InetAddress inetAddress = InetAddress.getByName(ip); location = inetAddress.getCanonicalHostName(); hostNameCache.put(ip, location); } for(Map.Entry < KeyExtent, List < Range > > extentRanges : tserverBin.getValue().entrySet()) { Range ke = extentRanges.getKey().toDataRange(); if(batchScan) { ArrayList < Range > clippedRanges = new ArrayList < Range > (); for(Range r : extentRanges.getValue())clippedRanges.add(ke.clip(r)); BatchInputSplit split = new BatchInputSplit(tableName, tableId, clippedRanges, new String[] { location }); SplitUtils.updateSplit(split, instance, tableConfig, principal, token, auths, logLevel); splits.add(split); } else { for(Range r : extentRanges.getValue()) { if(autoAdjust) { RangeInputSplit split = new RangeInputSplit(tableName, tableId, ke.clip(r), new String[] { location }); SplitUtils.updateSplit(split, instance, tableConfig, principal, token, auths, logLevel); split.setOffline(tableConfig.isOfflineScan()); split.setIsolatedScan(tableConfig.shouldUseIsolatedScanners()); split.setUsesLocalIterators(tableConfig.shouldUseLocalIterators()); splits.add(split); } else { ArrayList < String > locations = splitsToAdd.get(r); if(locations == null)locations = new ArrayList < String > (1); locations.add(location); splitsToAdd.put(r, locations); } } } } } if( ! autoAdjust)for(Map.Entry < Range, ArrayList < String > > entry : splitsToAdd.entrySet()) { RangeInputSplit split = new RangeInputSplit(tableName, tableId, entry.getKey(), entry.getValue().toArray(new String[0])); SplitUtils.updateSplit(split, instance, tableConfig, principal, token, auths, logLevel); split.setOffline(tableConfig.isOfflineScan()); split.setIsolatedScan(tableConfig.shouldUseIsolatedScanners()); split.setUsesLocalIterators(tableConfig.shouldUseLocalIterators()); splits.add(split); } } return splits.toArray(new InputSplit[splits.size()]); } ",
        "test_tgt": "@Test public void testGetSplits()throws Exception { Connector conn = getConnector(); String table = getUniqueNames(1)[0]; conn.tableOperations().create(table); insertData(table, currentTimeMillis()); ClientConfiguration clientConf = cluster.getClientConfig(); AccumuloConfiguration clusterClientConf = new ConfigurationCopy(new DefaultConfiguration()); boolean sslEnabled = Boolean.valueOf(clusterClientConf.get(Property.INSTANCE_RPC_SSL_ENABLED)); if(sslEnabled) { ClientProperty[]sslProperties = new ClientProperty[] { ClientProperty.INSTANCE_RPC_SSL_ENABLED, ClientProperty.INSTANCE_RPC_SSL_CLIENT_AUTH, ClientProperty.RPC_SSL_KEYSTORE_PATH, ClientProperty.RPC_SSL_KEYSTORE_TYPE, ClientProperty.RPC_SSL_KEYSTORE_PASSWORD, ClientProperty.RPC_SSL_TRUSTSTORE_PATH, ClientProperty.RPC_SSL_TRUSTSTORE_TYPE, ClientProperty.RPC_SSL_TRUSTSTORE_PASSWORD, ClientProperty.RPC_USE_JSSE, ClientProperty.GENERAL_SECURITY_CREDENTIAL_PROVIDER_PATHS }; for(ClientProperty prop : sslProperties) { clientConf.setProperty(prop, clusterClientConf.get(prop.getKey())); } } Job job = Job.getInstance(); AccumuloInputFormat.setInputTableName(job, table); AccumuloInputFormat.setZooKeeperInstance(job, clientConf); AccumuloInputFormat.setConnectorInfo(job, getAdminPrincipal(), getAdminToken()); TreeSet < Text > splitsToAdd = new TreeSet < > (); for(int i = 0; i < 10000; i += 1000)splitsToAdd.add(new Text(String.format(\"%09d\", i))); conn.tableOperations().addSplits(table, splitsToAdd); UtilWaitThread.sleep(500); Collection < Text > actualSplits = conn.tableOperations().listSplits(table); List < InputSplit > splits = inputFormat.getSplits(job); assertEquals(actualSplits.size() + 1, splits.size()); List < Range > ranges = new ArrayList < > (); for(Text text : actualSplits)ranges.add(new Range(text)); AccumuloInputFormat.setRanges(job, ranges); splits = inputFormat.getSplits(job); assertEquals(actualSplits.size(), splits.size()); AccumuloInputFormat.setOfflineTableScan(job, true); try { inputFormat.getSplits(job); fail(\"An exception should have been thrown\"); } catch(IOException e) { } conn.tableOperations().offline(table, true); splits = inputFormat.getSplits(job); assertEquals(actualSplits.size(), splits.size()); ranges = new ArrayList < > (); for(int i = 0; i < 5; i ++ )ranges.add(new Range(String.format(\"%09d\", i), String.format(\"%09d\", i + 2))); AccumuloInputFormat.setRanges(job, ranges); splits = inputFormat.getSplits(job); assertEquals(2, splits.size()); AccumuloInputFormat.setAutoAdjustRanges(job, false); splits = inputFormat.getSplits(job); assertEquals(ranges.size(), splits.size()); AccumuloInputFormat.setBatchScan(job, true); AccumuloInputFormat.setAutoAdjustRanges(job, true); AccumuloInputFormat.setOfflineTableScan(job, true); try { inputFormat.getSplits(job); fail(\"An exception should have been thrown\"); } catch(IllegalArgumentException e) { } conn.tableOperations().online(table, true); AccumuloInputFormat.setOfflineTableScan(job, false); splits = inputFormat.getSplits(job); assertEquals(2, splits.size()); AccumuloInputFormat.setScanIsolation(job, true); try { inputFormat.getSplits(job); fail(\"An exception should have been thrown\"); } catch(IllegalArgumentException e) { } AccumuloInputFormat.setScanIsolation(job, false); splits = inputFormat.getSplits(job); assertEquals(2, splits.size()); AccumuloInputFormat.setLocalIterators(job, true); try { inputFormat.getSplits(job); fail(\"An exception should have been thrown\"); } catch(IllegalArgumentException e) { } AccumuloInputFormat.setLocalIterators(job, false); conn.tableOperations().online(table); splits = inputFormat.getSplits(job); for(InputSplit split : splits)assert(split instanceof BatchInputSplit); assertEquals(2, splits.size()); } "
    },
    {
        "test_src": "@Test public void testOnTopicCreated_retryTimeout(TestContext context) { TopicMetadata topicMetadata = getTopicMetadata(); mockKafka.setTopicMetadataResponse(topicName, null, new UnknownTopicOrPartitionException()); Async async = context.async(); op.onTopicCreated(topicName, ar -> { assertFailed(context, ar); context.assertEquals(ar.cause().getClass(), MaxAttemptsExceededException.class); mockK8s.assertNotExists(context, mapName); mockTopicStore.assertNotExists(context, topicName); async.complete(); }); } ",
        "focal_tgt": "void onTopicCreated(TopicName topicName, Handler < AsyncResult < Void > > resultHandler) { Handler < Future < Void > > futureHandler = new Reconciliation(\"onTopicCreated\") { @Override public void handle(Future < Void > fut) { Handler < AsyncResult < TopicMetadata > > handler = new Handler < AsyncResult < TopicMetadata > > () { private final BackOff backOff = new BackOff(); @Override public void handle(AsyncResult < TopicMetadata > metadataResult) { if(metadataResult.succeeded()) { if(metadataResult.result() == null) { long delay; try { delay = backOff.delayMs(); logger.debug(\"Topic {} created in ZK, but no metadata available from Kafka yet: Backing off for {}ms\", topicName, delay); } catch(MaxAttemptsExceededException e) { logger.info(\"Topic {} created in ZK, and no metadata available from Kafka after {}ms, giving up for now\", topicName, backOff.totalDelayMs()); fut.fail(e); return; } if(delay < 1) { vertx.runOnContext(timerId -> kafka.topicMetadata(topicName, this)); } else { vertx.setTimer(TimeUnit.MILLISECONDS.convert(delay, TimeUnit.MILLISECONDS), timerId -> kafka.topicMetadata(topicName, this)); } } else { Topic kafkaTopic = TopicSerialization.fromTopicMetadata(metadataResult.result()); reconcileOnTopicChange(topicName, kafkaTopic, fut); } } else { fut.handle(metadataResult.map((Void)null)); } } }; kafka.topicMetadata(topicName, handler); } }; inFlight.enqueue(topicName, resultHandler, futureHandler); } ",
        "focal_src": "public void onTopicCreated(TopicName topicName, Handler < AsyncResult < Void > > resultHandler) { if(inFlight.shouldProcessTopicCreate(topicName)) { Handler < AsyncResult < TopicMetadata > > handler = new Handler < AsyncResult < TopicMetadata > > () { BackOff backOff = new BackOff(); @Override public void handle(AsyncResult < TopicMetadata > metadataResult) { if(metadataResult.failed()) { if(metadataResult.cause()instanceof UnknownTopicOrPartitionException) { long delay; try { delay = backOff.delayMs(); } catch(MaxAttemptsExceededException e) { resultHandler.handle(Future.failedFuture(e)); return; } if(delay < 1) { vertx.runOnContext(timerId -> kafka.topicMetadata(topicName, this)); } else { vertx.setTimer(TimeUnit.MILLISECONDS.convert(delay, TimeUnit.MILLISECONDS), timerId -> kafka.topicMetadata(topicName, this)); } } else { resultHandler.handle(Future.failedFuture(metadataResult.cause())); } } else { Topic topic = TopicSerialization.fromTopicMetadata(metadataResult.result()); enqueue(new CreateConfigMap(topic, kubeResult -> { if(kubeResult.succeeded()) { enqueue(new CreateInTopicStore(topic, null, resultHandler)); } else { resultHandler.handle(kubeResult); } })); } } }; kafka.topicMetadata(topicName, handler); } else { resultHandler.handle(Future.succeededFuture()); } } ",
        "test_tgt": "@Test public void testOnTopicCreated_retryTimeout(TestContext context) { TopicMetadata topicMetadata = getTopicMetadata(); mockKafka.setTopicMetadataResponse(topicName, null, null); Async async = context.async(); controller.onTopicCreated(topicName, ar -> { assertFailed(context, ar); context.assertEquals(ar.cause().getClass(), MaxAttemptsExceededException.class); mockK8s.assertNotExists(context, mapName); mockTopicStore.assertNotExists(context, topicName); async.complete(); }); } "
    },
    {
        "test_src": "@Test public void testSizeLe() { assertEquals(new SizeLeCriterion(\"id\", 3), instance.sizeLe(\"id\", 3).getQueryCriterion()); } ",
        "focal_tgt": "public CriteriaQuery sizeLe(String propName, int size) { criterion = criterion.and(Criteria.sizeLe(propName, size)); return this; } ",
        "focal_src": "public CriteriaQuery sizeLe(String propName, int size) { criterion = criterion.and(criterionBuilder.sizeLe(propName, size)); return this; } ",
        "test_tgt": "@Test public void testSizeLe() { assertEquals(Criteria.sizeLe(\"id\", 3), instance.sizeLe(\"id\", 3).getQueryCriterion()); } "
    },
    {
        "test_src": "@Test public void testLoadWebSubmissionExtension()throws Exception { final Configuration configuration = new Configuration(); configuration.setString(JobManagerOptions.ADDRESS, \"localhost\"); final WebMonitorExtension webMonitorExtension = WebMonitorUtils.loadWebSubmissionExtension(CompletableFuture :: new, Time.seconds(10), Collections.emptyMap(), CompletableFuture.completedFuture(\"localhost:12345\"), Paths.get(\"/tmp\"), Executors.directExecutor(), configuration); assertThat(webMonitorExtension, is(not(nullValue()))); } ",
        "focal_tgt": "public static WebMonitorExtension loadWebSubmissionExtension(GatewayRetriever < ? extends DispatcherGateway > leaderRetriever, CompletableFuture < String > restAddressFuture, Time timeout, Map < String, String > responseHeaders, java.nio.file.Path uploadDir, Executor executor, Configuration configuration)throws FlinkException { if(isFlinkRuntimeWebInClassPath()) { try { final Constructor < ? > webSubmissionExtensionConstructor = Class.forName(\"org.apache.flink.runtime.webmonitor.WebSubmissionExtension\").getConstructor(Configuration.class, CompletableFuture.class, GatewayRetriever.class, Map.class, java.nio.file.Path.class, Executor.class, Time.class); return(WebMonitorExtension)webSubmissionExtensionConstructor.newInstance(configuration, restAddressFuture, leaderRetriever, responseHeaders, uploadDir, executor, timeout); } catch(ClassNotFoundException | NoSuchMethodException | InstantiationException | InvocationTargetException | IllegalAccessException e) { throw new FlinkException(\"Could not load web submission extension.\", e); } } else { throw new FlinkException(\"The module flink-runtime-web could not be found in the class path. Please add \" + \"this jar in order to enable web based job submission.\"); } } ",
        "focal_src": "public static WebMonitorExtension loadWebSubmissionExtension(GatewayRetriever < ? extends DispatcherGateway > leaderRetriever, Time timeout, Map < String, String > responseHeaders, CompletableFuture < String > localAddressFuture, java.nio.file.Path uploadDir, Executor executor, Configuration configuration)throws FlinkException { if(isFlinkRuntimeWebInClassPath()) { try { final Constructor < ? > webSubmissionExtensionConstructor = Class.forName(\"org.apache.flink.runtime.webmonitor.WebSubmissionExtension\").getConstructor(Configuration.class, GatewayRetriever.class, Map.class, CompletableFuture.class, java.nio.file.Path.class, Executor.class, Time.class); return(WebMonitorExtension)webSubmissionExtensionConstructor.newInstance(configuration, leaderRetriever, responseHeaders, localAddressFuture, uploadDir, executor, timeout); } catch(ClassNotFoundException | NoSuchMethodException | InstantiationException | InvocationTargetException | IllegalAccessException e) { throw new FlinkException(\"Could not load web submission extension.\", e); } } else { throw new FlinkException(\"The module flink-runtime-web could not be found in the class path. Please add \" + \"this jar in order to enable web based job submission.\"); } } ",
        "test_tgt": "@Test public void testLoadWebSubmissionExtension()throws Exception { final Configuration configuration = new Configuration(); configuration.setString(JobManagerOptions.ADDRESS, \"localhost\"); final WebMonitorExtension webMonitorExtension = WebMonitorUtils.loadWebSubmissionExtension(CompletableFuture :: new, CompletableFuture.completedFuture(\"localhost:12345\"), Time.seconds(10), Collections.emptyMap(), Paths.get(\"/tmp\"), Executors.directExecutor(), configuration); assertThat(webMonitorExtension, is(not(nullValue()))); } "
    },
    {
        "test_src": "@Test public void testEncode() { String result = NSNameResourceCodec.encode(\"ws\", \"name\"); assertEquals(\"ws__name\", result); } ",
        "focal_tgt": "@Override public void encode(Object o)throws IllegalArgumentException { if( ! (o instanceof DescribeCoverageType)) { throw new IllegalArgumentException(new StringBuffer(\"Not a GetCapabilitiesType: \").append(o).toString()); } this.request = (DescribeCoverageType)o; final AttributesImpl attributes = WCS20Const.getDefaultNamespaces(); List < String > badCoverageIds = new ArrayList < String > (); List < LayerInfo > coverages = new ArrayList < LayerInfo > (); for(String encodedCoverageId : (List < String > )request.getCoverageId()) { LayerInfo layer = NCNameResourceCodec.getCoverage(catalog, encodedCoverageId); if(layer != null) { coverages.add(layer); } else { badCoverageIds.add(encodedCoverageId); } } if( ! badCoverageIds.isEmpty()) { String mergedIds = StringUtils.merge(badCoverageIds); throw new WCS20Exception(\"Could not find the requested coverage(s): \" + mergedIds, WCS20Exception.WCSExceptionCode.NoSuchCoverage, mergedIds); } start(\"wcs:CoverageDescriptions\", attributes); for(LayerInfo layer : coverages) { CoverageInfo ci = catalog.getCoverageByName(layer.prefixedName()); try { handleCoverageDescription(ci); } catch(Exception e) { throw new RuntimeException(\"Unexpected error occurred during describe coverage xml encoding\", e); } } end(\"wcs:CoverageDescriptions\"); } ",
        "focal_src": "@Override public void encode(Object o)throws IllegalArgumentException { if( ! (o instanceof DescribeCoverageType)) { throw new IllegalArgumentException(new StringBuffer(\"Not a GetCapabilitiesType: \").append(o).toString()); } this.request = (DescribeCoverageType)o; final AttributesImpl attributes = WCS20Const.getDefaultNamespaces(); List < String > badCoverageIds = new ArrayList < String > (); List < LayerInfo > coverages = new ArrayList < LayerInfo > (); for(String encodedCoverageId : (List < String > )request.getCoverageId()) { LayerInfo layer = getCoverage(encodedCoverageId); if(layer != null) { coverages.add(layer); } else { badCoverageIds.add(encodedCoverageId); } } if( ! badCoverageIds.isEmpty()) { String mergedIds = StringUtils.merge(badCoverageIds); throw new WCS20Exception(\"Could not find the requested coverage(s): \" + mergedIds, WCS20Exception.WCSExceptionCode.NoSuchCoverage, mergedIds); } start(\"wcs:CoverageDescriptions\", attributes); for(LayerInfo layer : coverages) { CoverageInfo ci = catalog.getCoverageByName(layer.prefixedName()); try { handleCoverageDescription(ci); } catch(Exception e) { throw new RuntimeException(\"Unexpected error occurred during describe coverage xml encoding\", e); } } end(\"wcs:CoverageDescriptions\"); } ",
        "test_tgt": "@Test public void testEncode() { String result = NCNameResourceCodec.encode(\"ws\", \"name\"); assertEquals(\"ws__name\", result); } "
    },
    {
        "test_src": "@Test public void testSubscribe() { Logger.getLogger(ControllerTest.class.getName()).info(\"subscribe\"); final String callback = \"http://localhost/doNothing\"; final String topic = \"http://feeds.feedburner.com/screaming-penguin\"; final long lease_seconds = - 1; final String secret = null; final String verify_token = \"MyVoiceIsMyPassport\"; final HubDAO dao = new InMemoryHubDAO(); final Notifier notifier = null; final FeedFetcher fetcher = new HttpURLFeedFetcher(HashMapFeedInfoCache.getInstance()); Hub instance = new Hub(dao, new AlwaysVerifier(), notifier, fetcher); Boolean result = instance.subscribe(callback, topic, \"sync\", lease_seconds, secret, verify_token); assertEquals(true, result); instance = new Hub(dao, new NeverVerifier(), notifier, fetcher); result = instance.subscribe(callback, topic, \"sync\", lease_seconds, secret, verify_token); assertEquals(false, result); result = instance.subscribe(callback, topic, \"async\", lease_seconds, secret, verify_token); assertEquals(null, result); try { instance.subscribe(null, topic, \"async\", lease_seconds, secret, verify_token); fail(); } catch(final HttpStatusCodeException e) { assertEquals(400, e.getStatus()); Logger.getLogger(ControllerTest.class.getName()).info(e.getMessage()); } try { instance.subscribe(callback, null, \"async\", lease_seconds, secret, verify_token); fail(); } catch(final HttpStatusCodeException e) { assertEquals(400, e.getStatus()); Logger.getLogger(ControllerTest.class.getName()).info(e.getMessage()); } try { instance.subscribe(callback, topic, \"foo\", lease_seconds, secret, verify_token); fail(); } catch(final HttpStatusCodeException e) { assertEquals(400, e.getStatus()); Logger.getLogger(ControllerTest.class.getName()).info(e.getMessage()); } instance = new Hub(dao, new ExceptionVerifier(), notifier, fetcher); try { result = instance.subscribe(callback, topic, \"sync\", lease_seconds, secret, verify_token); fail(); } catch(final HttpStatusCodeException e) { assertEquals(500, e.getStatus()); } } ",
        "focal_tgt": "public Boolean subscribe(final String callback, final String topic, final String verify, final long lease_seconds, final String secret, final String verify_token) { LOG.debug(\"{} wants to subscribe to {}\", callback, topic); try { try { assert callback != null : \"Callback URL is required.\"; assert topic != null : \"Topic URL is required.\"; final URI uri = new URI(callback); assert validSchemes.contains(uri.getScheme()) : \"Not a valid protocol \" + uri.getScheme(); assert validPorts.isEmpty() || validPorts.contains(uri.getPort()) : \"Not a valid port \" + uri.getPort(); assert validTopics.isEmpty() || validTopics.contains(topic) : \"Not a supported topic \" + topic; } catch(final URISyntaxException ex) { assert false : \"Not a valid URI \" + callback; } assert verify != null && (verify.equals(Subscriber.VERIFY_ASYNC) || verify.equals(Subscriber.VERIFY_SYNC)) : \"Unexpected verify value \" + verify; final Subscriber subscriber = new Subscriber(); subscriber.setCallback(callback); subscriber.setLeaseSeconds(lease_seconds); subscriber.setSecret(secret); subscriber.setTopic(topic); subscriber.setVerify(verify); subscriber.setVertifyToken(verify_token); final VerificationCallback verified = new VerificationCallback() { @Override public void onVerify(final boolean verified) { if(verified) { LOG.debug(\"Verified {} subscribed to {}\", subscriber.getCallback(), subscriber.getTopic()); dao.addSubscriber(subscriber); } } }; if(Subscriber.VERIFY_SYNC.equals(subscriber.getVerify())) { final boolean result = verifier.verifySubcribeSyncronously(subscriber); verified.onVerify(result); return result; } else { verifier.verifySubscribeAsyncronously(subscriber, verified); return null; } } catch(final AssertionError ae) { throw new HttpStatusCodeException(400, ae.getMessage(), ae); } catch(final Exception e) { throw new HttpStatusCodeException(500, e.getMessage(), e); } } ",
        "focal_src": "public Boolean subscribe(final String callback, final String topic, final String verify, final long lease_seconds, final String secret, final String verify_token) { Logger.getLogger(Hub.class.getName()).log(Level.FINE, \"{0} wants to subscribe to {1}\", new Object[] { callback, topic }); try { try { assert callback != null : \"Callback URL is required.\"; assert topic != null : \"Topic URL is required.\"; final URI uri = new URI(callback); assert validSchemes.contains(uri.getScheme()) : \"Not a valid protocol \" + uri.getScheme(); assert validPorts.isEmpty() || validPorts.contains(uri.getPort()) : \"Not a valid port \" + uri.getPort(); assert validTopics.isEmpty() || validTopics.contains(topic) : \"Not a supported topic \" + topic; } catch(final URISyntaxException ex) { assert false : \"Not a valid URI \" + callback; } assert verify != null && (verify.equals(Subscriber.VERIFY_ASYNC) || verify.equals(Subscriber.VERIFY_SYNC)) : \"Unexpected verify value \" + verify; final Subscriber subscriber = new Subscriber(); subscriber.setCallback(callback); subscriber.setLeaseSeconds(lease_seconds); subscriber.setSecret(secret); subscriber.setTopic(topic); subscriber.setVerify(verify); subscriber.setVertifyToken(verify_token); final VerificationCallback verified = new VerificationCallback() { @Override public void onVerify(final boolean verified) { if(verified) { Logger.getLogger(Hub.class.getName()).log(Level.FINE, \"Verified {0} subscribed to {1}\", new Object[] { subscriber.getCallback(), subscriber.getTopic() }); dao.addSubscriber(subscriber); } } }; if(Subscriber.VERIFY_SYNC.equals(subscriber.getVerify())) { final boolean result = verifier.verifySubcribeSyncronously(subscriber); verified.onVerify(result); return result; } else { verifier.verifySubscribeAsyncronously(subscriber, verified); return null; } } catch(final AssertionError ae) { throw new HttpStatusCodeException(400, ae.getMessage(), ae); } catch(final Exception e) { throw new HttpStatusCodeException(500, e.getMessage(), e); } } ",
        "test_tgt": "@Test public void testSubscribe() { LOG.info(\"subscribe\"); final String callback = \"http://localhost/doNothing\"; final String topic = \"http://feeds.feedburner.com/screaming-penguin\"; final long lease_seconds = - 1; final String secret = null; final String verify_token = \"MyVoiceIsMyPassport\"; final HubDAO dao = new InMemoryHubDAO(); final Notifier notifier = null; final FeedFetcher fetcher = new HttpURLFeedFetcher(HashMapFeedInfoCache.getInstance()); Hub instance = new Hub(dao, new AlwaysVerifier(), notifier, fetcher); Boolean result = instance.subscribe(callback, topic, \"sync\", lease_seconds, secret, verify_token); assertEquals(true, result); instance = new Hub(dao, new NeverVerifier(), notifier, fetcher); result = instance.subscribe(callback, topic, \"sync\", lease_seconds, secret, verify_token); assertEquals(false, result); result = instance.subscribe(callback, topic, \"async\", lease_seconds, secret, verify_token); assertEquals(null, result); try { instance.subscribe(null, topic, \"async\", lease_seconds, secret, verify_token); fail(); } catch(final HttpStatusCodeException e) { assertEquals(400, e.getStatus()); LOG.info(e.getMessage()); } try { instance.subscribe(callback, null, \"async\", lease_seconds, secret, verify_token); fail(); } catch(final HttpStatusCodeException e) { assertEquals(400, e.getStatus()); LOG.info(e.getMessage()); } try { instance.subscribe(callback, topic, \"foo\", lease_seconds, secret, verify_token); fail(); } catch(final HttpStatusCodeException e) { assertEquals(400, e.getStatus()); LOG.info(e.getMessage()); } instance = new Hub(dao, new ExceptionVerifier(), notifier, fetcher); try { result = instance.subscribe(callback, topic, \"sync\", lease_seconds, secret, verify_token); fail(); } catch(final HttpStatusCodeException e) { assertEquals(500, e.getStatus()); } } "
    },
    {
        "test_src": "@Test public void query() { contains(_CLIENT_EXECUTE.args(conn(), new ShowUsers()), Text.S_USERINFO[0]); query(\"let $a := \" + conn() + \", $b := \" + conn() + \" return \" + _CLIENT_QUERY.args(\"$a\", \"1\") + '+' + _CLIENT_QUERY.args(\"$b\", \"2\"), \"3\"); query(_CLIENT_QUERY.args(conn(), \"\\\"$a*2\\\"\", \" map { 'a': 1 }\"), \"2\"); error(_CLIENT_QUERY.args(conn(), \"x\"), Err.NOCTX); error(_CLIENT_QUERY.args(conn(), \"\\\"$a\\\"\", \" map { 'a': (1,2) }\"), Err.BXCL_ITEM); } ",
        "focal_tgt": "private AQuery query(final Function f) { final HTTPContext http = session.http; final String query = \"declare variable $d external;\" + \"declare variable $p external;\" + f.args(\"$d\", \"$p\"); return new XQuery(query).bind(\"d\", http.db()).bind(\"p\", http.dbpath()); } ",
        "focal_src": "private AQuery query(final Function f) { final HTTPContext http = session.http; return new XQuery(f.args(\"$d\", \"$p\")).bind(\"d\", http.db()).bind(\"p\", http.dbpath()); } ",
        "test_tgt": "@Test public void query() { contains(_CLIENT_EXECUTE.args(conn(), new ShowUsers()), Text.S_USERINFO[0]); query(\"let $a := \" + conn() + \", $b := \" + conn() + \" return \" + _CLIENT_QUERY.args(\"$a\", \"1\") + '+' + _CLIENT_QUERY.args(\"$b\", \"2\"), \"3\"); query(_CLIENT_QUERY.args(conn(), \"\\\"declare variable $a external; $a*2\\\"\", \" map { 'a': 1 }\"), \"2\"); error(_CLIENT_QUERY.args(conn(), \"x\"), Err.NOCTX); error(_CLIENT_QUERY.args(conn(), \"\\\"$a\\\"\", \" map { 'a': (1,2) }\"), Err.BXCL_ITEM); } "
    },
    {
        "test_src": "@Test public void matchVlanPcpTest() { Criterion criterion = Criteria.matchVlanPcp((byte)4); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result.get(\"type\").textValue(), is(criterion.type().toString())); assertThat(result.get(\"priority\").asInt(), is(4)); } ",
        "focal_tgt": "public static Criterion matchVlanPcp(byte vlanPcp) { return new VlanPcpCriterion(vlanPcp); } ",
        "focal_src": "public static Criterion matchVlanPcp(Byte vlanPcp) { return new VlanPcpCriterion(vlanPcp); } ",
        "test_tgt": "@Test public void matchVlanPcpTest() { Criterion criterion = Criteria.matchVlanPcp((byte)7); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result.get(\"type\").textValue(), is(criterion.type().toString())); assertThat(result.get(\"priority\").asInt(), is(7)); } "
    },
    {
        "test_src": "@Test public void receive() { final int numberOfEvents = 15; final String messageId = UUID.randomUUID().toString(); final EventHubAsyncClient asyncClient = new EventHubClientBuilder().connectionString(getConnectionString()).buildAsyncClient(); final EventHubProducerAsyncClient producer = asyncClient.createProducer(); final EventHubConsumer receiver = client.createConsumer(EventHubAsyncClient.DEFAULT_CONSUMER_GROUP_NAME, PARTITION_ID, EventPosition.earliest()); producer.send(TestUtils.getEvents(numberOfEvents, messageId), sendOptions).block(); final IterableStream < EventData > receive = receiver.receive(15, Duration.ofSeconds(30)); Assert.assertNotNull(receive); final List < EventData > results = receive.stream().collect(Collectors.toList()); Assert.assertEquals(numberOfEvents, results.size()); } ",
        "focal_tgt": "public void receive() { String partitionId = \"0\"; Instant twelveHoursAgo = Instant.now().minus(Duration.ofHours(12)); EventHubConsumerClient consumer = new EventHubClientBuilder().connectionString(\"event-hub-instance-connection-string\").consumerGroup(EventHubClientBuilder.DEFAULT_CONSUMER_GROUP_NAME).startingPosition(EventPosition.fromEnqueuedTime(twelveHoursAgo)).buildConsumer(); IterableStream < PartitionEvent > events = consumer.receive(partitionId, 100, Duration.ofSeconds(30)); for(PartitionEvent partitionEvent : events) { System.out.print(\"Event received: \" + partitionEvent.getEventData().getSequenceNumber()); } IterableStream < PartitionEvent > nextEvents = consumer.receive(partitionId, 100, Duration.ofSeconds(30)); for(PartitionEvent partitionEvent : nextEvents) { System.out.print(\"Event received: \" + partitionEvent.getEventData().getSequenceNumber()); } } ",
        "focal_src": "public void receive() { String partitionId = \"0\"; Instant twelveHoursAgo = Instant.now().minus(Duration.ofHours(12)); EventHubConsumer consumer = client.createConsumer(EventHubAsyncClient.DEFAULT_CONSUMER_GROUP_NAME, partitionId, EventPosition.fromEnqueuedTime(twelveHoursAgo)); IterableStream < EventData > events = consumer.receive(100, Duration.ofSeconds(30)); for(EventData event : events) { System.out.print(\"Event received: \" + event.getSequenceNumber()); } IterableStream < EventData > nextEvents = consumer.receive(100, Duration.ofSeconds(30)); for(EventData event : nextEvents) { System.out.print(\"Event received: \" + event.getSequenceNumber()); } } ",
        "test_tgt": "@Test public void receive() { final int numberOfEvents = 15; final String messageId = UUID.randomUUID().toString(); final EventHubAsyncClient asyncClient = new EventHubClientBuilder().connectionString(getConnectionString()).buildAsyncClient(); final EventHubProducerAsyncClient producer = asyncClient.createProducer(); final EventHubConsumerClient receiver = client.createConsumer(EventHubClientBuilder.DEFAULT_CONSUMER_GROUP_NAME, EventPosition.earliest()); producer.send(TestUtils.getEvents(numberOfEvents, messageId), sendOptions).block(); final IterableStream < PartitionEvent > receive = receiver.receive(PARTITION_ID, 15, Duration.ofSeconds(30)); Assert.assertNotNull(receive); final List < PartitionEvent > results = receive.stream().collect(Collectors.toList()); Assert.assertEquals(numberOfEvents, results.size()); } "
    },
    {
        "test_src": "@Test public void testReadGroup() { Map < String, Feature > group = testedStore.readGroup(G1); Assert.assertEquals(2, group.size()); Assert.assertTrue(group.containsKey(F3)); Assert.assertTrue(group.containsKey(F4)); } ",
        "focal_tgt": "@Override public Map < String, Feature > readGroup(String groupName) { if(groupName == null || groupName.isEmpty()) { throw new IllegalArgumentException(\"groupName cannot be null nor empty\"); } if( ! existGroup(groupName)) { throw new GroupNotFoundException(groupName); } Map < String, Feature > features = new HashMap < String, Feature > (); for(String feat : featureGroups.get(groupName)) { features.put(feat, this.read(feat)); } return features; } ",
        "focal_src": "@Override public Map < String, Feature > readGroup(String groupName) { if( ! existGroup(groupName)) { throw new GroupNotFoundException(groupName); } Map < String, Feature > features = new HashMap < String, Feature > (); for(String feat : featureGroups.get(groupName)) { features.put(feat, this.read(feat)); } return features; } ",
        "test_tgt": "@Test public void testReadGroup() { assertFf4j.assertThatGroupExist(G1); assertFf4j.assertThatFeatureExist(F3); assertFf4j.assertThatFeatureExist(F4); assertFf4j.assertThatFeatureIsInGroup(F3, G1); assertFf4j.assertThatFeatureIsInGroup(F4, G1); Map < String, Feature > group = testedStore.readGroup(G1); Assert.assertEquals(2, group.size()); Assert.assertTrue(group.containsKey(F3)); Assert.assertTrue(group.containsKey(F4)); } "
    },
    {
        "test_src": "@Test public void append() { error(_FILE_APPEND.args(PATH, \"()\"), Err.FILE_IS_DIR); error(_FILE_APPEND.args(PATH4, \"()\"), Err.FILE_NO_DIR); query(_FILE_APPEND.args(PATH1, \"0\")); query(_FILE_SIZE.args(PATH1), \"1\"); query(_FILE_APPEND.args(PATH1, \"0\", \"()\")); query(_FILE_SIZE.args(PATH1), \"2\"); query(_FILE_DELETE.args(PATH1)); query(_FILE_APPEND.args(PATH1, \"a\u00e4\", serialParams(\"<encoding value='CP1252'/>\"))); query(_FILE_READ_TEXT.args(PATH1, \"CP1252\"), \"a\u00e4\"); query(_FILE_DELETE.args(PATH1)); query(_FILE_APPEND.args(PATH1, \"\\\"<a/>\\\"\", serialParams(\"<method value='text'/>\"))); query(_FILE_READ_TEXT.args(PATH1), \"&lt;a/&gt;\"); query(_FILE_DELETE.args(PATH1)); } ",
        "focal_tgt": "private Array append(final QueryContext qc)throws QueryException { final Array array = toArray(exprs[0], qc); final int as = array.arraySize(); final ValueList vl = new ValueList(as + 1); for(final Value v : array.members())vl.add(v); return vl.add(qc.value(exprs[1])).array(); } ",
        "focal_src": "private Array append(final QueryContext qc)throws QueryException { final Array array = array(0, qc); final int as = array.arraySize(); final ValueList vl = new ValueList(as + 1); for(final Value v : array.members())vl.add(v); return vl.add(qc.value(exprs[1])).array(); } ",
        "test_tgt": "@Test public void append() { error(_FILE_APPEND.args(PATH, \"()\"), Err.FILE_IS_DIR_X); error(_FILE_APPEND.args(PATH4, \"()\"), Err.FILE_NO_DIR_X); query(_FILE_APPEND.args(PATH1, \"0\")); query(_FILE_SIZE.args(PATH1), \"1\"); query(_FILE_APPEND.args(PATH1, \"0\", \"()\")); query(_FILE_SIZE.args(PATH1), \"2\"); query(_FILE_DELETE.args(PATH1)); query(_FILE_APPEND.args(PATH1, \"a\u00e4\", serialParams(\"<encoding value='CP1252'/>\"))); query(_FILE_READ_TEXT.args(PATH1, \"CP1252\"), \"a\u00e4\"); query(_FILE_DELETE.args(PATH1)); query(_FILE_APPEND.args(PATH1, \"\\\"<a/>\\\"\", serialParams(\"<method value='text'/>\"))); query(_FILE_READ_TEXT.args(PATH1), \"&lt;a/&gt;\"); query(_FILE_DELETE.args(PATH1)); } "
    },
    {
        "test_src": "@Test public final void testGetFieldValueMap()throws IllegalArgumentException, IllegalAccessException { User user = new User(12L); LOGGER.info(JsonUtil.format(FieldUtil.getFieldValueMap(user))); } ",
        "focal_tgt": "public static Map < String, Object > getFieldValueMap(Object obj) { return getFieldValueMap(obj, null); } ",
        "focal_src": "public static Map < String, Object > getFieldValueMap(Object obj)throws ReflectException { return getFieldValueMap(obj, null); } ",
        "test_tgt": "@Test public final void testGetFieldValueMap()throws IllegalAccessException { User user = new User(12L); LOGGER.info(JsonUtil.format(FieldUtil.getFieldValueMap(user))); } "
    },
    {
        "test_src": "@Test public void testIsDirectChild() { assertFalse(isDirectChild(\"\", \"\")); assertTrue(isDirectChild(\"\", \"path\")); assertFalse(isDirectChild(\"\", \"path/to\")); assertFalse(isDirectChild(\"path\", \"path\")); assertFalse(isDirectChild(\"path\", \"\")); assertTrue(isDirectChild(\"path\", \"path/to\")); assertFalse(isDirectChild(\"path\", \"path/to/node\")); assertFalse(isDirectChild(\"path/to\", \"\")); assertFalse(isDirectChild(\"path/to\", \"path\")); assertFalse(isDirectChild(\"path/to\", \"path/to\")); assertFalse(isDirectChild(\"path/to\", \"path2/to\")); assertTrue(isDirectChild(\"path/to\", \"path/to/node\")); } ",
        "focal_tgt": "public static boolean isDirectChild(String parentPath, String nodePath) { checkNotNull(parentPath, \"parentPath\"); checkNotNull(nodePath, \"nodePath\"); int idx = nodePath.lastIndexOf(PATH_SEPARATOR); if(parentPath.isEmpty()) { return ! nodePath.isEmpty() && idx == - 1; } return idx == parentPath.length() && nodePath.substring(0, idx).equals(parentPath); } ",
        "focal_src": "public static boolean isDirectChild(String parentPath, String nodePath) { checkNotNull(parentPath, \"parentPath\"); checkNotNull(nodePath, \"nodePath\"); int idx = nodePath.lastIndexOf(PATH_SEPARATOR); if(parentPath.isEmpty()) { return ! nodePath.isEmpty() && idx == - 1; } return idx == parentPath.length(); } ",
        "test_tgt": "@Test public void testIsDirectChild() { assertFalse(isDirectChild(\"\", \"\")); assertTrue(isDirectChild(\"\", \"path\")); assertFalse(isDirectChild(\"\", \"path/to\")); assertFalse(isDirectChild(\"path\", \"path\")); assertFalse(isDirectChild(\"path\", \"\")); assertTrue(isDirectChild(\"path\", \"path/to\")); assertFalse(isDirectChild(\"path\", \"path/to/node\")); assertFalse(isDirectChild(\"path/to\", \"\")); assertFalse(isDirectChild(\"path/to\", \"path\")); assertFalse(isDirectChild(\"path/to\", \"path/to\")); assertFalse(isDirectChild(\"path/to\", \"path2/to\")); assertTrue(isDirectChild(\"path/to\", \"path/to/node\")); assertTrue(isDirectChild(\"roads\", \"roads/highway\")); assertFalse(isDirectChild(\"roads/highway\", \"roads\")); } "
    },
    {
        "test_src": "@Test public void testPackAlignments()throws Exception { String path = \"http://www.broadinstitute.org/igvdata/1KG/pilot2Bams/NA12878.SLX.bam\"; String chr = \"1\"; int start = 557000; int end = 558000; boolean contained = false; ResourceLocator rl = new ResourceLocator(path); AlignmentReader samReader = AlignmentReaderFactory.getReader(rl); CloseableIterator < Alignment > iter = samReader.query(chr, start, end, contained); boolean showDuplicates = false; int qualityThreshold = 0; int maxLevels = 1000; Map < String, List < AlignmentInterval.Row > > result = (new AlignmentPacker()).packAlignments(iter, end, new AlignmentTrack.RenderOptions()); assertEquals(1, result.size()); for(List < AlignmentInterval.Row > alignmentrows : result.values()) { for(AlignmentInterval.Row alignmentrow : alignmentrows) { List < Alignment > alignments = alignmentrow.alignments; for(int ii = 1; ii < alignments.size(); ii ++ ) { assertTrue(alignments.get(ii).getAlignmentStart() > alignments.get(ii - 1).getAlignmentStart()); assertTrue(alignments.get(ii).getAlignmentStart() - alignments.get(ii - 1).getAlignmentEnd() >= AlignmentPacker.MIN_ALIGNMENT_SPACING); } } } } ",
        "focal_tgt": "public LinkedHashMap < String, List < AlignmentInterval.Row > > packAlignments(Iterator < Alignment > iter, int end, AlignmentTrack.RenderOptions renderOptions) { LinkedHashMap < String, List < AlignmentInterval.Row > > packedAlignments = new LinkedHashMap < String, List < Row > > (); boolean pairAlignments = renderOptions.isViewPairs() || renderOptions.isPairedArcView(); if(iter == null || ! iter.hasNext()) { return packedAlignments; } if(renderOptions.groupByOption == null) { List < Row > alignmentRows = new ArrayList < Row > (10000); pack(iter, end, pairAlignments, alignmentRows); packedAlignments.put(\"\", alignmentRows); } else { List < Alignment > nullGroup = new ArrayList < Alignment > (); HashMap < String, List < Alignment > > groupedAlignments = new HashMap < String, List < Alignment > > (); while(iter.hasNext()) { Alignment alignment = iter.next(); String groupKey = getGroupValue(alignment, renderOptions); if(groupKey == null)nullGroup.add(alignment); else { List < Alignment > group = groupedAlignments.get(groupKey); if(group == null) { group = new ArrayList < Alignment > (1000); groupedAlignments.put(groupKey, group); } group.add(alignment); } } List < String > keys = new ArrayList < String > (groupedAlignments.keySet()); Comparator < String > groupComparator = getGroupComparator(renderOptions.groupByOption); Collections.sort(keys, groupComparator); for(String key : keys) { List < Row > alignmentRows = new ArrayList < Row > (10000); List < Alignment > group = groupedAlignments.get(key); pack(group.iterator(), end, pairAlignments, alignmentRows); packedAlignments.put(key, alignmentRows); } List < Row > alignmentRows = new ArrayList < Row > (10000); pack(nullGroup.iterator(), end, pairAlignments, alignmentRows); packedAlignments.put(\"\", alignmentRows); } return packedAlignments; } ",
        "focal_src": "public LinkedHashMap < String, List < AlignmentInterval.Row > > packAlignments(Iterator < Alignment > iter, int end, AlignmentTrack.RenderOptions renderOptions) { LinkedHashMap < String, List < AlignmentInterval.Row > > packedAlignments = new LinkedHashMap < String, List < Row > > (); boolean pairAlignments = renderOptions.isViewPairs() || renderOptions.isPairedArcView(); if(iter == null || ! iter.hasNext()) { return packedAlignments; } if(renderOptions.groupByOption == null) { List < Row > alignmentRows = new ArrayList < Row > (10000); pack(iter, end, pairAlignments, alignmentRows); packedAlignments.put(\"\", alignmentRows); } else { List < Alignment > nullGroup = new ArrayList < Alignment > (); HashMap < String, List < Alignment > > groupedAlignments = new HashMap < String, List < Alignment > > (); while(iter.hasNext()) { Alignment alignment = iter.next(); String groupKey = getGroupValue(alignment, renderOptions); if(groupKey == null)nullGroup.add(alignment); else { List < Alignment > group = groupedAlignments.get(groupKey); if(group == null) { group = new ArrayList < Alignment > (1000); groupedAlignments.put(groupKey, group); } group.add(alignment); } } List < String > keys = new ArrayList < String > (groupedAlignments.keySet()); Collections.sort(keys); for(String key : keys) { List < Row > alignmentRows = new ArrayList < Row > (10000); List < Alignment > group = groupedAlignments.get(key); pack(group.iterator(), end, pairAlignments, alignmentRows); packedAlignments.put(key, alignmentRows); } List < Row > alignmentRows = new ArrayList < Row > (10000); pack(nullGroup.iterator(), end, pairAlignments, alignmentRows); packedAlignments.put(\"\", alignmentRows); } return packedAlignments; } ",
        "test_tgt": "@Test public void testPackAlignments()throws Exception { CloseableIterator < Alignment > iter = getAlignments(); Map < String, List < AlignmentInterval.Row > > result = (new AlignmentPacker()).packAlignments(iter, end, new AlignmentTrack.RenderOptions()); assertEquals(1, result.size()); for(List < AlignmentInterval.Row > alignmentrows : result.values()) { for(AlignmentInterval.Row alignmentrow : alignmentrows) { List < Alignment > alignments = alignmentrow.alignments; for(int ii = 1; ii < alignments.size(); ii ++ ) { assertTrue(alignments.get(ii).getAlignmentStart() > alignments.get(ii - 1).getAlignmentStart()); assertTrue(alignments.get(ii).getAlignmentStart() - alignments.get(ii - 1).getAlignmentEnd() >= AlignmentPacker.MIN_ALIGNMENT_SPACING); } } } } "
    },
    {
        "test_src": "@Test@SuppressWarnings(\"unchecked\")public void execute()throws Exception { final DataSet dataSet = Mockito.mock(DataSet.class); Mockito.when(dataSet.persist(Mockito.any(StorageLevel.class))).thenReturn(dataSet); Mockito.when(dataSet.schema()).thenReturn(new StructType()); final SparkContextService sparkContextService = Mockito.mock(SparkContextService.class); final SparkScriptEngine engine = Mockito.mock(SparkScriptEngine.class); Mockito.when(engine.eval(Mockito.anyString(), Mockito.anyListOf(NamedParam.class))).thenReturn(dataSet); Mockito.when(engine.getSparkContext()).thenReturn(Mockito.mock(SparkContext.class)); final TransformRequest request = new TransformRequest(); request.setScript(\"sqlContext.range(1,10)\"); final TransformService service = new TransformService(TransformScript.class, engine, sparkContextService, new MockJobTrackerService()); final TransformResponse response = service.execute(request); Assert.assertEquals(TransformResponse.Status.PENDING, response.getStatus()); final ArgumentCaptor < String > evalScript = ArgumentCaptor.forClass(String.class); final ArgumentCaptor < List > evalBindings = ArgumentCaptor.forClass(List.class); Mockito.verify(engine).eval(evalScript.capture(), evalBindings.capture()); String expectedScript = null; try(InputStream stream = getClass().getResourceAsStream(\"transform-service-script1.scala\")) { expectedScript = IOUtils.toString(stream, \"UTF-8\"); } if(expectedScript == null) { throw new Exception(\"transform-service-script1.scala failed to load\"); } Assert.assertEquals(expectedScript, evalScript.getValue()); final List < NamedParam > bindings = evalBindings.getValue(); Assert.assertEquals(1, bindings.size()); Assert.assertEquals(\"sparkContextService\", bindings.get(0).name()); Assert.assertEquals(\"com.thinkbiganalytics.spark.SparkContextService\", bindings.get(0).tpe()); Assert.assertEquals(sparkContextService, bindings.get(0).value()); } ",
        "focal_tgt": "@Nonnull public TransformResponse execute(@Nonnull final TransformRequest request)throws ScriptException { log.entry(request); if(request.isAsync()) { return cacheTransform(request); } final DataSet dataSet = createShellTask(request); final StructType schema = dataSet.schema(); TransformResponse response = submitTransformJob(new ShellTransformStage(dataSet, converterService), getPolicies(request)); if(response.getStatus() != TransformResponse.Status.SUCCESS) { final String table = response.getTable(); final TransformQueryResult partialResult = new TransformQueryResult(); partialResult.setColumns(Arrays. < QueryResultColumn > asList(new QueryResultRowTransform(schema, table, converterService).columns())); response = new TransformResponse(); response.setProgress(0.0); response.setResults(partialResult); response.setStatus(TransformResponse.Status.PENDING); response.setTable(table); } return log.exit(response); } ",
        "focal_src": "@Nonnull public TransformResponse execute(@Nonnull final TransformRequest request)throws ScriptException { log.entry(request); if(request.isAsync()) { return cacheTransform(request); } final DataSet dataSet = createShellTask(request); final StructType schema = dataSet.schema(); TransformResponse response = submitTransformJob(new ShellTransformStage(dataSet), getPolicies(request)); if(response.getStatus() != TransformResponse.Status.SUCCESS) { final String table = response.getTable(); final TransformQueryResult partialResult = new TransformQueryResult(); partialResult.setColumns(Arrays. < QueryResultColumn > asList(new QueryResultRowTransform(schema, table).columns())); response = new TransformResponse(); response.setProgress(0.0); response.setResults(partialResult); response.setStatus(TransformResponse.Status.PENDING); response.setTable(table); } return log.exit(response); } ",
        "test_tgt": "@Test@SuppressWarnings(\"unchecked\")public void execute()throws Exception { final DataSet dataSet = Mockito.mock(DataSet.class); Mockito.when(dataSet.persist(Mockito.any(StorageLevel.class))).thenReturn(dataSet); Mockito.when(dataSet.schema()).thenReturn(new StructType()); final SparkContextService sparkContextService = Mockito.mock(SparkContextService.class); final SparkScriptEngine engine = Mockito.mock(SparkScriptEngine.class); Mockito.when(engine.eval(Mockito.anyString(), Mockito.anyListOf(NamedParam.class))).thenReturn(dataSet); Mockito.when(engine.getSparkContext()).thenReturn(Mockito.mock(SparkContext.class)); final TransformRequest request = new TransformRequest(); request.setScript(\"sqlContext.range(1,10)\"); final TransformService service = new TransformService(TransformScript.class, engine, sparkContextService, new MockJobTrackerService(), Mockito.mock(DataSetConverterService.class)); final TransformResponse response = service.execute(request); Assert.assertEquals(TransformResponse.Status.PENDING, response.getStatus()); final ArgumentCaptor < String > evalScript = ArgumentCaptor.forClass(String.class); final ArgumentCaptor < List > evalBindings = ArgumentCaptor.forClass(List.class); Mockito.verify(engine).eval(evalScript.capture(), evalBindings.capture()); String expectedScript = null; try(InputStream stream = getClass().getResourceAsStream(\"transform-service-script1.scala\")) { expectedScript = IOUtils.toString(stream, \"UTF-8\"); } if(expectedScript == null) { throw new Exception(\"transform-service-script1.scala failed to load\"); } Assert.assertEquals(expectedScript, evalScript.getValue()); final List < NamedParam > bindings = evalBindings.getValue(); Assert.assertEquals(1, bindings.size()); Assert.assertEquals(\"sparkContextService\", bindings.get(0).name()); Assert.assertEquals(\"com.thinkbiganalytics.spark.SparkContextService\", bindings.get(0).tpe()); Assert.assertEquals(sparkContextService, bindings.get(0).value()); } "
    },
    {
        "test_src": "@Test public void readEOFReturnsNegativeTest() { Whitebox.setInternalState(UnderFileSystemCluster.class, \"sUnderFSClass\", (String)null); Assert.assertFalse(UnderFileSystemCluster.readEOFReturnsNegative()); Whitebox.setInternalState(UnderFileSystemCluster.class, \"sUnderFSClass\", \"XXXX\"); Assert.assertFalse(UnderFileSystemCluster.readEOFReturnsNegative()); Whitebox.setInternalState(UnderFileSystemCluster.class, \"sUnderFSClass\", \"alluxio.underfs.hdfs.LocalMiniDFSCluster\"); Assert.assertTrue(UnderFileSystemCluster.readEOFReturnsNegative()); } ",
        "focal_tgt": "public static synchronized String getUnderFSClass() { return sUnderFSClass; } ",
        "focal_src": "public static boolean readEOFReturnsNegative() { return sUnderFSClass != null && sUnderFSClass.equals(\"alluxio.underfs.hdfs.LocalMiniDFSCluster\"); } ",
        "test_tgt": "@Test public void readEOFReturnsNegativeTest() { Whitebox.setInternalState(UnderFileSystemCluster.class, \"sUnderFSClass\", (String)null); String underFSClass = UnderFileSystemCluster.getUnderFSClass(); Assert.assertFalse(underFSClass != null && underFSClass.equals(\"alluxio.underfs.hdfs.LocalMiniDFSCluster\")); Whitebox.setInternalState(UnderFileSystemCluster.class, \"sUnderFSClass\", \"XXXX\"); underFSClass = UnderFileSystemCluster.getUnderFSClass(); Assert.assertFalse(underFSClass != null && underFSClass.equals(\"alluxio.underfs.hdfs.LocalMiniDFSCluster\")); Whitebox.setInternalState(UnderFileSystemCluster.class, \"sUnderFSClass\", \"alluxio.underfs.hdfs.LocalMiniDFSCluster\"); underFSClass = UnderFileSystemCluster.getUnderFSClass(); Assert.assertTrue(underFSClass != null && underFSClass.equals(\"alluxio.underfs.hdfs.LocalMiniDFSCluster\")); } "
    },
    {
        "test_src": "@Test public void testGetCorpusProcessingState() { CorpusProcessingState corpusProcessingState = service.getCorpusProcessingState(Corpus.IBM_RESEARCHERS); Assert.assertNotNull(corpusProcessingState); } ",
        "focal_tgt": "public CorpusProcessingState getCorpusProcessingState(final Corpus corpus) { final String corpusId = IDHelper.getCorpusId(corpus, getAccountId()); return executeRequest(API_VERSION + corpusId + PROCESSING_STATE_PATH, null, CorpusProcessingState.class); } ",
        "focal_src": "public CorpusProcessingState getCorpusProcessingState(final Corpus corpus) { String corpusId = IDHelper.getCorpusId(corpus, getAccountId()); return executeRequest(API_VERSION + corpusId + PROCESSING_STATE_PATH, null, CorpusProcessingState.class); } ",
        "test_tgt": "@Test public void testGetCorpusProcessingState() { final CorpusProcessingState corpusProcessingState = service.getCorpusProcessingState(Corpus.IBM_RESEARCHERS); Assert.assertNotNull(corpusProcessingState); } "
    },
    {
        "test_src": "@Test(groups = { \"deferredEvent\", \"broken\" })public void testDeferEvent() { EventManager eventManager = new EventManager(); Observer < DangerCall > observer = new AnObserver < DangerCall > (); try { } catch(Exception e) { } assert this.registeredSynch != null; assert((DeferredEventNotification)this.registeredSynch).getObserver().equals(observer); } ",
        "focal_tgt": "private < T > void deferEvent(T event, Observer < T > observer) { TransactionListener transactionListener = manager.getInstanceByType(TransactionListener.class); DeferredEventNotification < T > deferredEvent = new DeferredEventNotification < T > (event, observer); transactionListener.registerSynhronization(deferredEvent); } ",
        "focal_src": "private < T > void deferEvent(T event, Observer < T > observer) { TransactionListener transactionListener = ManagerImpl.instance().getInstanceByType(TransactionListener.class); DeferredEventNotification < T > deferredEvent = new DeferredEventNotification < T > (event, observer); transactionListener.registerSynhronization(deferredEvent); } ",
        "test_tgt": "@Test(groups = { \"deferredEvent\", \"broken\" })public void testDeferEvent() { EventManager eventManager = new EventManager(manager); Observer < DangerCall > observer = new AnObserver < DangerCall > (); try { } catch(Exception e) { } assert this.registeredSynch != null; assert((DeferredEventNotification)this.registeredSynch).getObserver().equals(observer); } "
    },
    {
        "test_src": "@Test public void createSession() { when(reactor.process()).thenReturn(true); when(reactor.connectionToHost(connectionHandler.getHostname(), connectionHandler.getProtocolPort(), connectionHandler)).thenReturn(connectionProtonJ); when(connectionProtonJ.session()).thenReturn(session); when(session.attachments()).thenReturn(record); StepVerifier.create(connection.createSession(SESSION_NAME)).assertNext(s -> { Assert.assertNotNull(s); Assert.assertEquals(SESSION_NAME, s.getSessionName()); Assert.assertTrue(s instanceof ReactorSession); Assert.assertSame(session, ((ReactorSession)s).session()); }).verifyComplete(); StepVerifier.create(connection.createSession(SESSION_NAME)).assertNext(s -> { Assert.assertNotNull(s); Assert.assertEquals(SESSION_NAME, s.getSessionName()); Assert.assertTrue(s instanceof ReactorSession); Assert.assertSame(session, ((ReactorSession)s).session()); }).verifyComplete(); verify(record, Mockito.times(1)).set(Handler.class, Handler.class, sessionHandler); } ",
        "focal_tgt": "@Override public Mono < AmqpSession > createSession(String sessionName) { AmqpSession existingSession = sessionMap.get(sessionName); if(existingSession != null) { return Mono.just(existingSession); } return connectionMono.map(connection -> sessionMap.computeIfAbsent(sessionName, key -> { final SessionHandler handler = handlerProvider.createSessionHandler(connectionId, getHost(), sessionName, connectionOptions.getRetry().getTryTimeout()); final Session session = connection.session(); BaseHandler.setHandler(session, handler); return new ReactorSession(session, handler, sessionName, reactorProvider, handlerProvider, getCBSNode(), tokenResourceProvider, connectionOptions.getRetry().getTryTimeout()); })); } ",
        "focal_src": "@Override public Mono < AmqpSession > createSession(String sessionName) { AmqpSession existingSession = sessionMap.get(sessionName); if(existingSession != null) { return Mono.just(existingSession); } return connectionMono.map(connection -> sessionMap.computeIfAbsent(sessionName, key -> { final SessionHandler handler = handlerProvider.createSessionHandler(connectionId, getHost(), sessionName, connectionOptions.retry().tryTimeout()); final Session session = connection.session(); BaseHandler.setHandler(session, handler); return new ReactorSession(session, handler, sessionName, reactorProvider, handlerProvider, getCBSNode(), tokenResourceProvider, connectionOptions.retry().tryTimeout()); })); } ",
        "test_tgt": "@Test public void createSession() { when(reactor.process()).thenReturn(true); when(reactor.connectionToHost(connectionHandler.getHostname(), connectionHandler.getProtocolPort(), connectionHandler)).thenReturn(connectionProtonJ); when(connectionProtonJ.session()).thenReturn(session); when(session.attachments()).thenReturn(record); StepVerifier.create(connection.createSession(SESSION_NAME)).assertNext(s -> { Assert.assertNotNull(s); Assert.assertEquals(SESSION_NAME, s.getSessionName()); Assert.assertTrue(s instanceof ReactorSession); Assert.assertSame(session, ((ReactorSession)s).session()); }).verifyComplete(); StepVerifier.create(connection.createSession(SESSION_NAME)).assertNext(s -> { Assert.assertNotNull(s); Assert.assertEquals(SESSION_NAME, s.getSessionName()); Assert.assertTrue(s instanceof ReactorSession); Assert.assertSame(session, ((ReactorSession)s).session()); }).verifyComplete(); verify(record, Mockito.times(1)).set(Handler.class, Handler.class, sessionHandler); } "
    },
    {
        "test_src": "@Test public void testGetMembers()throws TwilioRestException { setupMocks(); stub(client.safeRequest(Matchers.eq(\"/2010-04-01/Accounts/\" + accountSid + \"/Queues/\" + queueSid + \".json\"), Matchers.eq(\"GET\"), Matchers.any(Map.class))).toReturn(resp); final TwilioRestResponse membersresp = mock(TwilioRestResponse.class); final HashMap < String, Object > map = new HashMap < String, Object > (); stub(membersresp.toMap()).toReturn(map); stub(membersresp.getParser()).toReturn(new JsonResponseParser()); formattedDate = dateFormat.format(new Date()); map.put(\"next_page_uri\", \"http://next.page.uri/\"); map.put(\"start\", \"1\"); map.put(\"end\", \"1\"); map.put(\"total\", \"1\"); map.put(\"page\", \"1\"); map.put(\"num_pages\", \"1\"); stub(client.safeRequest(Matchers.eq(\"/2010-04-01/Accounts/\" + accountSid + \"/Queues/\" + queueSid + \"/Members.json\"), Matchers.eq(\"GET\"), Matchers.any(Map.class))).toReturn(membersresp); final Queue q = new Queue(client, queueSid); q.setRequestAccountSid(accountSid); final MemberList m = q.getMembers(); final Iterator < Member > memiter = m.iterator(); assertTrue(memiter.hasNext()); } ",
        "focal_tgt": "public MemberList getMembers() { MemberList list = new MemberList(this.getClient(), this.getSid()); list.setRequestAccountSid(this.getRequestAccountSid()); return list; } ",
        "focal_src": "public MemberList getMembers() { final MemberList list = new MemberList(this.getClient(), this.getSid()); list.setRequestAccountSid(this.getRequestAccountSid()); return list; } ",
        "test_tgt": "@Test public void testGetMembers()throws TwilioRestException { setupMocks(); stub(client.safeRequest(Matchers.eq(\"/2010-04-01/Accounts/\" + accountSid + \"/Queues/\" + queueSid + \".json\"), Matchers.eq(\"GET\"), Matchers.any(Map.class))).toReturn(resp); TwilioRestResponse membersresp = mock(TwilioRestResponse.class); HashMap < String, Object > map = new HashMap < String, Object > (); stub(membersresp.toMap()).toReturn(map); stub(membersresp.getParser()).toReturn(new JsonResponseParser()); formattedDate = dateFormat.format(new Date()); map.put(\"next_page_uri\", \"http://next.page.uri/\"); map.put(\"start\", \"1\"); map.put(\"end\", \"1\"); map.put(\"total\", \"1\"); map.put(\"page\", \"1\"); map.put(\"num_pages\", \"1\"); stub(client.safeRequest(Matchers.eq(\"/2010-04-01/Accounts/\" + accountSid + \"/Queues/\" + queueSid + \"/Members.json\"), Matchers.eq(\"GET\"), Matchers.any(Map.class))).toReturn(membersresp); Queue q = new Queue(client, queueSid); q.setRequestAccountSid(accountSid); MemberList m = q.getMembers(); Iterator < Member > memiter = m.iterator(); assertTrue(memiter.hasNext()); } "
    },
    {
        "test_src": "@Test public void generateClientFileInfoTest() { InodeDirectory inodeDirectory = createInodeDirectory(); String path = \"/test/path\"; FileInfo info = inodeDirectory.generateClientFileInfo(path); Assert.assertEquals(inodeDirectory.getId(), info.getFileId()); Assert.assertEquals(inodeDirectory.getName(), info.getName()); Assert.assertEquals(path, info.getPath()); Assert.assertEquals(null, info.getUfsPath()); Assert.assertEquals(0, info.getLength()); Assert.assertEquals(0, info.getBlockSizeBytes()); Assert.assertEquals(inodeDirectory.getCreationTimeMs(), info.getCreationTimeMs()); Assert.assertTrue(info.isIsCompleted()); Assert.assertTrue(info.isIsFolder()); Assert.assertEquals(inodeDirectory.isPinned(), info.isIsPinned()); Assert.assertFalse(info.isIsCacheable()); Assert.assertNull(info.getBlockIds()); Assert.assertEquals(inodeDirectory.getLastModificationTimeMs(), info.getLastModificationTimeMs()); } ",
        "focal_tgt": "@Override public synchronized FileInfo generateClientFileInfo(String path) { FileInfo ret = new FileInfo(); ret.setFileId(getId()); ret.setName(getName()); ret.setPath(path); ret.setLength(0); ret.setBlockSizeBytes(0); ret.setCreationTimeMs(getCreationTimeMs()); ret.setCompleted(true); ret.setFolder(true); ret.setPinned(isPinned()); ret.setCacheable(false); ret.setPersisted(isPersisted()); ret.setBlockIds(null); ret.setLastModificationTimeMs(getLastModificationTimeMs()); ret.setTtl(Constants.NO_TTL); ret.setUserName(getUserName()); ret.setGroupName(getGroupName()); ret.setPermission(getPermission()); ret.setPersistenceState(getPersistenceState().toString()); return ret; } ",
        "focal_src": "@Override public synchronized FileInfo generateClientFileInfo(String path) { FileInfo ret = new FileInfo(); ret.setFileId(getId()); ret.setName(getName()); ret.setPath(path); ret.setLength(0); ret.setBlockSizeBytes(0); ret.setCreationTimeMs(getCreationTimeMs()); ret.setIsCompleted(true); ret.setIsFolder(true); ret.setIsPinned(isPinned()); ret.setIsCacheable(false); ret.setIsPersisted(isPersisted()); ret.setBlockIds(null); ret.setLastModificationTimeMs(getLastModificationTimeMs()); ret.setTtl(Constants.NO_TTL); ret.setUserName(getUserName()); ret.setGroupName(getGroupName()); ret.setPermission(getPermission()); ret.setPersistenceState(getPersistenceState().toString()); return ret; } ",
        "test_tgt": "@Test public void generateClientFileInfoTest() { InodeDirectory inodeDirectory = createInodeDirectory(); String path = \"/test/path\"; FileInfo info = inodeDirectory.generateClientFileInfo(path); Assert.assertEquals(inodeDirectory.getId(), info.getFileId()); Assert.assertEquals(inodeDirectory.getName(), info.getName()); Assert.assertEquals(path, info.getPath()); Assert.assertEquals(null, info.getUfsPath()); Assert.assertEquals(0, info.getLength()); Assert.assertEquals(0, info.getBlockSizeBytes()); Assert.assertEquals(inodeDirectory.getCreationTimeMs(), info.getCreationTimeMs()); Assert.assertTrue(info.isCompleted()); Assert.assertTrue(info.isFolder()); Assert.assertEquals(inodeDirectory.isPinned(), info.isPinned()); Assert.assertFalse(info.isCacheable()); Assert.assertNull(info.getBlockIds()); Assert.assertEquals(inodeDirectory.getLastModificationTimeMs(), info.getLastModificationTimeMs()); } "
    },
    {
        "test_src": "@Test public void testEq() { assertTrue(instance.eq(\"name\", \"abc\").getQueryCriterions().contains(new EqCriterion(\"name\", \"abc\"))); } ",
        "focal_tgt": "public CriteriaQuery eq(String propName, Object value) { criterion = criterion.and(criterionBuilder.eq(propName, value)); return this; } ",
        "focal_src": "public CriteriaQuery eq(String propName, Object value) { addCriterion(criterionBuilder.eq(propName, value)); return this; } ",
        "test_tgt": "@Test public void testEq() { assertEquals(new EqCriterion(\"name\", \"abc\"), instance.eq(\"name\", \"abc\").getQueryCriterion()); } "
    },
    {
        "test_src": "@Test(description = \"DELETE /catalogItem/{id}\", dependsOnMethods = \"testDeleteCatalogItemMetadataValue\")public void testDeleteCatalogItem() { catalogApi.deleteCatalogItem(catalogItem.getHref()); catalogItem = catalogApi.getCatalogItem(catalogItem.getHref()); assertNull(catalogItem); } ",
        "focal_tgt": "void deleteItem(String catalogItemUrn); ",
        "focal_src": "void deleteCatalogItem(URI catalogItemRef); ",
        "test_tgt": "@Test(description = \"DELETE /catalogItem/{id}\", dependsOnMethods = \"testDeleteCatalogItemMetadataValue\")public void testDeleteCatalogItem() { catalogApi.deleteItem(catalogItem.getId()); catalogItem = catalogApi.getItem(catalogItem.getId()); assertNull(catalogItem); } "
    },
    {
        "test_src": "@Test public void testProcess()throws Exception { System.out.println(\"process\"); InputStream inStream = this.getClass().getResourceAsStream(\"/BondFeature.gb\"); assertNotNull(inStream); GenbankReader < ProteinSequence, AminoAcidCompound > GenbankReader = new GenbankReader < ProteinSequence, AminoAcidCompound > (inStream, new GenericGenbankHeaderParser < ProteinSequence, AminoAcidCompound > (), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet())); LinkedHashMap < String, ProteinSequence > proteinSequences = GenbankReader.process(); inStream.close(); } ",
        "focal_tgt": "public LinkedHashMap < String, S > process(int max)throws IOException { LinkedHashMap < String, S > sequences = new LinkedHashMap < String, S > (); List section = null; try { do { section = this.readSection(); sectionKey = ((String[])section.get(0))[0]; if(sectionKey == null) { throw new ParserException(\"Section key was null\"); } if(sectionKey.equals(LOCUS_TAG)) { String loc = ((String[])section.get(0))[1]; Matcher m = lp.matcher(loc); if(m.matches()) { headerParser.setName(m.group(1)); accession = m.group(1); headerParser.setAccession(accession); } else { throw new ParserException(\"Bad locus line\"); } } else if(sectionKey.equals(DEFINITION_TAG)) { headerParser.setDescription(((String[])section.get(0))[1]); } else if(sectionKey.equals(ACCESSION_TAG)) { String[]accs = ((String[])section.get(0))[1].split(\"\\\\s+\"); accession = accs[0].trim(); headerParser.setAccession(accession); } else if(sectionKey.equals(VERSION_TAG)) { String ver = ((String[])section.get(0))[1]; Matcher m = vp.matcher(ver); if(m.matches()) { String verAcc = m.group(1); if( ! accession.equals(verAcc)) { accession = verAcc; headerParser.setAccession(accession); } if(m.group(3) != null)headerParser.setVersion(Integer.parseInt(m.group(3))); if(m.group(5) != null) { identifier = m.group(5); headerParser.setIdentifier(identifier); } } else { throw new ParserException(\"Bad version line\"); } } else if(sectionKey.equals(KEYWORDS_TAG)) { } else if(sectionKey.equals(SOURCE_TAG)) { } else if(sectionKey.equals(REFERENCE_TAG)) { } else if(sectionKey.equals(COMMENT_TAG)) { headerParser.setComment(((String[])section.get(0))[1]); } else if(sectionKey.equals(FEATURE_TAG)) { } else if(sectionKey.equals(BASE_COUNT_TAG)) { } else if(sectionKey.equals(START_SEQUENCE_TAG)) { StringBuffer seq = new StringBuffer(); for(int i = 1; i < section.size(); i ++ )seq.append(((String[])section.get(i))[1]); String seqData = seq.toString().replaceAll(\"\\\\s+\", \"\").replaceAll(\"[\\\\.|~]\", \"-\").toUpperCase(); S sequence = (S)sequenceCreator.getSequence(seqData, sequenceIndex); headerParser.parseHeader(header, sequence); sequences.put(sequence.getAccession().getID(), sequence); } } while( ! sectionKey.equals(END_SEQUENCE_TAG)); } catch(RuntimeException e) { throw new ParserException(\"Bad sequence section\", e); } return sequences; } ",
        "focal_src": "public LinkedHashMap < String, S > process(int max)throws IOException { LinkedHashMap < String, S > sequences = new LinkedHashMap < String, S > (); List section = null; try { do { section = this.readSection(); sectionKey = ((String[])section.get(0))[0]; if(sectionKey == null) { throw new ParserException(\"Section key was null\"); } if(sectionKey.equals(LOCUS_TAG)) { String loc = ((String[])section.get(0))[1]; header = loc; Matcher m = lp.matcher(loc); if(m.matches()) { seqName = m.group(1); } } else if(sectionKey.equals(DEFINITION_TAG)) { } else if(sectionKey.equals(ACCESSION_TAG)) { String[]accs = ((String[])section.get(0))[1].split(\"\\\\s+\"); accession = accs[0].trim(); } else if(sectionKey.equals(VERSION_TAG)) { } else if(sectionKey.equals(KEYWORDS_TAG)) { } else if(sectionKey.equals(SOURCE_TAG)) { } else if(sectionKey.equals(REFERENCE_TAG)) { } else if(sectionKey.equals(COMMENT_TAG)) { } else if(sectionKey.equals(FEATURE_TAG)) { } else if(sectionKey.equals(BASE_COUNT_TAG)) { } else if(sectionKey.equals(START_SEQUENCE_TAG)) { StringBuffer seq = new StringBuffer(); for(int i = 1; i < section.size(); i ++ )seq.append(((String[])section.get(i))[1]); String seqData = seq.toString().replaceAll(\"\\\\s+\", \"\").replaceAll(\"[\\\\.|~]\", \"-\").toUpperCase(); S sequence = (S)sequenceCreator.getSequence(seqData, sequenceIndex); headerParser.parseHeader(header, sequence); sequence.setOriginalHeader(seqName); sequence.setAccession(new AccessionID(accession)); sequences.put(sequence.getAccession().getID(), sequence); } } while( ! sectionKey.equals(END_SEQUENCE_TAG)); } catch(RuntimeException e) { throw new ParserException(\"Bad sequence section\"); } return sequences; } ",
        "test_tgt": "@Test public void testProcess()throws Exception { System.out.println(\"process protein\"); InputStream inStream = this.getClass().getResourceAsStream(\"/BondFeature.gb\"); assertNotNull(inStream); GenbankReader < ProteinSequence, AminoAcidCompound > GenbankProtein = new GenbankReader < ProteinSequence, AminoAcidCompound > (inStream, new GenericGenbankHeaderParser < ProteinSequence, AminoAcidCompound > (), new ProteinSequenceCreator(AminoAcidCompoundSet.getAminoAcidCompoundSet())); LinkedHashMap < String, ProteinSequence > proteinSequences = GenbankProtein.process(); inStream.close(); System.out.println(\"process DNA\"); inStream = this.getClass().getResourceAsStream(\"/NM_000266.gb\"); assertNotNull(inStream); GenbankReader < DNASequence, NucleotideCompound > GenbankDNA = new GenbankReader < DNASequence, NucleotideCompound > (inStream, new GenericGenbankHeaderParser < DNASequence, NucleotideCompound > (), new DNASequenceCreator(DNACompoundSet.getDNACompoundSet())); LinkedHashMap < String, DNASequence > dnaSequences = GenbankDNA.process(); inStream.close(); } "
    },
    {
        "test_src": "@Test public void testObtainInternalConnection()throws SQLException, ClassNotFoundException { expect(mockPool.getConfig()).andReturn(config).anyTimes(); testClass.url = \"jdbc:mock:driver\"; config.setAcquireRetryDelay(1); CustomHook testHook = new CustomHook(); config.setConnectionHook(testHook); new MockJDBCDriver(new MockJDBCAnswer() { @SuppressWarnings(\"synthetic-access\")public Connection answer()throws SQLException { if(count -- > 0) { throw new SQLException(); } return mockConnection; } }); replay(mockPool); testClass.obtainInternalConnection(); assertEquals(1, testHook.fail); assertEquals(1, testHook.acquire); count = 1; config.setConnectionHook(null); assertEquals(mockConnection, testClass.obtainInternalConnection()); count = 99; config.setAcquireRetryAttempts(2); try { testClass.obtainInternalConnection(); fail(\"Should have thrown an exception\"); } catch(SQLException e) { } count = 99; config.setAcquireRetryAttempts(2); config.setAcquireRetryDelay(7000); final Thread currentThread = Thread.currentThread(); try { new Thread(new Runnable() { public void run() { while( ! currentThread.getState().equals(State.TIMED_WAITING)) { try { Thread.sleep(50); } catch(InterruptedException e) { e.printStackTrace(); } } currentThread.interrupt(); } }).start(); testClass.obtainInternalConnection(); fail(\"Should have thrown an exception\"); } catch(SQLException e) { } config.setAcquireRetryDelay(10); } ",
        "focal_tgt": "protected Connection obtainInternalConnection()throws SQLException { boolean tryAgain = false; Connection result = null; int acquireRetryAttempts = this.pool.getConfig().getAcquireRetryAttempts(); int acquireRetryDelay = this.pool.getConfig().getAcquireRetryDelay(); this.connectionHook = this.pool.getConfig().getConnectionHook(); do { try { this.connection = this.pool.obtainRawInternalConnection(); tryAgain = false; if(acquireRetryAttempts != this.pool.getConfig().getAcquireRetryAttempts()) { logger.info(\"Successfully re-established connection to DB\"); } if(this.connectionHook != null) { this.connectionHook.onAcquire(this); } sendInitSQL(); result = this.connection; } catch(Throwable t) { if(this.connectionHook != null) { tryAgain = this.connectionHook.onAcquireFail(t); } else { logger.error(\"Failed to acquire connection. Sleeping for \" + acquireRetryDelay + \"ms. Attempts left: \" + acquireRetryAttempts); try { Thread.sleep(acquireRetryDelay); if(acquireRetryAttempts > 0) { tryAgain = ( -- acquireRetryAttempts) != 0; } } catch(InterruptedException e) { tryAgain = false; } } if( ! tryAgain) { throw markPossiblyBroken(t); } } } while(tryAgain); return result; } ",
        "focal_src": "protected Connection obtainInternalConnection()throws SQLException { boolean tryAgain = false; Connection result = null; int acquireRetryAttempts = this.pool.getConfig().getAcquireRetryAttempts(); int acquireRetryDelay = this.pool.getConfig().getAcquireRetryDelay(); this.connectionHook = this.pool.getConfig().getConnectionHook(); do { try { this.connection = DriverManager.getConnection(this.url, this.username, this.password); tryAgain = false; if(acquireRetryAttempts != this.pool.getConfig().getAcquireRetryAttempts()) { logger.info(\"Successfully re-established connection to DB\"); } if(this.connectionHook != null) { this.connectionHook.onAcquire(this); } sendInitSQL(); result = this.connection; } catch(Throwable t) { if(this.connectionHook != null) { tryAgain = this.connectionHook.onAcquireFail(t); } else { logger.error(\"Failed to acquire connection. Sleeping for \" + acquireRetryDelay + \"ms. Attempts left: \" + acquireRetryAttempts); try { Thread.sleep(acquireRetryDelay); if(acquireRetryAttempts > 0) { tryAgain = ( -- acquireRetryAttempts) != 0; } } catch(InterruptedException e) { tryAgain = false; } } if( ! tryAgain) { throw markPossiblyBroken(t); } } } while(tryAgain); return result; } ",
        "test_tgt": "@Test public void testObtainInternalConnection()throws SQLException, ClassNotFoundException { expect(mockPool.getConfig()).andReturn(config).anyTimes(); testClass.url = \"jdbc:mock:driver\"; config.setAcquireRetryDelay(1); CustomHook testHook = new CustomHook(); config.setConnectionHook(testHook); expect(mockPool.obtainRawInternalConnection()).andThrow(new SQLException()).once().andReturn(mockConnection).once(); replay(mockPool); testClass.obtainInternalConnection(); assertEquals(1, testHook.fail); assertEquals(1, testHook.acquire); reset(mockPool); expect(mockPool.getConfig()).andReturn(config).anyTimes(); expect(mockPool.obtainRawInternalConnection()).andThrow(new SQLException()).once().andReturn(mockConnection).once(); count = 1; config.setConnectionHook(null); replay(mockPool); assertEquals(mockConnection, testClass.obtainInternalConnection()); reset(mockPool); expect(mockPool.getConfig()).andReturn(config).anyTimes(); expect(mockPool.obtainRawInternalConnection()).andThrow(new SQLException()).anyTimes(); replay(mockPool); count = 99; config.setAcquireRetryAttempts(2); try { testClass.obtainInternalConnection(); fail(\"Should have thrown an exception\"); } catch(SQLException e) { } count = 99; config.setAcquireRetryAttempts(2); config.setAcquireRetryDelay(7000); final Thread currentThread = Thread.currentThread(); try { new Thread(new Runnable() { public void run() { while( ! currentThread.getState().equals(State.TIMED_WAITING)) { try { Thread.sleep(50); } catch(InterruptedException e) { e.printStackTrace(); } } currentThread.interrupt(); } }).start(); testClass.obtainInternalConnection(); fail(\"Should have thrown an exception\"); } catch(SQLException e) { } config.setAcquireRetryDelay(10); } "
    },
    {
        "test_src": "@Test public void testInitialize() { @Cleanup TestContext context = new TestContext(DEFAULT_CONFIG); context.transactionAggregators[0].initialize(TIMEOUT, executorService()).join(); Assert.assertTrue(\"isDeleted() flag not set on metadata for deleted segment.\", context.transactionAggregators[0].getMetadata().isDeleted()); context.storage.create(context.transactionAggregators[1].getMetadata().getName(), TIMEOUT).join(); context.storage.seal(writeHandle(context.transactionAggregators[1].getMetadata().getName()), TIMEOUT).join(); AssertExtensions.assertThrows(\"initialize() succeeded on a Segment is sealed in Storage but not in the metadata.\", () -> context.transactionAggregators[1].initialize(TIMEOUT, executorService()), ex -> ex instanceof DataCorruptionException); context.storage.create(context.transactionAggregators[2].getMetadata().getName(), TIMEOUT).join(); context.storage.seal(writeHandle(context.transactionAggregators[2].getMetadata().getName()), TIMEOUT).join(); ((UpdateableSegmentMetadata)context.transactionAggregators[2].getMetadata()).markSealed(); context.transactionAggregators[2].initialize(TIMEOUT, executorService()).join(); Assert.assertTrue(\"isSealedInStorage() flag not set on metadata for storage-sealed segment.\", context.transactionAggregators[2].getMetadata().isSealedInStorage()); final int writeLength = 10; context.storage.create(context.segmentAggregator.getMetadata().getName(), TIMEOUT).join(); context.storage.write(writeHandle(context.segmentAggregator.getMetadata().getName()), 0, new ByteArrayInputStream(new byte[writeLength]), writeLength, TIMEOUT).join(); context.segmentAggregator.initialize(TIMEOUT, executorService()).join(); Assert.assertEquals(\"SegmentMetadata.StorageLength was not updated after call to initialize().\", writeLength, context.segmentAggregator.getMetadata().getStorageLength()); } ",
        "focal_tgt": "CompletableFuture < Void > initialize(Duration timeout, Executor executor) { Exceptions.checkNotClosed(isClosed(), this); Preconditions.checkState(this.state.get() == AggregatorState.NotInitialized, \"SegmentAggregator has already been initialized.\"); assert this.handle.get() == null : \"non-null handle but state == \" + this.state.get(); long traceId = LoggerHelpers.traceEnterWithContext(log, this.traceObjectId, \"initialize\"); return openWrite(this.metadata.getName(), this.handle, executor, timeout).thenAccept(segmentInfo -> { if(this.metadata.getStorageLength() != segmentInfo.getLength()) { if(this.metadata.getStorageLength() >= 0) { log.warn(\"{}: SegmentMetadata has a StorageLength ({}) that is different than the actual one ({}) - updating metadata.\", this.traceObjectId, this.metadata.getStorageLength(), segmentInfo.getLength()); } this.metadata.setStorageLength(segmentInfo.getLength()); this.dataSource.notifyStorageLengthUpdated(this.metadata.getId()); } if(segmentInfo.isSealed()) { if( ! this.metadata.isSealed()) { throw new CompletionException(new DataCorruptionException(String.format(\"Segment '%s' is sealed in Storage but not in the metadata.\", this.metadata.getName()))); } if( ! this.metadata.isSealedInStorage()) { this.metadata.markSealedInStorage(); log.warn(\"{}: Segment is sealed in Storage but metadata does not reflect that - updating metadata.\", this.traceObjectId, segmentInfo.getLength()); } } log.info(\"{}: Initialized. StorageLength = {}, Sealed = {}.\", this.traceObjectId, segmentInfo.getLength(), segmentInfo.isSealed()); LoggerHelpers.traceLeave(log, this.traceObjectId, \"initialize\", traceId); setState(AggregatorState.Writing); }).exceptionally(ex -> { ex = ExceptionHelpers.getRealException(ex); if(ex instanceof StreamSegmentNotExistsException) { this.metadata.markDeleted(); log.warn(\"{}: Segment does not exist in Storage. Ignoring all further operations on it.\", this.traceObjectId, ex); setState(AggregatorState.Writing); LoggerHelpers.traceLeave(log, this.traceObjectId, \"initialize\", traceId); } else { throw new CompletionException(ex); } return null; }); } ",
        "focal_src": "CompletableFuture < Void > initialize(Duration timeout, Executor executor) { Exceptions.checkNotClosed(isClosed(), this); Preconditions.checkState(this.state.get() == AggregatorState.NotInitialized, \"SegmentAggregator has already been initialized.\"); assert this.handle.get() == null : \"non-null handle but state == \" + this.state.get(); long traceId = LoggerHelpers.traceEnterWithContext(log, this.traceObjectId, \"initialize\"); return openWrite(this.metadata.getName(), this.handle, executor, timeout).thenAccept(segmentInfo -> { if(this.metadata.getStorageLength() != segmentInfo.getLength()) { if(this.metadata.getStorageLength() >= 0) { log.warn(\"{}: SegmentMetadata has a StorageLength ({}) that is different than the actual one ({}) - updating metadata.\", this.traceObjectId, this.metadata.getStorageLength(), segmentInfo.getLength()); } this.metadata.setStorageLength(segmentInfo.getLength()); } if(segmentInfo.isSealed()) { if( ! this.metadata.isSealed()) { throw new CompletionException(new DataCorruptionException(String.format(\"Segment '%s' is sealed in Storage but not in the metadata.\", this.metadata.getName()))); } if( ! this.metadata.isSealedInStorage()) { this.metadata.markSealedInStorage(); log.warn(\"{}: Segment is sealed in Storage but metadata does not reflect that - updating metadata.\", this.traceObjectId, segmentInfo.getLength()); } } log.info(\"{}: Initialized. StorageLength = {}, Sealed = {}.\", this.traceObjectId, segmentInfo.getLength(), segmentInfo.isSealed()); LoggerHelpers.traceLeave(log, this.traceObjectId, \"initialize\", traceId); setState(AggregatorState.Writing); }).exceptionally(ex -> { ex = ExceptionHelpers.getRealException(ex); if(ex instanceof StreamSegmentNotExistsException) { this.metadata.markDeleted(); log.warn(\"{}: Segment does not exist in Storage. Ignoring all further operations on it.\", this.traceObjectId, ex); setState(AggregatorState.Writing); LoggerHelpers.traceLeave(log, this.traceObjectId, \"initialize\", traceId); } else { throw new CompletionException(ex); } return null; }); } ",
        "test_tgt": "@Test public void testInitialize() { @Cleanup TestContext context = new TestContext(DEFAULT_CONFIG); context.transactionAggregators[0].initialize(TIMEOUT, executorService()).join(); Assert.assertTrue(\"isDeleted() flag not set on metadata for deleted segment.\", context.transactionAggregators[0].getMetadata().isDeleted()); context.storage.create(context.transactionAggregators[1].getMetadata().getName(), TIMEOUT).join(); context.storage.seal(writeHandle(context.transactionAggregators[1].getMetadata().getName()), TIMEOUT).join(); AssertExtensions.assertThrows(\"initialize() succeeded on a Segment is sealed in Storage but not in the metadata.\", () -> context.transactionAggregators[1].initialize(TIMEOUT, executorService()), ex -> ex instanceof DataCorruptionException); context.storage.create(context.transactionAggregators[2].getMetadata().getName(), TIMEOUT).join(); context.storage.seal(writeHandle(context.transactionAggregators[2].getMetadata().getName()), TIMEOUT).join(); ((UpdateableSegmentMetadata)context.transactionAggregators[2].getMetadata()).markSealed(); context.transactionAggregators[2].initialize(TIMEOUT, executorService()).join(); Assert.assertTrue(\"isSealedInStorage() flag not set on metadata for storage-sealed segment.\", context.transactionAggregators[2].getMetadata().isSealedInStorage()); final int writeLength = 10; AtomicLong lengthNotifyCallback = new AtomicLong( - 1234); context.dataSource.setNotifyStorageLengthUpdatedCallback(lengthNotifyCallback :: set); context.storage.create(context.segmentAggregator.getMetadata().getName(), TIMEOUT).join(); context.storage.write(writeHandle(context.segmentAggregator.getMetadata().getName()), 0, new ByteArrayInputStream(new byte[writeLength]), writeLength, TIMEOUT).join(); context.segmentAggregator.initialize(TIMEOUT, executorService()).join(); Assert.assertEquals(\"SegmentMetadata.StorageLength was not updated after call to initialize().\", writeLength, context.segmentAggregator.getMetadata().getStorageLength()); Assert.assertEquals(\"notifyStorageLengthUpdated was not invoked.\", context.segmentAggregator.getMetadata().getId(), lengthNotifyCallback.get()); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"the order of the fetched Obs is proper according to the specified sort options\", method = \"getObservations(java.util.List, java.util.List, java.util.List, java.util.List, java.util.List, java.util.List, java.util.List, Integer, Integer, java.util.Date, java.util.Date, boolean)\")public void getObservations_shouldBeOrderedCorrectly()throws Exception { Session session = sessionFactory.getCurrentSession(); List < Obs > obsListActual; List < Obs > obsListExpected; obsListExpected = session.createCriteria(Obs.class, \"obs\").addOrder(Order.desc(\"id\")).list(); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"id\"), null, null, null, null, false); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"id desc\"), null, null, null, null, false); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); obsListExpected = session.createCriteria(Obs.class, \"obs\").addOrder(Order.asc(\"id\")).list(); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"id asc\"), null, null, null, null, false); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); obsListExpected = session.createCriteria(Obs.class, \"obs\").addOrder(Order.asc(\"person.id\")).addOrder(Order.desc(\"id\")).list(); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"person.id asc\", \"id\"), null, null, null, null, false); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); obsListExpected = session.createCriteria(Obs.class, \"obs\").addOrder(Order.asc(\"person.id\")).addOrder(Order.asc(\"id\")).list(); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"person.id asc\", \"id asc\"), null, null, null, null, false); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); } ",
        "focal_tgt": "public List < Obs > getObservations(List < Person > whom, List < Encounter > encounters, List < Concept > questions, List < Concept > answers, List < PERSON_TYPE > personTypes, List < Location > locations, List < String > sort, Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs, String accessionNumber)throws DAOException; ",
        "focal_src": "public List < Obs > getObservations(List < Person > whom, List < Encounter > encounters, List < Concept > questions, List < Concept > answers, List < PERSON_TYPE > personTypes, List < Location > locations, List < String > sort, Integer mostRecentN, Integer obsGroupId, Date fromDate, Date toDate, boolean includeVoidedObs)throws DAOException; ",
        "test_tgt": "@Test@Verifies(value = \"the order of the fetched Obs is proper according to the specified sort options\", method = \"getObservations(java.util.List, java.util.List, java.util.List, java.util.List, java.util.List, java.util.List, java.util.List, Integer, Integer, java.util.Date, java.util.Date, boolean)\")public void getObservations_shouldBeOrderedCorrectly()throws Exception { Session session = sessionFactory.getCurrentSession(); List < Obs > obsListActual; List < Obs > obsListExpected; obsListExpected = session.createCriteria(Obs.class, \"obs\").addOrder(Order.desc(\"id\")).list(); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"id\"), null, null, null, null, false, null); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"id desc\"), null, null, null, null, false, null); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); obsListExpected = session.createCriteria(Obs.class, \"obs\").addOrder(Order.asc(\"id\")).list(); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"id asc\"), null, null, null, null, false, null); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); obsListExpected = session.createCriteria(Obs.class, \"obs\").addOrder(Order.asc(\"person.id\")).addOrder(Order.desc(\"id\")).list(); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"person.id asc\", \"id\"), null, null, null, null, false, null); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); obsListExpected = session.createCriteria(Obs.class, \"obs\").addOrder(Order.asc(\"person.id\")).addOrder(Order.asc(\"id\")).list(); obsListActual = dao.getObservations(null, null, null, null, null, null, Arrays.asList(\"person.id asc\", \"id asc\"), null, null, null, null, false, null); Assert.assertArrayEquals(obsListExpected.toArray(), obsListActual.toArray()); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should return unlocalized name when no localization is added\", method = \"getName()\")public void getName_shouldReturnUnlocalizedNameWhenNoLocalizationIsAdded()throws Exception { FieldType type = new FieldType(); String expected = \"Test\"; OpenmrsSerializer serializer = new LocalizedStringSerializer(); LocalizedString ls = serializer.deserialize(expected, LocalizedString.class); type.setLocalizedName(ls); Assert.assertEquals(expected, type.getName()); } ",
        "focal_tgt": "public String getName() { return getLocalizedName().getValue(); } ",
        "focal_src": "public String getName() { return name; } ",
        "test_tgt": "@Test@Verifies(value = \"should return unlocalized name when no localization is added\", method = \"getName()\")public void getName_shouldReturnUnlocalizedNameWhenNoLocalizationIsAdded()throws Exception { FieldType type = new FieldType(); String expected = \"Test\"; LocalizedString ls = LocalizedString.valueOf(expected); type.setLocalizedName(ls); Assert.assertEquals(expected, type.getName()); } "
    },
    {
        "test_src": "@Test public void getAuthorityTests() { String[]authorities = new String[] { \"localhost\", \"localhost:8080\", \"127.0.0.1\", \"127.0.0.1:8080\", \"localhost\", null }; for(String authority : authorities) { AlluxioURI uri = new AlluxioURI(\"file\", authority, \"/a/b\"); assertEquals(authority, uri.getAuthority()); } assertEquals(null, new AlluxioURI(\"file\", \"\", \"/b/c\").getAuthority()); assertEquals(null, new AlluxioURI(\"file\", null, \"/b/c\").getAuthority()); assertEquals(null, new AlluxioURI(\"file:///b/c\").getAuthority()); } ",
        "focal_tgt": "public Authority getAuthority() { return mUri.getAuthority(); } ",
        "focal_src": "@Nullable public String getAuthority() { return mUri.getAuthority(); } ",
        "test_tgt": "@Test public void getAuthorityTests() { String[]authorities = new String[] { \"localhost\", \"localhost:8080\", \"127.0.0.1\", \"127.0.0.1:8080\", \"localhost\" }; for(String authority : authorities) { AlluxioURI uri = new AlluxioURI(\"file\", Authority.fromString(authority), \"/a/b\"); assertEquals(authority, uri.getAuthority().toString()); } assertEquals(\"\", new AlluxioURI(\"file\", Authority.fromString(\"\"), \"/b/c\").getAuthority().toString()); assertEquals(\"\", new AlluxioURI(\"file\", null, \"/b/c\").getAuthority().toString()); assertEquals(\"\", new AlluxioURI(\"file\", Authority.fromString(null), \"/b/c\").getAuthority().toString()); assertEquals(\"\", new AlluxioURI(\"file:///b/c\").getAuthority().toString()); } "
    },
    {
        "test_src": "@Test public final void testStart() { Map < String, Double > context = new HashMap < String, Double > (); average.start(context); TupleEntryCollector resultEntryCollector = new TupleEntryCollector(new Fields(\"field\")); average.complete(context, resultEntryCollector.iterator()); Tuple tuple = resultEntryCollector.iterator().next().getTuple(); assertEquals(\"Got expected initial value on start\", 0.0, tuple.getDouble(0), 0.0d); } ",
        "focal_tgt": "@SuppressWarnings(\"unchecked\")public void start(Map context, TupleEntry groupEntry) { context.put(SUMSQR, 0d); } ",
        "focal_src": "@SuppressWarnings(\"unchecked\")public void start(Map context) { context.put(SUMSQR, 0d); } ",
        "test_tgt": "@Test public final void testStart() { Map < String, Double > context = new HashMap < String, Double > (); average.start(context, null); TupleEntryCollector resultEntryCollector = new TupleEntryCollector(new Fields(\"field\")); average.complete(context, resultEntryCollector.iterator()); Tuple tuple = resultEntryCollector.iterator().next().getTuple(); assertEquals(\"Got expected initial value on start\", 0.0, tuple.getDouble(0), 0.0d); } "
    },
    {
        "test_src": "@Test public void testAttachInvocationIdIfAsync_forceAttache() { URL url = URL.valueOf(\"dubbo://localhost/?\" + Constants.AUTO_ATTACH_INVOCATIONID_KEY + \"=true\"); Invocation inv = new RpcInvocation(\"test\", new Class[] { }, new String[] { }); RpcUtils.attachInvocationIdIfAsync(url, inv); assertNotNull(RpcUtils.getInvocationId(inv)); } ",
        "focal_tgt": "public static void attachInvocationIdIfAsync(URL url, Invocation inv) { if(isAttachInvocationId(url, inv) && getInvocationId(inv) == null && inv instanceof RpcInvocation) { ((RpcInvocation)inv).setAttachment(ID_KEY, String.valueOf(INVOKE_ID.getAndIncrement())); } } ",
        "focal_src": "public static void attachInvocationIdIfAsync(URL url, Invocation inv) { if(isAttachInvocationId(url, inv) && getInvocationId(inv) == null && inv instanceof RpcInvocation) { ((RpcInvocation)inv).setAttachment(Constants.ID_KEY, String.valueOf(INVOKE_ID.getAndIncrement())); } } ",
        "test_tgt": "@Test public void testAttachInvocationIdIfAsync_forceAttache() { URL url = URL.valueOf(\"dubbo://localhost/?\" + AUTO_ATTACH_INVOCATIONID_KEY + \"=true\"); Invocation inv = new RpcInvocation(\"test\", new Class[] { }, new String[] { }); RpcUtils.attachInvocationIdIfAsync(url, inv); assertNotNull(RpcUtils.getInvocationId(inv)); } "
    },
    {
        "test_src": "@Test public void getAllFlattenObs_shouldGetAllFlattenObs() { Encounter enc = new Encounter(); Obs firstObs = new Obs(); firstObs.setValueText(\"firstObs\"); enc.addObs(firstObs); Obs secondObs = new Obs(); secondObs.setValueText(\"secondObs\"); firstObs.addGroupMember(secondObs); Obs thirdObs = new Obs(); thirdObs.setValueText(\"thirdObs\"); enc.addObs(thirdObs); assertEquals(3, enc.getAllFlattenObs(true).size()); assertEquals(3, enc.getAllFlattenObs(false).size()); } ",
        "focal_tgt": "public Set < Obs > getAllFlattenedObs(boolean includeVoided) { Set < Obs > ret = new LinkedHashSet < > (); if(this.obs != null) { for(Obs o : this.obs) { if(includeVoided || ( ! o.getVoided())) { ret.addAll(getFlattenedObsLeaves(o, includeVoided)); } } } return ret; } ",
        "focal_src": "public Set < Obs > getAllFlattenObs(boolean includeVoided) { Set < Obs > ret = new LinkedHashSet < > (); if(this.obs != null) { for(Obs o : this.obs) { if(includeVoided || ( ! includeVoided && ! o.getVoided())) { ret.add(o); ret.addAll(getFlattenObsLeaves(o, includeVoided)); } } } return ret; } ",
        "test_tgt": "@Test public void getAllFlattenObs_shouldGetAllFlattenedObs() { Encounter enc = new Encounter(); Obs firstObs = new Obs(); firstObs.setValueText(\"firstObs\"); enc.addObs(firstObs); Obs secondObs = new Obs(); secondObs.setValueText(\"secondObs\"); firstObs.addGroupMember(secondObs); Obs thirdObs = new Obs(); thirdObs.setValueText(\"thirdObs\"); thirdObs.setVoided(true); enc.addObs(thirdObs); Obs fourthObs = new Obs(); fourthObs.setValueText(\"fourthObs\"); Obs fifthObs = new Obs(); fifthObs.setValueText(\"fifthObs\"); Obs sixthObs = new Obs(); sixthObs.setValueText(\"sixthObs\"); sixthObs.setVoided(true); Obs seventhObs = new Obs(); seventhObs.setValueText(\"seventhObs\"); fifthObs.addGroupMember(sixthObs); fifthObs.addGroupMember(seventhObs); fourthObs.addGroupMember(fifthObs); enc.addObs(fourthObs); assertEquals(7, enc.getAllFlattenedObs(true).size()); assertTrue(enc.getAllFlattenedObs(true).contains(thirdObs)); assertTrue(enc.getAllFlattenedObs(true).contains(seventhObs)); assertEquals(5, enc.getAllFlattenedObs(false).size()); assertFalse(enc.getAllFlattenedObs(false).contains(sixthObs)); assertTrue(enc.getAllFlattenedObs(false).contains(secondObs)); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should not fail on field answers\", method = \"onSubmit(HttpServletRequest,HttpServletResponse,Object,BindException)\")public void onSubmit_shouldNotFailOnFieldAnswers()throws Exception { final String FIELD_ID = \"1\"; MockHttpServletRequest request = new MockHttpServletRequest(\"GET\", \"\"); request.setParameter(\"fieldId\", FIELD_ID); HttpServletResponse response = new MockHttpServletResponse(); FieldFormController controller = (FieldFormController)applicationContext.getBean(\"fieldForm\"); controller.handleRequest(request, response); Context.closeSession(); Context.openSession(); authenticate(); request = new MockHttpServletRequest(\"POST\", \"\"); response = new MockHttpServletResponse(); request.setParameter(\"fieldId\", FIELD_ID); request.setParameter(\"name\", \"Some concept\"); request.setParameter(\"description\", \"This is a test field\"); request.setParameter(\"fieldTypeId\", \"1\"); request.setParameter(\"name\", \"Some concept\"); request.setParameter(\"conceptId\", \"3\"); controller.handleRequest(request, response); } ",
        "focal_tgt": "protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response, Object obj, BindException errors)throws Exception { HttpSession httpSession = request.getSession(); String view = getFormView(); String action = request.getParameter(\"action\"); if(Context.isAuthenticated()) { Field field = (Field)obj; field = setObjects(field, request); if(action != null && action.equals(Context.getMessageSourceService().getMessage(\"general.delete\"))) { try { Context.getFormService().purgeField(field); } catch(DataIntegrityViolationException e) { httpSession.setAttribute(WebConstants.OPENMRS_ERROR_ATTR, \"error.object.inuse.cannot.purge\"); return new ModelAndView(new RedirectView(\"field.form?fieldId=\" + field.getFieldId())); } httpSession.setAttribute(WebConstants.OPENMRS_MSG_ATTR, \"Field.Deleted\"); } else { Context.getFormService().saveField(field); httpSession.setAttribute(WebConstants.OPENMRS_MSG_ATTR, \"Field.saved\"); } } view = getSuccessView(); view = view + \"?phrase=\" + request.getParameter(\"phrase\"); return new ModelAndView(new RedirectView(view)); } ",
        "focal_src": "protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response, Object obj, BindException errors)throws Exception { HttpSession httpSession = request.getSession(); String view = getFormView(); String action = request.getParameter(\"action\"); if(Context.isAuthenticated()) { Field field = (Field)obj; field = setObjects(field, request); if(action.equals(Context.getMessageSourceService().getMessage(\"general.delete\"))) { try { Context.getFormService().purgeField(field); } catch(DataIntegrityViolationException e) { httpSession.setAttribute(WebConstants.OPENMRS_ERROR_ATTR, \"error.object.inuse.cannot.purge\"); return new ModelAndView(new RedirectView(\"field.form?fieldId=\" + field.getFieldId())); } httpSession.setAttribute(WebConstants.OPENMRS_MSG_ATTR, \"Field.Deleted\"); } else { Context.getFormService().saveField(field); httpSession.setAttribute(WebConstants.OPENMRS_MSG_ATTR, \"Field.saved\"); } } view = getSuccessView(); view = view + \"?phrase=\" + request.getParameter(\"phrase\"); return new ModelAndView(new RedirectView(view)); } ",
        "test_tgt": "@Test@Verifies(value = \"should not fail on field answers\", method = \"onSubmit(HttpServletRequest,HttpServletResponse,Object,BindException)\")public void onSubmit_shouldNotFailOnFieldAnswers()throws Exception { final String FIELD_ID = \"1\"; MockHttpServletRequest request = new MockHttpServletRequest(\"GET\", \"\"); request.setParameter(\"fieldId\", FIELD_ID); HttpServletResponse response = new MockHttpServletResponse(); FieldFormController controller = (FieldFormController)applicationContext.getBean(\"fieldForm\"); controller.handleRequest(request, response); Context.closeSession(); Context.openSession(); authenticate(); request = new MockHttpServletRequest(\"POST\", \"\"); response = new MockHttpServletResponse(); request.setParameter(\"fieldId\", FIELD_ID); request.setParameter(\"name\", \"Some concept\"); request.setParameter(\"description\", \"This is a test field\"); request.setParameter(\"fieldTypeId\", \"1\"); request.setParameter(\"name\", \"Some concept\"); request.setParameter(\"conceptId\", \"3\"); request.setParameter(\"action\", \"save\"); controller.handleRequest(request, response); } "
    },
    {
        "test_src": "@Test public void setBaselineTopology()throws Exception { cluster.baselineAutoAdjustEnabled(false); IgniteEx ignite_2 = startGrid(2); IgniteEx ignite_3 = startGrid(3); List < String > ids = Lists.newArrayList(cluster.localNode().id().toString(), ignite_2.cluster().localNode().id().toString(), ignite_3.cluster().localNode().id().toString()); Request req = new Request().setId(UUID.randomUUID()).setAction(\"BaselineActions.setBaselineTopology\").setArgument(ids); executeAction(req, (r) -> r.getStatus() == COMPLETED && cluster.currentBaselineTopology().size() == 3); } ",
        "focal_tgt": "public void setBaselineTopology(Collection < String > consIds) { authorizeIfNeeded(ctx.security(), SecurityPermission.ADMIN_OPS); ctx.grid().cluster().setBaselineTopology(baselineNodesForIds(consIds)); } ",
        "focal_src": "public void setBaselineTopology(Collection < String > ids) { authorizeIfNeeded(ctx.security(), SecurityPermission.ADMIN_OPS); Set < UUID > uuids = ids.stream().map(UUID :: fromString).collect(Collectors.toSet()); Collection < ClusterNode > nodes = ctx.grid().cluster().forNodeIds(uuids).forServers().nodes(); ctx.grid().cluster().setBaselineTopology(nodes); } ",
        "test_tgt": "@Test public void setBaselineTopology()throws Exception { cluster.baselineAutoAdjustEnabled(false); IgniteEx ignite_2 = startGrid(2); IgniteEx ignite_3 = startGrid(3); List < String > ids = Lists.newArrayList(cluster.localNode().consistentId().toString(), ignite_2.cluster().localNode().consistentId().toString(), ignite_3.cluster().localNode().consistentId().toString()); Request req = new Request().setId(UUID.randomUUID()).setAction(\"BaselineActions.setBaselineTopology\").setArgument(ids); executeAction(req, (r) -> r.getStatus() == COMPLETED && cluster.currentBaselineTopology().size() == 3); } "
    },
    {
        "test_src": "@Test(expected = IllegalStateException.class)public void handleGetTest()throws IOException, JSONException, RestServiceException, URISyntaxException { AdminBlobStorageService adminBlobStorageService = getAdminBlobStorageService(); MessageInfo messageInfo = createMessageInfo(RestMethod.GET, \"/\", new JSONObject()); adminBlobStorageService.handleMessage(messageInfo); } ",
        "focal_tgt": "public void handleGet(MessageInfo messageInfo)throws RestServiceException { RestRequest request = messageInfo.getRestRequest(); logger.trace(\"Handling get request - \" + request.getUri()); if( ! isCustomOperation(request)) { throw new IllegalStateException(\"Traditional GET not implemented\"); } else { handleCustomGetOperation(messageInfo); } } ",
        "focal_src": "private void handleGet(MessageInfo messageInfo)throws RestServiceException { RestRequest request = messageInfo.getRestRequest(); logger.trace(\"Handling get request - \" + request.getUri()); if( ! isCustomOperation(request)) { throw new IllegalStateException(\"Traditional GET not implemented\"); } else { handleCustomGetOperation(messageInfo); } } ",
        "test_tgt": "@Test(expected = IllegalStateException.class)public void handleGetTest()throws IOException, JSONException, RestServiceException, URISyntaxException { AdminBlobStorageService adminBlobStorageService = getAdminBlobStorageService(); MessageInfo messageInfo = createMessageInfo(RestMethod.GET, \"/\", new JSONObject()); adminBlobStorageService.handleGet(messageInfo); } "
    },
    {
        "test_src": "@Test public void reportOrphanedSpans_whenReporterDies()throws Exception { MutableSpanMap map = new MutableSpanMap(localEndpoint, () -> 0, span -> { throw new RuntimeException(\"die!\"); }); map.getOrCreate(context.toBuilder().build()); blockOnGC(); assertThat(map.delegate.keySet()).extracting(o -> ((Reference)o).get()).hasSize(1).containsNull(); map.remove(context); assertThat(map.delegate.keySet()).isEmpty(); } ",
        "focal_tgt": "void reportOrphanedSpans() { Reference < ? extends TraceContext > reference; while((reference = poll()) != null) { TraceContext context = reference.get(); MutableSpan value = delegate.remove(reference); if(value == null || noop.get())continue; try { value.annotate(clock.currentTimeMicroseconds(), \"brave.flush\"); reporter.report(value.toSpan()); } catch(RuntimeException e) { if(context != null && logger.isLoggable(Level.FINE)) { logger.log(Level.FINE, \"error flushing \" + context, e); } } } } ",
        "focal_src": "void reportOrphanedSpans() { Reference < ? extends TraceContext > reference; while((reference = poll()) != null) { TraceContext context = reference.get(); MutableSpan value = delegate.remove(reference); if(value == null)continue; try { value.annotate(clock.currentTimeMicroseconds(), \"brave.flush\"); reporter.report(value.toSpan()); } catch(RuntimeException e) { if(context != null && logger.isLoggable(Level.FINE)) { logger.log(Level.FINE, \"error flushing \" + context, e); } } } } ",
        "test_tgt": "@Test public void reportOrphanedSpans_whenReporterDies()throws Exception { MutableSpanMap map = new MutableSpanMap(localEndpoint, () -> 0, span -> { throw new RuntimeException(\"die!\"); }, new AtomicBoolean(true)); map.getOrCreate(context.toBuilder().build()); blockOnGC(); assertThat(map.delegate.keySet()).extracting(o -> ((Reference)o).get()).hasSize(1).containsNull(); map.remove(context); assertThat(map.delegate.keySet()).isEmpty(); } "
    },
    {
        "test_src": "@Test public void testCreateCommand()throws GenieException { final String id = UUID.randomUUID().toString(); final Command command = new Command.Builder(COMMAND_1_NAME, COMMAND_1_USER, COMMAND_1_VERSION, CommandStatus.ACTIVE, COMMAND_1_EXECUTABLE).withId(id).build(); final String createdId = this.service.createCommand(command); Assert.assertThat(createdId, Matchers.is(id)); final Command created = this.service.getCommand(id); Assert.assertNotNull(this.service.getCommand(id)); Assert.assertEquals(id, created.getId()); Assert.assertEquals(COMMAND_1_NAME, created.getName()); Assert.assertEquals(COMMAND_1_USER, created.getUser()); Assert.assertEquals(CommandStatus.ACTIVE, created.getStatus()); Assert.assertEquals(COMMAND_1_EXECUTABLE, created.getExecutable()); this.service.deleteCommand(id); try { this.service.getCommand(id); Assert.fail(\"Should have thrown exception\"); } catch(final GenieException ge) { Assert.assertEquals(HttpURLConnection.HTTP_NOT_FOUND, ge.getErrorCode()); } } ",
        "focal_tgt": "@Override public String createCommand(@NotNull(message = \"No command entered. Unable to create.\")@Valid final Command command)throws GenieException { log.debug(\"Called to create command {}\", command); if(StringUtils.isNotBlank(command.getId()) && this.commandRepo.exists(command.getId())) { throw new GenieConflictException(\"A command with id \" + command.getId() + \" already exists\"); } final CommandEntity commandEntity = new CommandEntity(); commandEntity.setId(StringUtils.isBlank(command.getId()) ? UUID.randomUUID().toString() : command.getId()); commandEntity.setName(command.getName()); commandEntity.setUser(command.getUser()); commandEntity.setVersion(command.getVersion()); commandEntity.setDescription(command.getDescription()); commandEntity.setExecutable(command.getExecutable()); commandEntity.setCheckDelay(command.getCheckDelay()); commandEntity.setConfigs(command.getConfigs()); commandEntity.setSetupFile(command.getSetupFile()); commandEntity.setStatus(command.getStatus()); commandEntity.setTags(command.getTags()); return this.commandRepo.save(commandEntity).getId(); } ",
        "focal_src": "@Override public String createCommand(@NotNull(message = \"No command entered. Unable to create.\")@Valid final Command command)throws GenieException { log.debug(\"Called to create command {}\", command); if(StringUtils.isNotBlank(command.getId()) && this.commandRepo.exists(command.getId())) { throw new GenieConflictException(\"A command with id \" + command.getId() + \" already exists\"); } final CommandEntity commandEntity = new CommandEntity(); commandEntity.setId(StringUtils.isBlank(command.getId()) ? UUID.randomUUID().toString() : command.getId()); commandEntity.setName(command.getName()); commandEntity.setUser(command.getUser()); commandEntity.setVersion(command.getVersion()); commandEntity.setDescription(command.getDescription()); commandEntity.setExecutable(command.getExecutable()); commandEntity.setConfigs(command.getConfigs()); commandEntity.setSetupFile(command.getSetupFile()); commandEntity.setStatus(command.getStatus()); commandEntity.setTags(command.getTags()); return this.commandRepo.save(commandEntity).getId(); } ",
        "test_tgt": "@Test public void testCreateCommand()throws GenieException { final String id = UUID.randomUUID().toString(); final Command command = new Command.Builder(COMMAND_1_NAME, COMMAND_1_USER, COMMAND_1_VERSION, CommandStatus.ACTIVE, COMMAND_1_EXECUTABLE, COMMAND_1_CHECK_DELAY).withId(id).build(); final String createdId = this.service.createCommand(command); Assert.assertThat(createdId, Matchers.is(id)); final Command created = this.service.getCommand(id); Assert.assertNotNull(this.service.getCommand(id)); Assert.assertEquals(id, created.getId()); Assert.assertEquals(COMMAND_1_NAME, created.getName()); Assert.assertEquals(COMMAND_1_USER, created.getUser()); Assert.assertEquals(CommandStatus.ACTIVE, created.getStatus()); Assert.assertEquals(COMMAND_1_EXECUTABLE, created.getExecutable()); Assert.assertThat(COMMAND_1_CHECK_DELAY, Matchers.is(created.getCheckDelay())); this.service.deleteCommand(id); try { this.service.getCommand(id); Assert.fail(\"Should have thrown exception\"); } catch(final GenieException ge) { Assert.assertEquals(HttpURLConnection.HTTP_NOT_FOUND, ge.getErrorCode()); } } "
    },
    {
        "test_src": "@Test public void testAppendWithSeparators_Iterator() { StrBuilder sb = new StrBuilder(); sb.appendWithSeparators((Iterator < ? > )null, \",\"); assertEquals(\"\", sb.toString()); sb.clear(); sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), \",\"); assertEquals(\"\", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[] { \"foo\", \"bar\", \"baz\" }).iterator(), \",\"); assertEquals(\"foo,bar,baz\", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[] { \"foo\", \"bar\", \"baz\" }).iterator(), null); assertEquals(\"foobarbaz\", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[] { \"foo\", null, \"baz\" }).iterator(), \",\"); assertEquals(\"foo,,baz\", sb.toString()); } ",
        "focal_tgt": "public StrBuilder appendWithSeparators(final Iterable < ? > iterable, String separator) { if(iterable != null) { separator = ObjectUtils.toString(separator); final Iterator < ? > it = iterable.iterator(); while(it.hasNext()) { append(it.next()); if(it.hasNext()) { append(separator); } } } return this; } ",
        "focal_src": "public StrBuilder appendWithSeparators(final Iterable < ? > iterable, String separator) { if(iterable != null) { separator = ObjectUtils.toString(separator); Iterator < ? > it = iterable.iterator(); while(it.hasNext()) { append(it.next()); if(it.hasNext()) { append(separator); } } } return this; } ",
        "test_tgt": "@Test public void testAppendWithSeparators_Iterator() { final StrBuilder sb = new StrBuilder(); sb.appendWithSeparators((Iterator < ? > )null, \",\"); assertEquals(\"\", sb.toString()); sb.clear(); sb.appendWithSeparators(Collections.EMPTY_LIST.iterator(), \",\"); assertEquals(\"\", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[] { \"foo\", \"bar\", \"baz\" }).iterator(), \",\"); assertEquals(\"foo,bar,baz\", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[] { \"foo\", \"bar\", \"baz\" }).iterator(), null); assertEquals(\"foobarbaz\", sb.toString()); sb.clear(); sb.appendWithSeparators(Arrays.asList(new Object[] { \"foo\", null, \"baz\" }).iterator(), \",\"); assertEquals(\"foo,,baz\", sb.toString()); } "
    },
    {
        "test_src": "@Test public void updateAttribute()throws Exception { final String query = \"S:update-attribute('a','b'), S:attribute('a')\"; assertEquals(\"b\", get(\"?query=\" + request(query))); } ",
        "focal_tgt": "@Requires(Permission.NONE)public void set(final Str key, final Item item)throws QueryException { Item it = item; final Data d = it.data(); if(d != null && ! d.inMemory()) { it = ((ANode)it).dbCopy(context.context.prop); } else if(it instanceof FItem) { BXSE_FITEM.thrw(null); } session().setAttribute(key.toJava(), it); } ",
        "focal_src": "@ContextDependent@Requires(Permission.NONE)public void updateAttribute(final Str key, final Item item)throws QueryException { Item it = item; final Data d = it.data(); if(d != null && ! d.inMemory()) { it = ((ANode)it).dbCopy(context.context.prop); } else if(it instanceof FItem) { BXSE_FITEM.thrw(null, it); } session().setAttribute(key.toJava(), it); } ",
        "test_tgt": "@Test public void set()throws Exception { final String query = \"S:set('a','b'), S:get('a')\"; assertEquals(\"b\", get(\"?query=\" + request(query))); } "
    },
    {
        "test_src": "@Test public void setDescription_compare() { fail(\"implement\"); } ",
        "focal_tgt": "public boolean setDescription(PyramidKltFeature feature) { for(int layer = 0; layer < image.getNumLayers(); layer ++ ) { float scale = (float)image.getScale(layer); float x = feature.x / scale; float y = feature.y / scale; setupKltTracker(layer); feature.desc[layer].setPosition(x, y); if( ! tracker.setDescription(feature.desc[layer]))return false; } return true; } ",
        "focal_src": "public boolean setDescription(PyramidKltFeature feature) { boolean valid = false; for(int layer = 0; layer < image.getNumLayers(); layer ++ ) { float scale = (float)image.getScale(layer); float x = feature.x / scale; float y = feature.y / scale; setupKltTracker(layer); feature.desc[layer].setPosition(x, y); if( ! tracker.setDescription(feature.desc[layer]))break; feature.maxLayer = layer; valid = true; } return valid; } ",
        "test_tgt": "@Test public void setDescription_compare() { ImageMiscOps.fillUniform(image, rand, 0, 100); GradientSobel.process(image, derivX, derivY, new ImageBorder1D_F32(BorderIndex1D_Extend.class)); KltTracker < ImageFloat32, ImageFloat32 > tracker = createDefaultTracker(); tracker.setImage(image, derivX, derivY); KltFeature featureA = new KltFeature(3); KltFeature featureB = new KltFeature(3); featureA.setPosition(20.6f, 25.1f); featureB.setPosition(20.6f, 25.1f); tracker.setAllowedBounds(featureA); tracker.internalSetDescription(featureA); tracker.internalSetDescriptionBorder(featureB); for(int i = 0; i < featureA.desc.data.length; i ++ ) { assertTrue(featureA.desc.data[i] == featureB.desc.data[i]); assertTrue(featureA.derivX.data[i] == featureB.derivX.data[i]); assertTrue(featureA.derivY.data[i] == featureB.derivY.data[i]); } } "
    },
    {
        "test_src": "@Test public void testGetDocumentCollection() { DocumentCollection docCollWithQueryResponse = new DocumentCollection(); List < Document > documentsWithQuery = new ArrayList < Document > (); String docId = UUID.randomUUID().toString(); String docName = \"documentName\"; Document doc = createMockDocument(docId, docName, MediaType.TEXT_HTML); String docContent = \"<html><title>Test</title><body><text>test document</text></body></html>\"; documentsWithQuery.add(doc); List < Link > links = new ArrayList < Link > (); docCollWithQueryResponse.setLinks(links); List < Parameter > queryParams = new ArrayList < Parameter > (); queryParams.add(new Parameter(\"name\", docName)); queryParams.add(new Parameter(\"limit\", \"5\")); mockServer.reset().when(request().withPath(DOCUMENTS_PATH).withQueryStringParameters(queryParams)).respond(response().withBody(GsonSingleton.getGson().toJson(docCollWithQueryResponse))); DocumentCollection docCollWithQuery = service.getDocumentCollection(null, 5, docName, null, null); Assert.assertNotNull(docCollWithQuery); Assert.assertEquals(docCollWithQuery.toString(), docCollWithQueryResponse.toString()); mockServer.when(request().withPath(DOCUMENTS_PATH + \"/\" + docId)).respond(response().withBody(docContent)); String document1 = service.getDocument(docId); Assert.assertNotNull(document1); Assert.assertEquals(document1, docContent); } ",
        "focal_tgt": "public DocumentCollection getDocumentCollection() { return getDocumentCollection(null); } ",
        "focal_src": "public DocumentCollection getDocumentCollection() { return getDocumentCollection(null, LIMIT, null, null, null); } ",
        "test_tgt": "@Test public void testGetDocumentCollection() { DocumentCollection docCollWithQueryResponse = new DocumentCollection(); List < Document > documentsWithQuery = new ArrayList < Document > (); String docId = UUID.randomUUID().toString(); String docName = \"documentName\"; Document doc = createMockDocument(docId, docName, MediaType.TEXT_HTML); String docContent = \"<html><title>Test</title><body><text>test document</text></body></html>\"; documentsWithQuery.add(doc); List < Link > links = new ArrayList < Link > (); docCollWithQueryResponse.setLinks(links); List < Parameter > queryParams = new ArrayList < Parameter > (); queryParams.add(new Parameter(\"name\", docName)); queryParams.add(new Parameter(\"limit\", \"5\")); mockServer.reset().when(request().withPath(DocumentConversion.DOCUMENTS_PATH).withQueryStringParameters(queryParams)).respond(response().withBody(GsonSingleton.getGson().toJson(docCollWithQueryResponse))); Map < String, Object > docListParams = new HashMap < String, Object > (); docListParams.put(DocumentConversion.LIMIT, 5); docListParams.put(DocumentConversion.NAME, docName); DocumentCollection docCollWithQuery = service.getDocumentCollection(docListParams); Assert.assertNotNull(docCollWithQuery); Assert.assertEquals(docCollWithQuery.toString(), docCollWithQueryResponse.toString()); mockServer.when(request().withPath(DocumentConversion.DOCUMENTS_PATH + \"/\" + docId)).respond(response().withBody(docContent)); String document1 = ConversionUtils.writeInputStreamToString(service.getDocument(docId)); Assert.assertNotNull(document1); Assert.assertEquals(document1, docContent); } "
    },
    {
        "test_src": "@Test public void backup()throws BaseXException { query(COUNT.args(_DB_BACKUPS.args(NAME)), \"0\"); query(_DB_BACKUP.args(NAME)); query(COUNT.args(_DB_BACKUPS.args(NAME)), \"1\"); error(_DB_BACKUP.args(NAME + 'x'), Err.BXDB_WHICH); new DropBackup(NAME).execute(context); query(COUNT.args(_DB_BACKUPS.args(NAME)), \"0\"); } ",
        "focal_tgt": "private Item dropBackup(final QueryContext ctx)throws QueryException { final String name = string(checkStr(expr[0], ctx)); if( ! Databases.validName(name))throw BXDB_NAME.get(info, name); final StringList files = DropBackup.backups(name, ctx.context); if(files.isEmpty())throw BXDB_WHICHBACK.get(info, name); for(final String file : files) { ctx.updates.add(new BackupDrop(file, info, ctx), ctx); } return null; } ",
        "focal_src": "private Item backup(final QueryContext ctx)throws QueryException { checkCreate(ctx); final String name = string(checkStr(expr[0], ctx)); if( ! Databases.validName(name))throw BXDB_NAME.get(info, name); if( ! ctx.context.globalopts.dbexists(name))throw BXDB_WHICH.get(info, name); ctx.updates.add(new DBBackup(name, info, ctx), ctx); return null; } ",
        "test_tgt": "@Test public void createBackup()throws BaseXException { query(COUNT.args(_DB_BACKUPS.args(NAME)), \"0\"); query(_DB_CREATE_BACKUP.args(NAME)); query(COUNT.args(_DB_BACKUPS.args(NAME)), \"1\"); error(_DB_CREATE_BACKUP.args(NAME + 'x'), Err.BXDB_WHICH); new DropBackup(NAME).execute(context); query(COUNT.args(_DB_BACKUPS.args(NAME)), \"0\"); } "
    },
    {
        "test_src": "@Test public void getLocalFilePermissionTest()throws IOException { File tmpDir = mTestFolder.newFolder(\"dir\"); File tmpFile777 = mTestFolder.newFile(\"dir/0777\"); tmpFile777.setReadable(true, false); tmpFile777.setWritable(true, false); tmpFile777.setExecutable(true, false); File tmpFile755 = mTestFolder.newFile(\"dir/0755\"); tmpFile755.setReadable(true, false); tmpFile755.setWritable(true, true); tmpFile755.setExecutable(true, false); File tmpFile444 = mTestFolder.newFile(\"dir/0444\"); tmpFile444.setReadOnly(); Assert.assertEquals((short)0777, FileUtils.getLocalFilePermission(tmpFile777.getPath())); Assert.assertEquals((short)0755, FileUtils.getLocalFilePermission(tmpFile755.getPath())); Assert.assertEquals((short)0444, FileUtils.getLocalFilePermission(tmpFile444.getPath())); FileUtils.deletePathRecursively(tmpDir.getAbsolutePath()); } ",
        "focal_tgt": "public static short getLocalFileMode(String filePath)throws IOException { Set < PosixFilePermission > permission = Files.readAttributes(Paths.get(filePath), PosixFileAttributes.class).permissions(); int mode = 0; for(PosixFilePermission action : PosixFilePermission.values()) { mode = mode << 1; mode += permission.contains(action) ? 1 : 0; } return(short)mode; } ",
        "focal_src": "public static short getLocalFilePermission(String filePath)throws IOException { Set < PosixFilePermission > permission = Files.readAttributes(Paths.get(filePath), PosixFileAttributes.class).permissions(); int mode = 0; for(PosixFilePermission action : PosixFilePermission.values()) { mode = mode << 1; mode += permission.contains(action) ? 1 : 0; } return(short)mode; } ",
        "test_tgt": "@Test public void getLocalFileModeTest()throws IOException { File tmpDir = mTestFolder.newFolder(\"dir\"); File tmpFile777 = mTestFolder.newFile(\"dir/0777\"); tmpFile777.setReadable(true, false); tmpFile777.setWritable(true, false); tmpFile777.setExecutable(true, false); File tmpFile755 = mTestFolder.newFile(\"dir/0755\"); tmpFile755.setReadable(true, false); tmpFile755.setWritable(true, true); tmpFile755.setExecutable(true, false); File tmpFile444 = mTestFolder.newFile(\"dir/0444\"); tmpFile444.setReadOnly(); Assert.assertEquals((short)0777, FileUtils.getLocalFileMode(tmpFile777.getPath())); Assert.assertEquals((short)0755, FileUtils.getLocalFileMode(tmpFile755.getPath())); Assert.assertEquals((short)0444, FileUtils.getLocalFileMode(tmpFile444.getPath())); FileUtils.deletePathRecursively(tmpDir.getAbsolutePath()); } "
    },
    {
        "test_src": "@TestTargetNew(level = TestLevel.COMPLETE, method = \"size\", args = { })@KnownFailure(\"IllegalStateException not thrown when using ZipFile.size() \" + \"after close().\")public void test_size()throws IOException { assertEquals(6, zfile.size()); zfile.close(); try { zfile.size(); fail(\"IllegalStateException expected\"); } catch(IllegalStateException ee) { } } ",
        "focal_tgt": "public int size() { int count = 0; for(Node < E > p = first(); p != null; p = succ(p)) { if(p.getItem() != null) { if( ++ count == Integer.MAX_VALUE)break; } } return count; } ",
        "focal_src": "public int size() { int count = 0; for(Node < E > p = first(); p != null; p = p.getNext()) { if(p.getItem() != null) { if( ++ count == Integer.MAX_VALUE)break; } } return count; } ",
        "test_tgt": "@TestTargetNew(level = TestLevel.COMPLETE, method = \"size\", args = { })@KnownFailure(\"IllegalStateException not thrown when using ZipFile.size() \" + \"after close().\")public void test_size()throws IOException { assertEquals(6, zfile.size()); zfile.close(); try { zfile.size(); fail(\"IllegalStateException expected\"); } catch(IllegalStateException ee) { } } "
    },
    {
        "test_src": "@Test public void testRepairSurvivors()throws InterruptedException, ExecutionException { System.out.println(\"Running testRepairSurvivors\"); InitiatorMailbox mailbox = mock(MpInitiatorMailbox.class); doReturn(4L).when(mailbox).getHSId(); ArrayList < Long > masters = new ArrayList < Long > (); masters.add(1L); masters.add(2L); masters.add(3L); MpPromoteAlgo algo = new MpPromoteAlgo(masters, mailbox, \"Test\"); long requestId = algo.getRequestId(); Future < RepairResult > result = algo.start(); verify(mailbox, times(1)).send(any(long[].class), any(Iv2RepairLogRequestMessage.class)); final long uid = uig.getNextUniqueId(); algo.deliver(makeRealAckResponse(requestId, 1L, 0, 2, txnEgo(1000L), m_hashinatorConfig, uid)); algo.deliver(makeRealFragResponse(requestId, 1L, 1, 2, txnEgo(1000L))); algo.deliver(makeRealAckResponse(requestId, 2L, 0, 1, Long.MAX_VALUE, m_hashinatorConfig, uid)); Pair < Long, byte[] > torv3 = Pair.of(m_hashinatorConfig.getFirst() + 1, m_hashinatorConfig.getSecond()); algo.deliver(makeRealAckResponse(requestId, 3L, 0, 3, txnEgo(1000L), torv3, uid)); algo.deliver(makeRealFragResponse(requestId, 3L, 1, 3, txnEgo(1000L))); algo.deliver(makeRealCompleteResponse(requestId, 3L, 2, 3, txnEgo(1000L))); algo.deliver(makeRealAckResponse(requestId, 4L, 0, 2, txnEgo(1000L), m_hashinatorConfig, uid)); algo.deliver(makeRealCompleteResponse(requestId, 4L, 1, 2, txnEgo(1000L))); List < Long > needsRepair = new ArrayList < Long > (); needsRepair.add(1L); needsRepair.add(2L); needsRepair.add(3L); verify(mailbox, times(1)).repairReplicasWith(eq(needsRepair), any(Iv2RepairLogResponseMessage.class)); assertEquals(txnEgo(1000L), result.get().m_txnId); assertEquals(uid, result.get().m_uniqueId); assertEquals(torv3.getFirst(), TheHashinator.getCurrentVersionedConfig().getFirst()); } ",
        "focal_tgt": "public void repairSurvivors() { if(this.m_promotionResult.isCancelled()) { tmLog.debug(m_whoami + \"Skipping repair message creation for cancelled Term.\"); return; } int queued = 0; tmLog.debug(m_whoami + \"received all repair logs and is repairing surviving replicas.\"); for(Iv2RepairLogResponseMessage li : m_repairLogUnion) { List < Long > needsRepair = new ArrayList < Long > (5); for(Entry < Long, ReplicaRepairStruct > entry : m_replicaRepairStructs.entrySet()) { if(entry.getValue().needs(li.getHandle())) { ++ queued; tmLog.debug(m_whoami + \"repairing \" + CoreUtils.hsIdToString(entry.getKey()) + \". Max seen \" + entry.getValue().m_maxSpHandleSeen + \". Repairing with \" + li.getHandle()); needsRepair.add(entry.getKey()); } } if( ! needsRepair.isEmpty()) { if(tmLog.isTraceEnabled()) { tmLog.trace(m_whoami + \"repairing: \" + CoreUtils.hsIdCollectionToString(needsRepair) + \" with message: \" + li.getPayload()); } m_mailbox.repairReplicasWith(needsRepair, li.getPayload()); } } tmLog.debug(m_whoami + \"finished queuing \" + queued + \" replica repair messages.\"); m_promotionResult.set(new RepairResult(m_maxSeenTxnId, m_maxSeenBinaryLogSequenceNumber, m_maxSeenBinaryLogUniqueId)); } ",
        "focal_src": "public void repairSurvivors() { if(this.m_promotionResult.isCancelled()) { tmLog.debug(m_whoami + \"Skipping repair message creation for cancelled Term.\"); return; } int queued = 0; tmLog.debug(m_whoami + \"received all repair logs and is repairing surviving replicas.\"); for(Iv2RepairLogResponseMessage li : m_repairLogUnion) { List < Long > needsRepair = new ArrayList < Long > (5); for(Entry < Long, ReplicaRepairStruct > entry : m_replicaRepairStructs.entrySet()) { if(entry.getValue().needs(li.getHandle())) { ++ queued; tmLog.debug(m_whoami + \"repairing \" + CoreUtils.hsIdToString(entry.getKey()) + \". Max seen \" + entry.getValue().m_maxSpHandleSeen + \". Repairing with \" + li.getHandle()); needsRepair.add(entry.getKey()); } } if( ! needsRepair.isEmpty()) { if(tmLog.isTraceEnabled()) { tmLog.trace(m_whoami + \"repairing: \" + CoreUtils.hsIdCollectionToString(needsRepair) + \" with message: \" + li.getPayload()); } m_mailbox.repairReplicasWith(needsRepair, li.getPayload()); } } tmLog.debug(m_whoami + \"finished queuing \" + queued + \" replica repair messages.\"); m_promotionResult.set(new RepairResult(m_maxSeenTxnId, m_maxSeenUniqueId, m_maxSeenBinaryLogSequenceNumber, m_maxSeenBinaryLogUniqueId)); } ",
        "test_tgt": "@Test public void testRepairSurvivors()throws InterruptedException, ExecutionException { System.out.println(\"Running testRepairSurvivors\"); InitiatorMailbox mailbox = mock(MpInitiatorMailbox.class); doReturn(4L).when(mailbox).getHSId(); ArrayList < Long > masters = new ArrayList < Long > (); masters.add(1L); masters.add(2L); masters.add(3L); MpPromoteAlgo algo = new MpPromoteAlgo(masters, mailbox, \"Test\"); long requestId = algo.getRequestId(); Future < RepairResult > result = algo.start(); verify(mailbox, times(1)).send(any(long[].class), any(Iv2RepairLogRequestMessage.class)); algo.deliver(makeRealAckResponse(requestId, 1L, 0, 2, txnEgo(1000L), m_hashinatorConfig)); algo.deliver(makeRealFragResponse(requestId, 1L, 1, 2, txnEgo(1000L))); algo.deliver(makeRealAckResponse(requestId, 2L, 0, 1, Long.MAX_VALUE, m_hashinatorConfig)); Pair < Long, byte[] > torv3 = Pair.of(m_hashinatorConfig.getFirst() + 1, m_hashinatorConfig.getSecond()); algo.deliver(makeRealAckResponse(requestId, 3L, 0, 3, txnEgo(1000L), torv3)); algo.deliver(makeRealFragResponse(requestId, 3L, 1, 3, txnEgo(1000L))); algo.deliver(makeRealCompleteResponse(requestId, 3L, 2, 3, txnEgo(1000L))); algo.deliver(makeRealAckResponse(requestId, 4L, 0, 2, txnEgo(1000L), m_hashinatorConfig)); algo.deliver(makeRealCompleteResponse(requestId, 4L, 1, 2, txnEgo(1000L))); List < Long > needsRepair = new ArrayList < Long > (); needsRepair.add(1L); needsRepair.add(2L); needsRepair.add(3L); verify(mailbox, times(1)).repairReplicasWith(eq(needsRepair), any(Iv2RepairLogResponseMessage.class)); assertEquals(txnEgo(1000L), result.get().m_txnId); assertEquals(torv3.getFirst(), TheHashinator.getCurrentVersionedConfig().getFirst()); } "
    },
    {
        "test_src": "@Test public void testCompletedStage()throws Exception { CompletionStage < Integer > cs0; try { cs0 = ManagedCompletableFuture.completedStage(86); } catch(UnsupportedOperationException x) { if(AT_LEAST_JAVA_9)throw x; else return; } CompletableFuture < Integer > cf0 = (CompletableFuture < Integer > )cs0; try { cf0.obtrudeValue(860); fail(\"obtrudeValue must not be permitted on minimal stage: \"); } catch(UnsupportedOperationException x) { } try { fail(\"cancel must not be permitted on minimal stage: \" + cf0.cancel(true)); } catch(UnsupportedOperationException x) { } final CompletableFuture < String > cf = new CompletableFuture < String > (); CompletionStage < Void > cs1 = cs0.thenAcceptAsync(value -> cf.complete(Thread.currentThread().getName() + \":\" + value)); String result = cf.get(TIMEOUT_NS, TimeUnit.NANOSECONDS); assertTrue(result, result.endsWith(\":86\")); assertTrue(result, result.startsWith(\"Default Executor-thread-\")); assertTrue(result, ! result.startsWith(Thread.currentThread().getName())); CompletableFuture < Void > cf1 = (CompletableFuture < Void > )cs1; try { fail(\"get must not be permitted on minimal stage: \" + cf1.get()); } catch(UnsupportedOperationException x) { } try { cf1.obtrudeException(new ArithmeticException(\"test\")); fail(\"obtrudeException must not be permitted on minimal stage: \"); } catch(UnsupportedOperationException x) { } } ",
        "focal_tgt": "public static < U > CompletionStage < U > completedStage(U value) { ManagedExecutorService defaultExecutor = AccessController.doPrivileged(getDefaultManagedExecutorAction); return completedStage(value, defaultExecutor); } ",
        "focal_src": "public static < U > CompletionStage < U > completedStage(U value) { if(JAVA8)throw new UnsupportedOperationException(); ManagedExecutorService defaultExecutor = AccessController.doPrivileged(getDefaultManagedExecutorAction); ManagedCompletionStage < U > stage = new ManagedCompletionStage < U > (defaultExecutor); stage.super_complete(value); return stage; } ",
        "test_tgt": "@Test public void testCompletedStage()throws Exception { CompletionStage < Integer > cs0 = defaultManagedExecutor.completedStage(86); CompletableFuture < Integer > cf0 = (CompletableFuture < Integer > )cs0; try { cf0.obtrudeValue(860); fail(\"obtrudeValue must not be permitted on minimal stage: \"); } catch(UnsupportedOperationException x) { } try { fail(\"cancel must not be permitted on minimal stage: \" + cf0.cancel(true)); } catch(UnsupportedOperationException x) { } final CompletableFuture < String > cf = new CompletableFuture < String > (); CompletionStage < Void > cs1 = cs0.thenAcceptAsync(value -> cf.complete(Thread.currentThread().getName() + \":\" + value)); for(long start = System.nanoTime(); ! cf.isDone() && System.nanoTime() - start < TIMEOUT_NS; TimeUnit.MILLISECONDS.sleep(200)); assertTrue(cf.isDone()); String result = cf.getNow(\"value-if-absent\"); assertTrue(result, result.endsWith(\":86\")); assertTrue(result, result.startsWith(\"Default Executor-thread-\")); assertTrue(result, ! result.startsWith(Thread.currentThread().getName())); CompletableFuture < Void > cf1 = (CompletableFuture < Void > )cs1; try { fail(\"get must not be permitted on minimal stage: \" + cf1.get()); } catch(UnsupportedOperationException x) { } try { cf1.obtrudeException(new ArithmeticException(\"test\")); fail(\"obtrudeException must not be permitted on minimal stage: \"); } catch(UnsupportedOperationException x) { } } "
    },
    {
        "test_src": "@Test public void event()throws BaseXException { cs.execute(\"create event \" + EVENT_NAME); for(int i = ccs.length / 2; i < ccs.length; i ++ ) { ccs[i].watchEvent(EVENT_NAME, new EventNotification() { @Override public void update(final String data) { assertEquals(RETURN_VALUE, data); } }); } cs.event(\"1 to 10\", EVENT_NAME, RETURN_VALUE); for(int i = ccs.length / 2; i < ccs.length; i ++ ) { ccs[i].unwatchEvent(EVENT_NAME); } cs.execute(\"drop event \" + EVENT_NAME); } ",
        "focal_tgt": "private Iter event(final QueryContext ctx)throws QueryException { String name = expr[0].toString(); String q2 = expr[2].toString(); String msg = \"\"; Value v = expr[1].value(ctx); if(q2.replaceAll(\"\\\"\", \"\").trim().isEmpty()) { ctx.updating = true; msg = ctx.value(expr[1]).toString(); } else { msg = ctx.value(expr[2]).toString(); } ctx.context.events.notify(ctx.context.session, name, msg); return v.iter(); } ",
        "focal_src": "private Iter event(final QueryContext ctx)throws QueryException { String msg = expr[3].toString().equals(\"m\") ? expr[2].toString() : null; Value v = expr[0].value(ctx); if(msg == null) { ctx.updating = true; msg = ctx.value(expr[0]).toString(); } ctx.context.events.notify(ctx.context.session, expr[1].toString(), msg); return v.iter(); } ",
        "test_tgt": "@Test public void event()throws BaseXException { event(RETURN_VALUE1, true); event(RETURN_VALUE2, false); } "
    },
    {
        "test_src": "@SuppressWarnings(\"unchecked\")@Test public void testSelectableConvert()throws Exception { Object nativeInput = Arrays.asList(\"//a:a1\", \"//a:a2\"); Object selectableInput = SelectorList.of(new SelectorValue(ImmutableMap.of(\"//conditions:a\", nativeInput, BuildType.Selector.DEFAULT_CONDITION_KEY, nativeInput), \"\")); List < Label > expectedLabels = ImmutableList.of(Label.create(\"@//a\", \"a1\"), Label.create(\"@//a\", \"a2\")); Object converted = BuildType.selectableConvert(BuildType.LABEL_LIST, nativeInput, null, currentRule); assertThat(converted instanceof List < ? > ).isTrue(); assertThat((List < Label > )converted).containsExactlyElementsIn(expectedLabels); converted = BuildType.selectableConvert(BuildType.LABEL_LIST, selectableInput, null, currentRule); BuildType.SelectorList < ? > selectorList = (BuildType.SelectorList < ? > )converted; assertThat(((Selector < Label > )selectorList.getSelectors().get(0)).getEntries().entrySet()).containsExactlyElementsIn(ImmutableMap.of(Label.parseAbsolute(\"//conditions:a\"), expectedLabels, Label.parseAbsolute(BuildType.Selector.DEFAULT_CONDITION_KEY), expectedLabels).entrySet()); } ",
        "focal_tgt": "public static < T > Object selectableConvert(Type < T > type, Object x, Object what, LabelConversionContext context)throws ConversionException { if(x instanceof com.google.devtools.build.lib.syntax.SelectorList) { return new SelectorList < T > (((com.google.devtools.build.lib.syntax.SelectorList)x).getElements(), what, context, type); } else { return type.convert(x, what, context); } } ",
        "focal_src": "public static < T > Object selectableConvert(Type type, Object x, Object what, @Nullable Label context)throws ConversionException { if(x instanceof com.google.devtools.build.lib.syntax.SelectorList) { return new SelectorList < T > (((com.google.devtools.build.lib.syntax.SelectorList)x).getElements(), what, context, type); } else { return type.convert(x, what, context); } } ",
        "test_tgt": "@SuppressWarnings(\"unchecked\")@Test public void testSelectableConvert()throws Exception { Object nativeInput = Arrays.asList(\"//a:a1\", \"//a:a2\"); Object selectableInput = SelectorList.of(new SelectorValue(ImmutableMap.of(\"//conditions:a\", nativeInput, BuildType.Selector.DEFAULT_CONDITION_KEY, nativeInput), \"\")); List < Label > expectedLabels = ImmutableList.of(Label.create(\"@//a\", \"a1\"), Label.create(\"@//a\", \"a2\")); Object converted = BuildType.selectableConvert(BuildType.LABEL_LIST, nativeInput, null, labelConversionContext); assertThat(converted instanceof List < ? > ).isTrue(); assertThat((List < Label > )converted).containsExactlyElementsIn(expectedLabels); converted = BuildType.selectableConvert(BuildType.LABEL_LIST, selectableInput, null, labelConversionContext); BuildType.SelectorList < ? > selectorList = (BuildType.SelectorList < ? > )converted; assertThat(((Selector < Label > )selectorList.getSelectors().get(0)).getEntries().entrySet()).containsExactlyElementsIn(ImmutableMap.of(Label.parseAbsolute(\"//conditions:a\"), expectedLabels, Label.parseAbsolute(BuildType.Selector.DEFAULT_CONDITION_KEY), expectedLabels).entrySet()); } "
    },
    {
        "test_src": "@Test(description = \"POST /vApp/{id}/action/relocate\", dependsOnMethods = { \"testGetVm\" })public void testRelocate() { QueryResultRecords records = context.getApi().getQueryApi().queryAll(\"datastore\"); QueryResultRecordType datastore = Iterables.getLast(records.getRecords()); RelocateParams params = RelocateParams.builder().datastore(Reference.builder().href(datastore.getHref()).build()).build(); Task relocate = vmApi.relocate(vm.getHref(), params); assertTrue(retryTaskSuccess.apply(relocate), String.format(TASK_COMPLETE_TIMELY, \"relocate\")); } ",
        "focal_tgt": "Task relocate(URI vmHref, RelocateParams params); ",
        "focal_src": "Task relocate(URI vmURI, RelocateParams params); ",
        "test_tgt": "@Test(description = \"POST /vApp/{id}/action/relocate\", dependsOnMethods = { \"testGetVm\" })public void testRelocate() { QueryResultRecords records = context.getApi().getQueryApi().queryAll(\"datastore\"); QueryResultRecordType datastore = Iterables.getLast(records.getRecords()); RelocateParams params = RelocateParams.builder().datastore(Reference.builder().href(datastore.getHref()).build()).build(); Task relocate = vmApi.relocate(vmUrn, params); assertTrue(retryTaskSuccess.apply(relocate), String.format(TASK_COMPLETE_TIMELY, \"relocate\")); } "
    },
    {
        "test_src": "@Test public void convolve() { Kernel2D_I32 kernel = FactoryKernel.random2D_I32(7, 3, 0, 20, rand); kernel.offset = 1; GrayU8 input = new GrayU8(15, 16); ImageMiscOps.fillUniform(input, rand, 0, 50); GrayU8 output = new GrayU8(15, 16); ConvolveNormalizedNaive.convolve(kernel, input, output); for(int y = 0; y < output.height; y ++ ) { for(int x = 0; x < output.width; x ++ ) { int expected = convolve(x, y, kernel, input); int found = output.get(x, y); assertEquals(x + \" \" + y, expected, found); } } } ",
        "focal_tgt": "public static void convolve(Kernel2D_S32 kernel, GrayS16 image, GrayI16 dest, int skip) { checkParameters(image, dest, skip); if(kernel.width >= image.width) { ConvolveDownNormalizedNaive.convolve(kernel, image, dest, skip); } else { ConvolveDownNoBorder.convolve(kernel, image, dest, skip, kernel.computeSum()); ConvolveDownNormalized_JustBorder.convolve(kernel, image, dest, skip); } } ",
        "focal_src": "public static void convolve(Kernel2D_I32 kernel, GrayS16 image, GrayI16 dest, int skip) { checkParameters(image, dest, skip); if(kernel.width >= image.width) { ConvolveDownNormalizedNaive.convolve(kernel, image, dest, skip); } else { ConvolveDownNoBorder.convolve(kernel, image, dest, skip, kernel.computeSum()); ConvolveDownNormalized_JustBorder.convolve(kernel, image, dest, skip); } } ",
        "test_tgt": "@Test public void convolve() { Kernel2D_S32 kernel = FactoryKernel.random2D_I32(7, 3, 0, 20, rand); kernel.offset = 1; GrayU8 input = new GrayU8(15, 16); ImageMiscOps.fillUniform(input, rand, 0, 50); GrayU8 output = new GrayU8(15, 16); ConvolveNormalizedNaive.convolve(kernel, input, output); for(int y = 0; y < output.height; y ++ ) { for(int x = 0; x < output.width; x ++ ) { int expected = convolve(x, y, kernel, input); int found = output.get(x, y); assertEquals(x + \" \" + y, expected, found); } } } "
    },
    {
        "test_src": "@Test(expected = IllegalArgumentException.class)public void test_checkNearCacheConfig_NATIVE() { checkNearCacheConfig(getNearCacheConfig(NATIVE), false); } ",
        "focal_tgt": "public static void checkNearCacheConfig(NearCacheConfig nearCacheConfig, boolean isClient) { checkNotNative(nearCacheConfig.getInMemoryFormat()); checkEvictionConfig(nearCacheConfig.getEvictionConfig(), true); if(isClient && nearCacheConfig.isCacheLocalEntries()) { throw new IllegalArgumentException(\"The Near Cache option `cache-local-entries` is not supported in client configurations!\"); } } ",
        "focal_src": "public static void checkNearCacheConfig(NearCacheConfig nearCacheConfig, boolean isClient) { checkNotNative(nearCacheConfig.getInMemoryFormat()); if(isClient && nearCacheConfig.isCacheLocalEntries()) { throw new IllegalArgumentException(\"The Near Cache option `cache-local-entries` is not supported in client configurations!\"); } } ",
        "test_tgt": "@Test(expected = IllegalArgumentException.class)public void checkNearCacheConfig_NATIVE() { checkNearCacheConfig(getNearCacheConfig(NATIVE), false); } "
    },
    {
        "test_src": "@Test public void testGetDocument() { Map < String, Object > params = new HashMap < String, Object > (); params.put(ConceptInsights.ACCOUNT_ID, \"public\"); params.put(ConceptInsights.CORPUS, \"ibmresearcher\"); params.put(ConceptInsights.DOCUMENT, \"il-AHARONA\"); Document document = service.getDocument(\"public\", \"ibmresearcher\", \"il-AHARONA\"); Assert.assertNotNull(document); } ",
        "focal_tgt": "public Document getDocument(final Document document) { String documentId = IDValidator.getDocumentId(document); return executeRequest(API_VERSION + documentId, null, Document.class); } ",
        "focal_src": "public Document getDocument(Document document, String corpusName) { ConceptInsightsId.validateGenarate(document, getAccountId(), corpusName); return executeRequest(version + document.getId(), null, Document.class); } ",
        "test_tgt": "@Test public void testGetDocument() { Document document = service.getDocument(EXAMPLE_DOCUMENT); Assert.assertNotNull(document); } "
    },
    {
        "test_src": "@Test public void testGetIdentifiableLanguages() { Map < String, Object > response = new HashMap < String, Object > (); List < IdentifiableLanguage > langs = new ArrayList < IdentifiableLanguage > (); langs.add(new IdentifiableLanguage(\"af\", \"Afrikaans\")); langs.add(new IdentifiableLanguage(\"ar\", \"Arabic\")); langs.add(new IdentifiableLanguage(\"az\", \"Azerbaijani\")); langs.add(new IdentifiableLanguage(\"zh\", \"Chinese\")); response.put(\"languages\", langs); mockServer.when(request().withPath(IDENTIFIABLE_LANGUAGES_PATH)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, MediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGson().toJson(response))); List < IdentifiableLanguage > languages = service.getIdentifiableLanguages(); mockServer.verify(request().withPath(IDENTIFIABLE_LANGUAGES_PATH), VerificationTimes.exactly(1)); assertNotNull(languages); assertEquals(languages, langs); } ",
        "focal_tgt": "public List < IdentifiableLanguage > getIdentifiableLanguages() { final RequestBuilder requestBuilder = RequestBuilder.get(\"/v2/identifiable_languages\"); final Response response = execute(requestBuilder.build()); final JsonObject jsonObject = ResponseUtil.getJsonObject(response); final List < IdentifiableLanguage > langs = GsonSingleton.getGson().fromJson(jsonObject.get(LANGUAGES), identifiableLanguagesListType); return langs; } ",
        "focal_src": "public List < IdentifiableLanguage > getIdentifiableLanguages() { Request request = Request.Get(\"/v2/identifiable_languages\"); HttpRequestBase requestBase = request.build(); try { HttpResponse response = execute(requestBase); JsonObject jsonObject = ResponseUtil.getJsonObject(response); List < IdentifiableLanguage > langs = GsonSingleton.getGson().fromJson(jsonObject.get(LANGUAGES), identifiableLanguagesListType); return langs; } catch(IOException e) { throw new RuntimeException(e); } } ",
        "test_tgt": "@Test public void testGetIdentifiableLanguages() { final Map < String, Object > response = new HashMap < String, Object > (); final List < IdentifiableLanguage > langs = new ArrayList < IdentifiableLanguage > (); langs.add(new IdentifiableLanguage(\"af\", \"Afrikaans\")); langs.add(new IdentifiableLanguage(\"ar\", \"Arabic\")); langs.add(new IdentifiableLanguage(\"az\", \"Azerbaijani\")); langs.add(new IdentifiableLanguage(\"zh\", \"Chinese\")); response.put(\"languages\", langs); mockServer.when(request().withPath(IDENTIFIABLE_LANGUAGES_PATH)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGson().toJson(response))); final List < IdentifiableLanguage > languages = service.getIdentifiableLanguages(); mockServer.verify(request().withPath(IDENTIFIABLE_LANGUAGES_PATH), VerificationTimes.exactly(1)); assertNotNull(languages); assertEquals(languages, langs); } "
    },
    {
        "test_src": "@Test public void testNbar() { logger.info(\"Nbar\"); TransposeDataList clusterIdList = generateClusterIdList(); double expResult = 10.0; double result = ClusterSampling.Nbar(clusterIdList); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } ",
        "focal_tgt": "public static double nBar(TransposeDataList clusterIdList) { int populationM = clusterIdList.size(); double nBar = 0.0; for(Map.Entry < Object, FlatDataList > entry : clusterIdList.entrySet()) { nBar += (double)entry.getValue().size() / populationM; } return nBar; } ",
        "focal_src": "public static double Nbar(TransposeDataList clusterIdList) { int populationM = clusterIdList.size(); double Nbar = 0.0; for(Map.Entry < Object, FlatDataList > entry : clusterIdList.entrySet()) { Nbar += (double)entry.getValue().size() / populationM; } return Nbar; } ",
        "test_tgt": "@Test public void testNbar() { logger.info(\"Nbar\"); TransposeDataList clusterIdList = generateClusterIdList(); double expResult = 10.0; double result = ClusterSampling.nBar(clusterIdList); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } "
    },
    {
        "test_src": "@Test public void test_projectGeoPoint_1() { final GeoPoint hannover = new GeoPoint(52370816, 9735936); final int zoom = 8; final Point point = Mercator.projectGeoPoint(hannover, zoom, null); assertEquals(\"TODO describe test\", 134, point.x); assertEquals(\"TODO describe test\", 84, point.y); } ",
        "focal_tgt": "public static BasicPoint projectGeoPoint(final GeoPoint aGeoPoint, final int aZoom, final BasicPoint aUseAsReturnValue) { final BasicPoint p = (aUseAsReturnValue != null) ? aUseAsReturnValue : new BasicPoint(); final double aLon = aGeoPoint.getLongitudeE6() * 1E-6; final double aLat = aGeoPoint.getLatitudeE6() * 1E-6; p.x = (int)Math.floor((aLon + 180) / 360 * (1 << aZoom)); p.y = (int)Math.floor((1 - Math.log(Math.tan(aLat * DEG2RAD) + 1 / Math.cos(aLat * DEG2RAD)) / Math.PI) / 2 * (1 << aZoom)); return p; } ",
        "focal_src": "public static Point projectGeoPoint(final GeoPoint aGeoPoint, final int aZoom, final Point aUseAsReturnValue) { final Point p = (aUseAsReturnValue != null) ? aUseAsReturnValue : new Point(); final double aLon = aGeoPoint.getLongitudeE6() * 1E-6; final double aLat = aGeoPoint.getLatitudeE6() * 1E-6; p.x = (int)Math.floor((aLon + 180) / 360 * (1 << aZoom)); p.y = (int)Math.floor((1 - Math.log(Math.tan(aLat * DEG2RAD) + 1 / Math.cos(aLat * DEG2RAD)) / Math.PI) / 2 * (1 << aZoom)); return p; } ",
        "test_tgt": "@Test public void test_projectGeoPoint_1() { final GeoPoint hannover = new GeoPoint(52370816, 9735936); final int zoom = 8; final BasicPoint point = Mercator.projectGeoPoint(hannover, zoom, null); assertEquals(\"TODO describe test\", 134, point.x); assertEquals(\"TODO describe test\", 84, point.y); } "
    },
    {
        "test_src": "@Test public void testGetLicenseText_4args()throws SQLException, AuthorizeException { Locale locale = null; Collection collection = null; Item item = null; EPerson person = null; String template = \"Template license: %1$s %2$s %3$s %5$s %6$s\"; String templateResult = \"Template license: first name last name test@email.com \"; String defaultLicense = LicenseManager.getDefaultSubmissionLicense(); context.turnOffAuthorisationSystem(); locale = Locale.ENGLISH; collection = Collection.create(context); item = Item.create(context); person = EPerson.create(context); person.setFirstName(\"first name\"); person.setLastName(\"last name\"); person.setEmail(\"test@email.com\"); assertThat(\"testGetLicenseText_5args 0\", LicenseUtils.getLicenseText(locale, collection, item, person), equalTo(defaultLicense)); locale = Locale.GERMAN; collection = Collection.create(context); item = Item.create(context); person = EPerson.create(context); person.setFirstName(\"first name\"); person.setLastName(\"last name\"); person.setEmail(\"test@email.com\"); assertThat(\"testGetLicenseText_5args 1\", LicenseUtils.getLicenseText(locale, collection, item, person), equalTo(defaultLicense)); locale = Locale.ENGLISH; collection = Collection.create(context); collection.setLicense(template); item = Item.create(context); person = EPerson.create(context); person.setFirstName(\"first name\"); person.setLastName(\"last name\"); person.setEmail(\"test@email.com\"); assertThat(\"testGetLicenseText_5args 3\", LicenseUtils.getLicenseText(locale, collection, item, person), equalTo(templateResult)); locale = Locale.GERMAN; collection = Collection.create(context); collection.setLicense(template); item = Item.create(context); person = EPerson.create(context); person.setFirstName(\"first name\"); person.setLastName(\"last name\"); person.setEmail(\"test@email.com\"); assertThat(\"testGetLicenseText_5args 4\", LicenseUtils.getLicenseText(locale, collection, item, person), equalTo(templateResult)); context.restoreAuthSystemState(); } ",
        "focal_tgt": "public static String getLicenseText(Locale locale, Collection collection, Item item, EPerson eperson, Map < String, Object > additionalInfo) { Formatter formatter = new Formatter(locale); int numArgs = 7 + (additionalInfo != null ? additionalInfo.size() : 0); Object[]args = new Object[numArgs]; args[0] = eperson.getFirstName(); args[1] = eperson.getLastName(); args[2] = eperson.getEmail(); args[3] = new java.util.Date(); args[4] = new FormattableArgument(\"collection\", collection); args[5] = new FormattableArgument(\"item\", item); args[6] = new FormattableArgument(\"eperson\", eperson); if(additionalInfo != null) { int i = 7; for(Map.Entry < String, Object > info : additionalInfo.entrySet()) { args[i] = new FormattableArgument(info.getKey(), info.getValue()); i ++ ; } } String licenseTemplate = collectionService.getLicense(collection); return formatter.format(licenseTemplate, args).toString(); } ",
        "focal_src": "public static String getLicenseText(Locale locale, Collection collection, Item item, EPerson eperson, Map < String, Object > additionalInfo) { Formatter formatter = new Formatter(locale); int numArgs = 7 + (additionalInfo != null ? additionalInfo.size() : 0); Object[]args = new Object[numArgs]; args[0] = eperson.getFirstName(); args[1] = eperson.getLastName(); args[2] = eperson.getEmail(); args[3] = new java.util.Date(); args[4] = new FormattableArgument(\"collection\", collection); args[5] = new FormattableArgument(\"item\", item); args[6] = new FormattableArgument(\"eperson\", eperson); if(additionalInfo != null) { int i = 7; for(Map.Entry < String, Object > info : additionalInfo.entrySet()) { args[i] = new FormattableArgument(info.getKey(), info.getValue()); i ++ ; } } String licenseTemplate = collection.getLicense(); return formatter.format(licenseTemplate, args).toString(); } ",
        "test_tgt": "@Test public void testGetLicenseText_4args()throws SQLException, AuthorizeException, IOException { Locale locale = null; Collection collection = null; Item item = null; EPerson person = null; String template = \"Template license: %1$s %2$s %3$s %5$s %6$s\"; String templateResult = \"Template license: first name last name testgetlicensetext_4args@email.com \"; context.turnOffAuthorisationSystem(); person = ePersonService.create(context); person.setFirstName(context, \"first name\"); person.setLastName(context, \"last name\"); person.setEmail(\"testGetLicenseText_4args@email.com\"); ePersonService.update(context, person); String defaultLicense = licenseService.getDefaultSubmissionLicense(); context.turnOffAuthorisationSystem(); locale = Locale.ENGLISH; collection = collectionService.create(context, owningCommunity); item = installItemService.installItem(context, workspaceItemService.create(context, collection, false)); assertThat(\"testGetLicenseText_5args 0\", LicenseUtils.getLicenseText(locale, collection, item, person), equalTo(defaultLicense)); locale = Locale.GERMAN; collection = collectionService.create(context, owningCommunity); item = installItemService.installItem(context, workspaceItemService.create(context, collection, false)); assertThat(\"testGetLicenseText_5args 1\", LicenseUtils.getLicenseText(locale, collection, item, person), equalTo(defaultLicense)); locale = Locale.ENGLISH; collection = collectionService.create(context, owningCommunity); collection.setLicense(context, template); item = installItemService.installItem(context, workspaceItemService.create(context, collection, false)); assertThat(\"testGetLicenseText_5args 3\", LicenseUtils.getLicenseText(locale, collection, item, person), equalTo(templateResult)); locale = Locale.GERMAN; collection = collectionService.create(context, owningCommunity); collection.setLicense(context, template); item = installItemService.installItem(context, workspaceItemService.create(context, collection, false)); assertThat(\"testGetLicenseText_5args 4\", LicenseUtils.getLicenseText(locale, collection, item, person), equalTo(templateResult)); context.restoreAuthSystemState(); } "
    },
    {
        "test_src": "@Test public void hugeFolder()throws Exception { String username = generateUsername(); String password = \"test01\"; UserContext context = ensureSignedUp(username, password, network, crypto); FileTreeNode userRoot = context.getUserRoot().get(); List < String > names = new ArrayList < > (); IntStream.range(0, 100).forEach(i -> names.add(randomString())); long worst = 0, best = Long.MAX_VALUE, start = System.currentTimeMillis(); for(int i = 0; i < names.size(); i ++ ) { String filename = names.get(i); long t1 = System.currentTimeMillis(); userRoot.mkdir(filename, context.network, false, context.crypto.random, context.entrie).get(); long duration = System.currentTimeMillis() - t1; worst = Math.max(worst, duration); best = Math.min(best, duration); System.err.printf(\"MKDIR(%d) duration: %d mS, best: %d mS, worst: %d mS, av: %d mS\\n\", i, duration, best, worst, (t1 + duration - start) / (i + 1)); } } ",
        "focal_tgt": "public void hugeFolder()throws Exception { String username = generateUsername(); String password = \"test01\"; UserContext context = ensureSignedUp(username, password, network, crypto); FileTreeNode userRoot = context.getUserRoot().get(); List < String > names = new ArrayList < > (); IntStream.range(0, 2000).forEach(i -> names.add(randomString())); for(String filename : names) { userRoot.mkdir(filename, context.network, false, context.crypto.random); } } ",
        "focal_src": "public void hugeFolder()throws Exception { String username = generateUsername(); String password = \"test01\"; UserContext context = ensureSignedUp(username, password, network, crypto); FileTreeNode userRoot = context.getUserRoot().get(); List < String > names = new ArrayList < > (); IntStream.range(0, 2000).forEach(i -> names.add(randomString())); for(String filename : names) { userRoot.mkdir(filename, context.network, false, context.crypto.random, context.entrie); } } ",
        "test_tgt": "@Test public void hugeFolder()throws Exception { String username = generateUsername(); String password = \"test01\"; UserContext context = ensureSignedUp(username, password, network, crypto); FileTreeNode userRoot = context.getUserRoot().get(); List < String > names = new ArrayList < > (); IntStream.range(0, 100).forEach(i -> names.add(randomString())); long worst = 0, best = Long.MAX_VALUE, start = System.currentTimeMillis(); for(int i = 0; i < names.size(); i ++ ) { String filename = names.get(i); long t1 = System.currentTimeMillis(); userRoot.mkdir(filename, context.network, false, context.crypto.random).get(); long duration = System.currentTimeMillis() - t1; worst = Math.max(worst, duration); best = Math.min(best, duration); System.err.printf(\"MKDIR(%d) duration: %d mS, best: %d mS, worst: %d mS, av: %d mS\\n\", i, duration, best, worst, (t1 + duration - start) / (i + 1)); } } "
    },
    {
        "test_src": "@Test public void testSyncLocalCoreWithSharedStore_syncEquivalent()throws Exception { CoreContainer ccSpy = Mockito.spy(cc); ZkController zkSpy = Mockito.spy(zk); BlobStorageProvider blobProvideMock = Mockito.mock(BlobStorageProvider.class); CoreStorageClient blobClientMock = Mockito.mock(CoreStorageClient.class); Mockito.when(ccSpy.getZkController()).thenReturn(zkSpy); Mockito.when(zkSpy.getBlobStorageProvider()).thenReturn(blobProvideMock); Mockito.when(blobProvideMock.getDefaultClient()).thenReturn(blobClientMock); SharedShardMetadataController sharedMetadataController = zk.getSharedShardMetadataController(); sharedMetadataController.ensureMetadataNodeExists(collectionName, shardName); try { BlobStoreUtils.syncLocalCoreWithSharedStore(collectionName, newReplica.getCoreName(), shardName, ccSpy); verify(blobClientMock, never()).pullCoreMetadata(anyString(), anyString()); } catch(Exception ex) { fail(\"syncLocalCoreWithSharedStore failed with exception: \" + ex.getMessage()); } } ",
        "focal_tgt": "public static void syncLocalCoreWithSharedStore(String collectionName, String coreName, String shardName, CoreContainer coreContainer)throws SolrException { assertTrue(coreContainer.isZooKeeperAware()); ZkController zkController = coreContainer.getZkController(); SharedShardMetadataController sharedMetadataController = coreContainer.getSharedStoreManager().getSharedShardMetadataController(); DocCollection collection = zkController.getClusterState().getCollection(collectionName); CoreStorageClient blobClient = coreContainer.getSharedStoreManager().getBlobStorageProvider().getDefaultClient(); log.info(\"sync intialized for collection=\" + collectionName + \" shard=\" + shardName + \" coreName=\" + coreName); CoreSyncStatus syncStatus = CoreSyncStatus.FAILURE; Slice shard = collection.getSlicesMap().get(shardName); if(shard != null) { try { String sharedStoreName = (String)shard.get(ZkStateReader.SHARED_SHARD_NAME); VersionedData data = sharedMetadataController.readMetadataValue(collectionName, shardName, false); Map < String, String > nodeUserData = (Map < String, String > )Utils.fromJSON(data.getData()); String metadataSuffix = nodeUserData.get(SharedShardMetadataController.SUFFIX_NODE_NAME); if(SharedShardMetadataController.METADATA_NODE_DEFAULT_VALUE.equals(metadataSuffix)) { log.info(\"sync successful, nothing to pull, collection=\" + collectionName + \" shard=\" + shardName + \" coreName=\" + coreName); return; } String blobCoreMetadataName = BlobStoreUtils.buildBlobStoreMetadataName(metadataSuffix); BlobCoreMetadata blobstoreMetadata = blobClient.pullCoreMetadata(sharedStoreName, blobCoreMetadataName); if(null == blobstoreMetadata) { throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"cannot get core.metadata file from shared store, blobCoreMetadataName=\" + blobCoreMetadataName + \" shard=\" + shardName + \" collectionName=\" + collectionName + \" sharedStoreName=\" + sharedStoreName); } else if(blobstoreMetadata.getIsDeleted()) { throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"core.metadata file is marked deleted in shared store, blobCoreMetadataName=\" + blobCoreMetadataName + \" shard=\" + shardName + \" collectionName=\" + collectionName + \" sharedStoreName=\" + sharedStoreName); } else if(blobstoreMetadata.getIsCorrupt()) { log.warn(\"core.Metadata file is marked corrpt, skipping sync, collection=\" + collectionName + \" shard=\" + shardName + \" coreName=\" + coreName + \" sharedStoreName=\" + sharedStoreName); return; } ServerSideMetadata serverMetadata = new ServerSideMetadata(coreName, coreContainer); SharedMetadataResolutionResult resolutionResult = SharedStoreResolutionUtil.resolveMetadata(serverMetadata, blobstoreMetadata); PushPullData pushPullData = new PushPullData.Builder().setCollectionName(collectionName).setShardName(shardName).setCoreName(coreName).setSharedStoreName(sharedStoreName).setLastReadMetadataSuffix(metadataSuffix).setNewMetadataSuffix(BlobStoreUtils.generateMetadataSuffix()).setZkVersion(data.getVersion()).build(); if(resolutionResult.getFilesToPull().size() > 0) { BlobDeleteManager deleteManager = coreContainer.getSharedStoreManager().getBlobDeleteManager(); CorePushPull cp = new CorePushPull(blobClient, deleteManager, pushPullData, resolutionResult, serverMetadata, blobstoreMetadata); cp.pullUpdateFromBlob(true); } else { log.info(\"sync successful, nothing to pull for collection=\" + collectionName + \" shard=\" + shardName + \" coreName=\" + coreName); } } catch(Exception ex) { throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error occured pulling shard=\" + shardName + \" collection=\" + collectionName + \" from shared store \" + ex); } } else { throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Sync requested for unknown shard=\" + shardName + \" in collection=\" + collectionName); } } ",
        "focal_src": "public static void syncLocalCoreWithSharedStore(String collectionName, String coreName, String shardName, CoreContainer coreContainer)throws SolrException { assertTrue(coreContainer.isZooKeeperAware()); ZkController zkController = coreContainer.getZkController(); SharedShardMetadataController sharedMetadataController = zkController.getSharedShardMetadataController(); DocCollection collection = zkController.getClusterState().getCollection(collectionName); CoreStorageClient blobClient = zkController.getBlobStorageProvider().getDefaultClient(); log.info(\"sync intialized for collection=\" + collectionName + \" shard=\" + shardName + \" coreName=\" + coreName); CoreSyncStatus syncStatus = CoreSyncStatus.FAILURE; Slice shard = collection.getSlicesMap().get(shardName); if(shard != null) { try { String sharedStoreName = (String)shard.get(ZkStateReader.SHARED_SHARD_NAME); VersionedData data = sharedMetadataController.readMetadataValue(collectionName, shardName, false); Map < String, String > nodeUserData = (Map < String, String > )Utils.fromJSON(data.getData()); String metadataSuffix = nodeUserData.get(SharedShardMetadataController.SUFFIX_NODE_NAME); if(SharedShardMetadataController.METADATA_NODE_DEFAULT_VALUE.equals(metadataSuffix)) { log.info(\"sync successful, nothing to pull, collection=\" + collectionName + \" shard=\" + shardName + \" coreName=\" + coreName); return; } String blobCoreMetadataName = BlobStoreUtils.buildBlobStoreMetadataName(metadataSuffix); BlobCoreMetadata blobstoreMetadata = blobClient.pullCoreMetadata(sharedStoreName, blobCoreMetadataName); if(null == blobstoreMetadata) { throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"cannot get core.metadata file from shared store, blobCoreMetadataName=\" + blobCoreMetadataName + \" shard=\" + shardName + \" collectionName=\" + collectionName + \" sharedStoreName=\" + sharedStoreName); } else if(blobstoreMetadata.getIsDeleted()) { throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"core.metadata file is marked deleted in shared store, blobCoreMetadataName=\" + blobCoreMetadataName + \" shard=\" + shardName + \" collectionName=\" + collectionName + \" sharedStoreName=\" + sharedStoreName); } else if(blobstoreMetadata.getIsCorrupt()) { log.warn(\"core.Metadata file is marked corrpt, skipping sync, collection=\" + collectionName + \" shard=\" + shardName + \" coreName=\" + coreName + \" sharedStoreName=\" + sharedStoreName); return; } ServerSideMetadata serverMetadata = new ServerSideMetadata(coreName, coreContainer); SharedMetadataResolutionResult resolutionResult = SharedStoreResolutionUtil.resolveMetadata(serverMetadata, blobstoreMetadata); PushPullData pushPullData = new PushPullData.Builder().setCollectionName(collectionName).setShardName(shardName).setCoreName(coreName).setSharedStoreName(sharedStoreName).setLastReadMetadataSuffix(metadataSuffix).setNewMetadataSuffix(BlobStoreUtils.generateMetadataSuffix()).setZkVersion(data.getVersion()).build(); if(resolutionResult.getFilesToPull().size() > 0) { BlobDeleteManager deleteManager = zkController.getBlobDeleteManager(); CorePushPull cp = new CorePushPull(blobClient, deleteManager, pushPullData, resolutionResult, serverMetadata, blobstoreMetadata); cp.pullUpdateFromBlob(true); } else { log.info(\"sync successful, nothing to pull for collection=\" + collectionName + \" shard=\" + shardName + \" coreName=\" + coreName); } } catch(Exception ex) { throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error occured pulling shard=\" + shardName + \" collection=\" + collectionName + \" from shared store \" + ex); } } else { throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Sync requested for unknown shard=\" + shardName + \" in collection=\" + collectionName); } } ",
        "test_tgt": "@Test public void testSyncLocalCoreWithSharedStore_syncEquivalent()throws Exception { CoreStorageClient blobClientSpy = Mockito.spy(storageClient); SharedShardMetadataController sharedMetadataController = cc.getSharedStoreManager().getSharedShardMetadataController(); sharedMetadataController.ensureMetadataNodeExists(collectionName, shardName); try { BlobStoreUtils.syncLocalCoreWithSharedStore(collectionName, newReplica.getCoreName(), shardName, cc); verify(blobClientSpy, never()).pullCoreMetadata(anyString(), anyString()); } catch(Exception ex) { fail(\"syncLocalCoreWithSharedStore failed with exception: \" + ex.getMessage()); } } "
    },
    {
        "test_src": "@Test public void testAuthenticate()throws Exception { SAMLMessageContext context = new SAMLMessageContext(); SAMLAuthenticationToken token = new SAMLAuthenticationToken(context, messageStorage); SAMLMessageStorage store = token.getMessageStore(); SAMLCredential result = new SAMLCredential(nameID, assertion, \"IDP\", \"testSP\"); expect(consumer.processAuthenticationResponse(context, store)).andReturn(result); expect(nameID.getValue()).andReturn(\"Name\"); DateTime expiry = new DateTime().plusHours(4); AuthnStatement as = createMock(AuthnStatement.class); expect(assertion.getAuthnStatements()).andReturn(Arrays.asList(as)).anyTimes(); expect(as.getSessionNotOnOrAfter()).andReturn(expiry); replay(as); replayMock(); Authentication authentication = provider.authenticate(token); assertEquals(\"Name\", authentication.getName()); assertTrue(authentication instanceof ExpiringUsernameAuthenticationToken); ExpiringUsernameAuthenticationToken t = (ExpiringUsernameAuthenticationToken)authentication; assertEquals(expiry.toDate(), t.getTokenExpiration()); verifyMock(); verify(as); } ",
        "focal_tgt": "public Authentication authenticate(Authentication authentication)throws AuthenticationException { if( ! supports(authentication.getClass())) { throw new IllegalArgumentException(\"Only SAMLAuthenticationToken is supported, \" + authentication.getClass() + \" was attempted\"); } SAMLAuthenticationToken token = (SAMLAuthenticationToken)authentication; SAMLMessageStorage store = token.getMessageStore(); SAMLMessageContext context = token.getCredentials(); SAMLCredential credential; try { if(SAMLConstants.SAML2_WEBSSO_PROFILE_URI.equals(context.getCommunicationProfileId())) { credential = consumer.processAuthenticationResponse(context, store); } else if(SAMLConstants.SAML2_HOK_WEBSSO_PROFILE_URI.equals(context.getCommunicationProfileId())) { credential = hokConsumer.processAuthenticationResponse(context, store); } else { throw new SAMLException(\"Unsupported profile encountered in the context \" + context.getCommunicationProfileId()); } } catch(SAMLRuntimeException e) { samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.FAILURE, context, e); throw new AuthenticationServiceException(\"Error validating SAML message\", e); } catch(SAMLException e) { samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.FAILURE, context, e); throw new AuthenticationServiceException(\"Error validating SAML message\", e); } catch(ValidationException e) { log.debug(\"Error validating signature\", e); samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.FAILURE, context); throw new AuthenticationServiceException(\"Error validating SAML message signature\", e); } catch(org.opensaml.xml.security.SecurityException e) { log.debug(\"Error validating signature\", e); samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.FAILURE, context); throw new AuthenticationServiceException(\"Error validating SAML message signature\", e); } catch(DecryptionException e) { log.debug(\"Error decrypting SAML message\", e); samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.FAILURE, context); throw new AuthenticationServiceException(\"Error decrypting SAML message\", e); } Object userDetails = getUserDetails(credential); Object principal = getPrincipal(credential, userDetails); Collection < GrantedAuthority > entitlements = getEntitlements(credential, userDetails); Date expiration = getExpirationDate(credential); ExpiringUsernameAuthenticationToken result = new ExpiringUsernameAuthenticationToken(expiration, principal, credential, entitlements); result.setDetails(userDetails); samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.SUCCESS, context, result, null); return result; } ",
        "focal_src": "public Authentication authenticate(Authentication authentication)throws AuthenticationException { if( ! supports(authentication.getClass())) { throw new IllegalArgumentException(\"Only SAMLAuthenticationToken is supported, \" + authentication.getClass() + \" was attempted\"); } SAMLAuthenticationToken token = (SAMLAuthenticationToken)authentication; SAMLMessageStorage store = token.getMessageStore(); SAMLMessageContext context = token.getCredentials(); SAMLCredential credential; try { credential = consumer.processAuthenticationResponse(context, store); } catch(SAMLException e) { samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.FAILURE, context, e); throw new AuthenticationServiceException(\"Error validating SAML message\", e); } catch(ValidationException e) { log.debug(\"Error validating signature\", e); samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.FAILURE, context); throw new AuthenticationServiceException(\"Error validating SAML message signature\", e); } catch(org.opensaml.xml.security.SecurityException e) { log.debug(\"Error validating signature\", e); samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.FAILURE, context); throw new AuthenticationServiceException(\"Error validating SAML message signature\", e); } catch(DecryptionException e) { log.debug(\"Error decrypting SAML message\", e); samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.FAILURE, context); throw new AuthenticationServiceException(\"Error decrypting SAML message\", e); } Object userDetails = getUserDetails(credential); Object principal = getPrincipal(credential, userDetails); Collection < GrantedAuthority > entitlements = getEntitlements(credential, userDetails); Date expiration = getExpirationDate(credential); ExpiringUsernameAuthenticationToken result = new ExpiringUsernameAuthenticationToken(expiration, principal, credential, entitlements); result.setDetails(userDetails); samlLogger.log(SAMLConstants.AUTH_N_RESPONSE, SAMLConstants.SUCCESS, context, result, null); return result; } ",
        "test_tgt": "@Test public void testAuthenticate()throws Exception { SAMLMessageContext context = new SAMLMessageContext(); context.setCommunicationProfileId(SAMLConstants.SAML2_WEBSSO_PROFILE_URI); SAMLAuthenticationToken token = new SAMLAuthenticationToken(context, messageStorage); SAMLMessageStorage store = token.getMessageStore(); SAMLCredential result = new SAMLCredential(nameID, assertion, \"IDP\", \"testSP\"); expect(consumer.processAuthenticationResponse(context, store)).andReturn(result); expect(nameID.getValue()).andReturn(\"Name\"); DateTime expiry = new DateTime().plusHours(4); AuthnStatement as = createMock(AuthnStatement.class); expect(assertion.getAuthnStatements()).andReturn(Arrays.asList(as)).anyTimes(); expect(as.getSessionNotOnOrAfter()).andReturn(expiry); replay(as); replayMock(); Authentication authentication = provider.authenticate(token); assertEquals(\"Name\", authentication.getName()); assertTrue(authentication instanceof ExpiringUsernameAuthenticationToken); ExpiringUsernameAuthenticationToken t = (ExpiringUsernameAuthenticationToken)authentication; assertEquals(expiry.toDate(), t.getTokenExpiration()); verifyMock(); verify(as); } "
    },
    {
        "test_src": "@Test public void testGetPrefixLength() { assertEquals( - 1, FilenameUtils.getPrefixLength(null)); assertEquals( - 1, FilenameUtils.getPrefixLength(\":\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"1:\\\\a\\\\b\\\\c.txt\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"1:\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"1:a\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"\\\\\\\\a\")); assertEquals(0, FilenameUtils.getPrefixLength(\"\")); assertEquals(1, FilenameUtils.getPrefixLength(\"\\\\\")); assertEquals(2, FilenameUtils.getPrefixLength(\"C:\")); assertEquals(3, FilenameUtils.getPrefixLength(\"C:\\\\\")); assertEquals(9, FilenameUtils.getPrefixLength(\"//server/\")); assertEquals(2, FilenameUtils.getPrefixLength(\"~\")); assertEquals(2, FilenameUtils.getPrefixLength(\"~/\")); assertEquals(6, FilenameUtils.getPrefixLength(\"~user\")); assertEquals(6, FilenameUtils.getPrefixLength(\"~user/\")); assertEquals(0, FilenameUtils.getPrefixLength(\"a\\\\b\\\\c.txt\")); assertEquals(1, FilenameUtils.getPrefixLength(\"\\\\a\\\\b\\\\c.txt\")); assertEquals(2, FilenameUtils.getPrefixLength(\"C:a\\\\b\\\\c.txt\")); assertEquals(3, FilenameUtils.getPrefixLength(\"C:\\\\a\\\\b\\\\c.txt\")); assertEquals(9, FilenameUtils.getPrefixLength(\"\\\\\\\\server\\\\a\\\\b\\\\c.txt\")); assertEquals(0, FilenameUtils.getPrefixLength(\"a/b/c.txt\")); assertEquals(1, FilenameUtils.getPrefixLength(\"/a/b/c.txt\")); assertEquals(3, FilenameUtils.getPrefixLength(\"C:/a/b/c.txt\")); assertEquals(9, FilenameUtils.getPrefixLength(\"//server/a/b/c.txt\")); assertEquals(2, FilenameUtils.getPrefixLength(\"~/a/b/c.txt\")); assertEquals(6, FilenameUtils.getPrefixLength(\"~user/a/b/c.txt\")); assertEquals(0, FilenameUtils.getPrefixLength(\"a\\\\b\\\\c.txt\")); assertEquals(1, FilenameUtils.getPrefixLength(\"\\\\a\\\\b\\\\c.txt\")); assertEquals(2, FilenameUtils.getPrefixLength(\"~\\\\a\\\\b\\\\c.txt\")); assertEquals(6, FilenameUtils.getPrefixLength(\"~user\\\\a\\\\b\\\\c.txt\")); assertEquals(9, FilenameUtils.getPrefixLength(\"//server/a/b/c.txt\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"///a/b/c.txt\")); } ",
        "focal_tgt": "public static int getPrefixLength(final String filename) { if(filename == null) { return NOT_FOUND; } final int len = filename.length(); if(len == 0) { return 0; } char ch0 = filename.charAt(0); if(ch0 == ':') { return NOT_FOUND; } if(len == 1) { if(ch0 == '~') { return 2; } return isSeparator(ch0) ? 1 : 0; } else { if(ch0 == '~') { int posUnix = filename.indexOf(UNIX_SEPARATOR, 1); int posWin = filename.indexOf(WINDOWS_SEPARATOR, 1); if(posUnix == NOT_FOUND && posWin == NOT_FOUND) { return len + 1; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix; posWin = posWin == NOT_FOUND ? posUnix : posWin; return Math.min(posUnix, posWin) + 1; } final char ch1 = filename.charAt(1); if(ch1 == ':') { ch0 = Character.toUpperCase(ch0); if(ch0 >= 'A' && ch0 <= 'Z') { if(len == 2 || isSeparator(filename.charAt(2)) == false) { return 2; } return 3; } else if(ch0 == UNIX_SEPARATOR) { return 1; } return NOT_FOUND; } else if(isSeparator(ch0) && isSeparator(ch1)) { int posUnix = filename.indexOf(UNIX_SEPARATOR, 2); int posWin = filename.indexOf(WINDOWS_SEPARATOR, 2); if(posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) { return NOT_FOUND; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix; posWin = posWin == NOT_FOUND ? posUnix : posWin; return Math.min(posUnix, posWin) + 1; } else { return isSeparator(ch0) ? 1 : 0; } } } ",
        "focal_src": "public static int getPrefixLength(final String filename) { if(filename == null) { return NOT_FOUND; } final int len = filename.length(); if(len == 0) { return 0; } char ch0 = filename.charAt(0); if(ch0 == ':') { return NOT_FOUND; } if(len == 1) { if(ch0 == '~') { return 2; } return isSeparator(ch0) ? 1 : 0; } else { if(ch0 == '~') { int posUnix = filename.indexOf(UNIX_SEPARATOR, 1); int posWin = filename.indexOf(WINDOWS_SEPARATOR, 1); if(posUnix == NOT_FOUND && posWin == NOT_FOUND) { return len + 1; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix; posWin = posWin == NOT_FOUND ? posUnix : posWin; return Math.min(posUnix, posWin) + 1; } final char ch1 = filename.charAt(1); if(ch1 == ':') { ch0 = Character.toUpperCase(ch0); if(ch0 >= 'A' && ch0 <= 'Z') { if(len == 2 || isSeparator(filename.charAt(2)) == false) { return 2; } return 3; } return NOT_FOUND; } else if(isSeparator(ch0) && isSeparator(ch1)) { int posUnix = filename.indexOf(UNIX_SEPARATOR, 2); int posWin = filename.indexOf(WINDOWS_SEPARATOR, 2); if(posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) { return NOT_FOUND; } posUnix = posUnix == NOT_FOUND ? posWin : posUnix; posWin = posWin == NOT_FOUND ? posUnix : posWin; return Math.min(posUnix, posWin) + 1; } else { return isSeparator(ch0) ? 1 : 0; } } } ",
        "test_tgt": "@Test public void testGetPrefixLength() { assertEquals( - 1, FilenameUtils.getPrefixLength(null)); assertEquals( - 1, FilenameUtils.getPrefixLength(\":\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"1:\\\\a\\\\b\\\\c.txt\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"1:\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"1:a\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"\\\\\\\\a\")); assertEquals(0, FilenameUtils.getPrefixLength(\"\")); assertEquals(1, FilenameUtils.getPrefixLength(\"\\\\\")); assertEquals(2, FilenameUtils.getPrefixLength(\"C:\")); assertEquals(3, FilenameUtils.getPrefixLength(\"C:\\\\\")); assertEquals(9, FilenameUtils.getPrefixLength(\"//server/\")); assertEquals(2, FilenameUtils.getPrefixLength(\"~\")); assertEquals(2, FilenameUtils.getPrefixLength(\"~/\")); assertEquals(6, FilenameUtils.getPrefixLength(\"~user\")); assertEquals(6, FilenameUtils.getPrefixLength(\"~user/\")); assertEquals(0, FilenameUtils.getPrefixLength(\"a\\\\b\\\\c.txt\")); assertEquals(1, FilenameUtils.getPrefixLength(\"\\\\a\\\\b\\\\c.txt\")); assertEquals(2, FilenameUtils.getPrefixLength(\"C:a\\\\b\\\\c.txt\")); assertEquals(3, FilenameUtils.getPrefixLength(\"C:\\\\a\\\\b\\\\c.txt\")); assertEquals(9, FilenameUtils.getPrefixLength(\"\\\\\\\\server\\\\a\\\\b\\\\c.txt\")); assertEquals(0, FilenameUtils.getPrefixLength(\"a/b/c.txt\")); assertEquals(1, FilenameUtils.getPrefixLength(\"/a/b/c.txt\")); assertEquals(3, FilenameUtils.getPrefixLength(\"C:/a/b/c.txt\")); assertEquals(9, FilenameUtils.getPrefixLength(\"//server/a/b/c.txt\")); assertEquals(2, FilenameUtils.getPrefixLength(\"~/a/b/c.txt\")); assertEquals(6, FilenameUtils.getPrefixLength(\"~user/a/b/c.txt\")); assertEquals(0, FilenameUtils.getPrefixLength(\"a\\\\b\\\\c.txt\")); assertEquals(1, FilenameUtils.getPrefixLength(\"\\\\a\\\\b\\\\c.txt\")); assertEquals(2, FilenameUtils.getPrefixLength(\"~\\\\a\\\\b\\\\c.txt\")); assertEquals(6, FilenameUtils.getPrefixLength(\"~user\\\\a\\\\b\\\\c.txt\")); assertEquals(9, FilenameUtils.getPrefixLength(\"//server/a/b/c.txt\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\")); assertEquals( - 1, FilenameUtils.getPrefixLength(\"///a/b/c.txt\")); assertEquals(1, FilenameUtils.getPrefixLength(\"/:foo\")); assertEquals(1, FilenameUtils.getPrefixLength(\"/:/\")); assertEquals(1, FilenameUtils.getPrefixLength(\"/:::::::.txt\")); } "
    },
    {
        "test_src": "@Test public void testRecoverWorkers()throws Exception { new Context() { { MesosWorkerStore.Worker worker1 = MesosWorkerStore.Worker.newWorker(task1); MesosWorkerStore.Worker worker2 = MesosWorkerStore.Worker.newWorker(task2).launchWorker(slave1, slave1host); MesosWorkerStore.Worker worker3 = MesosWorkerStore.Worker.newWorker(task3).launchWorker(slave1, slave1host).releaseWorker(); when(rmServices.workerStore.getFrameworkID()).thenReturn(Option.apply(framework1)); when(rmServices.workerStore.recoverWorkers()).thenReturn(Arrays.asList(worker1, worker2, worker3)); startResourceManager(); assertThat(resourceManager.workersInNew.entrySet(), empty()); assertThat(resourceManager.workersInLaunch, hasEntry(extractResourceID(task2), worker2)); assertThat(resourceManager.workersBeingReturned, hasEntry(extractResourceID(task3), worker3)); resourceManager.taskRouter.expectMsgClass(TaskMonitor.TaskGoalStateUpdated.class); LaunchCoordinator.Assign actualAssign = resourceManager.launchCoordinator.expectMsgClass(LaunchCoordinator.Assign.class); assertThat(actualAssign.tasks(), hasSize(1)); assertThat(actualAssign.tasks().get(0).f0.getId(), equalTo(task2.getValue())); assertThat(actualAssign.tasks().get(0).f1, equalTo(slave1host)); resourceManager.launchCoordinator.expectNoMsg(); } }; } ",
        "focal_tgt": "private void recoverWorkers()throws Exception { final List < MesosWorkerStore.Worker > tasksFromPreviousAttempts = workerStore.recoverWorkers(); assert(workersInNew.isEmpty()); assert(workersInLaunch.isEmpty()); assert(workersBeingReturned.isEmpty()); if( ! tasksFromPreviousAttempts.isEmpty()) { LOG.info(\"Retrieved {} TaskManagers from previous attempt\", tasksFromPreviousAttempts.size()); List < Tuple2 < TaskRequest, String > > toAssign = new ArrayList < > (tasksFromPreviousAttempts.size()); for(final MesosWorkerStore.Worker worker : tasksFromPreviousAttempts) { LaunchableMesosWorker launchable = createLaunchableMesosWorker(worker.taskID(), worker.profile()); switch(worker.state()) { case New : workerStore.removeWorker(worker.taskID()); break; case Launched : workersInLaunch.put(extractResourceID(worker.taskID()), worker); toAssign.add(new Tuple2 < > (launchable.taskRequest(), worker.hostname().get())); break; case Released : workersBeingReturned.put(extractResourceID(worker.taskID()), worker); break; } taskMonitor.tell(new TaskMonitor.TaskGoalStateUpdated(extractGoalState(worker)), selfActor); } if(toAssign.size() >= 1) { launchCoordinator.tell(new LaunchCoordinator.Assign(toAssign), selfActor); } } } ",
        "focal_src": "private void recoverWorkers(final List < MesosWorkerStore.Worker > tasksFromPreviousAttempts) { assert(workersInNew.isEmpty()); assert(workersInLaunch.isEmpty()); assert(workersBeingReturned.isEmpty()); if( ! tasksFromPreviousAttempts.isEmpty()) { LOG.info(\"Retrieved {} TaskManagers from previous attempt\", tasksFromPreviousAttempts.size()); List < Tuple2 < TaskRequest, String > > toAssign = new ArrayList < > (tasksFromPreviousAttempts.size()); for(final MesosWorkerStore.Worker worker : tasksFromPreviousAttempts) { switch(worker.state()) { case Launched : workersInLaunch.put(extractResourceID(worker.taskID()), worker); final LaunchableMesosWorker launchable = createLaunchableMesosWorker(worker.taskID()); toAssign.add(new Tuple2 < > (launchable.taskRequest(), worker.hostname().get())); break; case Released : workersBeingReturned.put(extractResourceID(worker.taskID()), worker); break; } taskMonitor.tell(new TaskMonitor.TaskGoalStateUpdated(extractGoalState(worker)), selfActor); } if(toAssign.size() >= 1) { launchCoordinator.tell(new LaunchCoordinator.Assign(toAssign), selfActor); } } } ",
        "test_tgt": "@Test public void testRecoverWorkers()throws Exception { new Context() { { MesosWorkerStore.Worker worker1 = MesosWorkerStore.Worker.newWorker(task1); MesosWorkerStore.Worker worker2 = MesosWorkerStore.Worker.newWorker(task2).launchWorker(slave1, slave1host); MesosWorkerStore.Worker worker3 = MesosWorkerStore.Worker.newWorker(task3).launchWorker(slave1, slave1host).releaseWorker(); when(rmServices.workerStore.getFrameworkID()).thenReturn(Option.apply(framework1)); when(rmServices.workerStore.recoverWorkers()).thenReturn(Arrays.asList(worker1, worker2, worker3)); startResourceManager(); assertThat(resourceManager.workersInNew.entrySet(), empty()); assertThat(resourceManager.workersInLaunch, hasEntry(extractResourceID(task2), worker2)); assertThat(resourceManager.workersBeingReturned, hasEntry(extractResourceID(task3), worker3)); resourceManager.taskRouter.expectMsgClass(TaskMonitor.TaskGoalStateUpdated.class); LaunchCoordinator.Assign actualAssign = resourceManager.launchCoordinator.expectMsgClass(LaunchCoordinator.Assign.class); assertThat(actualAssign.tasks(), hasSize(1)); assertThat(actualAssign.tasks().get(0).f0.getId(), equalTo(task2.getValue())); assertThat(actualAssign.tasks().get(0).f1, equalTo(slave1host)); resourceManager.launchCoordinator.expectNoMsg(); } }; } "
    },
    {
        "test_src": "@Test public void readBinary() { error(_FILE_READ_BINARY.args(PATH1), Err.FILE_WHICH); error(_FILE_READ_BINARY.args(PATH), Err.FILE_DIR); query(_FILE_WRITE.args(PATH1, \"0\")); query(_FILE_READ_BINARY.args(PATH1), \"MA==\"); query(_FILE_WRITE.args(PATH1, \"a\u00e4\")); query(_FILE_READ_BINARY.args(PATH1), \"YcOk\"); query(_FILE_WRITE_BINARY.args(PATH1, _CONVERT_STRING_TO_BASE64.args(\"a\u00e4\"))); query(_FILE_READ_BINARY.args(PATH1), \"YcOk\"); query(_FILE_DELETE.args(PATH1)); } ",
        "focal_tgt": "private B64 readBinary(final QueryContext ctx)throws QueryException, IOException { final File path = checkFile(0, ctx); final long off = expr.length > 1 ? checkItr(expr[1], ctx) : 0; long len = expr.length > 2 ? checkItr(expr[2], ctx) : 0; if( ! path.exists())FILE_WHICH.thrw(info, path.getAbsolutePath()); if(path.isDirectory())FILE_DIR.thrw(info, path.getAbsolutePath()); if(expr.length == 1)return new B64Stream(new IOFile(path), FILE_IO); final DataAccess da = new DataAccess(new IOFile(path)); try { final long dlen = da.length(); if(expr.length == 2)len = dlen - off; if(off < 0 || off > dlen || len < 0 || off + len > dlen)FILE_BOUNDS.thrw(info, off, off + len); da.cursor(off); return new B64(da.readBytes((int)len)); } finally { da.close(); } } ",
        "focal_src": "private B64Stream readBinary(final QueryContext ctx)throws QueryException { final File path = checkFile(0, ctx); if( ! path.exists())FILE_WHICH.thrw(info, path.getAbsolutePath()); if(path.isDirectory())FILE_DIR.thrw(info, path.getAbsolutePath()); return new B64Stream(new IOFile(path), FILE_IO); } ",
        "test_tgt": "@Test public void readBinary() { error(_FILE_READ_BINARY.args(PATH1), Err.FILE_WHICH); error(_FILE_READ_BINARY.args(PATH), Err.FILE_DIR); query(_FILE_WRITE.args(PATH1, \"0\")); query(_FILE_READ_BINARY.args(PATH1), \"MA==\"); query(_FILE_READ_BINARY.args(PATH1, 0), \"MA==\"); query(_FILE_READ_BINARY.args(PATH1, 0, 1), \"MA==\"); query(_FILE_READ_BINARY.args(PATH1, 1), \"\"); query(_FILE_READ_BINARY.args(PATH1, 1, 0), \"\"); query(_FILE_READ_BINARY.args(PATH1, 0, 0), \"\"); error(_FILE_READ_BINARY.args(PATH1, - 1), Err.FILE_BOUNDS); error(_FILE_READ_BINARY.args(PATH1, 2), Err.FILE_BOUNDS); error(_FILE_READ_BINARY.args(PATH1, 0, - 1), Err.FILE_BOUNDS); error(_FILE_READ_BINARY.args(PATH1, 0, 2), Err.FILE_BOUNDS); error(_FILE_READ_BINARY.args(PATH1, 2, 1), Err.FILE_BOUNDS); query(_FILE_WRITE.args(PATH1, \"a\u00e4\")); query(_FILE_READ_BINARY.args(PATH1), \"YcOk\"); query(_FILE_WRITE_BINARY.args(PATH1, _CONVERT_STRING_TO_BASE64.args(\"a\u00e4\"))); query(_FILE_READ_BINARY.args(PATH1), \"YcOk\"); query(_FILE_DELETE.args(PATH1)); } "
    },
    {
        "test_src": "@Test public void parse() { for(final String[]test : TOXML) { final String query = test[1].isEmpty() ? _CSV_PARSE.args(test[0]) : _CSV_PARSE.args(test[0], \" {\" + test[1] + \"}\"); if(test.length == 2) { error(query, Err.BXCS_CONFIG, Err.INVALIDOPT); } else if(test[2].startsWith(\"...\")) { contains(query, test[2].substring(3)); } else { query(query, test[2]); } } } ",
        "focal_tgt": "private FDoc parse(final QueryContext ctx)throws QueryException { final byte[]input = checkStr(expr[0], ctx); final CsvParserOptions opts = checkOptions(1, Q_OPTIONS, new CsvParserOptions(), ctx); try { return CsvConverter.convert(input, opts); } catch(final IOException ex) { throw BXCS_PARSE.thrw(info, ex); } } ",
        "focal_src": "private FDoc parse(final QueryContext ctx)throws QueryException { final byte[]input = checkStr(expr[0], ctx); final CsvParserOptions opts = checkOptions(1, Q_OPTIONS, new CsvParserOptions(), ctx); try { return CsvConverter.convert(input, opts); } catch(final QueryIOException ex) { throw ex.getCause(info); } catch(final IOException ex) { throw BXCS_PARSE.thrw(info, ex); } } ",
        "test_tgt": "@Test public void parse() { parse(\"\", \"\", \"<csv/>\"); parse(\"X\", \"\", \"<csv><record><entry>X</entry></record></csv>\"); parse(\" '\\\"X\\\"\\\"Y\\\"'\", \"\", \"...<entry>X\\\"Y</entry>\"); parse(\" '\\\"X\\\",Y'\", \"\", \"...<entry>X</entry><entry>Y</entry>\"); parse(\"X;Y\", \"'separator':';'\", \"...<entry>X</entry><entry>Y</entry>\"); parse(\"X,Y\", \"\", \"...<entry>X</entry><entry>Y</entry>\"); parse(\"X\\nY\", \"'header':true()\", \"<csv><record><X>Y</X></record></csv>\"); parse(\"A,B,C\\nX,Y,Z\", \"'header':true()\", \"...<A>X</A><B>Y</B><C>Z</C>\"); parse(\"X\\nY\", \"'format':'attributes','header':true()\", \"...<entry name=\\\"X\\\">Y</entry>\"); parseError(\"\", \"'x':'y'\"); parseError(\"\", \"'format':'abc'\"); parseError(\"\", \"'separator':''\"); parseError(\"\", \"'separator':'XXX'\"); } "
    },
    {
        "test_src": "@Test public void testSetApplicationsForCommand()throws GenieException { Assert.assertTrue(this.service.getApplicationsForCommand(COMMAND_2_ID).isEmpty()); final List < String > appIds = Lists.newArrayList(APP_1_ID); final Set < Command > preCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(1, preCommands.size()); Assert.assertEquals(1, preCommands.stream().filter(command -> COMMAND_1_ID.equals(command.getId())).count()); this.service.setApplicationsForCommand(COMMAND_2_ID, appIds); final Set < Command > savedCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(2, savedCommands.size()); Assert.assertEquals(1, this.service.getApplicationsForCommand(COMMAND_2_ID).stream().filter(application -> APP_1_ID.equals(application.getId())).count()); } ",
        "focal_tgt": "@Override public void setApplicationsForCommand(@NotBlank(message = \"No command id entered. Unable to set applications.\")final String id, @NotNull(message = \"No application ids entered. Unable to set applications.\")final List < String > applicationIds)throws GenieException { if(applicationIds.size() != applicationIds.stream().filter(this.appRepo :: exists).count()) { throw new GeniePreconditionException(\"All applications need to exist to add to a command\"); } final CommandEntity commandEntity = this.findCommand(id); final List < ApplicationEntity > applicationEntities = new ArrayList < > (); applicationIds.forEach(appId -> applicationEntities.add(this.appRepo.findOne(appId))); commandEntity.setApplications(applicationEntities); } ",
        "focal_src": "@Override public void setApplicationsForCommand(@NotBlank(message = \"No command id entered. Unable to set applications.\")final String id, @NotNull(message = \"No application ids entered. Unable to set applications.\")final List < String > applicationIds)throws GenieException { if(applicationIds.size() != applicationIds.stream().filter(this.appRepo :: exists).count()) { throw new GeniePreconditionException(\"All applications need to exist to add to a command\"); } final CommandEntity commandEntity = this.findCommand(id); final List < ApplicationEntity > applicationEntities = new ArrayList < > (); applicationIds.stream().forEach(appId -> applicationEntities.add(this.appRepo.findOne(appId))); commandEntity.setApplications(applicationEntities); } ",
        "test_tgt": "@Test public void testSetApplicationsForCommand()throws GenieException { Assert.assertTrue(this.service.getApplicationsForCommand(COMMAND_2_ID).isEmpty()); final List < String > appIds = Lists.newArrayList(APP_1_ID); final Set < Command > preCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(1, preCommands.size()); Assert.assertEquals(1, preCommands.stream().filter(command -> COMMAND_1_ID.equals(command.getId().orElseThrow(IllegalArgumentException :: new))).count()); this.service.setApplicationsForCommand(COMMAND_2_ID, appIds); final Set < Command > savedCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(2, savedCommands.size()); Assert.assertEquals(1, this.service.getApplicationsForCommand(COMMAND_2_ID).stream().filter(application -> APP_1_ID.equals(application.getId().orElseThrow(IllegalArgumentException :: new))).count()); } "
    },
    {
        "test_src": "@Test public void testExecute()throws IOException { final Counter counter = new Counter(\"test html report\", null); counter.addRequest(\"test1\", 0, 1, false, 1000); counter.addRequest(\"test2\", 1000, 900, false, 1000); counter.addRequest(\"test3\", 10000, 1000, true, 10000); final Timer timer = new Timer(\"test\", true); try { final Collector collector = new Collector(\"test\", Collections.singletonList(counter), timer); final String counterName = counter.getName(); final String sessionId = \"sessionId\"; assertNotNull(\"message GC\", Action.GC.execute(collector, counterName, sessionId)); assertNotNull(\"message CLEAR_COUNTER\", Action.CLEAR_COUNTER.execute(collector, counterName, sessionId)); if(CacheManager.getInstance().getCache(\"test clear\") == null) { CacheManager.getInstance().addCache(\"test clear\"); } assertNotNull(\"message CLEAR_CACHES\", Action.CLEAR_CACHES.execute(collector, counterName, sessionId)); final String heapDump1 = Action.HEAP_DUMP.execute(collector, counterName, sessionId); assertNotNull(\"message HEAP_DUMP\", heapDump1); String heapDump2; do { heapDump2 = Action.HEAP_DUMP.execute(collector, counterName, sessionId); assertNotNull(\"message HEAP_DUMP\", heapDump2); } while(heapDump1.equals(heapDump2)); for(final File file : Parameters.TEMPORARY_DIRECTORY.listFiles()) { if( ! file.isDirectory() && file.getName().startsWith(\"heapdump\") && ! file.delete()) { file.deleteOnExit(); } } assertNotNull(\"message INVALIDATE_SESSIONS\", Action.INVALIDATE_SESSIONS.execute(collector, counterName, sessionId)); assertNotNull(\"message INVALIDATE_SESSION\", Action.INVALIDATE_SESSION.execute(collector, counterName, sessionId)); } finally { timer.cancel(); } } ",
        "focal_tgt": "String execute(Collector collector, String counterName, String sessionId, String threadId)throws IOException { String messageForReport; switch(this) { case CLEAR_COUNTER : assert collector != null; assert counterName != null; messageForReport = clearCounter(collector, counterName); break; case GC : if(GC_ENABLED) { final long before = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); gc(); final long after = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); messageForReport = I18N.getFormattedString(\"ramasse_miette_execute\", (before - after) / 1024); } else { messageForReport = I18N.getString(\"ramasse_miette_desactive\"); } break; case HEAP_DUMP : if(HEAP_DUMP_ENABLED) { final String heapDumpPath = heapDump().getPath(); messageForReport = I18N.getFormattedString(\"heap_dump_genere\", heapDumpPath.replace('\\\\', '/')); } else { messageForReport = I18N.getString(\"heap_dump_not_good\"); } break; case INVALIDATE_SESSIONS : SessionListener.invalidateAllSessions(); messageForReport = I18N.getString(\"sessions_http_invalidees\"); break; case INVALIDATE_SESSION : assert sessionId != null; SessionListener.invalidateSession(sessionId); messageForReport = I18N.getString(\"session_http_invalidee\"); break; case CLEAR_CACHES : clearCaches(); messageForReport = I18N.getString(\"caches_purges\"); break; case KILL_THREAD : assert threadId != null; messageForReport = killThread(threadId); break; default : throw new IllegalStateException(toString()); } return messageForReport; } ",
        "focal_src": "String execute(Collector collector, String counterName, String sessionId)throws IOException { String messageForReport; switch(this) { case CLEAR_COUNTER : assert collector != null; assert counterName != null; if(\"all\".equalsIgnoreCase(counterName)) { clearCounters(collector); messageForReport = I18N.getFormattedString(\"Toutes_statistiques_reinitialisees\", counterName); } else { collector.clearCounter(counterName); messageForReport = I18N.getFormattedString(\"Statistiques_reinitialisees\", counterName); } break; case GC : if(GC_ENABLED) { final long before = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); gc(); final long after = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory(); messageForReport = I18N.getFormattedString(\"ramasse_miette_execute\", (before - after) / 1024); } else { messageForReport = I18N.getString(\"ramasse_miette_desactive\"); } break; case HEAP_DUMP : if(HEAP_DUMP_ENABLED) { final String heapDumpPath = heapDump().getPath(); messageForReport = I18N.getFormattedString(\"heap_dump_genere\", heapDumpPath.replace('\\\\', '/')); } else { messageForReport = I18N.getString(\"heap_dump_not_good\"); } break; case INVALIDATE_SESSIONS : SessionListener.invalidateAllSessions(); messageForReport = I18N.getString(\"sessions_http_invalidees\"); break; case INVALIDATE_SESSION : assert sessionId != null; SessionListener.invalidateSession(sessionId); messageForReport = I18N.getString(\"session_http_invalidee\"); break; case CLEAR_CACHES : clearCaches(); messageForReport = I18N.getString(\"caches_purges\"); break; default : throw new IllegalStateException(toString()); } return messageForReport; } ",
        "test_tgt": "@Test public void testExecute()throws IOException { final Counter counter = new Counter(\"test html report\", null); counter.addRequest(\"test1\", 0, 1, false, 1000); counter.addRequest(\"test2\", 1000, 900, false, 1000); counter.addRequest(\"test3\", 10000, 1000, true, 10000); final Timer timer = new Timer(\"test\", true); try { final Collector collector = new Collector(\"test\", Collections.singletonList(counter), timer); final String counterName = counter.getName(); final String sessionId = \"sessionId\"; final String threadId = \"threadId\"; assertNotNull(\"message GC\", Action.GC.execute(collector, counterName, sessionId, threadId)); assertNotNull(\"message CLEAR_COUNTER\", Action.CLEAR_COUNTER.execute(collector, counterName, sessionId, threadId)); if(CacheManager.getInstance().getCache(\"test clear\") == null) { CacheManager.getInstance().addCache(\"test clear\"); } assertNotNull(\"message CLEAR_CACHES\", Action.CLEAR_CACHES.execute(collector, counterName, sessionId, threadId)); final String heapDump1 = Action.HEAP_DUMP.execute(collector, counterName, sessionId, threadId); assertNotNull(\"message HEAP_DUMP\", heapDump1); String heapDump2; do { heapDump2 = Action.HEAP_DUMP.execute(collector, counterName, sessionId, threadId); assertNotNull(\"message HEAP_DUMP\", heapDump2); } while(heapDump1.equals(heapDump2)); for(final File file : Parameters.TEMPORARY_DIRECTORY.listFiles()) { if( ! file.isDirectory() && file.getName().startsWith(\"heapdump\") && ! file.delete()) { file.deleteOnExit(); } } assertNotNull(\"message INVALIDATE_SESSIONS\", Action.INVALIDATE_SESSIONS.execute(collector, counterName, sessionId, threadId)); assertNotNull(\"message INVALIDATE_SESSION\", Action.INVALIDATE_SESSION.execute(collector, counterName, sessionId, threadId)); try { assertNull(\"message KILL_THREAD\", Action.KILL_THREAD.execute(collector, counterName, sessionId, threadId)); } catch(final IllegalArgumentException e) { assertNotNull(e.toString(), e); } assertNull(\"message KILL_THREAD\", Action.KILL_THREAD.execute(collector, counterName, sessionId, \"pid_ip_id\")); final Thread myThread = new Thread(\"thread test\"); myThread.start(); final String globalThreadId = PID.getPID() + '_' + Parameters.getHostAddress() + '_' + myThread.getId(); assertNotNull(\"message KILL_THREAD\", Action.KILL_THREAD.execute(collector, counterName, sessionId, globalThreadId)); } finally { timer.cancel(); } } "
    },
    {
        "test_src": "@Test public void testReplace()throws QueryException, BaseXException { final String fun = check(Function.REPLACEDOC); new Add(\"etc/test/input.xml\", null, \"test\").execute(CONTEXT); query(fun + \"('db', 'test/input.xml', document { <root/> })\"); query(\"count(collection('db/test/input.xml')/html) eq 0\", \"true\"); query(\"count(collection('db/test/input.xml')/root) eq 1\", \"true\"); } ",
        "focal_tgt": "private Item replace(final QueryContext ctx)throws QueryException { final String path = path(string(checkStr(expr[0], ctx))); final int pos = path.indexOf('/'); if(pos <= 0)NODB.thrw(input, path); final byte[]db = token(path.substring(0, pos)); final Data data = ctx.resource.data(db, input); final String src = path.substring(pos + 1); final byte[]trg = token(src); final Item doc = checkItem(expr[1], ctx); final int[]old = data.doc(src); if(old.length > 0) { final int pre = old[0]; if(old.length > 1 || ! eq(data.text(pre, true), trg))DOCTRGMULT.thrw(input); ctx.updates.add(new DeleteNode(pre, data, input), ctx); } final byte[]trgname; final byte[]trgpath; final int p = lastIndexOf(trg, '/'); if(p < 0) { trgname = trg; trgpath = null; } else { trgname = subtoken(trg, p + 1); trgpath = subtoken(trg, 0, p); } final ArrayList < Item > docs = new ArrayList < Item > (); docs.add(doc); final Add add = new Add(data, input, docs, trgname, trgpath, ctx.context); ctx.updates.add(add, ctx); return null; } ",
        "focal_src": "private Item replace(final QueryContext ctx)throws QueryException { final Data data = ctx.resource.data(checkStr(expr[0], ctx), input); final String path = ACreate.path(string(checkStr(expr[1], ctx))); final ANode doc = checkNode(checkItem(expr[2], ctx)); final int[]old = data.doc(path); if(old.length > 0) { final int pre = old[0]; if(old.length > 1 || ! eq(data.text(pre, true), token(path)))DOCTRGMULT.thrw(input); ctx.updates.add(new DeleteNode(pre, data, input), ctx); } final NodeCache c = new NodeCache(); c.add(doc); final TokenList p = new TokenList(1); p.add(token(path)); ctx.updates.add(new Add(data, input, c, p, ctx.context), ctx); return null; } ",
        "test_tgt": "@Test public void testReplace()throws QueryException, BaseXException { final String fun = check(Function.REPLACEDOC); new Add(\"etc/test/input.xml\", null, \"test\").execute(CONTEXT); query(fun + \"('db/test/input.xml', document { <root/> })\"); query(\"count(collection('db/test/input.xml')/html) eq 0\", \"true\"); query(\"count(collection('db/test/input.xml')/root) eq 1\", \"true\"); query(fun + \"('db/test/input.xml', 'etc/test/input.xml')\"); query(\"count(collection('db/test/input.xml')/html) eq 1\", \"true\"); query(\"count(collection('db/test/input.xml')/root) eq 0\", \"true\"); } "
    },
    {
        "test_src": "@Test(expected = RuntimeException.class)public void testInitialize() { new JKSKeyManager(null, \"xxx\"); } ",
        "focal_tgt": "private KeyStore initialize(Resource storeFile, String storePass, String storeType) { InputStream inputStream = null; try { inputStream = storeFile.getInputStream(); KeyStore ks = KeyStore.getInstance(storeType); ks.load(inputStream, storePass.toCharArray()); return ks; } catch(Exception e) { log.error(\"Error initializing key store\", e); throw new RuntimeException(\"Error initializing keystore\", e); } finally { if(inputStream != null) { try { inputStream.close(); } catch(IOException e) { log.debug(\"Error closing input stream for keystore.\", e); } } } } ",
        "focal_src": "private void initialize(Resource storeFile, String storePass, String storeType) { InputStream inputStream = null; try { inputStream = storeFile.getInputStream(); ks = KeyStore.getInstance(storeType); ks.load(inputStream, storePass.toCharArray()); } catch(Exception e) { log.error(\"Error initializing key store\", e); throw new RuntimeException(\"Error initializing keystore\", e); } finally { if(inputStream != null) { try { inputStream.close(); } catch(IOException e) { log.debug(\"Error closing input stream for keystore.\", e); } } } } ",
        "test_tgt": "@Test(expected = RuntimeException.class)public void testInitialize() { new JKSKeyManager(null, \"xxx\", null, null); } "
    },
    {
        "test_src": "@Test public final void replace() { no(new Replace(FILE, \"xxx\")); ok(new CreateDB(NAME, FILE)); ok(new Replace(FN, \"<a/>\")); ok(new Replace(FN, \"<a/>\")); no(new Replace(FN, \"\")); } ",
        "focal_tgt": "public static String replace(final String p, final InputSource input, final Context ctx, final boolean lock)throws BaseXException { final Data data = ctx.data(); String path = path(p); if(path.isEmpty())return Util.info(DIRERR, path); final byte[]src = token(path); final IntList docs = data.doc(p); if(docs.size() == 0)return Util.info(FILEWHICH, path); for(int i = 0, is = docs.size(); i < is; i ++ ) { if( ! eq(data.text(docs.get(i), true), src))return Util.info(DIRERR, path); } final String target; final int i = path.lastIndexOf('/'); if(i != - 1) { target = path.substring(0, i); path = path.substring(i + 1); } else { target = \"\"; } try { if(lock)ctx.register(true); Add.add(path, target, input, ctx, null, false); for(int d = docs.size() - 1; d >= 0; d -- )data.delete(docs.get(d)); data.flush(); } finally { if(lock)ctx.unregister(true); } return Util.info(PATHREPLACED, docs.size()); } ",
        "focal_src": "public static String replace(final String p, final InputSource input, final Context ctx, final boolean lock)throws BaseXException { final Data data = ctx.data(); String path = path(p); if(path.isEmpty())return Util.info(DIRERR, path); final byte[]src = token(path); final IntList docs = data.doc(p); if(docs.size() == 0)return Util.info(FILEWHICH, path); for(int i = 0, is = docs.size(); i < is; i ++ ) { if( ! eq(data.text(docs.get(i), true), src))return Util.info(DIRERR, path); } final String target; final int i = path.lastIndexOf('/'); if(i != - 1) { target = path.substring(0, i); path = path.substring(i + 1); } else { target = \"\"; } try { if(lock)ctx.register(true); for(int d = docs.size() - 1; d >= 0; d -- )data.delete(docs.get(d)); Add.add(path, target, input, ctx, null, false); } finally { if(lock)ctx.unregister(true); } return Util.info(PATHREPLACED, docs.size()); } ",
        "test_tgt": "@Test public final void replace() { no(new Replace(FILE, \"xxx\")); ok(new CreateDB(NAME, FILE)); ok(new Replace(FN, \"<a/>\")); ok(new Replace(FN, \"<a/>\")); no(new Replace(FN, \"\")); no(new Replace(FN, \"<a>\")); assertTrue( ! ok(new XQuery(\"doc('\" + NAME + \"')\")).isEmpty()); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should fail validation if program name already in use\", method = \"validate(Object,Errors)\")public void validate_shouldFailValidationIfProgramNameAlreadyInUse()throws Exception { Program prog = new Program(); prog.setName(\"MDR program\"); prog.setConcept(Context.getConceptService().getConcept(3)); Errors errors = new BindException(prog, \"prog\"); programValidator.validate(prog, errors); Assert.assertTrue(errors.hasFieldErrors(\"name\")); } ",
        "focal_tgt": "public void validate(Object obj, Errors errors) { Program p = (Program)obj; if(p == null) { errors.rejectValue(\"program\", \"error.general\"); } else { ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\"); ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"description\", \"error.required\"); List < Program > programs = Context.getProgramWorkflowService().getAllPrograms(false); for(Program program : programs) { if(program.getName().equals(p.getName()) && ! program.getProgramId().equals(p.getProgramId())) { errors.rejectValue(\"name\", \"general.error.nameAlreadyInUse\"); break; } else { Context.evictFromSession(program); } } ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"concept\", \"error.concept\"); } } ",
        "focal_src": "public void validate(Object obj, Errors errors) { Program p = (Program)obj; if(p == null) { errors.rejectValue(\"program\", \"error.general\"); } else { ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\"); List < Program > programs = Context.getProgramWorkflowService().getAllPrograms(false); for(Program program : programs) { if(program.getName().equals(p.getName()) && ! program.getProgramId().equals(p.getProgramId())) { errors.rejectValue(\"name\", \"general.error.nameAlreadyInUse\"); break; } else { Context.evictFromSession(program); } } ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"concept\", \"error.concept\"); } } ",
        "test_tgt": "@Test@Verifies(value = \"should fail validation if program name already in use\", method = \"validate(Object,Errors)\")public void validate_shouldFailValidationIfProgramNameAlreadyInUse()throws Exception { Program prog = new Program(); prog.setName(\"MDR-TB PROGRAM\"); prog.setConcept(Context.getConceptService().getConcept(3)); Errors errors = new BindException(prog, \"prog\"); programValidator.validate(prog, errors); Assert.assertTrue(errors.hasFieldErrors(\"name\")); } "
    },
    {
        "test_src": "@Test public void getMountTable()throws Exception { Map < String, MountInfo > mountTable = new HashMap < > (2); mountTable.put(\"/mnt/foo\", new MountInfo(new AlluxioURI(\"/mnt/foo\"), new AlluxioURI(\"hdfs://localhost:5678/foo\"), 1L, MountOptions.defaults())); mountTable.put(\"/mnt/bar\", new MountInfo(new AlluxioURI(\"/mnt/bar\"), new AlluxioURI(\"hdfs://localhost:5678/bar\"), 2L, MountOptions.defaults())); AlluxioURI masterAddr = new AlluxioURI(\"alluxio://localhost:1234\"); for(Map.Entry < String, MountInfo > mountPoint : mountTable.entrySet()) { MountInfo mountInfo = mountPoint.getValue(); mMountTable.add(masterAddr.join(mountPoint.getKey()), mountInfo.getUfsUri(), mountInfo.getMountId(), mountInfo.getOptions()); } Assert.assertEquals(mountTable, mMountTable.getMountTable()); } ",
        "focal_tgt": "public Map < String, MountInfo > getMountTable() { try(LockResource r = new LockResource(mReadLock)) { return new HashMap < > (mState.getMountTable()); } } ",
        "focal_src": "public Map < String, MountInfo > getMountTable() { try(LockResource r = new LockResource(mReadLock)) { return new HashMap < > (mMountTable); } } ",
        "test_tgt": "@Test public void getMountTable()throws Exception { Map < String, MountInfo > mountTable = new HashMap < > (2); mountTable.put(\"/mnt/foo\", new MountInfo(new AlluxioURI(\"/mnt/foo\"), new AlluxioURI(\"hdfs://localhost:5678/foo\"), 2L, MountOptions.defaults())); mountTable.put(\"/mnt/bar\", new MountInfo(new AlluxioURI(\"/mnt/bar\"), new AlluxioURI(\"hdfs://localhost:5678/bar\"), 3L, MountOptions.defaults())); AlluxioURI masterAddr = new AlluxioURI(\"alluxio://localhost:1234\"); for(Map.Entry < String, MountInfo > mountPoint : mountTable.entrySet()) { MountInfo mountInfo = mountPoint.getValue(); mMountTable.add(NoopJournalContext.INSTANCE, masterAddr.join(mountPoint.getKey()), mountInfo.getUfsUri(), mountInfo.getMountId(), mountInfo.getOptions()); } mountTable.put(\"/\", new MountInfo(new AlluxioURI(\"/\"), new AlluxioURI(\"s3a://bucket/\"), IdUtils.ROOT_MOUNT_ID, MountOptions.defaults())); Assert.assertEquals(mountTable, mMountTable.getMountTable()); } "
    },
    {
        "test_src": "@Test public void matchTcpSrcTest() { Criterion criterion = Criteria.matchTcpSrc((short)40000); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result, matchesCriterion(criterion)); } ",
        "focal_tgt": "public static Criterion matchTcpSrc(TpPort tcpPort) { return new TcpPortCriterion(tcpPort, Type.TCP_SRC); } ",
        "focal_src": "public static Criterion matchTcpSrc(int tcpPort) { return new TcpPortCriterion(tcpPort, Type.TCP_SRC); } ",
        "test_tgt": "@Test public void matchTcpSrcTest() { Criterion criterion = Criteria.matchTcpSrc(tpPort); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result, matchesCriterion(criterion)); } "
    },
    {
        "test_src": "@Test public void testAssignToNode() { long i = getJBPMApplication().startProcess(\"defaultPackage.Trade\", \"aaa\", null); Map < String, Object > data = new HashMap < String, Object > (); data.put(\"approveStatus\", \"1\"); getJBPMApplication().completeTask(i, 1l, \"fhjl\", XmlParseUtil.paramsToXml(data), null); getJBPMApplication().assignToNode(i, 2l); List < TaskVO > tasks = getJBPMApplication().queryTodoList(\"fhjl\"); Assert.assertTrue(tasks.size() > 0); data = new HashMap < String, Object > (); data.put(\"approveStatus\", \"1\"); getJBPMApplication().completeTask(i, tasks.get(0).getTaskId(), \"fhjl\", XmlParseUtil.paramsToXml(data), null); tasks = getJBPMApplication().queryTodoList(\"fwzy\"); Assert.assertTrue(tasks.size() > 0); getJBPMApplication().removeProcessInstance(i); } ",
        "focal_tgt": "public void assignToNode(long processInstanceId, long nodeId) { UserTransaction owner = null; try { owner = startUserTransaction(); this.assignToNodeCall(processInstanceId, nodeId); this.commitUserTransaction(owner); } catch(RuntimeException e) { e.printStackTrace(); rollbackUserTransaction(owner); throw e; } catch(Exception e) { e.printStackTrace(); this.rollbackUserTransaction(owner); throw new RuntimeException(e.getCause()); } } ",
        "focal_src": "public void assignToNode(long processInstanceId, long nodeId) { try { this.getJbpmSupport().startTransaction(); this.assignToNodeCall(processInstanceId, nodeId); this.getJbpmSupport().commitTransaction(); } catch(RuntimeException e) { e.printStackTrace(); getJbpmSupport().rollbackTransaction(); throw e; } catch(Exception e) { e.printStackTrace(); this.getJbpmSupport().rollbackTransaction(); throw new RuntimeException(e.getCause()); } } ",
        "test_tgt": "@Test public void testAssignToNode() { long i = getJBPMApplication().startProcess(\"defaultPackage.Trade\", \"aaa\", null); Map < String, Object > data = new HashMap < String, Object > (); data.put(\"approveStatus\", \"1\"); getJBPMApplication().completeTask(i, 1l, \"fhjl\", XmlParseUtil.paramsToXml(data), null); getJBPMApplication().assignToNode(i, 2l); List < TaskVO > tasks = getJBPMApplication().queryTodoList(\"fhjl\"); Assert.assertTrue(tasks.size() > 0); data = new HashMap < String, Object > (); data.put(\"approveStatus\", \"1\"); getJBPMApplication().completeTask(i, tasks.get(0).getTaskId(), \"fhjl\", XmlParseUtil.paramsToXml(data), null); tasks = getJBPMApplication().queryTodoList(\"fwzy\"); Assert.assertTrue(tasks.size() > 0); } "
    },
    {
        "test_src": "@Test void score_SinglePath() { Planar < GrayU16 > costYXD = new Planar < > (GrayU16.class, rangeD, width, height); GImageMiscOps.fillUniform(costYXD, rand, 0, SgmDisparityCost.MAX_COST); SgmCostAggregation alg = new SgmCostAggregation(); alg.init(costYXD); int before = countNotZero(alg.aggregated); alg.score(0, 0, 1, 1); int length = alg.computePathLength(0, 0, 1, 1); int foundCount = countNotZero(alg.aggregated); assertEquals(length * rangeD, foundCount); } ",
        "focal_tgt": "void scorePath(int x0, int y0, int dx, int dy) { GrayU16 costXD = costYXD.getBand(y0); int idxCost = costXD.getIndex(0, x0); for(int d = 0; d < lengthD; d ++ ) { workCostLr[d] = costXD.data[idxCost + d]; } int lengthPath = computePathLength(x0, y0, dx, dy); int x = x0 + dx; int y = y0 + dy; final int lengthD = this.lengthD; for(int i = 1; i < lengthPath; i ++ , x += dx, y += dy) { int idxLr = (i - 1) * lengthD; int minLrPrev = Integer.MAX_VALUE; for(int d = 0; d < lengthD; d ++ ) { int cost = workCostLr[idxLr + d] & 0xFFFF; if(cost < minLrPrev)minLrPrev = cost; } costXD = costYXD.getBand(y); idxCost = costXD.getIndex(0, x); computeCostInnerD(costXD, idxCost, idxLr, minLrPrev); computeCostBorderD(idxCost, idxLr, 0, costXD, minLrPrev); computeCostBorderD(idxCost, idxLr, lengthD - 1, costXD, minLrPrev); } saveWorkToAggregated(x0, y0, dx, dy, lengthPath); } ",
        "focal_src": "void score(int x0, int y0, int dx, int dy) { GrayU16 costXD = costYXD.getBand(y0); int idxCost = costXD.getIndex(0, x0); for(int d = 0; d < lengthD; d ++ ) { workCostLr[d] = costXD.data[idxCost + d]; } int lengthPath = computePathLength(x0, y0, dx, dy); int x = x0 + dx; int y = y0 + dy; final int lengthD = this.lengthD; for(int i = 1; i < lengthPath; i ++ , x += dx, y += dy) { int idxLr = (i - 1) * lengthD; int minLrPrev = Integer.MAX_VALUE; for(int d = 0; d < lengthD; d ++ ) { int cost = workCostLr[idxLr + d] & 0xFFFF; if(cost < minLrPrev)minLrPrev = cost; } costXD = costYXD.getBand(y); idxCost = costXD.getIndex(0, x); computeCostInnerD(costXD, idxCost, idxLr, minLrPrev); computeCostBorderD(idxCost, idxLr, 0, costXD, minLrPrev); computeCostBorderD(idxCost, idxLr, lengthD - 1, costXD, minLrPrev); } saveWorkToAggregated(x0, y0, dx, dy, lengthPath); } ",
        "test_tgt": "@Test void scorePath() { Planar < GrayU16 > costYXD = new Planar < > (GrayU16.class, rangeD, width, height); GImageMiscOps.fillUniform(costYXD, rand, 0, SgmDisparityCost.MAX_COST); SgmCostAggregation alg = new SgmCostAggregation(); alg.init(costYXD); alg.scorePath(0, 0, 1, 1); int length = alg.computePathLength(0, 0, 1, 1); int foundCount = countNotZero(alg.aggregated); assertEquals(length * rangeD, foundCount); } "
    },
    {
        "test_src": "@Test public void createFile()throws Exception { doNothing().when(mFileSystemMasterClient).createFile(any(AlluxioURI.class), any(CreateFilePOptions.class)); URIStatus status = new URIStatus(new FileInfo()); AlluxioURI file = new AlluxioURI(\"/file\"); GetStatusPOptions getStatusOptions = FileSystemOptions.getStatusDefaults(mConf).toBuilder().setLoadMetadataType(LoadMetadataPType.NEVER).build(); when(mFileSystemMasterClient.getStatus(file, getStatusOptions)).thenReturn(status); FileOutStream out = mFileSystem.createFile(file, CreateFilePOptions.getDefaultInstance()); verify(mFileSystemMasterClient).createFile(file, FileSystemOptions.createFileDefaults(mConf).toBuilder().mergeFrom(CreateFilePOptions.getDefaultInstance()).build()); assertEquals(out.mUri, file); verifyFilesystemContextAcquiredAndReleased(); } ",
        "focal_tgt": "URIStatus createFile(AlluxioURI path, CreateFilePOptions options)throws AlluxioStatusException; ",
        "focal_src": "void createFile(AlluxioURI path, CreateFilePOptions options)throws AlluxioStatusException; ",
        "test_tgt": "@Test public void createFile()throws Exception { URIStatus status = new URIStatus(new FileInfo()); AlluxioURI file = new AlluxioURI(\"/file\"); when(mFileSystemMasterClient.createFile(any(AlluxioURI.class), any(CreateFilePOptions.class))).thenReturn(status); FileOutStream out = mFileSystem.createFile(file, CreateFilePOptions.getDefaultInstance()); verify(mFileSystemMasterClient).createFile(file, FileSystemOptions.createFileDefaults(mConf).toBuilder().mergeFrom(CreateFilePOptions.getDefaultInstance()).build()); assertEquals(out.mUri, file); verifyFilesystemContextAcquiredAndReleased(); } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void test_minusNanos_halfABillion() { LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT); LocalDate d = t.toLocalDate().minusDays(1); int hour = 0; int min = 0; int sec = 0; int nanos = 0; for(long i = 0; i < 3700 * 1000000000L; i += 500000000) { t = t.minusNanos(500000000); nanos -= 500000000; if(nanos < 0) { sec -- ; nanos += 1000000000; if(sec == - 1) { min -- ; sec += 60; if(min == - 1) { hour -- ; min += 60; if(hour == - 1) { hour += 24; } } } } assertEquals(t.toLocalDate(), d); assertEquals(t.getHour(), hour); assertEquals(t.getMinute(), min); assertEquals(t.getSecond(), sec); assertEquals(t.getNano(), nanos); } } ",
        "focal_tgt": "ChronoZonedDateTime < C > minusNanos(long nanos) { ChronoDateTime newDT = dateTime.getDateTime().minusNanos(nanos); return(newDT == dateTime.getDateTime() ? this : resolve(newDT, zone, dateTime, ZoneResolvers.retainOffset())); } ",
        "focal_src": "ChronoZonedDateTime < C > minusNanos(long nanos) { ChronoDateTime newDT = dateTime.toDateTime().minusNanos(nanos); return(newDT == dateTime.toDateTime() ? this : resolve(newDT, zone, dateTime, ZoneResolvers.retainOffset())); } ",
        "test_tgt": "@Test(groups = { \"tck\" })public void test_minusNanos_halfABillion() { LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT); LocalDate d = t.getDate().minusDays(1); int hour = 0; int min = 0; int sec = 0; int nanos = 0; for(long i = 0; i < 3700 * 1000000000L; i += 500000000) { t = t.minusNanos(500000000); nanos -= 500000000; if(nanos < 0) { sec -- ; nanos += 1000000000; if(sec == - 1) { min -- ; sec += 60; if(min == - 1) { hour -- ; min += 60; if(hour == - 1) { hour += 24; } } } } assertEquals(t.getDate(), d); assertEquals(t.getHour(), hour); assertEquals(t.getMinute(), min); assertEquals(t.getSecond(), sec); assertEquals(t.getNano(), nanos); } } "
    },
    {
        "test_src": "@Test(description = \"GET /v${apiVersion}/{tenantId}/extensions/{alias}\", dependsOnMethods = { \"testListExtensions\" })public void testGetExtensionByAlias()throws Exception { for(String zoneId : zones) { ExtensionApi api = novaContext.getApi().getExtensionApiForZone(zoneId); Set < ? extends Extension > response = api.listExtensions(); for(Extension extension : response) { Extension details = api.getExtensionByAlias(extension.getId()); assertNotNull(details); assertEquals(details.getId(), extension.getId()); assertEquals(details.getName(), extension.getName()); assertEquals(details.getDescription(), extension.getDescription()); assertEquals(details.getNamespace(), extension.getNamespace()); assertEquals(details.getUpdated(), extension.getUpdated()); assertEquals(details.getLinks(), extension.getLinks()); } } } ",
        "focal_tgt": "Extension get(String alias); ",
        "focal_src": "Extension getExtensionByAlias(String alias); ",
        "test_tgt": "@Test(description = \"GET /v${apiVersion}/{tenantId}/extensions/{alias}\", dependsOnMethods = { \"testListExtensions\" })public void testGetExtensionByAlias()throws Exception { for(String zoneId : zones) { ExtensionApi api = novaContext.getApi().getExtensionApiForZone(zoneId); Set < ? extends Extension > response = api.list(); for(Extension extension : response) { Extension details = api.get(extension.getId()); assertNotNull(details); assertEquals(details.getId(), extension.getId()); assertEquals(details.getName(), extension.getName()); assertEquals(details.getDescription(), extension.getDescription()); assertEquals(details.getNamespace(), extension.getNamespace()); assertEquals(details.getUpdated(), extension.getUpdated()); assertEquals(details.getLinks(), extension.getLinks()); } } } "
    },
    {
        "test_src": "@Ignore@Test public void testRun_domainInTestTld_isConsideredNotFound() { persistResource(Registry.get(\"lol\").asBuilder().setTldType(Registry.TldType.TEST).build()); Registrar registrar = persistResource(makeRegistrar(\"evilregistrar\", \"Yes Virginia\", ACTIVE)); persistResource(makeDomainResource(\"cat.lol\", persistResource(makeContactResource(\"5372808-ERL\", \"Goblin Market\", \"lol@cat.lol\")), persistResource(makeContactResource(\"5372808-IRL\", \"Santa Claus\", \"BOFH@cat.lol\")), persistResource(makeContactResource(\"5372808-TRL\", \"The Raven\", \"bog@cat.lol\")), persistResource(makeHostResource(\"ns1.cat.lol\", \"1.2.3.4\")), persistResource(makeHostResource(\"ns2.cat.lol\", \"bad:f00d:cafe::15:beef\")), registrar)); persistSimpleResources(makeRegistrarContacts(registrar)); newWhoisAction(\"domain cat.lol\\r\\n\").run(); assertThat(response.getStatus()).isEqualTo(200); assertThat(response.getPayload()).isEqualTo(loadFile(\"whois_action_domain_not_found.txt\")); } ",
        "focal_tgt": "@Override public final EppResponse run()throws EppException { extensionManager.register(MetadataExtension.class); extensionManager.validate(); validateClientIsLoggedIn(clientId); DateTime now = ofy().getTransactionTime(); DomainBase existingDomain = loadAndVerifyExistence(DomainBase.class, targetId, now); verifyOptionalAuthInfo(authInfo, existingDomain); verifyHasPendingTransfer(existingDomain); verifyResourceOwnership(clientId, existingDomain); String tld = existingDomain.getTld(); if( ! isSuperuser) { checkAllowedAccessToTld(clientId, tld); } TransferData transferData = existingDomain.getTransferData(); String gainingClientId = transferData.getGainingClientId(); Registry registry = Registry.get(existingDomain.getTld()); HistoryEntry historyEntry = buildHistoryEntry(existingDomain, registry, now, gainingClientId); Optional < BillingEvent.OneTime > billingEvent = (transferData.getTransferPeriod().getValue() == 0) ? Optional.empty() : Optional.of(new BillingEvent.OneTime.Builder().setReason(Reason.TRANSFER).setTargetId(targetId).setClientId(gainingClientId).setPeriodYears(1).setCost(getDomainRenewCost(targetId, transferData.getTransferRequestTime(), 1)).setEventTime(now).setBillingTime(now.plus(Registry.get(tld).getTransferGracePeriodLength())).setParent(historyEntry).build()); GracePeriod autorenewGrace = getOnlyElement(existingDomain.getGracePeriodsOfType(GracePeriodStatus.AUTO_RENEW), null); int extraYears = transferData.getTransferPeriod().getValue(); if(autorenewGrace != null) { extraYears = 0; if(billingEvent.isPresent()) { ofy().save().entity(BillingEvent.Cancellation.forGracePeriod(autorenewGrace, historyEntry, targetId)); } } updateAutorenewRecurrenceEndTime(existingDomain, now); DateTime newExpirationTime = extendRegistrationWithCap(now, existingDomain.getRegistrationExpirationTime(), extraYears); BillingEvent.Recurring autorenewEvent = new BillingEvent.Recurring.Builder().setReason(Reason.RENEW).setFlags(ImmutableSet.of(Flag.AUTO_RENEW)).setTargetId(targetId).setClientId(gainingClientId).setEventTime(newExpirationTime).setRecurrenceEndTime(END_OF_TIME).setParent(historyEntry).build(); PollMessage.Autorenew gainingClientAutorenewPollMessage = new PollMessage.Autorenew.Builder().setTargetId(targetId).setClientId(gainingClientId).setEventTime(newExpirationTime).setAutorenewEndTime(END_OF_TIME).setMsg(\"Domain was auto-renewed.\").setParent(historyEntry).build(); DomainBase partiallyApprovedDomain = approvePendingTransfer(existingDomain, TransferStatus.CLIENT_APPROVED, now); DomainBase newDomain = partiallyApprovedDomain.asBuilder().setTransferData(partiallyApprovedDomain.getTransferData().asBuilder().setTransferredRegistrationExpirationTime(newExpirationTime).build()).setRegistrationExpirationTime(newExpirationTime).setAutorenewBillingEvent(Key.create(autorenewEvent)).setAutorenewPollMessage(Key.create(gainingClientAutorenewPollMessage)).setGracePeriods((billingEvent.isPresent()) ? ImmutableSet.of(GracePeriod.forBillingEvent(GracePeriodStatus.TRANSFER, billingEvent.get())) : ImmutableSet.of()).setLastEppUpdateTime(now).setLastEppUpdateClientId(clientId).build(); PollMessage gainingClientPollMessage = createGainingTransferPollMessage(targetId, newDomain.getTransferData(), newExpirationTime, historyEntry); ImmutableSet.Builder < ImmutableObject > entitiesToSave = new ImmutableSet.Builder < > (); entitiesToSave.add(newDomain, historyEntry, autorenewEvent, gainingClientPollMessage, gainingClientAutorenewPollMessage); billingEvent.ifPresent(entitiesToSave :: add); ofy().save().entities(entitiesToSave.build()); ofy().delete().keys(existingDomain.getTransferData().getServerApproveEntities()); return responseBuilder.setResData(createTransferResponse(targetId, newDomain.getTransferData(), newDomain.getRegistrationExpirationTime())).build(); } ",
        "focal_src": "@Override public final EppResponse run()throws EppException { extensionManager.register(MetadataExtension.class); extensionManager.validate(); validateClientIsLoggedIn(clientId); DateTime now = ofy().getTransactionTime(); DomainResource existingDomain = loadAndVerifyExistence(DomainResource.class, targetId, now); verifyOptionalAuthInfo(authInfo, existingDomain); verifyHasPendingTransfer(existingDomain); verifyResourceOwnership(clientId, existingDomain); String tld = existingDomain.getTld(); if( ! isSuperuser) { checkAllowedAccessToTld(clientId, tld); } TransferData transferData = existingDomain.getTransferData(); String gainingClientId = transferData.getGainingClientId(); Registry registry = Registry.get(existingDomain.getTld()); HistoryEntry historyEntry = buildHistoryEntry(existingDomain, registry, now, gainingClientId); Optional < BillingEvent.OneTime > billingEvent = (transferData.getTransferPeriod().getValue() == 0) ? Optional.empty() : Optional.of(new BillingEvent.OneTime.Builder().setReason(Reason.TRANSFER).setTargetId(targetId).setClientId(gainingClientId).setPeriodYears(1).setCost(getDomainRenewCost(targetId, transferData.getTransferRequestTime(), 1)).setEventTime(now).setBillingTime(now.plus(Registry.get(tld).getTransferGracePeriodLength())).setParent(historyEntry).build()); GracePeriod autorenewGrace = getOnlyElement(existingDomain.getGracePeriodsOfType(GracePeriodStatus.AUTO_RENEW), null); int extraYears = transferData.getTransferPeriod().getValue(); if(autorenewGrace != null) { extraYears = 0; if(billingEvent.isPresent()) { ofy().save().entity(BillingEvent.Cancellation.forGracePeriod(autorenewGrace, historyEntry, targetId)); } } updateAutorenewRecurrenceEndTime(existingDomain, now); DateTime newExpirationTime = extendRegistrationWithCap(now, existingDomain.getRegistrationExpirationTime(), extraYears); BillingEvent.Recurring autorenewEvent = new BillingEvent.Recurring.Builder().setReason(Reason.RENEW).setFlags(ImmutableSet.of(Flag.AUTO_RENEW)).setTargetId(targetId).setClientId(gainingClientId).setEventTime(newExpirationTime).setRecurrenceEndTime(END_OF_TIME).setParent(historyEntry).build(); PollMessage.Autorenew gainingClientAutorenewPollMessage = new PollMessage.Autorenew.Builder().setTargetId(targetId).setClientId(gainingClientId).setEventTime(newExpirationTime).setAutorenewEndTime(END_OF_TIME).setMsg(\"Domain was auto-renewed.\").setParent(historyEntry).build(); DomainResource partiallyApprovedDomain = approvePendingTransfer(existingDomain, TransferStatus.CLIENT_APPROVED, now); DomainResource newDomain = partiallyApprovedDomain.asBuilder().setTransferData(partiallyApprovedDomain.getTransferData().asBuilder().setTransferredRegistrationExpirationTime(newExpirationTime).build()).setRegistrationExpirationTime(newExpirationTime).setAutorenewBillingEvent(Key.create(autorenewEvent)).setAutorenewPollMessage(Key.create(gainingClientAutorenewPollMessage)).setGracePeriods((billingEvent.isPresent()) ? ImmutableSet.of(GracePeriod.forBillingEvent(GracePeriodStatus.TRANSFER, billingEvent.get())) : ImmutableSet.of()).setLastEppUpdateTime(now).setLastEppUpdateClientId(clientId).build(); PollMessage gainingClientPollMessage = createGainingTransferPollMessage(targetId, newDomain.getTransferData(), newExpirationTime, historyEntry); ImmutableSet.Builder < ImmutableObject > entitiesToSave = new ImmutableSet.Builder < > (); entitiesToSave.add(newDomain, historyEntry, autorenewEvent, gainingClientPollMessage, gainingClientAutorenewPollMessage); billingEvent.ifPresent(entitiesToSave :: add); ofy().save().entities(entitiesToSave.build()); ofy().delete().keys(existingDomain.getTransferData().getServerApproveEntities()); return responseBuilder.setResData(createTransferResponse(targetId, newDomain.getTransferData(), newDomain.getRegistrationExpirationTime())).build(); } ",
        "test_tgt": "@Ignore@Test public void testRun_domainInTestTld_isConsideredNotFound() { persistResource(Registry.get(\"lol\").asBuilder().setTldType(Registry.TldType.TEST).build()); Registrar registrar = persistResource(makeRegistrar(\"evilregistrar\", \"Yes Virginia\", ACTIVE)); persistResource(makeDomainBase(\"cat.lol\", persistResource(makeContactResource(\"5372808-ERL\", \"Goblin Market\", \"lol@cat.lol\")), persistResource(makeContactResource(\"5372808-IRL\", \"Santa Claus\", \"BOFH@cat.lol\")), persistResource(makeContactResource(\"5372808-TRL\", \"The Raven\", \"bog@cat.lol\")), persistResource(makeHostResource(\"ns1.cat.lol\", \"1.2.3.4\")), persistResource(makeHostResource(\"ns2.cat.lol\", \"bad:f00d:cafe::15:beef\")), registrar)); persistSimpleResources(makeRegistrarContacts(registrar)); newWhoisAction(\"domain cat.lol\\r\\n\").run(); assertThat(response.getStatus()).isEqualTo(200); assertThat(response.getPayload()).isEqualTo(loadFile(\"whois_action_domain_not_found.txt\")); } "
    },
    {
        "test_src": "@Test public void testNegotiate() { final String securityPackage = \"Negotiate\"; IWindowsCredentialsHandle clientCredentials = null; WindowsSecurityContextImpl clientContext = null; try { clientCredentials = WindowsCredentialsHandleImpl.getCurrent(securityPackage); clientCredentials.initialize(); clientContext = new WindowsSecurityContextImpl(); clientContext.setPrincipalName(WindowsAccountImpl.getCurrentUsername()); clientContext.setCredentialsHandle(clientCredentials); clientContext.setSecurityPackage(securityPackage); clientContext.initialize(null, null, WindowsAccountImpl.getCurrentUsername()); boolean authenticated = false; final SimpleHttpRequest request = new SimpleHttpRequest(); while(true) { final String clientToken = BaseEncoding.base64().encode(clientContext.getToken()); request.addHeader(\"Authorization\", securityPackage + \" \" + clientToken); final SimpleHttpResponse response = new SimpleHttpResponse(); authenticated = this.authenticator.authenticate(request, response); if(authenticated) { Assert.assertNotNull(request.getUserPrincipal()); Assert.assertTrue(request.getUserPrincipal()instanceof GenericWindowsPrincipal); final GenericWindowsPrincipal windowsPrincipal = (GenericWindowsPrincipal)request.getUserPrincipal(); Assert.assertTrue(windowsPrincipal.getSidString().startsWith(\"S-\")); Assertions.assertThat(windowsPrincipal.getSid().length).isGreaterThan(0); Assert.assertTrue(windowsPrincipal.getGroups().containsKey(\"Everyone\")); Assertions.assertThat(response.getHeaderNames().size()).isLessThanOrEqualTo(1); break; } Assert.assertTrue(response.getHeader(\"WWW-Authenticate\").startsWith(securityPackage + \" \")); Assert.assertEquals(\"keep-alive\", response.getHeader(\"Connection\")); Assert.assertEquals(2, response.getHeaderNames().size()); Assert.assertEquals(401, response.getStatus()); final String continueToken = response.getHeader(\"WWW-Authenticate\").substring(securityPackage.length() + 1); final byte[]continueTokenBytes = BaseEncoding.base64().decode(continueToken); Assertions.assertThat(continueTokenBytes.length).isGreaterThan(0); final SecBufferDesc continueTokenBuffer = new SecBufferDesc(Sspi.SECBUFFER_TOKEN, continueTokenBytes); clientContext.initialize(clientContext.getHandle(), continueTokenBuffer, WindowsAccountImpl.getCurrentUsername()); } Assert.assertTrue(authenticated); } finally { if(clientContext != null) { clientContext.dispose(); } if(clientCredentials != null) { clientCredentials.dispose(); } } } ",
        "focal_tgt": "private boolean negotiate(final Request request, final HttpServletResponse response, final AuthorizationHeader authorizationHeader) { final String securityPackage = authorizationHeader.getSecurityPackage(); final String connectionId = NtlmServletRequest.getConnectionId(request); this.log.debug(\"security package: {}, connection id: {}\", securityPackage, connectionId); final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader(); if(ntlmPost) { this.auth.resetSecurityToken(connectionId); } IWindowsSecurityContext securityContext; try { final byte[]tokenBuffer = authorizationHeader.getTokenBytes(); this.log.debug(\"token buffer: {} byte(s)\", Integer.valueOf(tokenBuffer.length)); securityContext = this.auth.acceptSecurityToken(connectionId, tokenBuffer, securityPackage); this.log.debug(\"continue required: {}\", Boolean.valueOf(securityContext.isContinue())); final byte[]continueTokenBytes = securityContext.getToken(); if(continueTokenBytes != null && continueTokenBytes.length > 0) { final String continueToken = Base64.getEncoder().encodeToString(continueTokenBytes); this.log.debug(\"continue token: {}\", continueToken); response.addHeader(\"WWW-Authenticate\", securityPackage + \" \" + continueToken); } if(securityContext.isContinue() || ntlmPost) { response.setHeader(\"Connection\", \"keep-alive\"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); response.flushBuffer(); return false; } } catch(final IOException e) { this.log.warn(\"error logging in user: {}\", e.getMessage()); this.log.trace(\"\", e); this.sendUnauthorized(response); return false; } final IWindowsIdentity windowsIdentity = securityContext.getIdentity(); if( ! this.allowGuestLogin && windowsIdentity.isGuest()) { this.log.warn(\"guest login disabled: {}\", windowsIdentity.getFqn()); this.sendUnauthorized(response); return false; } try { this.log.debug(\"logged in user: {} ({})\", windowsIdentity.getFqn(), windowsIdentity.getSidString()); final GenericWindowsPrincipal windowsPrincipal = new GenericWindowsPrincipal(windowsIdentity, this.principalFormat, this.roleFormat); this.log.debug(\"roles: {}\", windowsPrincipal.getRolesString()); final HttpSession session = request.getSession(true); this.log.debug(\"session id: {}\", session == null ? \"null\" : session.getId()); this.register(request, response, windowsPrincipal, securityPackage, windowsPrincipal.getName(), null); this.log.info(\"successfully logged in user: {}\", windowsPrincipal.getName()); } finally { windowsIdentity.dispose(); } return true; } ",
        "focal_src": "private boolean negotiate(final Request request, final HttpServletResponse response, final AuthorizationHeader authorizationHeader) { final String securityPackage = authorizationHeader.getSecurityPackage(); final String connectionId = NtlmServletRequest.getConnectionId(request); this.log.debug(\"security package: {}, connection id: {}\", securityPackage, connectionId); final boolean ntlmPost = authorizationHeader.isNtlmType1PostAuthorizationHeader(); if(ntlmPost) { this.auth.resetSecurityToken(connectionId); } IWindowsSecurityContext securityContext; try { final byte[]tokenBuffer = authorizationHeader.getTokenBytes(); this.log.debug(\"token buffer: {} byte(s)\", Integer.valueOf(tokenBuffer.length)); securityContext = this.auth.acceptSecurityToken(connectionId, tokenBuffer, securityPackage); this.log.debug(\"continue required: {}\", Boolean.valueOf(securityContext.isContinue())); final byte[]continueTokenBytes = securityContext.getToken(); if(continueTokenBytes != null && continueTokenBytes.length > 0) { final String continueToken = BaseEncoding.base64().encode(continueTokenBytes); this.log.debug(\"continue token: {}\", continueToken); response.addHeader(\"WWW-Authenticate\", securityPackage + \" \" + continueToken); } if(securityContext.isContinue() || ntlmPost) { response.setHeader(\"Connection\", \"keep-alive\"); response.sendError(HttpServletResponse.SC_UNAUTHORIZED); response.flushBuffer(); return false; } } catch(final IOException e) { this.log.warn(\"error logging in user: {}\", e.getMessage()); this.log.trace(\"\", e); this.sendUnauthorized(response); return false; } final IWindowsIdentity windowsIdentity = securityContext.getIdentity(); if( ! this.allowGuestLogin && windowsIdentity.isGuest()) { this.log.warn(\"guest login disabled: {}\", windowsIdentity.getFqn()); this.sendUnauthorized(response); return false; } try { this.log.debug(\"logged in user: {} ({})\", windowsIdentity.getFqn(), windowsIdentity.getSidString()); final GenericWindowsPrincipal windowsPrincipal = new GenericWindowsPrincipal(windowsIdentity, this.principalFormat, this.roleFormat); this.log.debug(\"roles: {}\", windowsPrincipal.getRolesString()); final HttpSession session = request.getSession(true); this.log.debug(\"session id: {}\", session == null ? \"null\" : session.getId()); this.register(request, response, windowsPrincipal, securityPackage, windowsPrincipal.getName(), null); this.log.info(\"successfully logged in user: {}\", windowsPrincipal.getName()); } finally { windowsIdentity.dispose(); } return true; } ",
        "test_tgt": "@Test public void testNegotiate() { final String securityPackage = \"Negotiate\"; IWindowsCredentialsHandle clientCredentials = null; WindowsSecurityContextImpl clientContext = null; try { clientCredentials = WindowsCredentialsHandleImpl.getCurrent(securityPackage); clientCredentials.initialize(); clientContext = new WindowsSecurityContextImpl(); clientContext.setPrincipalName(WindowsAccountImpl.getCurrentUsername()); clientContext.setCredentialsHandle(clientCredentials); clientContext.setSecurityPackage(securityPackage); clientContext.initialize(null, null, WindowsAccountImpl.getCurrentUsername()); boolean authenticated = false; final SimpleHttpRequest request = new SimpleHttpRequest(); while(true) { final String clientToken = Base64.getEncoder().encodeToString(clientContext.getToken()); request.addHeader(\"Authorization\", securityPackage + \" \" + clientToken); final SimpleHttpResponse response = new SimpleHttpResponse(); authenticated = this.authenticator.authenticate(request, response); if(authenticated) { Assert.assertNotNull(request.getUserPrincipal()); Assert.assertTrue(request.getUserPrincipal()instanceof GenericWindowsPrincipal); final GenericWindowsPrincipal windowsPrincipal = (GenericWindowsPrincipal)request.getUserPrincipal(); Assert.assertTrue(windowsPrincipal.getSidString().startsWith(\"S-\")); Assertions.assertThat(windowsPrincipal.getSid().length).isGreaterThan(0); Assert.assertTrue(windowsPrincipal.getGroups().containsKey(\"Everyone\")); Assertions.assertThat(response.getHeaderNames().size()).isLessThanOrEqualTo(1); break; } Assert.assertTrue(response.getHeader(\"WWW-Authenticate\").startsWith(securityPackage + \" \")); Assert.assertEquals(\"keep-alive\", response.getHeader(\"Connection\")); Assert.assertEquals(2, response.getHeaderNames().size()); Assert.assertEquals(401, response.getStatus()); final String continueToken = response.getHeader(\"WWW-Authenticate\").substring(securityPackage.length() + 1); final byte[]continueTokenBytes = Base64.getDecoder().decode(continueToken); Assertions.assertThat(continueTokenBytes.length).isGreaterThan(0); final SecBufferDesc continueTokenBuffer = new SecBufferDesc(Sspi.SECBUFFER_TOKEN, continueTokenBytes); clientContext.initialize(clientContext.getHandle(), continueTokenBuffer, WindowsAccountImpl.getCurrentUsername()); } Assert.assertTrue(authenticated); } finally { if(clientContext != null) { clientContext.dispose(); } if(clientCredentials != null) { clientCredentials.dispose(); } } } "
    },
    {
        "test_src": "@Test public void testCoordinateJob()throws GenieException { final int cpu = 1; final int mem = 1; final String email = \"name@domain.com\"; final String setupFile = \"setupFilePath\"; final String group = \"group\"; final String description = \"job description\"; final Set < String > tags = new HashSet < > (); final String clientHost = \"localhost\"; tags.add(\"foo\"); tags.add(\"bar\"); final JobRequest jobRequest = new JobRequest.Builder(JOB_1_NAME, JOB_1_USER, JOB_1_VERSION, null, null, null).withId(JOB_1_ID).withDescription(description).withCpu(cpu).withMemory(mem).withEmail(email).withSetupFile(setupFile).withGroup(group).withTags(tags).withDisableLogArchival(true).build(); Mockito.when(this.jobPersistenceService.createJobRequest(jobRequest, clientHost)).thenReturn(jobRequest); this.jobCoordinatorService.coordinateJob(jobRequest, clientHost); Mockito.verify(this.taskExecutor, Mockito.times(1)).execute(Mockito.any(JobLauncher.class)); final ArgumentCaptor < Job > argument = ArgumentCaptor.forClass(Job.class); Mockito.verify(this.jobPersistenceService).createJob(argument.capture()); Assert.assertEquals(JOB_1_ID, argument.getValue().getId()); Assert.assertEquals(JOB_1_NAME, argument.getValue().getName()); Assert.assertEquals(JOB_1_USER, argument.getValue().getUser()); Assert.assertEquals(JOB_1_VERSION, argument.getValue().getVersion()); Assert.assertEquals(JobStatus.INIT, argument.getValue().getStatus()); Assert.assertEquals(description, argument.getValue().getDescription()); } ",
        "focal_tgt": "public String coordinateJob(@NotNull(message = \"No jobRequest provided. Unable to submit job for execution.\")@Valid final JobRequest jobRequest, final String clientHost)throws GenieException { log.debug(\"Called with job request {}\", jobRequest); if(StringUtils.isBlank(jobRequest.getId())) { throw new GenieServerException(\"Id of the jobRequest cannot be null\"); } this.jobPersistenceService.createJobRequest(jobRequest, clientHost); String archiveLocation = null; if( ! jobRequest.isDisableLogArchival()) { archiveLocation = this.baseArchiveLocation + JobConstants.FILE_PATH_DELIMITER + jobRequest.getId() + \".tar.gz\"; } final Job.Builder jobBuilder = new Job.Builder(jobRequest.getName(), jobRequest.getUser(), jobRequest.getVersion(), jobRequest.getCommandArgs()).withArchiveLocation(archiveLocation).withDescription(jobRequest.getDescription()).withId(jobRequest.getId()).withTags(jobRequest.getTags()); if(this.canRunJob()) { jobBuilder.withStatus(JobStatus.INIT).withStatusMsg(\"Job Accepted and in initialization phase.\"); this.jobPersistenceService.createJob(jobBuilder.build()); try { final Future < ? > task = this.taskExecutor.submit(new JobLauncher(this.jobSubmitterService, jobRequest, this.registry)); this.eventPublisher.publishEvent(new JobScheduledEvent(jobRequest.getId(), task, this)); } catch(final TaskRejectedException e) { final String errorMsg = \"Unable to launch job due to exception: \" + e.getMessage(); this.jobPersistenceService.updateJobStatus(jobRequest.getId(), JobStatus.FAILED, errorMsg); throw new GenieServerException(errorMsg, e); } return jobRequest.getId(); } else { jobBuilder.withStatus(JobStatus.FAILED).withStatusMsg(\"Unable to run job due to host being too busy during request.\"); this.jobPersistenceService.createJob(jobBuilder.build()); throw new GenieServerUnavailableException(\"Reached max running jobs on this host. Unable to run job.\"); } } ",
        "focal_src": "public String coordinateJob(@NotNull(message = \"No jobRequest provided. Unable to submit job for execution.\")@Valid final JobRequest jobRequest, final String clientHost)throws GenieException { log.debug(\"Called with job request {}\", jobRequest); if(StringUtils.isBlank(jobRequest.getId())) { throw new GenieServerException(\"Id of the jobRequest cannot be null\"); } this.jobPersistenceService.createJobRequest(jobRequest, clientHost); String archiveLocation = null; if( ! jobRequest.isDisableLogArchival()) { archiveLocation = this.baseArchiveLocation + JobConstants.FILE_PATH_DELIMITER + jobRequest.getId() + \".tar.gz\"; } final Job.Builder jobBuilder = new Job.Builder(jobRequest.getName(), jobRequest.getUser(), jobRequest.getVersion(), jobRequest.getCommandArgs()).withArchiveLocation(archiveLocation).withDescription(jobRequest.getDescription()).withId(jobRequest.getId()).withTags(jobRequest.getTags()); if(this.canRunJob()) { jobBuilder.withStatus(JobStatus.INIT).withStatusMsg(\"Job Accepted and in initialization phase.\"); this.jobPersistenceService.createJob(jobBuilder.build()); try { this.taskExecutor.execute(new JobLauncher(this.jobSubmitterService, jobRequest, this.registry)); } catch(final TaskRejectedException e) { final String errorMsg = \"Unable to launch job due to exception: \" + e.getMessage(); this.jobPersistenceService.updateJobStatus(jobRequest.getId(), JobStatus.FAILED, errorMsg); throw new GenieServerException(errorMsg, e); } return jobRequest.getId(); } else { jobBuilder.withStatus(JobStatus.FAILED).withStatusMsg(\"Unable to run job due to host being too busy during request.\"); this.jobPersistenceService.createJob(jobBuilder.build()); throw new GenieServerUnavailableException(\"Reached max running jobs on this host. Unable to run job.\"); } } ",
        "test_tgt": "@Test public void testCoordinateJob()throws GenieException { final int cpu = 1; final int mem = 1; final String email = \"name@domain.com\"; final String setupFile = \"setupFilePath\"; final String group = \"group\"; final String description = \"job description\"; final Set < String > tags = new HashSet < > (); final String clientHost = \"localhost\"; tags.add(\"foo\"); tags.add(\"bar\"); final JobRequest jobRequest = new JobRequest.Builder(JOB_1_NAME, JOB_1_USER, JOB_1_VERSION, null, null, null).withId(JOB_1_ID).withDescription(description).withCpu(cpu).withMemory(mem).withEmail(email).withSetupFile(setupFile).withGroup(group).withTags(tags).withDisableLogArchival(true).build(); Mockito.when(this.jobPersistenceService.createJobRequest(jobRequest, clientHost)).thenReturn(jobRequest); final Future < ? > task = Mockito.mock(Future.class); Mockito.doReturn(task).when(this.taskExecutor).submit(Mockito.any(JobLauncher.class)); this.jobCoordinatorService.coordinateJob(jobRequest, clientHost); Mockito.verify(this.taskExecutor, Mockito.times(1)).submit(Mockito.any(JobLauncher.class)); Mockito.verify(this.eventPublisher, Mockito.times(1)).publishEvent(Mockito.any(JobScheduledEvent.class)); final ArgumentCaptor < Job > argument = ArgumentCaptor.forClass(Job.class); Mockito.verify(this.jobPersistenceService).createJob(argument.capture()); Assert.assertEquals(JOB_1_ID, argument.getValue().getId()); Assert.assertEquals(JOB_1_NAME, argument.getValue().getName()); Assert.assertEquals(JOB_1_USER, argument.getValue().getUser()); Assert.assertEquals(JOB_1_VERSION, argument.getValue().getVersion()); Assert.assertEquals(JobStatus.INIT, argument.getValue().getStatus()); Assert.assertEquals(description, argument.getValue().getDescription()); } "
    },
    {
        "test_src": "@Test public void testGetScalingEvents()throws Exception { String resourceURI = getURI() + \"v1/scopes/scope1/streams/stream1/scaling-events\"; List < ScaleMetadata > scaleMetadataList = new ArrayList < > (); Segment segment1 = new Segment(0, 0, System.currentTimeMillis(), 0.00, 0.50); Segment segment2 = new Segment(1, 0, System.currentTimeMillis(), 0.50, 1.00); List < Segment > segmentList1 = Arrays.asList(segment1, segment2); ScaleMetadata scaleMetadata1 = new ScaleMetadata(System.currentTimeMillis() / 2, segmentList1, 0L, 0L); Segment segment3 = new Segment(2, 0, System.currentTimeMillis(), 0.00, 0.40); Segment segment4 = new Segment(3, 0, System.currentTimeMillis(), 0.40, 1.00); List < Segment > segmentList2 = Arrays.asList(segment3, segment4); ScaleMetadata scaleMetadata2 = new ScaleMetadata(1 + System.currentTimeMillis() / 2, segmentList2, 1L, 1L); long fromDateTime = System.currentTimeMillis(); Segment segment5 = new Segment(4, 0, System.currentTimeMillis(), 0.00, 0.50); Segment segment6 = new Segment(5, 0, System.currentTimeMillis(), 0.50, 1.00); List < Segment > segmentList3 = Arrays.asList(segment5, segment6); ScaleMetadata scaleMetadata3 = new ScaleMetadata(System.currentTimeMillis(), segmentList3, 1L, 1L); Segment segment7 = new Segment(6, 0, System.currentTimeMillis(), 0.00, 0.25); Segment segment8 = new Segment(7, 0, System.currentTimeMillis(), 0.25, 1.00); List < Segment > segmentList4 = Arrays.asList(segment7, segment8); ScaleMetadata scaleMetadata4 = new ScaleMetadata(System.currentTimeMillis(), segmentList4, 1L, 1L); long toDateTime = System.currentTimeMillis(); Segment segment9 = new Segment(8, 0, System.currentTimeMillis(), 0.00, 0.40); Segment segment10 = new Segment(9, 0, System.currentTimeMillis(), 0.40, 1.00); List < Segment > segmentList5 = Arrays.asList(segment9, segment10); ScaleMetadata scaleMetadata5 = new ScaleMetadata(toDateTime * 2, segmentList5, 1L, 1L); scaleMetadataList.add(scaleMetadata5); scaleMetadataList.add(scaleMetadata4); scaleMetadataList.add(scaleMetadata3); scaleMetadataList.add(scaleMetadata2); scaleMetadataList.add(scaleMetadata1); when(mockControllerService.getScaleRecords(scope1, stream1)).thenReturn(CompletableFuture.completedFuture(scaleMetadataList)); Response response = addAuthHeaders(client.target(resourceURI).queryParam(\"from\", fromDateTime).queryParam(\"to\", toDateTime).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 200, response.getStatus()); assertTrue(response.bufferEntity()); List < ScaleMetadata > scaleMetadataListResponse = response.readEntity(new GenericType < List < ScaleMetadata > > () { }); assertEquals(\"List Size\", 3, scaleMetadataListResponse.size()); scaleMetadataListResponse.forEach(data -> { log.warn(\"Here\"); data.getSegments().forEach(segment -> { log.debug(\"Checking segment number: \" + segment.segmentId()); assertTrue(\"Event 1 shouldn't be included\", segment.segmentId() != 0L); }); }); scaleMetadataList.clear(); scaleMetadataList.addAll(Collections.nCopies(50000, scaleMetadata3)); when(mockControllerService.getScaleRecords(scope1, stream1)).thenReturn(CompletableFuture.completedFuture(scaleMetadataList)); response = addAuthHeaders(client.target(resourceURI).queryParam(\"from\", fromDateTime).queryParam(\"to\", toDateTime).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 200, response.getStatus()); assertTrue(response.bufferEntity()); scaleMetadataListResponse = response.readEntity(new GenericType < List < ScaleMetadata > > () { }); assertEquals(\"List Size\", 50000, scaleMetadataListResponse.size()); final CompletableFuture < List < ScaleMetadata > > completableFuture1 = new CompletableFuture < > (); completableFuture1.completeExceptionally(StoreException.create(StoreException.Type.DATA_NOT_FOUND, \"stream1\")); when(mockControllerService.getScaleRecords(\"scope1\", \"stream1\")).thenReturn(completableFuture1); response = addAuthHeaders(client.target(resourceURI).queryParam(\"from\", fromDateTime).queryParam(\"to\", toDateTime).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 404, response.getStatus()); when(mockControllerService.getScaleRecords(\"scope1\", \"stream1\")).thenReturn(CompletableFuture.completedFuture(scaleMetadataList)); response = addAuthHeaders(client.target(resourceURI).queryParam(\"from\", fromDateTime * 2).queryParam(\"to\", fromDateTime).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 400, response.getStatus()); final CompletableFuture < List < ScaleMetadata > > completableFuture = new CompletableFuture < > (); completableFuture.completeExceptionally(new Exception()); when(mockControllerService.getScaleRecords(\"scope1\", \"stream1\")).thenReturn(completableFuture); response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 500, response.getStatus()); } ",
        "focal_tgt": "@Override public void getScalingEvents(final String scopeName, final String streamName, final Long from, final Long to, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"getScalingEvents\"); try { authenticateAuthorize(scopeName + \"/\" + streamName, READ); } catch(AuthException e) { log.warn(\"Get scaling events for {} failed due to authentication failure.\", scopeName + \"/\" + streamName); asyncResponse.resume(Response.status(Status.fromStatusCode(e.getResponseCode())).build()); LoggerHelpers.traceLeave(log, \"Get scaling events\", traceId); return; } if(from < 0 || to < 0 || from > to) { log.warn(\"Received invalid request from client for scopeName/streamName: {}/{} \", scopeName, streamName); asyncResponse.resume(Response.status(Status.BAD_REQUEST).build()); LoggerHelpers.traceLeave(log, \"getScalingEvents\", traceId); return; } controllerService.getScaleRecords(scopeName, streamName, from, to).thenApply(listScaleMetadata -> { Iterator < ScaleMetadata > metadataIterator = listScaleMetadata.iterator(); List < ScaleMetadata > finalScaleMetadataList = new ArrayList < ScaleMetadata > (); ScaleMetadata referenceEvent = null; while(metadataIterator.hasNext()) { ScaleMetadata scaleMetadata = metadataIterator.next(); if(scaleMetadata.getTimestamp() >= from && scaleMetadata.getTimestamp() <= to) { finalScaleMetadataList.add(scaleMetadata); } else if((scaleMetadata.getTimestamp() < from) && ! (referenceEvent != null && referenceEvent.getTimestamp() > scaleMetadata.getTimestamp())) { referenceEvent = scaleMetadata; } } if(referenceEvent != null) { finalScaleMetadataList.add(0, referenceEvent); } log.info(\"Successfully fetched required scaling events for scope: {}, stream: {}\", scopeName, streamName); return Response.status(Status.OK).entity(finalScaleMetadataList).build(); }).exceptionally(exception -> { if(exception.getCause()instanceof StoreException.DataNotFoundException || exception instanceof StoreException.DataNotFoundException) { log.warn(\"Stream/Scope name: {}/{} not found\", scopeName, streamName); return Response.status(Status.NOT_FOUND).build(); } else { log.warn(\"getScalingEvents for scopeName/streamName: {}/{} failed with exception \", scopeName, streamName, exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).thenApply(asyncResponse :: resume).thenAccept(x -> LoggerHelpers.traceLeave(log, \"getScalingEvents\", traceId)); } ",
        "focal_src": "@Override public void getScalingEvents(final String scopeName, final String streamName, final Long from, final Long to, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"getScalingEvents\"); try { authenticateAuthorize(scopeName + \"/\" + streamName, READ); } catch(AuthException e) { log.warn(\"Get scaling events for {} failed due to authentication failure.\", scopeName + \"/\" + streamName); asyncResponse.resume(Response.status(Status.fromStatusCode(e.getResponseCode())).build()); LoggerHelpers.traceLeave(log, \"Get scaling events\", traceId); return; } if(from < 0 || to < 0 || from > to) { log.warn(\"Received invalid request from client for scopeName/streamName: {}/{} \", scopeName, streamName); asyncResponse.resume(Response.status(Status.BAD_REQUEST).build()); LoggerHelpers.traceLeave(log, \"getScalingEvents\", traceId); return; } controllerService.getScaleRecords(scopeName, streamName).thenApply(listScaleMetadata -> { Iterator < ScaleMetadata > metadataIterator = listScaleMetadata.iterator(); List < ScaleMetadata > finalScaleMetadataList = new ArrayList < ScaleMetadata > (); ScaleMetadata referenceEvent = null; while(metadataIterator.hasNext()) { ScaleMetadata scaleMetadata = metadataIterator.next(); if(scaleMetadata.getTimestamp() >= from && scaleMetadata.getTimestamp() <= to) { finalScaleMetadataList.add(scaleMetadata); } else if((scaleMetadata.getTimestamp() < from) && ! (referenceEvent != null && referenceEvent.getTimestamp() > scaleMetadata.getTimestamp())) { referenceEvent = scaleMetadata; } } if(referenceEvent != null) { finalScaleMetadataList.add(0, referenceEvent); } log.info(\"Successfully fetched required scaling events for scope: {}, stream: {}\", scopeName, streamName); return Response.status(Status.OK).entity(finalScaleMetadataList).build(); }).exceptionally(exception -> { if(exception.getCause()instanceof StoreException.DataNotFoundException || exception instanceof StoreException.DataNotFoundException) { log.warn(\"Stream/Scope name: {}/{} not found\", scopeName, streamName); return Response.status(Status.NOT_FOUND).build(); } else { log.warn(\"getScalingEvents for scopeName/streamName: {}/{} failed with exception \", scopeName, streamName, exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).thenApply(asyncResponse :: resume).thenAccept(x -> LoggerHelpers.traceLeave(log, \"getScalingEvents\", traceId)); } ",
        "test_tgt": "@Test public void testGetScalingEvents()throws Exception { String resourceURI = getURI() + \"v1/scopes/scope1/streams/stream1/scaling-events\"; List < ScaleMetadata > scaleMetadataList = new ArrayList < > (); Segment segment1 = new Segment(0, 0, System.currentTimeMillis(), 0.00, 0.50); Segment segment2 = new Segment(1, 0, System.currentTimeMillis(), 0.50, 1.00); List < Segment > segmentList1 = Arrays.asList(segment1, segment2); ScaleMetadata scaleMetadata1 = new ScaleMetadata(System.currentTimeMillis() / 2, segmentList1, 0L, 0L); Segment segment3 = new Segment(2, 0, System.currentTimeMillis(), 0.00, 0.40); Segment segment4 = new Segment(3, 0, System.currentTimeMillis(), 0.40, 1.00); List < Segment > segmentList2 = Arrays.asList(segment3, segment4); ScaleMetadata scaleMetadata2 = new ScaleMetadata(1 + System.currentTimeMillis() / 2, segmentList2, 1L, 1L); long fromDateTime = System.currentTimeMillis(); Segment segment5 = new Segment(4, 0, System.currentTimeMillis(), 0.00, 0.50); Segment segment6 = new Segment(5, 0, System.currentTimeMillis(), 0.50, 1.00); List < Segment > segmentList3 = Arrays.asList(segment5, segment6); ScaleMetadata scaleMetadata3 = new ScaleMetadata(System.currentTimeMillis(), segmentList3, 1L, 1L); Segment segment7 = new Segment(6, 0, System.currentTimeMillis(), 0.00, 0.25); Segment segment8 = new Segment(7, 0, System.currentTimeMillis(), 0.25, 1.00); List < Segment > segmentList4 = Arrays.asList(segment7, segment8); ScaleMetadata scaleMetadata4 = new ScaleMetadata(System.currentTimeMillis(), segmentList4, 1L, 1L); long toDateTime = System.currentTimeMillis(); Segment segment9 = new Segment(8, 0, System.currentTimeMillis(), 0.00, 0.40); Segment segment10 = new Segment(9, 0, System.currentTimeMillis(), 0.40, 1.00); List < Segment > segmentList5 = Arrays.asList(segment9, segment10); ScaleMetadata scaleMetadata5 = new ScaleMetadata(toDateTime * 2, segmentList5, 1L, 1L); scaleMetadataList.add(scaleMetadata5); scaleMetadataList.add(scaleMetadata4); scaleMetadataList.add(scaleMetadata3); scaleMetadataList.add(scaleMetadata2); scaleMetadataList.add(scaleMetadata1); doAnswer(x -> CompletableFuture.completedFuture(scaleMetadataList)).when(mockControllerService).getScaleRecords(anyString(), anyString(), anyLong(), anyLong()); Response response = addAuthHeaders(client.target(resourceURI).queryParam(\"from\", fromDateTime).queryParam(\"to\", toDateTime).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 200, response.getStatus()); assertTrue(response.bufferEntity()); List < ScaleMetadata > scaleMetadataListResponse = response.readEntity(new GenericType < List < ScaleMetadata > > () { }); assertEquals(\"List Size\", 3, scaleMetadataListResponse.size()); scaleMetadataListResponse.forEach(data -> { log.warn(\"Here\"); data.getSegments().forEach(segment -> { log.debug(\"Checking segment number: \" + segment.segmentId()); assertTrue(\"Event 1 shouldn't be included\", segment.segmentId() != 0L); }); }); scaleMetadataList.clear(); scaleMetadataList.addAll(Collections.nCopies(50000, scaleMetadata3)); doAnswer(x -> CompletableFuture.completedFuture(scaleMetadataList)).when(mockControllerService).getScaleRecords(anyString(), anyString(), anyLong(), anyLong()); response = addAuthHeaders(client.target(resourceURI).queryParam(\"from\", fromDateTime).queryParam(\"to\", toDateTime).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 200, response.getStatus()); assertTrue(response.bufferEntity()); scaleMetadataListResponse = response.readEntity(new GenericType < List < ScaleMetadata > > () { }); assertEquals(\"List Size\", 50000, scaleMetadataListResponse.size()); final CompletableFuture < List < ScaleMetadata > > completableFuture1 = new CompletableFuture < > (); completableFuture1.completeExceptionally(StoreException.create(StoreException.Type.DATA_NOT_FOUND, \"stream1\")); doAnswer(x -> completableFuture1).when(mockControllerService).getScaleRecords(anyString(), anyString(), anyLong(), anyLong()); response = addAuthHeaders(client.target(resourceURI).queryParam(\"from\", fromDateTime).queryParam(\"to\", toDateTime).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 404, response.getStatus()); doAnswer(x -> CompletableFuture.completedFuture(scaleMetadataList)).when(mockControllerService).getScaleRecords(anyString(), anyString(), anyLong(), anyLong()); response = addAuthHeaders(client.target(resourceURI).queryParam(\"from\", fromDateTime * 2).queryParam(\"to\", fromDateTime).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 400, response.getStatus()); final CompletableFuture < List < ScaleMetadata > > completableFuture = new CompletableFuture < > (); completableFuture.completeExceptionally(new Exception()); doAnswer(x -> completableFuture).when(mockControllerService).getScaleRecords(anyString(), anyString(), anyLong(), anyLong()); response = addAuthHeaders(client.target(resourceURI).request()).buildGet().invoke(); assertEquals(\"Get Scaling Events response code\", 500, response.getStatus()); } "
    },
    {
        "test_src": "@Test public void testOnCreateOrUpdateCommand()throws GeniePreconditionException { this.c = new CommandEntity(NAME, USER, VERSION, CommandStatus.ACTIVE, EXECUTABLE); Assert.assertNotNull(this.c.getTags()); Assert.assertTrue(this.c.getTags().isEmpty()); this.c.onCreateOrUpdateCommand(); Assert.assertEquals(2, this.c.getTags().size()); } ",
        "focal_tgt": "@PrePersist@PreUpdate protected void onCreateOrUpdateCommand()throws GenieException { this.setCommandTags(this.getFinalTags()); } ",
        "focal_src": "@PostPersist@PostUpdate protected void onCreateOrUpdateCommand()throws GeniePreconditionException { this.addAndValidateSystemTags(this.tags); } ",
        "test_tgt": "@Test public void testOnCreateOrUpdateCommand()throws GenieException { this.c = new CommandEntity(NAME, USER, VERSION, CommandStatus.ACTIVE, EXECUTABLE); Assert.assertNotNull(this.c.getTags()); Assert.assertTrue(this.c.getTags().isEmpty()); this.c.onCreateOrUpdateCommand(); Assert.assertEquals(2, this.c.getTags().size()); } "
    },
    {
        "test_src": "@Test public void testWrap_StringInt() { assertEquals(null, WordUtils.wrap(null, 20)); assertEquals(null, WordUtils.wrap(null, - 1)); assertEquals(\"\", WordUtils.wrap(\"\", 20)); assertEquals(\"\", WordUtils.wrap(\"\", - 1)); final String systemNewLine = SystemUtils.LINE_SEPARATOR; String input = \"Here is one line of text that is going to be wrapped after 20 columns.\"; String expected = \"Here is one line of\" + systemNewLine + \"text that is going\" + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"; assertEquals(expected, WordUtils.wrap(input, 20)); input = \"Click here to jump to the commons website - http://commons.apache.org\"; expected = \"Click here to jump\" + systemNewLine + \"to the commons\" + systemNewLine + \"website -\" + systemNewLine + \"http://commons.apache.org\"; assertEquals(expected, WordUtils.wrap(input, 20)); input = \"Click here, http://commons.apache.org, to jump to the commons website\"; expected = \"Click here,\" + systemNewLine + \"http://commons.apache.org,\" + systemNewLine + \"to jump to the\" + systemNewLine + \"commons website\"; assertEquals(expected, WordUtils.wrap(input, 20)); input = \"word1 word2 word3\"; expected = \"word1 \" + systemNewLine + \"word2 \" + systemNewLine + \"word3\"; assertEquals(expected, WordUtils.wrap(input, 7)); } ",
        "focal_tgt": "public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords, String wrapOn) { if(str == null) { return null; } if(newLineStr == null) { newLineStr = System.lineSeparator(); } if(wrapLength < 1) { wrapLength = 1; } if(StringUtils.isBlank(wrapOn)) { wrapOn = \" \"; } final Pattern patternToWrapOn = Pattern.compile(wrapOn); final int inputLineLength = str.length(); int offset = 0; final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); while(offset < inputLineLength) { int spaceToWrapAt = - 1; Matcher matcher = patternToWrapOn.matcher(str.substring(offset, Math.min(offset + wrapLength + 1, inputLineLength))); if(matcher.find()) { if(matcher.start() == 0) { offset += matcher.end(); continue; } else { spaceToWrapAt = matcher.start() + offset; } } if(inputLineLength - offset <= wrapLength) { break; } while(matcher.find()) { spaceToWrapAt = matcher.start() + offset; } if(spaceToWrapAt >= offset) { wrappedLine.append(str.substring(offset, spaceToWrapAt)); wrappedLine.append(newLineStr); offset = spaceToWrapAt + 1; } else { if(wrapLongWords) { wrappedLine.append(str.substring(offset, wrapLength + offset)); wrappedLine.append(newLineStr); offset += wrapLength; } else { matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength)); if(matcher.find()) { spaceToWrapAt = matcher.start() + offset + wrapLength; } if(spaceToWrapAt >= 0) { wrappedLine.append(str.substring(offset, spaceToWrapAt)); wrappedLine.append(newLineStr); offset = spaceToWrapAt + 1; } else { wrappedLine.append(str.substring(offset)); offset = inputLineLength; } } } } wrappedLine.append(str.substring(offset)); return wrappedLine.toString(); } ",
        "focal_src": "public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords, String wrapOn) { if(str == null) { return null; } if(newLineStr == null) { newLineStr = SystemUtils.LINE_SEPARATOR; } if(wrapLength < 1) { wrapLength = 1; } if(StringUtils.isBlank(wrapOn)) { wrapOn = \" \"; } final Pattern patternToWrapOn = Pattern.compile(wrapOn); final int inputLineLength = str.length(); int offset = 0; final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32); while(offset < inputLineLength) { int spaceToWrapAt = - 1; Matcher matcher = patternToWrapOn.matcher(str.substring(offset, Math.min(offset + wrapLength + 1, inputLineLength))); if(matcher.find()) { if(matcher.start() == 0) { offset += matcher.end(); continue; } else { spaceToWrapAt = matcher.start() + offset; } } if(inputLineLength - offset <= wrapLength) { break; } while(matcher.find()) { spaceToWrapAt = matcher.start() + offset; } if(spaceToWrapAt >= offset) { wrappedLine.append(str.substring(offset, spaceToWrapAt)); wrappedLine.append(newLineStr); offset = spaceToWrapAt + 1; } else { if(wrapLongWords) { wrappedLine.append(str.substring(offset, wrapLength + offset)); wrappedLine.append(newLineStr); offset += wrapLength; } else { matcher = patternToWrapOn.matcher(str.substring(offset + wrapLength)); if(matcher.find()) { spaceToWrapAt = matcher.start() + offset + wrapLength; } if(spaceToWrapAt >= 0) { wrappedLine.append(str.substring(offset, spaceToWrapAt)); wrappedLine.append(newLineStr); offset = spaceToWrapAt + 1; } else { wrappedLine.append(str.substring(offset)); offset = inputLineLength; } } } } wrappedLine.append(str.substring(offset)); return wrappedLine.toString(); } ",
        "test_tgt": "@Test public void testWrap_StringInt() { assertEquals(null, WordUtils.wrap(null, 20)); assertEquals(null, WordUtils.wrap(null, - 1)); assertEquals(\"\", WordUtils.wrap(\"\", 20)); assertEquals(\"\", WordUtils.wrap(\"\", - 1)); final String systemNewLine = System.lineSeparator(); String input = \"Here is one line of text that is going to be wrapped after 20 columns.\"; String expected = \"Here is one line of\" + systemNewLine + \"text that is going\" + systemNewLine + \"to be wrapped after\" + systemNewLine + \"20 columns.\"; assertEquals(expected, WordUtils.wrap(input, 20)); input = \"Click here to jump to the commons website - http://commons.apache.org\"; expected = \"Click here to jump\" + systemNewLine + \"to the commons\" + systemNewLine + \"website -\" + systemNewLine + \"http://commons.apache.org\"; assertEquals(expected, WordUtils.wrap(input, 20)); input = \"Click here, http://commons.apache.org, to jump to the commons website\"; expected = \"Click here,\" + systemNewLine + \"http://commons.apache.org,\" + systemNewLine + \"to jump to the\" + systemNewLine + \"commons website\"; assertEquals(expected, WordUtils.wrap(input, 20)); input = \"word1 word2 word3\"; expected = \"word1 \" + systemNewLine + \"word2 \" + systemNewLine + \"word3\"; assertEquals(expected, WordUtils.wrap(input, 7)); } "
    },
    {
        "test_src": "@Test public void hash() { query(_HASH_HASH.args(\"\", \"MD5\"), \"1B2M2Y8AsgTpgAmY7PhCfg==\"); query(_HASH_HASH.args(\"\", \"md5\"), \"1B2M2Y8AsgTpgAmY7PhCfg==\"); query(_HASH_HASH.args(\"\", \"SHA\"), \"2jmj7l5rSw0yVb/vlWAYkK/YBwk=\"); query(_HASH_HASH.args(\"\", \"SHA1\"), \"2jmj7l5rSw0yVb/vlWAYkK/YBwk=\"); query(_HASH_HASH.args(\"\", \"SHA-1\"), \"2jmj7l5rSw0yVb/vlWAYkK/YBwk=\"); query(_HASH_HASH.args(\"\", \"SHA-256\"), \"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\"); query(_HASH_HASH.args(\"xs:base64Binary('')\", \"md5\"), \"1B2M2Y8AsgTpgAmY7PhCfg==\"); error(_HASH_HASH.args(\"xs:hexBinary('')\", \"md5\"), Err.STRB64TYPE); error(_HASH_HASH.args(\"\", \"\"), Err.HASH_ALG); } ",
        "focal_tgt": "private B64 hash(final String algo, final QueryContext ctx)throws QueryException { return hashBinary(checkStrBin(checkItem(expr[0], ctx)), algo); } ",
        "focal_src": "private B64 hash(final String algo, final QueryContext ctx)throws QueryException { final Item it = checkItem(expr[0], ctx); final byte[]val; if(it instanceof AStr) { val = it.string(info); } else if(it instanceof B64) { val = ((B64)it).binary(info); } else { throw STRB64TYPE.thrw(info, it.type); } return hashBinary(val, algo); } ",
        "test_tgt": "@Test public void hash() { query(_HASH_HASH.args(\"\", \"MD5\"), \"1B2M2Y8AsgTpgAmY7PhCfg==\"); query(_HASH_HASH.args(\"\", \"md5\"), \"1B2M2Y8AsgTpgAmY7PhCfg==\"); query(_HASH_HASH.args(\"\", \"SHA\"), \"2jmj7l5rSw0yVb/vlWAYkK/YBwk=\"); query(_HASH_HASH.args(\"\", \"SHA1\"), \"2jmj7l5rSw0yVb/vlWAYkK/YBwk=\"); query(_HASH_HASH.args(\"\", \"SHA-1\"), \"2jmj7l5rSw0yVb/vlWAYkK/YBwk=\"); query(_HASH_HASH.args(\"\", \"SHA-256\"), \"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=\"); query(_HASH_HASH.args(\"xs:base64Binary('')\", \"md5\"), \"1B2M2Y8AsgTpgAmY7PhCfg==\"); query(_HASH_HASH.args(\"xs:hexBinary('')\", \"md5\"), \"1B2M2Y8AsgTpgAmY7PhCfg==\"); error(_HASH_HASH.args(\"\", \"\"), Err.HASH_ALG); } "
    },
    {
        "test_src": "@Test public void testGetUserDetail() { ModelMap model = new ModelMap(); userController.getUserDetail(getTestUser(), model, getTestUser().getUserId()); User user = (User)model.get(\"user\"); assertThat(user.getId(), is(getTestUser().getId())); } ",
        "focal_tgt": "@RequestMapping(\"/new\")@PreAuthorize(\"hasAnyRole('A') or #user.userId == #userId\")public String openForm(User user, final ModelMap model) { model.addAttribute(\"roleSet\", EnumSet.allOf(Role.class)); return \"user/detail\"; } ",
        "focal_src": "@RequestMapping(\"/new\")@PreAuthorize(\"hasAnyRole('A') or #user.userId == #userId\")public String getUserDetail(User user, final ModelMap model) { model.addAttribute(\"roleSet\", EnumSet.allOf(Role.class)); return \"user/detail\"; } ",
        "test_tgt": "@Test public void testGetUserDetail() { ModelMap model = new ModelMap(); userController.getOne(getTestUser(), model, getTestUser().getUserId()); User user = (User)model.get(\"user\"); assertThat(user.getId(), is(getTestUser().getId())); } "
    },
    {
        "test_src": "@Test public void testGetNextTimeoutIntervalMs()throws Exception { Runnable r = new Runnable() { @Override public void run() { slaveLooper.exitLoop(); globalValue = 10; } }; long intervalNs = 6L * 1000 * 1000 * 1000; slaveLooper.registerTimerEventInNanoSeconds(intervalNs, r); long res = 1000; try { Method method = slaveLooper.getClass().getSuperclass().getDeclaredMethod(\"getNextTimeoutIntervalMs\"); method.setAccessible(true); res = (Long)method.invoke(slaveLooper) * 1000 * 1000; } catch(NoSuchMethodException e) { e.printStackTrace(); } catch(IllegalAccessException e) { e.printStackTrace(); } catch(InvocationTargetException e) { e.printStackTrace(); } Assert.assertNotNull(res); Assert.assertTrue(res <= intervalNs && res > intervalNs / 2); } ",
        "focal_tgt": "protected Duration getNextTimeoutInterval() { Duration nextTimeoutInterval = INFINITE_FUTURE; if( ! timers.isEmpty()) { nextTimeoutInterval = timers.peek().expirationTime.minusNanos(System.nanoTime()); } return nextTimeoutInterval; } ",
        "focal_src": "protected long getNextTimeoutIntervalMs() { long nextTimeoutIntervalMs = INFINITE_FUTURE; if( ! timers.isEmpty()) { nextTimeoutIntervalMs = (timers.peek().getExpirationNs() - System.nanoTime() + Constants.MILLISECONDS_TO_NANOSECONDS) / Constants.MILLISECONDS_TO_NANOSECONDS; } return nextTimeoutIntervalMs; } ",
        "test_tgt": "@Test public void testGetNextTimeoutIntervalMs()throws Exception { Runnable r = new Runnable() { @Override public void run() { slaveLooper.exitLoop(); globalValue = 10; } }; Duration interval = Duration.ofSeconds(6); slaveLooper.registerTimerEvent(interval, r); Duration res = Duration.ofNanos(1000); try { Method method = slaveLooper.getClass().getSuperclass().getDeclaredMethod(\"getNextTimeoutInterval\"); method.setAccessible(true); res = (Duration)method.invoke(slaveLooper); } catch(NoSuchMethodException e) { e.printStackTrace(); } catch(IllegalAccessException e) { e.printStackTrace(); } catch(InvocationTargetException e) { e.printStackTrace(); } Assert.assertNotNull(res); Assert.assertTrue(res.compareTo(interval) <= 0 && res.compareTo(interval.dividedBy(2)) > 0); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should return true if given middle and family name are equal\", method = \"equalsContent(PersonName)\")public void equalsContent_shouldReturnTrueIfGivenMiddleAndFamilyNameAreEqual()throws Exception { PersonName pn = new PersonName(1); pn.setGivenName(\"Adam\"); pn.setMiddleName(\"Alex\"); pn.setFamilyName(\"Jones\"); PersonName other = new PersonName(2); other.setGivenName(\"Adam\"); other.setMiddleName(\"Alex\"); other.setFamilyName(\"Jones\"); Assert.assertTrue(pn.equalsContent(other)); } ",
        "focal_tgt": "@SuppressWarnings(\"unchecked\")public boolean equalsContent(PersonAddress otherAddress) { return new EqualsBuilder().append(defaultString(otherAddress.getAddress1()), defaultString(address1)).append(defaultString(otherAddress.getAddress2()), defaultString(address2)).append(defaultString(otherAddress.getAddress3()), defaultString(address3)).append(defaultString(otherAddress.getAddress4()), defaultString(address4)).append(defaultString(otherAddress.getAddress5()), defaultString(address5)).append(defaultString(otherAddress.getAddress6()), defaultString(address6)).append(defaultString(otherAddress.getCityVillage()), defaultString(cityVillage)).append(defaultString(otherAddress.getCountyDistrict()), defaultString(countyDistrict)).append(defaultString(otherAddress.getStateProvince()), defaultString(stateProvince)).append(defaultString(otherAddress.getCountry()), defaultString(country)).append(defaultString(otherAddress.getPostalCode()), defaultString(postalCode)).append(defaultString(otherAddress.getLatitude()), defaultString(latitude)).append(defaultString(otherAddress.getLongitude()), defaultString(longitude)).append(otherAddress.getStartDate(), startDate).append(otherAddress.getEndDate(), endDate).isEquals(); } ",
        "focal_src": "@SuppressWarnings(\"unchecked\")public boolean equalsContent(PersonAddress otherAddress) { boolean returnValue = true; String[]methods = { \"getAddress1\", \"getAddress2\", \"getAddress3\", \"getAddress4\", \"getAddress5\", \"getAddress6\", \"getCityVillage\", \"getCountyDistrict\", \"getStateProvince\", \"getCountry\", \"getPostalCode\", \"getLatitude\", \"getLongitude\" }; Class addressClass = this.getClass(); for(String methodName : methods) { try { Method method = addressClass.getMethod(methodName, new Class[] { }); String thisValue = (String)method.invoke(this); String otherValue = (String)method.invoke(otherAddress); if(otherValue != null && otherValue.length() > 0)returnValue &= otherValue.equals(thisValue); } catch(NoSuchMethodException e) { log.warn(\"No such method for comparison \" + methodName, e); } catch(IllegalAccessException e) { log.error(\"Error while comparing addresses\", e); } catch(InvocationTargetException e) { log.error(\"Error while comparing addresses\", e); } } return returnValue; } ",
        "test_tgt": "@Test@Verifies(value = \"should return false if family name 2 is not equal\", method = \"equalsContent(PersonName)\")public void equalsContent_shouldReturnFalseIfFamilyName2IsNotEqual()throws Exception { PersonName name1 = new PersonName(1); PersonName name2 = new PersonName(2); name1.setFamilyName2(\"van der\"); name2.setFamilyName2(\"de\"); assertThat(name1.equalsContent(name2), is(false)); } "
    },
    {
        "test_src": "@Test public void testSendMessages() { List < ProtocolMessage > protocolMessages = new LinkedList < > (); protocolMessages.add(message); executor.sendMessages(protocolMessages); byte[]sendByte = ((FakeTransportHandler)context.getTransportHandler()).getSendByte(); LOGGER.info(ArrayConverter.bytesToHexString(sendByte)); assertArrayEquals(sendByte, new byte[] { 21, 03, 03, 00, 02, 02, 51 }); } ",
        "focal_tgt": "@Override public List < ProtocolMessage > sendMessages(List < ProtocolMessage > messages) { if( ! proceed) { return null; } MessageBytesCollector messageBytesCollector = new MessageBytesCollector(); for(ProtocolMessage message : messages) { LOGGER.debug(\"Preparing \" + message.toCompactString()); byte[]protocolMessageBytes = prepareProtocolMessageBytes(message); if(message.isGoingToBeSent()) { messageBytesCollector.appendProtocolMessageBytes(protocolMessageBytes); } if(message.getRecords() != null && ! message.getRecords().isEmpty()) { byte[]recordBytes = prepareRecords(message, messageBytesCollector); messageBytesCollector.appendRecordBytes(recordBytes); messageBytesCollector.flushProtocolMessageBytes(); } } try { LOGGER.debug(\"Sending \" + ArrayConverter.bytesToHexString(messageBytesCollector.getRecordBytes())); sendData(context.getTransportHandler(), messageBytesCollector); } catch(IOException ex) { ex.printStackTrace(); } return messages; } ",
        "focal_src": "@Override public List < ProtocolMessage > sendMessages(List < ProtocolMessage > messages) { MessageBytesCollector messageBytesCollector = new MessageBytesCollector(); for(ProtocolMessage message : messages) { LOGGER.debug(\"Preparing \" + message.toCompactString()); byte[]protocolMessageBytes = prepareProtocolMessageBytes(message); if(message.isGoingToBeSent()) { messageBytesCollector.appendProtocolMessageBytes(protocolMessageBytes); } if(message.getRecords() != null && ! message.getRecords().isEmpty()) { byte[]recordBytes = prepareRecords(message, messageBytesCollector); messageBytesCollector.appendRecordBytes(recordBytes); messageBytesCollector.flushProtocolMessageBytes(); } } try { LOGGER.debug(\"Sending \" + ArrayConverter.bytesToHexString(messageBytesCollector.getRecordBytes())); sendData(context.getTransportHandler(), messageBytesCollector); } catch(IOException ex) { ex.printStackTrace(); } return messages; } ",
        "test_tgt": "@Test public void testSendMessages() { List < ProtocolMessage > protocolMessages = new LinkedList < > (); protocolMessages.add(message); executor.sendMessages(protocolMessages); byte[]sendByte = ((FakeTransportHandler)context.getTransportHandler()).getSendByte(); LOGGER.info(ArrayConverter.bytesToHexString(sendByte)); assertArrayEquals(new byte[] { 21, 03, 03, 00, 02, 02, 51 }, sendByte); } "
    },
    {
        "test_src": "@Test public void testToHumanizationDateString() { LOGGER.debug(DateExtensionUtil.toHumanizationDateString(DateUtil.string2Date(\"2012-10-18 13:55:00\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toHumanizationDateString(DateUtil.string2Date(\"2012-10-18 14:14:22\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toHumanizationDateString(DateUtil.string2Date(\"2012-10-18 14:15:22\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toHumanizationDateString(DateUtil.string2Date(\"2012-10-17 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toHumanizationDateString(DateUtil.string2Date(\"2012-10-16 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toHumanizationDateString(DateUtil.string2Date(\"2012-10-15 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toHumanizationDateString(DateUtil.string2Date(\"2012-09-15 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toHumanizationDateString(DateUtil.string2Date(\"2011-09-15 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toHumanizationDateString(DateUtil.string2Date(\"2015-7-30 13:00:00\", DatePattern.COMMON_DATE_AND_TIME))); } ",
        "focal_tgt": "public static String toPrettyDateString(Date inDate) { Date nowDate = new Date(); int inYear = DateUtil.getYear(inDate); int currentYear = DateUtil.getYear(nowDate); boolean isSameYear = currentYear == inYear; long spaceTime = DateUtil.getIntervalTime(inDate, nowDate); int spaceDay = DateUtil.getIntervalDay(spaceTime); switch(spaceDay) { case 0 : return doWithZeroDayInterval(inDate, nowDate, spaceTime); case 1 : return doWithOneDayInterval(inDate, nowDate); case 2 : return doWithTwoDaysInterval(inDate, nowDate, isSameYear); default : if(isSameYear) { return DateUtil.date2String(inDate, DatePattern.COMMON_DATE_AND_TIME_WITHOUT_YEAR_AND_SECOND); } return DateUtil.date2String(inDate, DatePattern.COMMON_DATE_AND_TIME_WITHOUT_SECOND); } } ",
        "focal_src": "@Deprecated public static String toHumanizationDateString(Date inDate) { Date nowDate = new Date(); int inYear = DateUtil.getYear(inDate); int currentYear = DateUtil.getYear(nowDate); boolean isSameYear = currentYear == inYear; long spaceTime = DateUtil.getIntervalTime(inDate, nowDate); int spaceDay = DateUtil.getIntervalDay(spaceTime); switch(spaceDay) { case 0 : return doWithZeroDayInterval(inDate, nowDate, spaceTime); case 1 : return doWithOneDayInterval(inDate, nowDate); case 2 : return doWithTwoDaysInterval(inDate, nowDate, isSameYear); default : if(isSameYear) { return DateUtil.date2String(inDate, DatePattern.COMMON_DATE_AND_TIME_WITHOUT_YEAR_AND_SECOND); } return DateUtil.date2String(inDate, DatePattern.COMMON_DATE_AND_TIME_WITHOUT_SECOND); } } ",
        "test_tgt": "@Test public void testToPrettyDateString() { LOGGER.debug(DateExtensionUtil.toPrettyDateString(DateUtil.string2Date(\"2012-10-18 13:55:00\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toPrettyDateString(DateUtil.string2Date(\"2012-10-18 14:14:22\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toPrettyDateString(DateUtil.string2Date(\"2012-10-18 14:15:22\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toPrettyDateString(DateUtil.string2Date(\"2012-10-17 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toPrettyDateString(DateUtil.string2Date(\"2012-10-16 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toPrettyDateString(DateUtil.string2Date(\"2012-10-15 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toPrettyDateString(DateUtil.string2Date(\"2012-09-15 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toPrettyDateString(DateUtil.string2Date(\"2015-08-02 14:15:02\", DatePattern.COMMON_DATE_AND_TIME))); LOGGER.debug(DateExtensionUtil.toPrettyDateString(DateUtil.string2Date(\"2015-7-30 13:00:00\", DatePattern.COMMON_DATE_AND_TIME))); } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void test_query_chrono() { assertEquals(TEST_2007_07_15_PONE.query(Query.CHRONO), ISOChrono.INSTANCE); } ",
        "focal_tgt": " < R > R query(TemporalQuery < R > query); ",
        "focal_src": " < R > R query(Query < R > query); ",
        "test_tgt": "@Test(groups = { \"tck\" })public void test_query_chrono() { assertEquals(TEST_2007_07_15_PONE.query(TemporalQuery.CHRONO), ISOChrono.INSTANCE); } "
    },
    {
        "test_src": "@Test(testName = \"PUT /vApp/{id}\", dependsOnMethods = { \"testGetVApp\" })public void testModifyVApp() { vApp.setName(\"new-name\"); vApp.setDescription(\"New Description\"); Task modifyVApp = vAppClient.modifyVApp(vApp.getHref(), vApp); assertTrue(retryTaskSuccess.apply(modifyVApp), String.format(TASK_COMPLETE_TIMELY, \"modifyVApp\")); vApp = vAppClient.getVApp(vApp.getHref()); assertEquals(vApp.getName(), \"new-name\", String.format(OBJ_FIELD_EQ, VAPP, \"name\", \"new-name\", \"modified\")); assertEquals(vApp.getDescription(), \"New Description\", String.format(OBJ_FIELD_EQ, VAPP, \"description\", \"New Description\", \"modified\")); } ",
        "focal_tgt": "@PUT@Produces(VAPP)@Consumes(TASK)@JAXBResponseParser@ExceptionParser(ThrowVCloudErrorOn4xx.class)ListenableFuture < Task > modifyVApp(@EndpointParam URI vAppURI, @BinderParam(BindToXMLPayload.class)VApp vApp); ",
        "focal_src": "@PUT@Produces(VCloudDirectorMediaType.VAPP)@Consumes(VCloudDirectorMediaType.TASK)@JAXBResponseParser@ExceptionParser(ThrowVCloudErrorOn4xx.class)ListenableFuture < Task > modifyVApp(@EndpointParam URI vAppURI, @BinderParam(BindToXMLPayload.class)VApp vApp); ",
        "test_tgt": "@Test(testName = \"PUT /vApp/{id}\", dependsOnMethods = { \"testGetVApp\" })public void testModifyVApp() { VApp newVApp = VApp.builder().name(\"new-name\").description(\"New Description\").build(); Task modifyVApp = vAppClient.modifyVApp(vApp.getHref(), newVApp); assertTrue(retryTaskSuccess.apply(modifyVApp), String.format(TASK_COMPLETE_TIMELY, \"modifyVApp\")); vApp = vAppClient.getVApp(vApp.getHref()); assertEquals(vApp.getName(), newVApp.getName(), String.format(OBJ_FIELD_EQ, VAPP, \"Name\", newVApp.getName(), vApp.getName())); assertEquals(vApp.getDescription(), newVApp.getDescription(), String.format(OBJ_FIELD_EQ, VAPP, \"Description\", newVApp.getDescription(), vApp.getDescription())); } "
    },
    {
        "test_src": "@Test public void testGetDocumentRelationScores() { List < Concept > concepts = new ArrayList < Concept > (); concepts.add(EXAMPLE_CONCEPT); Scores scores = service.getDocumentRelationScores(EXAMPLE_DOCUMENT, concepts); Assert.assertNotNull(scores); } ",
        "focal_tgt": "public Scores getDocumentRelationScores(final Document document, final List < Concept > concepts) { final String documentId = IDHelper.getDocumentId(document); Validate.notEmpty(concepts, \"concepts cannot be empty\"); final Map < String, Object > queryParams = new HashMap < String, Object > (); final JsonObject contentJson = new JsonObject(); final JsonArray conceptsJson = new JsonArray(); for(final Concept con : concepts) { conceptsJson.add(new JsonPrimitive(con.getId())); } contentJson.add(CONCEPTS, conceptsJson); queryParams.put(CONCEPTS, conceptsJson.toString()); return executeRequest(API_VERSION + documentId + RELATION_SCORES_PATH, queryParams, Scores.class); } ",
        "focal_src": "public Scores getDocumentRelationScores(final Document document, final List < Concept > concepts) { String documentId = IDHelper.getDocumentId(document); Validate.notEmpty(concepts, \"concepts cannot be empty\"); Map < String, Object > queryParams = new HashMap < String, Object > (); JsonObject contentJson = new JsonObject(); JsonArray conceptsJson = new JsonArray(); for(Concept con : concepts) { conceptsJson.add(new JsonPrimitive(con.getId())); } contentJson.add(CONCEPTS, conceptsJson); queryParams.put(CONCEPTS, conceptsJson.toString()); return executeRequest(API_VERSION + documentId + RELATION_SCORES_PATH, queryParams, Scores.class); } ",
        "test_tgt": "@Test public void testGetDocumentRelationScores() { final List < Concept > concepts = new ArrayList < Concept > (); concepts.add(EXAMPLE_CONCEPT); final Scores scores = service.getDocumentRelationScores(EXAMPLE_DOCUMENT, concepts); Assert.assertNotNull(scores); } "
    },
    {
        "test_src": "@Test public void testUpdateJobStatus()throws GenieException { final String id = UUID.randomUUID().toString(); final JobEntity jobEntity = new JobEntity(); final ArgumentCaptor < JobEntity > argument = ArgumentCaptor.forClass(JobEntity.class); Mockito.when(this.jobRepo.findOne(Mockito.eq(id))).thenReturn(jobEntity); this.jobPersistenceService.updateJobStatus(id, JobStatus.RUNNING, JOB_1_STATUS_MSG); Mockito.verify(jobRepo).save(argument.capture()); Assert.assertEquals(JobStatus.RUNNING, argument.getValue().getStatus()); Assert.assertEquals(JOB_1_STATUS_MSG, argument.getValue().getStatusMsg()); Assert.assertEquals(new Date(0), argument.getValue().getFinished()); } ",
        "focal_tgt": "@Override public void updateJobStatus(@NotBlank(message = \"No job id entered. Unable to update.\")final String id, @NotNull(message = \"Status cannot be null.\")final JobStatus jobStatus, @NotBlank(message = \"Status message cannot be empty.\")final String statusMsg)throws GenieException { log.debug(\"Called to update job with id {}, status {} and statusMsg \\\"{}\\\"\", id, jobStatus, statusMsg); final JobEntity jobEntity = this.jobRepo.findOne(id); if(jobEntity == null) { throw new GenieNotFoundException(\"No job exists for the id specified\"); } jobEntity.setStatus(jobStatus); jobEntity.setStatusMsg(statusMsg); if(jobStatus.equals(JobStatus.RUNNING)) { jobEntity.setStarted(new Date()); } else if(jobEntity.getStarted() != null && (jobStatus.equals(JobStatus.KILLED) || jobStatus.equals(JobStatus.FAILED) || jobStatus.equals(JobStatus.SUCCEEDED))) { jobEntity.setFinished(new Date()); } this.jobRepo.save(jobEntity); } ",
        "focal_src": "@Override public void updateJobStatus(@NotBlank(message = \"No job id entered. Unable to update.\")final String id, @NotNull(message = \"Status cannot be null.\")final JobStatus jobStatus, @NotBlank(message = \"Status message cannot be empty.\")final String statusMsg)throws GenieException { log.debug(\"Called to update job with id {}, status {} and statusMsg \\\"{}\\\"\", id, jobStatus, statusMsg); final JobEntity jobEntity = this.jobRepo.findOne(id); if(jobEntity == null) { throw new GenieNotFoundException(\"No job exists for the id specified\"); } jobEntity.setStatus(jobStatus); jobEntity.setStatusMsg(statusMsg); if(jobStatus.equals(JobStatus.KILLED) || jobStatus.equals(JobStatus.FAILED) || jobStatus.equals(JobStatus.SUCCEEDED)) { jobEntity.setFinished(new Date()); } this.jobRepo.save(jobEntity); } ",
        "test_tgt": "@Test public void testUpdateJobStatusForStatusRunning()throws GenieException { final String id = UUID.randomUUID().toString(); final JobEntity jobEntity = new JobEntity(); final ArgumentCaptor < JobEntity > argument = ArgumentCaptor.forClass(JobEntity.class); Mockito.when(this.jobRepo.findOne(Mockito.eq(id))).thenReturn(jobEntity); this.jobPersistenceService.updateJobStatus(id, JobStatus.RUNNING, JOB_1_STATUS_MSG); Mockito.verify(jobRepo).save(argument.capture()); Assert.assertEquals(JobStatus.RUNNING, argument.getValue().getStatus()); Assert.assertEquals(JOB_1_STATUS_MSG, argument.getValue().getStatusMsg()); Assert.assertEquals(new Date(0), argument.getValue().getFinished()); Assert.assertNotNull(argument.getValue().getStarted()); } "
    },
    {
        "test_src": "@Test(expectedExceptions = NullPointerException.class, groups = { \"tck\" })public void test_with_null_adjustDate() { TEST_2007_07_15_12_30_40_987654321.with(new MockDateAdjusterReturnsNull()); } ",
        "focal_tgt": "@Override public LocalTime with(CalendricalAdjuster adjuster) { if(adjuster instanceof TimeAdjuster) { return((TimeAdjuster)adjuster).adjustTime(this); } else if(adjuster instanceof LocalTime) { return((LocalTime)adjuster); } DateTimes.checkNotNull(adjuster, \"Adjuster must not be null\"); throw new CalendricalException(\"Unable to adjust LocalTime with \" + adjuster.getClass().getSimpleName()); } ",
        "focal_src": "public LocalTime with(TimeAdjuster adjuster) { LocalTime time = adjuster.adjustTime(this); if(time == null) { throw new NullPointerException(\"TimeAdjuster implementation must not return null\"); } return time; } ",
        "test_tgt": "@Test(expectedExceptions = NullPointerException.class, groups = { \"tck\" })public void test_with_null() { TEST_2007_07_15_12_30_40_987654321.with(null); } "
    },
    {
        "test_src": "@Test public void testRelease()throws Exception { LongStateStorage longStateStorage = new LongStateStorage(); ZooKeeperStateHandleStore < Long > zkStore = new ZooKeeperStateHandleStore < > (ZOOKEEPER.getClient(), longStateStorage); final String path = \"/state\"; zkStore.addAndLock(path, 42L); final String lockPath = zkStore.getLockPath(path); Stat stat = ZOOKEEPER.getClient().checkExists().forPath(lockPath); assertNotNull(\"Expected an existing lock\", stat); zkStore.release(path); stat = ZOOKEEPER.getClient().checkExists().forPath(path); assertEquals(\"Expected no lock nodes as children\", 0, stat.getNumChildren()); zkStore.releaseAndTryRemove(path); stat = ZOOKEEPER.getClient().checkExists().forPath(path); assertNull(\"State node should have been removed.\", stat); } ",
        "focal_tgt": "public void release(Throwable cause) { if(isReleased.compareAndSet(false, true)) { LOG.debug(\"{}: Releasing {}.\", owningTaskName, this); if(cause != null) { this.cause = cause; } releaseInternal(); } } ",
        "focal_src": "public void release(Throwable cause) { if(isReleased.compareAndSet(false, true)) { LOG.debug(\"{}: Releasing {}.\", owningTaskName, this); if(cause != null) { this.cause = cause; } for(ResultSubpartition subpartition : subpartitions) { try { subpartition.release(); } catch(Throwable t) { LOG.error(\"Error during release of result subpartition: \" + t.getMessage(), t); } } } } ",
        "test_tgt": "@Test public void testRelease()throws Exception { LongStateStorage longStateStorage = new LongStateStorage(); ZooKeeperStateHandleStore < Long > zkStore = new ZooKeeperStateHandleStore < > (ZOOKEEPER.getClient(), longStateStorage, Executors.directExecutor()); final String path = \"/state\"; zkStore.addAndLock(path, 42L); final String lockPath = zkStore.getLockPath(path); Stat stat = ZOOKEEPER.getClient().checkExists().forPath(lockPath); assertNotNull(\"Expected an existing lock\", stat); zkStore.release(path); stat = ZOOKEEPER.getClient().checkExists().forPath(path); assertEquals(\"Expected no lock nodes as children\", 0, stat.getNumChildren()); zkStore.releaseAndTryRemove(path); stat = ZOOKEEPER.getClient().checkExists().forPath(path); assertNull(\"State node should have been removed.\", stat); } "
    },
    {
        "test_src": "@Test public void testReproject()throws NoSuchAuthorityCodeException, FactoryException { GridCoverage2D coverage_ = project(ushortCoverage, CRS.parseWKT(GOOGLE_MERCATOR_WKT), null, \"nearest\", null, true); coverage_ = (GridCoverage2D)Operations.DEFAULT.extrema(coverage_); Object minimums = coverage_.getProperty(Extrema.GT_SYNTHETIC_PROPERTY_MINIMUM); Assert.assertTrue(minimums instanceof double[]); final double[]mins = (double[])minimums; Object maximums = coverage_.getProperty(Extrema.GT_SYNTHETIC_PROPERTY_MAXIMUM); Assert.assertTrue(maximums instanceof double[]); final double[]max = (double[])maximums; boolean fail = true; for(int i = 0; i < mins.length; i ++ )if(mins[i] != max[i] && max[i] > 0)fail = false; Assert.assertFalse(\"Reprojection failed\", fail); try { assertEquals(\"Warp\", showProjected(coverage, CRS.parseWKT(GOOGLE_MERCATOR_WKT), coverage.getGridGeometry(), null, true)); Assert.assertTrue(\"We should not be allowed to set different crs for target crs and target gg\", false); } catch(Exception e) { } } ",
        "focal_tgt": "public static GridCoverage2D reproject(GridCoverage2D sourceCoverage, CoordinateReferenceSystem targetCRS, GridGeometry2D targetGG, Interpolation interpolation, final Hints hints, final double[]backgroundValues)throws FactoryException, TransformException { Utilities.ensureNonNull(\"sourceCoverage\", sourceCoverage); final CoordinateReferenceSystem sourceCRS = sourceCoverage.getCoordinateReferenceSystem(); if(targetCRS == null) { if(targetGG != null && targetGG.isDefined(GridGeometry2D.CRS_BITMASK)) { targetCRS = targetGG.getCoordinateReferenceSystem(); } else { targetCRS = sourceCRS; } } else { if(targetGG != null && targetGG.isDefined(GridGeometry2D.CRS_BITMASK)) { final CoordinateReferenceSystem targetGGCRS = targetGG.getCoordinateReferenceSystem(); if( ! CRS.equalsIgnoreMetadata(targetCRS, targetGGCRS) && ! CRS.findMathTransform(targetCRS, targetGGCRS).isIdentity()) { throw new IllegalArgumentException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1, \"TargetCRS must be compatible with TargetGG CRS\")); } } } if(interpolation == null) { if(hints != null) { if(hints.containsKey(JAI.KEY_INTERPOLATION))interpolation = (Interpolation)hints.get(JAI.KEY_INTERPOLATION); } } else { hints.put(JAI.KEY_INTERPOLATION, interpolation); } if( ! hints.containsKey(JAI.KEY_BORDER_EXTENDER)) { hints.put(JAI.KEY_BORDER_EXTENDER, BorderExtender.createInstance(BorderExtender.BORDER_COPY)); } final boolean automaticGG, automaticGR; if(targetGG == null) { automaticGG = true; automaticGR = true; } else { automaticGR = ! targetGG.isDefined(GridGeometry2D.GRID_RANGE_BITMASK); if( ! automaticGR || targetGG.isDefined(GridGeometry2D.GRID_TO_CRS_BITMASK)) { automaticGG = false; } else { if(targetGG.isDefined(GridGeometry2D.ENVELOPE_BITMASK)) { final Envelope envelope = targetGG.getEnvelope(); final GridGeometry2D sourceGG = sourceCoverage.getGridGeometry(); final MathTransform gridToCRS; switch(envelope.getDimension()) { case 2 : gridToCRS = sourceGG.getGridToCRS2D(CORNER); break; default : gridToCRS = sourceGG.getGridToCRS(CORNER); break; } targetGG = new GridGeometry2D(PixelInCell.CELL_CENTER, gridToCRS, envelope, null); automaticGG = false; } else { targetGG = null; automaticGG = true; } } } GridCoverage2D targetCoverage = existingCoverage(sourceCoverage, targetCRS, targetGG); if(targetCoverage != null) { return targetCoverage; } final GridGeometry2D sourceGG = sourceCoverage.getGridGeometry(); final CoordinateReferenceSystem compatibleSourceCRS = compatibleSourceCRS(sourceCoverage.getCoordinateReferenceSystem2D(), sourceCRS, targetCRS); final ViewType processingView = CoverageUtilities.preferredViewForOperation(sourceCoverage, interpolation, false, hints); final ViewType finalView = CoverageUtilities.preferredViewAfterOperation(sourceCoverage); sourceCoverage = sourceCoverage.view(processingView); PlanarImage sourceImage = PlanarImage.wrapRenderedImage(sourceCoverage.getRenderedImage()); assert sourceCoverage.getCoordinateReferenceSystem() == sourceCRS : sourceCoverage; final CoordinateOperationFactory factory = ReferencingFactoryFinder.getCoordinateOperationFactory(hints); final MathTransformFactory mtFactory; if(factory instanceof AbstractCoordinateOperationFactory) { mtFactory = ((AbstractCoordinateOperationFactory)factory).getMathTransformFactory(); } else { mtFactory = ReferencingFactoryFinder.getMathTransformFactory(hints); } final MathTransform step1, step2, step3, allSteps, allSteps2D; if(CRS.equalsIgnoreMetadata(sourceCRS, targetCRS)) { if( ! targetGG.isDefined(GridGeometry2D.GRID_TO_CRS_BITMASK)) { step1 = sourceGG.getGridToCRS(CORNER); step2 = IdentityTransform.create(step1.getTargetDimensions()); step3 = step1.inverse(); allSteps = IdentityTransform.create(step1.getSourceDimensions()); targetGG = new GridGeometry2D(targetGG.getGridRange(), step1, targetCRS); } else { step1 = targetGG.getGridToCRS(CORNER); step2 = IdentityTransform.create(step1.getTargetDimensions()); step3 = sourceGG.getGridToCRS(CORNER).inverse(); allSteps = mtFactory.createConcatenatedTransform(step1, step3); if( ! targetGG.isDefined(GridGeometry2D.GRID_RANGE_BITMASK)) { Envelope gridRange; gridRange = toEnvelope(sourceGG.getGridRange()); gridRange = CRS.transform(allSteps.inverse(), gridRange); targetGG = new GridGeometry2D(new GeneralGridEnvelope(gridRange, PixelInCell.CELL_CORNER), targetGG.getGridToCRS(PixelInCell.CELL_CENTER), targetCRS); } } } else { if(sourceCRS == null) { throw new CannotReprojectException(Errors.format(ErrorKeys.UNSPECIFIED_CRS)); } final Envelope sourceEnvelope; final GeneralEnvelope targetEnvelope; final CoordinateOperation operation = factory.createOperation(sourceCRS, targetCRS); final boolean force2D = (sourceCRS != compatibleSourceCRS); step2 = factory.createOperation(targetCRS, compatibleSourceCRS).getMathTransform(); step3 = (force2D ? sourceGG.getGridToCRS2D(CORNER) : sourceGG.getGridToCRS(CORNER)).inverse(); sourceEnvelope = sourceCoverage.getEnvelope(); targetEnvelope = CRS.transform(operation, sourceEnvelope); targetEnvelope.setCoordinateReferenceSystem(targetCRS); if(targetGG == null) { final GridEnvelope targetGR; targetGR = force2D ? new GridEnvelope2D(sourceGG.getGridRange2D()) : sourceGG.getGridRange(); targetGG = new GridGeometry2D(targetGR, targetEnvelope); step1 = targetGG.getGridToCRS(CORNER); } else if( ! targetGG.isDefined(GridGeometry2D.GRID_TO_CRS_BITMASK)) { targetGG = new GridGeometry2D(targetGG.getGridRange(), targetEnvelope); step1 = targetGG.getGridToCRS(CORNER); } else { step1 = targetGG.getGridToCRS(CORNER); if( ! targetGG.isDefined(GridGeometry2D.GRID_RANGE_BITMASK)) { GeneralEnvelope gridRange = CRS.transform(step1.inverse(), targetEnvelope); targetGG = new GridGeometry2D(new GeneralGridEnvelope(gridRange, PixelInCell.CELL_CENTER), step1, targetCRS); } } allSteps = mtFactory.createConcatenatedTransform(mtFactory.createConcatenatedTransform(step1, step2), step3); } allSteps2D = toMathTransform2D(allSteps, mtFactory, targetGG); if( ! (allSteps2D instanceof MathTransform2D)) { throw new TransformException(Errors.format(ErrorKeys.NO_TRANSFORM2D_AVAILABLE)); } final RenderingHints targetHints = processingView.getRenderingHints(sourceImage); if(hints != null) { targetHints.add(hints); } ImageLayout layout = (ImageLayout)targetHints.get(JAI.KEY_IMAGE_LAYOUT); if(layout != null) { layout = (ImageLayout)layout.clone(); } else { layout = new ImageLayout(); } final Rectangle sourceBB = sourceGG.getGridRange2D(); final Rectangle targetBB = targetGG.getGridRange2D(); if(isBoundsUndefined(layout, false)) { layout.setMinX(targetBB.x); layout.setMinY(targetBB.y); layout.setWidth(targetBB.width); layout.setHeight(targetBB.height); } if(isBoundsUndefined(layout, true)) { Dimension size = new Dimension(layout.getWidth(sourceImage), layout.getHeight(sourceImage)); size = ImageUtilities.toTileSize(size); layout.setTileGridXOffset(layout.getMinX(sourceImage)); layout.setTileGridYOffset(layout.getMinY(sourceImage)); layout.setTileWidth(size.width); layout.setTileHeight(size.height); } final double[]background = backgroundValues != null ? backgroundValues : CoverageUtilities.getBackgroundValues(sourceCoverage); if(ViewType.PHOTOGRAPHIC.equals(processingView)) { layout.unsetValid(ImageLayout.COLOR_MODEL_MASK | ImageLayout.SAMPLE_MODEL_MASK); } targetHints.put(JAI.KEY_IMAGE_LAYOUT, layout); final String operation; final ParameterBlock paramBlk = new ParameterBlock().addSource(sourceImage); Warp warp = null; if(allSteps.isIdentity() || (allSteps instanceof AffineTransform && XAffineTransform.isIdentity((AffineTransform)allSteps, EPS))) { sourceCoverage = sourceCoverage.view(ViewType.NATIVE); sourceImage = PlanarImage.wrapRenderedImage(sourceCoverage.getRenderedImage()); paramBlk.removeSources(); paramBlk.addSource(sourceImage); if(targetBB.equals(sourceBB)) { sourceCoverage = sourceCoverage.view(finalView); sourceImage = PlanarImage.wrapRenderedImage(sourceCoverage.getRenderedImage()); return create(sourceCoverage, sourceImage, targetGG, ViewType.SAME, null, null, hints); } if(sourceBB.contains(targetBB)) { operation = \"Crop\"; paramBlk.add(Float.valueOf(targetBB.x)).add(Float.valueOf(targetBB.y)).add(Float.valueOf(targetBB.width)).add(Float.valueOf(targetBB.height)); } else { operation = \"Mosaic\"; paramBlk.add(MosaicDescriptor.MOSAIC_TYPE_OVERLAY).add(null).add(null).add(null).add(background); } } else { if((automaticGR || targetBB.equals(sourceBB)) && allSteps instanceof AffineTransform) { if(automaticGG) { MathTransform mtr; mtr = sourceGG.getGridToCRS(CORNER); mtr = mtFactory.createConcatenatedTransform(mtr, step2.inverse()); targetGG = new GridGeometry2D(sourceGG.getGridRange(), mtr, targetCRS); return create(sourceCoverage, sourceImage, targetGG, finalView, null, null, hints); } operation = \"Affine\"; final AffineTransform affine = (AffineTransform)allSteps.inverse(); paramBlk.add(affine).add(interpolation).add(background); } else { boolean forceAdapter = false; switch(sourceImage.getSampleModel().getTransferType()) { case DataBuffer.TYPE_DOUBLE : case DataBuffer.TYPE_FLOAT : { Envelope source = CRS.transform(sourceGG.getEnvelope(), targetCRS); Envelope target = CRS.transform(targetGG.getEnvelope(), targetCRS); source = targetGG.reduce(source); target = targetGG.reduce(target); if( ! (new GeneralEnvelope(source).contains(target, true))) { if(interpolation != null && ! (interpolation instanceof InterpolationNearest)) { return reproject(sourceCoverage, targetCRS, targetGG, null, hints, background); } else { forceAdapter = true; } } } } final MathTransform2D transform = (MathTransform2D)allSteps2D; final CharSequence name = sourceCoverage.getName(); operation = \"Warp\"; if(forceAdapter) { warp = new WarpBuilder(0.0).buildWarp(transform, sourceBB); } else { warp = createWarp(name, sourceBB, targetBB, transform, mtFactory, hints); } paramBlk.add(warp).add(interpolation).add(background); } } final RenderedOp targetImage = getJAI(hints).createNS(operation, paramBlk, targetHints); final Locale locale = sourceCoverage.getLocale(); final GridEnvelope targetGR = targetGG.getGridRange(); final int[]lower = targetGR.getLow().getCoordinateValues(); final int[]upper = targetGR.getHigh().getCoordinateValues(); for(int i = 0; i < upper.length; i ++ ) { upper[i] ++ ; } lower[targetGG.gridDimensionX] = targetImage.getMinX(); lower[targetGG.gridDimensionY] = targetImage.getMinY(); upper[targetGG.gridDimensionX] = targetImage.getMaxX(); upper[targetGG.gridDimensionY] = targetImage.getMaxY(); final GridEnvelope actualGR = new GeneralGridEnvelope(lower, upper); if( ! targetGR.equals(actualGR)) { targetGG = new GridGeometry2D(actualGR, targetGG.getGridToCRS(PixelInCell.CELL_CENTER), targetCRS); if( ! automaticGR) { log(Loggings.getResources(locale).getLogRecord(Level.FINE, LoggingKeys.ADJUSTED_GRID_GEOMETRY_$1, sourceCoverage.getName().toString(locale))); } } targetCoverage = create(sourceCoverage, targetImage, targetGG, finalView, operation, warp, hints); assert CRS.equalsIgnoreMetadata(targetCoverage.getCoordinateReferenceSystem(), targetCRS) : targetGG; assert targetCoverage.getGridGeometry().getGridRange2D().equals(targetImage.getBounds()) : targetGG; if(CoverageProcessor.LOGGER.isLoggable(LOGGING_LEVEL)) { log(Loggings.getResources(locale).getLogRecord(LOGGING_LEVEL, LoggingKeys.APPLIED_RESAMPLE_$11, new Object[] { sourceCoverage.getName().toString(locale), sourceCoverage.getCoordinateReferenceSystem().getName().getCode(), sourceImage.getWidth(), sourceImage.getHeight(), targetCoverage.getCoordinateReferenceSystem().getName().getCode(), targetImage.getWidth(), targetImage.getHeight(), targetImage.getOperationName(), Integer.valueOf(sourceCoverage == sourceCoverage.view(ViewType.GEOPHYSICS) ? 1 : 0), ImageUtilities.getInterpolationName(interpolation), (background != null) ? background.length == 1 ? (Double.isNaN(background[0]) ? (Object)\"NaN\" : (Object)Double.valueOf(background[0])) : (Object)XArray.toString(background, locale) : \"No background used\" })); } return targetCoverage; } ",
        "focal_src": "public static GridCoverage2D reproject(GridCoverage2D sourceCoverage, CoordinateReferenceSystem targetCRS, GridGeometry2D targetGG, Interpolation interpolation, final Hints hints, final double[]backgroundValues)throws FactoryException, TransformException { Utilities.ensureNonNull(\"sourceCoverage\", sourceCoverage); final CoordinateReferenceSystem sourceCRS = sourceCoverage.getCoordinateReferenceSystem(); if(targetCRS == null) { if(targetGG != null && targetGG.isDefined(GridGeometry2D.CRS_BITMASK)) { targetCRS = targetGG.getCoordinateReferenceSystem(); } else { targetCRS = sourceCRS; } } else { if(targetGG != null && targetGG.isDefined(GridGeometry2D.CRS_BITMASK)) { final CoordinateReferenceSystem targetGGCRS = targetGG.getCoordinateReferenceSystem(); if( ! CRS.equalsIgnoreMetadata(targetCRS, targetGGCRS) && ! CRS.findMathTransform(targetCRS, targetGGCRS).isIdentity()) { throw new IllegalArgumentException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1, \"TargetCRS must be compatible with TargetGG CRS\")); } } } if(interpolation == null) { if(hints != null) { if(hints.containsKey(JAI.KEY_INTERPOLATION))interpolation = (Interpolation)hints.get(JAI.KEY_INTERPOLATION); } } else { hints.put(JAI.KEY_INTERPOLATION, interpolation); } if( ! hints.containsKey(JAI.KEY_BORDER_EXTENDER)) { hints.put(JAI.KEY_BORDER_EXTENDER, BorderExtender.createInstance(BorderExtender.BORDER_COPY)); } final boolean automaticGG, automaticGR; if(targetGG == null) { automaticGG = true; automaticGR = true; } else { automaticGR = ! targetGG.isDefined(GridGeometry2D.GRID_RANGE_BITMASK); if( ! automaticGR || targetGG.isDefined(GridGeometry2D.GRID_TO_CRS_BITMASK)) { automaticGG = false; } else { if(targetGG.isDefined(GridGeometry2D.ENVELOPE_BITMASK)) { final Envelope envelope = targetGG.getEnvelope(); final GridGeometry2D sourceGG = sourceCoverage.getGridGeometry(); final MathTransform gridToCRS; switch(envelope.getDimension()) { case 2 : gridToCRS = sourceGG.getGridToCRS2D(CORNER); break; default : gridToCRS = sourceGG.getGridToCRS(CORNER); break; } targetGG = new GridGeometry2D(PixelInCell.CELL_CENTER, gridToCRS, envelope, null); automaticGG = false; } else { targetGG = null; automaticGG = true; } } } GridCoverage2D targetCoverage = existingCoverage(sourceCoverage, targetCRS, targetGG); if(targetCoverage != null) { return targetCoverage; } final GridGeometry2D sourceGG = sourceCoverage.getGridGeometry(); final CoordinateReferenceSystem compatibleSourceCRS = compatibleSourceCRS(sourceCoverage.getCoordinateReferenceSystem2D(), sourceCRS, targetCRS); final ViewType processingView = CoverageUtilities.preferredViewForOperation(sourceCoverage, interpolation, false, hints); final ViewType finalView = CoverageUtilities.preferredViewAfterOperation(sourceCoverage); sourceCoverage = sourceCoverage.view(processingView); PlanarImage sourceImage = PlanarImage.wrapRenderedImage(sourceCoverage.getRenderedImage()); assert sourceCoverage.getCoordinateReferenceSystem() == sourceCRS : sourceCoverage; final CoordinateOperationFactory factory = ReferencingFactoryFinder.getCoordinateOperationFactory(hints); final MathTransformFactory mtFactory; if(factory instanceof AbstractCoordinateOperationFactory) { mtFactory = ((AbstractCoordinateOperationFactory)factory).getMathTransformFactory(); } else { mtFactory = ReferencingFactoryFinder.getMathTransformFactory(hints); } final MathTransform step1, step2, step3, allSteps, allSteps2D; if(CRS.equalsIgnoreMetadata(sourceCRS, targetCRS)) { if( ! targetGG.isDefined(GridGeometry2D.GRID_TO_CRS_BITMASK)) { step1 = sourceGG.getGridToCRS(CORNER); step2 = IdentityTransform.create(step1.getTargetDimensions()); step3 = step1.inverse(); allSteps = IdentityTransform.create(step1.getSourceDimensions()); targetGG = new GridGeometry2D(targetGG.getGridRange(), step1, targetCRS); } else { step1 = targetGG.getGridToCRS(CORNER); step2 = IdentityTransform.create(step1.getTargetDimensions()); step3 = sourceGG.getGridToCRS(CORNER).inverse(); allSteps = mtFactory.createConcatenatedTransform(step1, step3); if( ! targetGG.isDefined(GridGeometry2D.GRID_RANGE_BITMASK)) { Envelope gridRange; gridRange = toEnvelope(sourceGG.getGridRange()); gridRange = CRS.transform(allSteps.inverse(), gridRange); targetGG = new GridGeometry2D(new GeneralGridEnvelope(gridRange, PixelInCell.CELL_CORNER), targetGG.getGridToCRS(PixelInCell.CELL_CENTER), targetCRS); } } } else { if(sourceCRS == null) { throw new CannotReprojectException(Errors.format(ErrorKeys.UNSPECIFIED_CRS)); } final Envelope sourceEnvelope; final GeneralEnvelope targetEnvelope; final CoordinateOperation operation = factory.createOperation(sourceCRS, targetCRS); final boolean force2D = (sourceCRS != compatibleSourceCRS); step2 = factory.createOperation(targetCRS, compatibleSourceCRS).getMathTransform(); step3 = (force2D ? sourceGG.getGridToCRS2D(CORNER) : sourceGG.getGridToCRS(CORNER)).inverse(); sourceEnvelope = sourceCoverage.getEnvelope(); targetEnvelope = CRS.transform(operation, sourceEnvelope); targetEnvelope.setCoordinateReferenceSystem(targetCRS); if(targetGG == null) { final GridEnvelope targetGR; targetGR = force2D ? new GridEnvelope2D(sourceGG.getGridRange2D()) : sourceGG.getGridRange(); targetGG = new GridGeometry2D(targetGR, targetEnvelope); step1 = targetGG.getGridToCRS(CORNER); } else if( ! targetGG.isDefined(GridGeometry2D.GRID_TO_CRS_BITMASK)) { targetGG = new GridGeometry2D(targetGG.getGridRange(), targetEnvelope); step1 = targetGG.getGridToCRS(CORNER); } else { step1 = targetGG.getGridToCRS(CORNER); if( ! targetGG.isDefined(GridGeometry2D.GRID_RANGE_BITMASK)) { GeneralEnvelope gridRange = CRS.transform(step1.inverse(), targetEnvelope); targetGG = new GridGeometry2D(new GeneralGridEnvelope(gridRange, PixelInCell.CELL_CENTER), step1, targetCRS); } } if(step1.equals(step3.inverse())) { allSteps = step2; } else { allSteps = mtFactory.createConcatenatedTransform(mtFactory.createConcatenatedTransform(step1, step2), step3); } } allSteps2D = toMathTransform2D(allSteps, mtFactory, targetGG); if( ! (allSteps2D instanceof MathTransform2D)) { throw new TransformException(Errors.format(ErrorKeys.NO_TRANSFORM2D_AVAILABLE)); } final RenderingHints targetHints = processingView.getRenderingHints(sourceImage); if(hints != null) { targetHints.add(hints); } ImageLayout layout = (ImageLayout)targetHints.get(JAI.KEY_IMAGE_LAYOUT); if(layout != null) { layout = (ImageLayout)layout.clone(); } else { layout = new ImageLayout(); } final Rectangle sourceBB = sourceGG.getGridRange2D(); final Rectangle targetBB = targetGG.getGridRange2D(); if(isBoundsUndefined(layout, false)) { layout.setMinX(targetBB.x); layout.setMinY(targetBB.y); layout.setWidth(targetBB.width); layout.setHeight(targetBB.height); } if(isBoundsUndefined(layout, true)) { Dimension size = new Dimension(layout.getWidth(sourceImage), layout.getHeight(sourceImage)); size = ImageUtilities.toTileSize(size); layout.setTileGridXOffset(layout.getMinX(sourceImage)); layout.setTileGridYOffset(layout.getMinY(sourceImage)); layout.setTileWidth(size.width); layout.setTileHeight(size.height); } final double[]background = backgroundValues != null ? backgroundValues : CoverageUtilities.getBackgroundValues(sourceCoverage); if(ViewType.PHOTOGRAPHIC.equals(processingView)) { layout.unsetValid(ImageLayout.COLOR_MODEL_MASK | ImageLayout.SAMPLE_MODEL_MASK); } targetHints.put(JAI.KEY_IMAGE_LAYOUT, layout); final String operation; final ParameterBlock paramBlk = new ParameterBlock().addSource(sourceImage); Warp warp = null; if(allSteps.isIdentity() || (allSteps instanceof AffineTransform && XAffineTransform.isIdentity((AffineTransform)allSteps, EPS))) { sourceCoverage = sourceCoverage.view(ViewType.NATIVE); sourceImage = PlanarImage.wrapRenderedImage(sourceCoverage.getRenderedImage()); paramBlk.removeSources(); paramBlk.addSource(sourceImage); if(targetBB.equals(sourceBB)) { sourceCoverage = sourceCoverage.view(finalView); sourceImage = PlanarImage.wrapRenderedImage(sourceCoverage.getRenderedImage()); return create(sourceCoverage, sourceImage, targetGG, ViewType.SAME, null, null, hints); } if(sourceBB.contains(targetBB)) { operation = \"Crop\"; paramBlk.add(Float.valueOf(targetBB.x)).add(Float.valueOf(targetBB.y)).add(Float.valueOf(targetBB.width)).add(Float.valueOf(targetBB.height)); } else { operation = \"Mosaic\"; paramBlk.add(MosaicDescriptor.MOSAIC_TYPE_OVERLAY).add(null).add(null).add(null).add(background); } } else { if((automaticGR || targetBB.equals(sourceBB)) && allSteps instanceof AffineTransform) { if(automaticGG) { MathTransform mtr; mtr = sourceGG.getGridToCRS(CORNER); mtr = mtFactory.createConcatenatedTransform(mtr, step2.inverse()); targetGG = new GridGeometry2D(sourceGG.getGridRange(), mtr, targetCRS); return create(sourceCoverage, sourceImage, targetGG, finalView, null, null, hints); } operation = \"Affine\"; final AffineTransform affine = (AffineTransform)allSteps.inverse(); paramBlk.add(affine).add(interpolation).add(background); } else { boolean forceAdapter = false; switch(sourceImage.getSampleModel().getTransferType()) { case DataBuffer.TYPE_DOUBLE : case DataBuffer.TYPE_FLOAT : { Envelope source = CRS.transform(sourceGG.getEnvelope(), targetCRS); Envelope target = CRS.transform(targetGG.getEnvelope(), targetCRS); source = targetGG.reduce(source); target = targetGG.reduce(target); if( ! (new GeneralEnvelope(source).contains(target, true))) { if(interpolation != null && ! (interpolation instanceof InterpolationNearest)) { return reproject(sourceCoverage, targetCRS, targetGG, null, hints, background); } else { forceAdapter = true; } } } } final MathTransform2D transform = (MathTransform2D)allSteps2D; final CharSequence name = sourceCoverage.getName(); operation = \"Warp\"; if(forceAdapter) { warp = new WarpBuilder(0.0).buildWarp(transform, sourceBB); } else { warp = createWarp(name, sourceBB, targetBB, transform, mtFactory, hints); } paramBlk.add(warp).add(interpolation).add(background); } } final RenderedOp targetImage = getJAI(hints).createNS(operation, paramBlk, targetHints); final Locale locale = sourceCoverage.getLocale(); final GridEnvelope targetGR = targetGG.getGridRange(); final int[]lower = targetGR.getLow().getCoordinateValues(); final int[]upper = targetGR.getHigh().getCoordinateValues(); for(int i = 0; i < upper.length; i ++ ) { upper[i] ++ ; } lower[targetGG.gridDimensionX] = targetImage.getMinX(); lower[targetGG.gridDimensionY] = targetImage.getMinY(); upper[targetGG.gridDimensionX] = targetImage.getMaxX(); upper[targetGG.gridDimensionY] = targetImage.getMaxY(); final GridEnvelope actualGR = new GeneralGridEnvelope(lower, upper); if( ! targetGR.equals(actualGR)) { targetGG = new GridGeometry2D(actualGR, targetGG.getGridToCRS(PixelInCell.CELL_CENTER), targetCRS); if( ! automaticGR) { log(Loggings.getResources(locale).getLogRecord(Level.FINE, LoggingKeys.ADJUSTED_GRID_GEOMETRY_$1, sourceCoverage.getName().toString(locale))); } } targetCoverage = create(sourceCoverage, targetImage, targetGG, finalView, operation, warp, hints); assert CRS.equalsIgnoreMetadata(targetCoverage.getCoordinateReferenceSystem(), targetCRS) : targetGG; assert targetCoverage.getGridGeometry().getGridRange2D().equals(targetImage.getBounds()) : targetGG; if(CoverageProcessor.LOGGER.isLoggable(LOGGING_LEVEL)) { log(Loggings.getResources(locale).getLogRecord(LOGGING_LEVEL, LoggingKeys.APPLIED_RESAMPLE_$11, new Object[] { sourceCoverage.getName().toString(locale), sourceCoverage.getCoordinateReferenceSystem().getName().getCode(), sourceImage.getWidth(), sourceImage.getHeight(), targetCoverage.getCoordinateReferenceSystem().getName().getCode(), targetImage.getWidth(), targetImage.getHeight(), targetImage.getOperationName(), Integer.valueOf(sourceCoverage == sourceCoverage.view(ViewType.GEOPHYSICS) ? 1 : 0), ImageUtilities.getInterpolationName(interpolation), (background != null) ? background.length == 1 ? (Double.isNaN(background[0]) ? (Object)\"NaN\" : (Object)Double.valueOf(background[0])) : (Object)XArray.toString(background, locale) : \"No background used\" })); } return targetCoverage; } ",
        "test_tgt": "@Test public void testReproject()throws NoSuchAuthorityCodeException, FactoryException { GridCoverage2D coverage_ = project(ushortCoverage, CRS.parseWKT(GOOGLE_MERCATOR_WKT), null, \"nearest\", null, true); coverage_ = (GridCoverage2D)Operations.DEFAULT.extrema(coverage_); Object minimums = coverage_.getProperty(Extrema.GT_SYNTHETIC_PROPERTY_MINIMUM); Assert.assertTrue(minimums instanceof double[]); final double[]mins = (double[])minimums; Object maximums = coverage_.getProperty(Extrema.GT_SYNTHETIC_PROPERTY_MAXIMUM); Assert.assertTrue(maximums instanceof double[]); final double[]max = (double[])maximums; boolean fail = true; for(int i = 0; i < mins.length; i ++ )if(mins[i] != max[i] && max[i] > 0)fail = false; Assert.assertFalse(\"Reprojection failed\", fail); try { assertEquals(\"Warp\", showProjected(coverage, CRS.parseWKT(GOOGLE_MERCATOR_WKT), coverage.getGridGeometry(), null, true)); Assert.assertTrue(\"We should not be allowed to set different crs for target crs and target gg\", false); } catch(Exception e) { } } "
    },
    {
        "test_src": "@Test(groups = \"observerMethod\")public void testAddObserver() { EventManager eventManager = new EventManager(); Observer < DangerCall > observer = new AnObserver < DangerCall > (); eventManager.addObserver(observer, DangerCall.class); DangerCall event = new DangerCall(); Set < Observer < DangerCall > > observerSet = eventManager.getObservers(new MetaDataCache(), event); assert observerSet.size() == 1; assert observerSet.iterator().next().equals(observer); observer = new AnObserver < DangerCall > (); eventManager.addObserver(observer, DangerCall.class, new TameAnnotationLiteral()); observerSet = eventManager.getObservers(new MetaDataCache(), event); assert observerSet.size() == 1; observerSet = eventManager.getObservers(new MetaDataCache(), event, new TameAnnotationLiteral()); assert observerSet.size() == 2; } ",
        "focal_tgt": "public < T > void addObserver(Observer < T > observer, Class < T > eventType, Annotation ... bindings) { EventObserver < T > eventObserver = new EventObserver < T > (manager.getMetaDataCache(), observer, eventType, bindings); registeredObservers.put(eventType, eventObserver); } ",
        "focal_src": "public < T > void addObserver(Observer < T > observer, Class < T > eventType, Annotation ... bindings) { EventObserver < T > eventObserver = new EventObserver < T > (observer, eventType, bindings); registeredObservers.put(eventType, eventObserver); } ",
        "test_tgt": "@Test(groups = \"observerMethod\")public void testAddObserver() { EventManager eventManager = new EventManager(manager); Observer < DangerCall > observer = new AnObserver < DangerCall > (); eventManager.addObserver(observer, DangerCall.class); DangerCall event = new DangerCall(); Set < Observer < DangerCall > > observerSet = eventManager.getObservers(event); assert observerSet.size() == 1; assert observerSet.iterator().next().equals(observer); observer = new AnObserver < DangerCall > (); eventManager.addObserver(observer, DangerCall.class, new TameAnnotationLiteral()); observerSet = eventManager.getObservers(event); assert observerSet.size() == 1; observerSet = eventManager.getObservers(event, new TameAnnotationLiteral()); assert observerSet.size() == 2; } "
    },
    {
        "test_src": "@Test public void testGetMem() { System.out.println(\"getMem\"); long result = instance.getMem(); System.out.println(result); assertTrue(result >= 0); } ",
        "focal_tgt": "public long getMem() { long ret; String value = getData(\"mem\"); if(value != null) { ret = Long.parseLong(value); } else { ret = MetricsGetter.AGENT_ERROR; } return ret; } ",
        "focal_src": "public long getMem() { long ret; try { String value = getData(\"mem\"); if(value != null) { ret = Long.parseLong(value); } else { ret = MetricsGetter.AGENT_ERROR; } } catch(IOException ioex) { ret = MetricsGetter.AGENT_ERROR; } return ret; } ",
        "test_tgt": "@Test public void testGetMem() { System.out.println(\"getMem\"); prepareTestData(123); long result = instance.getMem(); System.out.println(result); assertTrue(result >= 0); } "
    },
    {
        "test_src": "@Test public void async()throws Exception { get(\"/async\"); assertThat(spans).hasSize(1); } ",
        "focal_tgt": "@Override@Ignore(\"ignored until https://github.com/perwendel/spark/issues/208\")public void async() { } ",
        "focal_src": "@Override@Test(expected = ComparisonFailure.class)public void async()throws Exception { super.async(); } ",
        "test_tgt": "@Test public void async()throws Exception { get(\"/async\"); takeSpan(); } "
    },
    {
        "test_src": "@Test public void testPurge_Predicate_RunTable() { System.out.println(\"purge_predicate_removed\"); Predicate < Run > predicate1 = new Predicate < Run > () { @Override public boolean check(Run run) { return run.getLength() == 2; } }; RunTable instance = createHorizontalInstance(); instance.dumpSequences(); System.out.println(\"table before1:\" + instance.dumpOf()); RunTable removed = new RunTable(\"purged\", HORIZONTAL, dim.width, dim.height); instance.purge(predicate1, removed); instance.dumpSequences(); System.out.println(\"table after1:\" + instance.dumpOf()); removed.dumpSequences(); System.out.println(\"purge after1:\" + removed.dumpOf()); Predicate < Run > predicate2 = new Predicate < Run > () { @Override public boolean check(Run run) { return run.getLength() == 1; } }; instance.purge(predicate2, removed); instance.dumpSequences(); System.out.println(\"table after2:\" + instance.dumpOf()); removed.dumpSequences(); System.out.println(\"purge after2:\" + removed.dumpOf()); } ",
        "focal_tgt": "public RunTable purge(Predicate < Run > predicate, RunTable removed) { if(removed != null) { if(removed.orientation != orientation) { throw new IllegalArgumentException(\"'removed' table is of different orientation\"); } if((removed.width != width) || (removed.height != height)) { throw new IllegalArgumentException(\"'removed' table is of different dimension\"); } } for(int i = 0, size = getSize(); i < size; i ++ ) { for(Itr it = new Itr(i); it.hasNext(); ) { Run run = it.next(); if(predicate.check(run)) { it.remove(); if(removed != null) { removed.addRun(i, run); } } } } return this; } ",
        "focal_src": "public RunTable purge(Predicate < Run > predicate, RunTable removed) { if(removed != null) { if(removed.orientation != orientation) { throw new IllegalArgumentException(\"'removed' table is of different orientation\"); } if((removed.width != width) || (removed.height != height)) { throw new IllegalArgumentException(\"'removed' table is of different dimension\"); } } for(int i = 0, size = getSize(); i < size; i ++ ) { RunSequence seq = getSequence(i); for(Iterator < Run > it = seq.iterator(); it.hasNext(); ) { Run run = it.next(); if(predicate.check(run)) { it.remove(); if(removed != null) { removed.getSequence(i).add(run); } } } } return this; } ",
        "test_tgt": "@Test public void testPurge_Predicate_RunTable() { System.out.println(\"\\n+++ purge_predicate_removed\"); Predicate < Run > predicate1 = new Predicate < Run > () { @Override public boolean check(Run run) { return run.getLength() == 2; } }; RunTable instance = createHorizontalInstance(); System.out.println(\"table before1:\" + instance.dumpOf()); instance.dumpSequences(); RunTable removed = new RunTable(\"purged\", HORIZONTAL, dim.width, dim.height); instance.purge(predicate1, removed); System.out.println(\"table after1:\" + instance.dumpOf()); instance.dumpSequences(); System.out.println(\"purge after1:\" + removed.dumpOf()); removed.dumpSequences(); Predicate < Run > predicate2 = new Predicate < Run > () { @Override public boolean check(Run run) { return run.getLength() == 1; } }; instance.purge(predicate2, removed); System.out.println(\"table after2:\" + instance.dumpOf()); instance.dumpSequences(); System.out.println(\"purge after2:\" + removed.dumpOf()); removed.dumpSequences(); } "
    },
    {
        "test_src": "@Test public void testUniform() { logger.info(\"Uniform\"); int n = 10; double expResult = 0.1; double result = DiscreteDistributions.Uniform(n); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } ",
        "focal_tgt": "public static double uniform(int n) { if(n < 1) { throw new IllegalArgumentException(\"The n must be larger than 1.\"); } double probability = 1.0 / n; return probability; } ",
        "focal_src": "public static double Uniform(int n) { if(n < 1) { throw new IllegalArgumentException(\"The n must be larger than 1.\"); } double probability = 1.0 / n; return probability; } ",
        "test_tgt": "@Test public void testUniform() { logger.info(\"Uniform\"); int n = 10; double expResult = 0.1; double result = DiscreteDistributions.uniform(n); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } "
    },
    {
        "test_src": "@Test@Ignore public void testGetSynonyms() { final SynonymResult synonymResult1 = new SynonymResult(); synonymResult1.setTrait(\"openness\"); synonymResult1.setHeadword(\"difficult\"); final Synonym synonym10 = new Synonym(); synonym10.setWord(\"petrified\"); synonym10.setSense(\"difficult\"); synonym10.setMeaning(\"not easy\"); synonym10.setHops(0); synonym10.setSemanticType(\"adj-all\"); synonym10.setWeight( - 0.028989519600000006); final Synonym synonym11 = new Synonym(); synonym11.setWord(\"embarrassing\"); synonym11.setSense(\"difficult\"); synonym11.setMeaning(\"not easy\"); synonym11.setHops(0); synonym11.setSemanticType(\"adj-all\"); synonym11.setWeight( - 0.028989519600000); final Synonym synonym12 = new Synonym(); synonym12.setWord(\"tough\"); synonym12.setSense(\"difficult\"); synonym12.setMeaning(\"not easy\"); synonym12.setHops(0); synonym12.setSemanticType(\"adj-all\"); synonym12.setWeight( - 0.0289895196000009); synonymResult1.setSynonyms(new ArrayList < Synonym > () { { add(synonym10); add(synonym11); add(synonym12); } }); final SynonymResult synonymResult2 = new SynonymResult(); synonymResult2.setTrait(\"conscientious\"); synonymResult2.setHeadword(\"difficult\"); final Synonym synonym20 = new Synonym(); synonym20.setWord(\"trying\"); synonym20.setSense(\"difficult\"); synonym20.setMeaning(\"not easy\"); synonym20.setHops(0); synonym20.setSemanticType(\"adj-all\"); synonym20.setWeight( - 0.02898951960000002); final Synonym synonym21 = new Synonym(); synonym21.setWord(\"challenging\"); synonym21.setSense(\"difficult\"); synonym21.setMeaning(\"not easy\"); synonym21.setHops(0); synonym21.setSemanticType(\"adj-all\"); synonym21.setWeight( - 0.0289895196007); final Synonym synonym22 = new Synonym(); synonym22.setWord(\"tough\"); synonym22.setSense(\"difficult\"); synonym22.setMeaning(\"not easy\"); synonym22.setHops(0); synonym22.setSemanticType(\"adj-all\"); synonym22.setWeight( - 0.0289895196000099); synonymResult2.setSynonyms(new ArrayList < Synonym > () { { add(synonym20); add(synonym21); add(synonym22); } }); final SynonymResult synonymResult3 = new SynonymResult(); synonymResult3.setTrait(\"confident\"); synonymResult3.setHeadword(\"difficult\"); final Synonym synonym30 = new Synonym(); synonym30.setWord(\"firm\"); synonym30.setSense(\"difficult\"); synonym30.setMeaning(\"not easy\"); synonym30.setHops(0); synonym30.setSemanticType(\"adj-all\"); synonym30.setWeight( - 0.02898951960000112); synonymResult3.setSynonyms(new ArrayList < Synonym > () { { add(synonym30); } }); final List < SynonymResult > response = new ArrayList < SynonymResult > (); response.add(synonymResult1); response.add(synonymResult1); response.add(synonymResult1); final SynonymOptions options = new SynonymOptions().words(\"difficult\", \"inferior\").limit(3); final JsonObject contentJson = new JsonObject(); final JsonArray wordsJson = new JsonArray(); for(final String word : options.getWords()) { wordsJson.add(new JsonPrimitive(word)); } contentJson.add(\"words\", wordsJson); if(options.getLimit() != null)contentJson.addProperty(\"limit\", options.getLimit()); mockServer.when(request().withMethod(POST).withPath(SYNONYM_PATH).withBody(contentJson.toString())).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGson().toJson(response))); final List < SynonymResult > synonyms = service.getSynonyms(options); Assert.assertNotNull(synonyms); Assert.assertFalse(synonyms.isEmpty()); Assert.assertEquals(synonyms, response); } ",
        "focal_tgt": "public List < SynonymResult > getSynonyms(SynonymOptions options) { if(options == null)throw new IllegalArgumentException(\"options cannot be null\"); if(options.getWords() == null || options.getWords().isEmpty())throw new IllegalArgumentException(\"options.words cannot be null or empty\"); final Request request = RequestBuilder.post(PATH_SYNONYM).withBodyContent(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(options), HttpMediaType.APPLICATION_JSON).build(); final Response response = execute(request); final String synonymResultJson = ResponseUtil.getString(response); final List < SynonymResult > synonyms = GsonSingleton.getGsonWithoutPrettyPrinting().fromJson(synonymResultJson, synonymListType); return synonyms; } ",
        "focal_src": "public List < SynonymResult > getSynonyms(SynonymOptions options) { if(options == null)throw new IllegalArgumentException(\"options cannot be null\"); if(options.getWords() == null || options.getWords().isEmpty())throw new IllegalArgumentException(\"options.words cannot be null or empty\"); final Request request = RequestBuilder.post(PATH_SYNONYM).withBodyContent(GsonSingleton.getGson().toJson(options), HttpMediaType.APPLICATION_JSON).build(); final Response response = execute(request); final String synonymResultJson = ResponseUtil.getString(response); final List < SynonymResult > synonyms = GsonSingleton.getGson().fromJson(synonymResultJson, synonymListType); return synonyms; } ",
        "test_tgt": "@Test@Ignore public void testGetSynonyms() { final SynonymResult synonymResult1 = new SynonymResult(); synonymResult1.setTrait(\"openness\"); synonymResult1.setHeadword(\"difficult\"); final Synonym synonym10 = new Synonym(); synonym10.setWord(\"petrified\"); synonym10.setSense(\"difficult\"); synonym10.setMeaning(\"not easy\"); synonym10.setHops(0); synonym10.setSemanticType(\"adj-all\"); synonym10.setWeight( - 0.028989519600000006); final Synonym synonym11 = new Synonym(); synonym11.setWord(\"embarrassing\"); synonym11.setSense(\"difficult\"); synonym11.setMeaning(\"not easy\"); synonym11.setHops(0); synonym11.setSemanticType(\"adj-all\"); synonym11.setWeight( - 0.028989519600000); final Synonym synonym12 = new Synonym(); synonym12.setWord(\"tough\"); synonym12.setSense(\"difficult\"); synonym12.setMeaning(\"not easy\"); synonym12.setHops(0); synonym12.setSemanticType(\"adj-all\"); synonym12.setWeight( - 0.0289895196000009); synonymResult1.setSynonyms(new ArrayList < Synonym > () { { add(synonym10); add(synonym11); add(synonym12); } }); final SynonymResult synonymResult2 = new SynonymResult(); synonymResult2.setTrait(\"conscientious\"); synonymResult2.setHeadword(\"difficult\"); final Synonym synonym20 = new Synonym(); synonym20.setWord(\"trying\"); synonym20.setSense(\"difficult\"); synonym20.setMeaning(\"not easy\"); synonym20.setHops(0); synonym20.setSemanticType(\"adj-all\"); synonym20.setWeight( - 0.02898951960000002); final Synonym synonym21 = new Synonym(); synonym21.setWord(\"challenging\"); synonym21.setSense(\"difficult\"); synonym21.setMeaning(\"not easy\"); synonym21.setHops(0); synonym21.setSemanticType(\"adj-all\"); synonym21.setWeight( - 0.0289895196007); final Synonym synonym22 = new Synonym(); synonym22.setWord(\"tough\"); synonym22.setSense(\"difficult\"); synonym22.setMeaning(\"not easy\"); synonym22.setHops(0); synonym22.setSemanticType(\"adj-all\"); synonym22.setWeight( - 0.0289895196000099); synonymResult2.setSynonyms(new ArrayList < Synonym > () { { add(synonym20); add(synonym21); add(synonym22); } }); final SynonymResult synonymResult3 = new SynonymResult(); synonymResult3.setTrait(\"confident\"); synonymResult3.setHeadword(\"difficult\"); final Synonym synonym30 = new Synonym(); synonym30.setWord(\"firm\"); synonym30.setSense(\"difficult\"); synonym30.setMeaning(\"not easy\"); synonym30.setHops(0); synonym30.setSemanticType(\"adj-all\"); synonym30.setWeight( - 0.02898951960000112); synonymResult3.setSynonyms(new ArrayList < Synonym > () { { add(synonym30); } }); final List < SynonymResult > response = new ArrayList < SynonymResult > (); response.add(synonymResult1); response.add(synonymResult1); response.add(synonymResult1); final SynonymOptions options = new SynonymOptions().words(\"difficult\", \"inferior\").limit(3); final JsonObject contentJson = new JsonObject(); final JsonArray wordsJson = new JsonArray(); for(final String word : options.getWords()) { wordsJson.add(new JsonPrimitive(word)); } contentJson.add(\"words\", wordsJson); if(options.getLimit() != null)contentJson.addProperty(\"limit\", options.getLimit()); mockServer.when(request().withMethod(POST).withPath(SYNONYM_PATH).withBody(contentJson.toString())).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGsonWithoutPrettyPrinting().toJson(response))); final List < SynonymResult > synonyms = service.getSynonyms(options); Assert.assertNotNull(synonyms); Assert.assertFalse(synonyms.isEmpty()); Assert.assertEquals(synonyms, response); } "
    },
    {
        "test_src": "@Test public void test_LatLongToPixelXY() { final PointL point = TileSystem.getMercatorFromGeo(60, 60, TileSystem.MapSize((double)10), null, true); Assert.assertEquals(174762, point.x); Assert.assertEquals(76126, point.y); } ",
        "focal_tgt": "@Deprecated public PointL LatLongToPixelXY(final double latitude, final double longitude, final double zoomLevel, final PointL reuse) { return LatLongToPixelXYMapSize(wrap(latitude, - 90, 90, 180), wrap(longitude, - 180, 180, 360), MapSize(zoomLevel), reuse); } ",
        "focal_src": "@Deprecated public static PointL LatLongToPixelXY(final double latitude, final double longitude, final double zoomLevel, final PointL reuse) { return LatLongToPixelXYMapSize(wrap(latitude, - 90, 90, 180), wrap(longitude, - 180, 180, 360), MapSize(zoomLevel), reuse); } ",
        "test_tgt": "@Test public void test_LatLongToPixelXY() { final PointL point = tileSystem.getMercatorFromGeo(60, 60, TileSystem.MapSize((double)10), null, true); Assert.assertEquals(174762, point.x); Assert.assertEquals(76126, point.y); } "
    },
    {
        "test_src": "@Test public void testAcceptEither()throws Exception { CountDownLatch blocker1 = new CountDownLatch(1); CountDownLatch blocker2 = new CountDownLatch(1); try { ManagedCompletableFuture < Boolean > cf1 = ManagedCompletableFuture.supplyAsync(() -> { System.out.println(\"> supplyAsync[1] from testAcceptEither\"); try { boolean result = blocker1.await(TIMEOUT_NS * 2, TimeUnit.NANOSECONDS); System.out.println(\"< supplyAsync[1] \" + result); return result; } catch(InterruptedException x) { System.out.println(\"< supplyAsync[1] \" + x); throw new CompletionException(x); } }); CompletableFuture < Boolean > cf2 = CompletableFuture.supplyAsync(() -> { System.out.println(\"> supplyAsync[2] from testAcceptEither\"); try { boolean result = blocker2.await(TIMEOUT_NS * 2, TimeUnit.NANOSECONDS); System.out.println(\"< supplyAsync[2] \" + result); return result; } catch(InterruptedException x) { System.out.println(\"< supplyAsync[2] \" + x); throw new CompletionException(x); } }); LinkedBlockingQueue < Object > results = new LinkedBlockingQueue < Object > (); ManagedCompletableFuture < Void > cf3 = cf1.acceptEither(cf2, (b) -> { System.out.println(\"> lookup from testAcceptEither\"); results.add(b); results.add(Thread.currentThread().getName()); try { ManagedExecutorService result = InitialContext.doLookup(\"java:module/noContextExecutorRef\"); results.add(result); System.out.println(\"< lookup: \" + result); } catch(NamingException x) { System.out.println(\"< lookup failed\"); x.printStackTrace(System.out); throw new CompletionException(x); } }); assertFalse(cf3.isDone()); try { Object result = cf3.get(100, TimeUnit.MILLISECONDS); fail(\"Dependent completion stage must not complete first\"); } catch(TimeoutException x) { } blocker2.countDown(); assertNull(cf3.get(TIMEOUT_NS, TimeUnit.NANOSECONDS)); assertTrue(cf3.isDone()); assertFalse(cf3.isCancelled()); assertFalse(cf3.isCompletedExceptionally()); assertEquals(Boolean.TRUE, results.poll(TIMEOUT_NS, TimeUnit.NANOSECONDS)); String threadName; assertNotNull(threadName = (String)results.poll(TIMEOUT_NS, TimeUnit.NANOSECONDS)); assertTrue(threadName, ! threadName.startsWith((\"Default Executor-thread-\"))); Object lookupResult; assertNotNull(lookupResult = results.poll(TIMEOUT_NS, TimeUnit.NANOSECONDS)); assertEquals(noContextExecutor, lookupResult); blocker1.countDown(); assertEquals(Boolean.TRUE, cf1.get(TIMEOUT_NS, TimeUnit.NANOSECONDS)); } finally { blocker1.countDown(); blocker2.countDown(); } } ",
        "focal_tgt": "@Override public CompletableFuture < Void > acceptEither(CompletionStage < ? extends T > other, Consumer < ? super T > action) { if(action instanceof ManagedTask)throw new IllegalArgumentException(ManagedTask.class.getName()); WSContextService contextSvc = ((WSManagedExecutorService)defaultExecutor).getContextService(); @SuppressWarnings(\"unchecked\")ThreadContextDescriptor contextDescriptor = contextSvc.captureThreadContext(XPROPS_SUSPEND_TRAN); action = new ContextualConsumer < > (contextDescriptor, action); if(JAVA8) { if(other instanceof ManagedCompletableFuture)other = ((ManagedCompletableFuture < ? extends T > )other).completableFuture; CompletableFuture < Void > dependentStage = completableFuture.acceptEither(other, action); return new ManagedCompletableFuture < Void > (dependentStage, defaultExecutor, null); } else { return super.acceptEither(other, action); } } ",
        "focal_src": "@Override public ManagedCompletableFuture < Void > acceptEither(CompletionStage < ? extends T > other, Consumer < ? super T > action) { if(action instanceof ManagedTask)throw new IllegalArgumentException(ManagedTask.class.getName()); WSContextService contextSvc = ((WSManagedExecutorService)defaultExecutor).getContextService(); @SuppressWarnings(\"unchecked\")ThreadContextDescriptor contextDescriptor = contextSvc.captureThreadContext(XPROPS_SUSPEND_TRAN); action = new ContextualConsumer < > (contextDescriptor, action); if(JAVA8) { if(other instanceof ManagedCompletableFuture)other = ((ManagedCompletableFuture < ? extends T > )other).completableFuture; CompletableFuture < Void > dependentStage = completableFuture.acceptEither(other, action); return new ManagedCompletableFuture < Void > (dependentStage, defaultExecutor, null); } else { return(ManagedCompletableFuture < Void > )super.acceptEither(other, action); } } ",
        "test_tgt": "@Test public void testAcceptEither()throws Exception { CountDownLatch blocker1 = new CountDownLatch(1); CountDownLatch blocker2 = new CountDownLatch(1); try { CompletableFuture < Boolean > cf1 = ManagedCompletableFuture.supplyAsync(() -> { System.out.println(\"> supplyAsync[1] from testAcceptEither\"); try { boolean result = blocker1.await(TIMEOUT_NS * 2, TimeUnit.NANOSECONDS); System.out.println(\"< supplyAsync[1] \" + result); return result; } catch(InterruptedException x) { System.out.println(\"< supplyAsync[1] \" + x); throw new CompletionException(x); } }); CompletableFuture < Boolean > cf2 = CompletableFuture.supplyAsync(() -> { System.out.println(\"> supplyAsync[2] from testAcceptEither\"); try { boolean result = blocker2.await(TIMEOUT_NS * 2, TimeUnit.NANOSECONDS); System.out.println(\"< supplyAsync[2] \" + result); return result; } catch(InterruptedException x) { System.out.println(\"< supplyAsync[2] \" + x); throw new CompletionException(x); } }); LinkedBlockingQueue < Object > results = new LinkedBlockingQueue < Object > (); CompletableFuture < Void > cf3 = cf1.acceptEither(cf2, (b) -> { System.out.println(\"> lookup from testAcceptEither\"); results.add(b); results.add(Thread.currentThread().getName()); try { ManagedExecutorService result = InitialContext.doLookup(\"java:module/noContextExecutorRef\"); results.add(result); System.out.println(\"< lookup: \" + result); } catch(NamingException x) { System.out.println(\"< lookup failed\"); x.printStackTrace(System.out); throw new CompletionException(x); } }); assertFalse(cf3.isDone()); try { Object result = cf3.get(100, TimeUnit.MILLISECONDS); fail(\"Dependent completion stage must not complete first\"); } catch(TimeoutException x) { } blocker2.countDown(); assertNull(cf3.get(TIMEOUT_NS, TimeUnit.NANOSECONDS)); assertTrue(cf3.isDone()); assertFalse(cf3.isCancelled()); assertFalse(cf3.isCompletedExceptionally()); assertEquals(Boolean.TRUE, results.poll(TIMEOUT_NS, TimeUnit.NANOSECONDS)); String threadName; assertNotNull(threadName = (String)results.poll(TIMEOUT_NS, TimeUnit.NANOSECONDS)); assertTrue(threadName, ! threadName.startsWith((\"Default Executor-thread-\"))); Object lookupResult; assertNotNull(lookupResult = results.poll(TIMEOUT_NS, TimeUnit.NANOSECONDS)); assertEquals(noContextExecutor, lookupResult); blocker1.countDown(); assertEquals(Boolean.TRUE, cf1.get(TIMEOUT_NS, TimeUnit.NANOSECONDS)); } finally { blocker1.countDown(); blocker2.countDown(); } } "
    },
    {
        "test_src": "@Test public void testReadDirect()throws Exception { final int randomAppendLength = 1024; @Cleanup TestContext context = new TestContext(); ArrayList < Long > segmentIds = new ArrayList < > (); final long segmentId = createSegment(0, context); final UpdateableSegmentMetadata segmentMetadata = context.metadata.getStreamSegmentMetadata(segmentId); segmentIds.add(segmentId); HashMap < Long, ArrayList < Long > > transactionsBySegment = createTransactions(segmentIds, 1, context); final long mergedTxId = transactionsBySegment.get(segmentId).get(0); HashMap < Long, ByteArrayOutputStream > segmentContents = new HashMap < > (); transactionsBySegment.values().forEach(segmentIds :: addAll); appendData(segmentIds, segmentContents, context); segmentMetadata.setStorageLength(segmentMetadata.getLength() - 100); final long mergedTxOffset = beginMergeTransaction(mergedTxId, segmentMetadata, segmentContents, context); final long endOfMergedDataOffset = segmentMetadata.getLength(); byte[]appendData = new byte[randomAppendLength]; new Random(0).nextBytes(appendData); appendSingleWrite(segmentId, appendData, context); recordAppend(segmentId, appendData, segmentContents); for(AtomicLong offset = new AtomicLong(0); offset.get() < segmentMetadata.getStorageLength(); offset.incrementAndGet()) { AssertExtensions.assertThrows(String.format(\"readDirect allowed reading from an illegal offset (%s).\", offset), () -> context.readIndex.readDirect(segmentId, offset.get(), 1), ex -> ex instanceof IllegalArgumentException); } for(long offset = mergedTxOffset - 1; offset < endOfMergedDataOffset; offset ++ ) { InputStream resultStream = context.readIndex.readDirect(segmentId, offset, 2); Assert.assertNull(\"readDirect() returned data overlapping a partially merged transaction\", resultStream); } final byte[]expectedData = segmentContents.get(segmentId).toByteArray(); BiConsumer < Long, Long > verifyReadResult = (startOffset, endOffset) -> { int readLength = (int)(endOffset - startOffset); while(readLength > 0) { InputStream actualDataStream = context.readIndex.readDirect(segmentId, startOffset, readLength); Assert.assertNotNull(String.format(\"Unexpected result when data is readily available for Offset = %s, Length = %s.\", startOffset, readLength), actualDataStream); byte[]actualData = new byte[readLength]; try { int bytesCopied = StreamHelpers.readAll(actualDataStream, actualData, 0, readLength); Assert.assertEquals(String.format(\"Unexpected number of bytes read for Offset = %s, Length = %s (pre-partial-merge).\", startOffset, readLength), readLength, bytesCopied); } catch(IOException ex) { throw new UncheckedIOException(ex); } AssertExtensions.assertArrayEquals(\"Unexpected data read from the segment at offset \" + startOffset, expectedData, startOffset.intValue(), actualData, 0, actualData.length); readLength -- ; if(readLength % 2 == 0) { startOffset ++ ; } } }; verifyReadResult.accept(segmentMetadata.getStorageLength(), mergedTxOffset); verifyReadResult.accept(endOfMergedDataOffset, segmentMetadata.getLength()); } ",
        "focal_tgt": "InputStream readDirect(long streamSegmentId, long startOffset, int length)throws StreamSegmentNotExistsException; ",
        "focal_src": "InputStream readDirect(long streamSegmentId, long startOffset, int length); ",
        "test_tgt": "@Test public void testReadDirect()throws Exception { final int randomAppendLength = 1024; @Cleanup TestContext context = new TestContext(); ArrayList < Long > segmentIds = new ArrayList < > (); final long segmentId = createSegment(0, context); final UpdateableSegmentMetadata segmentMetadata = context.metadata.getStreamSegmentMetadata(segmentId); segmentIds.add(segmentId); HashMap < Long, ArrayList < Long > > transactionsBySegment = createTransactions(segmentIds, 1, context); final long mergedTxId = transactionsBySegment.get(segmentId).get(0); HashMap < Long, ByteArrayOutputStream > segmentContents = new HashMap < > (); transactionsBySegment.values().forEach(segmentIds :: addAll); appendData(segmentIds, segmentContents, context); segmentMetadata.setStorageLength(segmentMetadata.getLength() - 100); final long mergedTxOffset = beginMergeTransaction(mergedTxId, segmentMetadata, segmentContents, context); final long endOfMergedDataOffset = segmentMetadata.getLength(); byte[]appendData = new byte[randomAppendLength]; new Random(0).nextBytes(appendData); appendSingleWrite(segmentId, appendData, context); recordAppend(segmentId, appendData, segmentContents); for(AtomicLong offset = new AtomicLong(0); offset.get() < segmentMetadata.getStorageLength(); offset.incrementAndGet()) { AssertExtensions.assertThrows(String.format(\"readDirect allowed reading from an illegal offset (%s).\", offset), () -> context.readIndex.readDirect(segmentId, offset.get(), 1), ex -> ex instanceof IllegalArgumentException); } for(long offset = mergedTxOffset - 1; offset < endOfMergedDataOffset; offset ++ ) { InputStream resultStream = context.readIndex.readDirect(segmentId, offset, 2); Assert.assertNull(\"readDirect() returned data overlapping a partially merged transaction\", resultStream); } final byte[]expectedData = segmentContents.get(segmentId).toByteArray(); BiConsumer < Long, Long > verifyReadResult = (startOffset, endOffset) -> { int readLength = (int)(endOffset - startOffset); while(readLength > 0) { InputStream actualDataStream; try { actualDataStream = context.readIndex.readDirect(segmentId, startOffset, readLength); } catch(StreamSegmentNotExistsException ex) { throw new CompletionException(ex); } Assert.assertNotNull(String.format(\"Unexpected result when data is readily available for Offset = %s, Length = %s.\", startOffset, readLength), actualDataStream); byte[]actualData = new byte[readLength]; try { int bytesCopied = StreamHelpers.readAll(actualDataStream, actualData, 0, readLength); Assert.assertEquals(String.format(\"Unexpected number of bytes read for Offset = %s, Length = %s (pre-partial-merge).\", startOffset, readLength), readLength, bytesCopied); } catch(IOException ex) { throw new UncheckedIOException(ex); } AssertExtensions.assertArrayEquals(\"Unexpected data read from the segment at offset \" + startOffset, expectedData, startOffset.intValue(), actualData, 0, actualData.length); readLength -- ; if(readLength % 2 == 0) { startOffset ++ ; } } }; verifyReadResult.accept(segmentMetadata.getStorageLength(), mergedTxOffset); verifyReadResult.accept(endOfMergedDataOffset, segmentMetadata.getLength()); } "
    },
    {
        "test_src": "@Test public void commitReturnsAck() { Layout layout = TestLayoutBuilder.single(9000); bootstrapServer(layout); long newEpoch = layout.getEpoch() + 1; Layout newLayout = TestLayoutBuilder.single(9000); newLayout.setEpoch(newEpoch); setEpoch(newEpoch); sendPrepare(newEpoch, 100); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.LAYOUT_PREPARE_ACK); sendPropose(newEpoch, 100, newLayout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); sendCommitted(newEpoch, newLayout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); } ",
        "focal_tgt": "@SuppressWarnings(\"checkstyle:magicnumber\")private void commitReturnsAck(LayoutServer s1, Integer reboot, long baseEpoch) { if((reboot & 1) > 0) { s1.reboot(); } long newEpoch = baseEpoch + reboot; sendMessage(new CorfuPayloadMsg < > (CorfuMsgType.SET_EPOCH, newEpoch)); Layout layout = TestLayoutBuilder.single(SERVERS.PORT_0); layout.setEpoch(newEpoch); sendPrepare(newEpoch, HIGH_RANK); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.LAYOUT_PREPARE_ACK); if((reboot & 2) > 0) { log.debug(\"Rebooted server because reboot & 2 {}\", reboot & 2); s1.reboot(); } sendPropose(newEpoch, HIGH_RANK, layout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); if((reboot & 4) > 0) { s1.reboot(); } sendCommitted(newEpoch, layout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); if((reboot & 8) > 0) { s1.reboot(); } sendCommitted(newEpoch, layout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); requestLayout(newEpoch); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.LAYOUT_RESPONSE); Assertions.assertThat(((LayoutMsg)getLastMessage()).getLayout()).isEqualTo(layout); } ",
        "focal_src": "private void commitReturnsAck(LayoutServer s1, Integer reboot, long baseEpoch) { if((reboot & 1) > 0) { s1.reboot(); } long newEpoch = baseEpoch + reboot; sendMessage(new CorfuPayloadMsg < > (CorfuMsgType.SET_EPOCH, newEpoch)); Layout layout = TestLayoutBuilder.single(9000); layout.setEpoch(newEpoch); sendPrepare(newEpoch, 100); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.LAYOUT_PREPARE_ACK); if((reboot & 2) > 0) { log.debug(\"Rebooted server because reboot & 2 {}\", reboot & 2); s1.reboot(); } sendPropose(newEpoch, 100, layout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); if((reboot & 4) > 0) { s1.reboot(); } sendCommitted(newEpoch, layout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); if((reboot & 8) > 0) { s1.reboot(); } sendCommitted(newEpoch, layout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); requestLayout(newEpoch); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.LAYOUT_RESPONSE); Assertions.assertThat(((LayoutMsg)getLastMessage()).getLayout()).isEqualTo(layout); } ",
        "test_tgt": "@Test public void commitReturnsAck() { Layout layout = TestLayoutBuilder.single(SERVERS.PORT_0); bootstrapServer(layout); long newEpoch = layout.getEpoch() + 1; Layout newLayout = TestLayoutBuilder.single(SERVERS.PORT_0); newLayout.setEpoch(newEpoch); setEpoch(newEpoch); sendPrepare(newEpoch, HIGH_RANK); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.LAYOUT_PREPARE_ACK); sendPropose(newEpoch, HIGH_RANK, newLayout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); sendCommitted(newEpoch, newLayout); Assertions.assertThat(getLastMessage().getMsgType()).isEqualTo(CorfuMsgType.ACK); } "
    },
    {
        "test_src": "@Test public void saveOrder_shouldSetOrderTypeOfTestOrderToTestOrderIfNotSetAndConceptNotMapped()throws Exception { TestOrder testOrder = new TestOrder(); testOrder.setPatient(patientService.getPatient(7)); Concept unmappedConcept = conceptService.getConcept(113); Assert.assertNull(orderService.getOrderTypeByConcept(unmappedConcept)); testOrder.setConcept(unmappedConcept); testOrder.setOrderer(providerService.getProvider(1)); testOrder.setCareSetting(orderService.getCareSetting(1)); Encounter encounter = encounterService.getEncounter(3); testOrder.setEncounter(encounter); testOrder.setStartDate(encounter.getEncounterDatetime()); testOrder.setClinicalHistory(\"Patient had a negative reaction to the test in the past\"); testOrder.setFrequency(orderService.getOrderFrequency(3)); testOrder.setSpecimenSource(conceptService.getConcept(22)); testOrder.setNumberOfRepeats(3); orderService.saveOrder(testOrder, null); Assert.assertNotNull(testOrder.getOrderType()); Assert.assertEquals(orderService.getOrderTypeByUuid(OrderType.TEST_ORDER_TYPE_UUID), testOrder.getOrderType()); } ",
        "focal_tgt": "public synchronized Order saveOrder(Order order, OrderContext orderContext)throws APIException { if(order.getOrderId() != null) { throw new APIException(\"Cannot edit an existing order, you need to revise it instead\"); } if(order.getDateActivated() == null) { order.setDateActivated(new Date()); } boolean isDrugOrder = DrugOrder.class.isAssignableFrom(getActualType(order)); Concept concept = order.getConcept(); if(concept == null && isDrugOrder) { DrugOrder dOrder = (DrugOrder)order; if(dOrder.getDrug() != null) { concept = dOrder.getDrug().getConcept(); dOrder.setConcept(concept); } } if(concept == null) { throw new APIException(\"concept is required for an order\"); } if( ! isDiscontinueOrReviseOrder(order)) { List < Order > activeOrders = getActiveOrders(order.getPatient(), null, order.getCareSetting(), null); for(Order activeOrder : activeOrders) { if(order.hasSameOrderableAs(activeOrder)) { throw new APIException(\"Cannot have more than one active order for the same orderable and care setting\"); } } } Order previousOrder = order.getPreviousOrder(); if(order.getOrderType() == null) { OrderType orderType = null; if(orderContext != null) { orderType = orderContext.getOrderType(); } if(orderType == null) { orderType = getOrderTypeByConcept(concept); } if(orderType == null && order instanceof DrugOrder) { orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.DRUG_ORDER_TYPE_UUID); } if(orderType == null && order instanceof TestOrder) { orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.TEST_ORDER_TYPE_UUID); } if(orderType == null || (previousOrder != null && ! orderType.equals(previousOrder.getOrderType()))) { throw new APIException(\"Cannot determine the order type of the order, make sure the concept's class is mapped to an order type\"); } order.setOrderType(orderType); } if(order.getCareSetting() == null) { CareSetting careSetting = null; if(orderContext != null) { careSetting = orderContext.getCareSetting(); } if(careSetting == null || (previousOrder != null && ! careSetting.equals(previousOrder.getCareSetting()))) { throw new APIException(\"Cannot determine the care setting of the order\"); } order.setCareSetting(careSetting); } if( ! order.getOrderType().getJavaClass().isAssignableFrom(order.getClass())) { throw new APIException(\"Order type class \" + order.getOrderType().getJavaClass() + \" does not match the order class \" + order.getClass().getName()); } if(REVISE == order.getAction()) { if(previousOrder == null) { throw new APIException(\"Previous Order is required for a revised order\"); } stopOrder(previousOrder, order.getDateActivated()); } else if(DISCONTINUE == order.getAction()) { discontinueExistingOrdersIfNecessary(order); } if(previousOrder != null) { String query = \"SELECT patient_id, care_setting, concept_id FROM orders WHERE order_id = \"; boolean isPreviousDrugOrder = DrugOrder.class.isAssignableFrom(previousOrder.getClass()); if(isPreviousDrugOrder) { query = \"SELECT o.patient_id, o.care_setting, o.concept_id, d.drug_inventory_id \" + \"FROM orders o, drug_order d WHERE o.order_id = d.order_id AND o.order_id =\"; } List < List < Object > > rows = Context.getAdministrationService().executeSQL(query + previousOrder.getOrderId(), true); List < Object > rowData = rows.get(0); if( ! rowData.get(0).equals(previousOrder.getPatient().getPatientId())) { throw new APIException(\"Cannot change the patient of an order\"); } else if( ! rowData.get(1).equals(previousOrder.getCareSetting().getCareSettingId())) { throw new APIException(\"Cannot change the careSetting of an order\"); } else if( ! rowData.get(2).equals(previousOrder.getConcept().getConceptId())) { throw new APIException(\"Cannot change the concept of an order\"); } else if(isPreviousDrugOrder && ! rowData.get(3).equals(((DrugOrder)previousOrder).getDrug().getDrugId())) { throw new APIException(\"Cannot change the drug of a drug order\"); } boolean isDrugOrderAndHasADrug = isDrugOrder && ((DrugOrder)order).getDrug() != null; if( ! OpenmrsUtil.nullSafeEquals(order.getConcept(), previousOrder.getConcept())) { throw new APIException(\"The concept of the previous order and the new one order don't match\"); } else if(isDrugOrderAndHasADrug) { DrugOrder drugOrder1 = (DrugOrder)order; DrugOrder drugOrder2 = (DrugOrder)previousOrder; if( ! OpenmrsUtil.nullSafeEquals(drugOrder1.getDrug(), drugOrder2.getDrug())) { throw new APIException(\"The drug of the previous order and the new one order don't match\"); } } else if( ! order.getOrderType().equals(previousOrder.getOrderType())) { throw new APIException(\"The order type does not match that of the previous order\"); } else if( ! order.getCareSetting().equals(previousOrder.getCareSetting())) { throw new APIException(\"The care setting does not match that of the previous order\"); } else if( ! getActualType(order).equals(getActualType(previousOrder))) { throw new APIException(\"The class does not match that of the previous order\"); } } return saveOrderInternal(order, orderContext); } ",
        "focal_src": "public synchronized Order saveOrder(Order order, OrderContext orderContext)throws APIException { if(order.getOrderId() != null) { throw new APIException(\"Cannot edit an existing order, you need to revise it instead\"); } if(order.getStartDate() == null) { order.setStartDate(new Date()); } boolean isDrugOrder = DrugOrder.class.isAssignableFrom(getActualType(order)); Concept concept = order.getConcept(); if(concept == null && isDrugOrder) { DrugOrder dOrder = (DrugOrder)order; if(dOrder.getDrug() != null) { concept = dOrder.getDrug().getConcept(); dOrder.setConcept(concept); } } if(concept == null) { throw new APIException(\"concept is required for an order\"); } if( ! isDiscontinueOrReviseOrder(order)) { List < Order > activeOrders = getActiveOrders(order.getPatient(), null, order.getCareSetting(), null); for(Order activeOrder : activeOrders) { if(order.hasSameOrderableAs(activeOrder)) { throw new APIException(\"Cannot have more than one active order for the same orderable and care setting\"); } } } Order previousOrder = order.getPreviousOrder(); if(order.getOrderType() == null) { OrderType orderType = null; if(orderContext != null) { orderType = orderContext.getOrderType(); } if(orderType == null) { orderType = getOrderTypeByConcept(concept); } if(orderType == null && order instanceof DrugOrder) { orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.DRUG_ORDER_TYPE_UUID); } if(orderType == null && order instanceof TestOrder) { orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.TEST_ORDER_TYPE_UUID); } if(orderType == null || (previousOrder != null && ! orderType.equals(previousOrder.getOrderType()))) { throw new APIException(\"Cannot determine the order type of the order, make sure the concept's class is mapped to an order type\"); } order.setOrderType(orderType); } if(order.getCareSetting() == null) { CareSetting careSetting = null; if(orderContext != null) { careSetting = orderContext.getCareSetting(); } if(careSetting == null || (previousOrder != null && ! careSetting.equals(previousOrder.getCareSetting()))) { throw new APIException(\"Cannot determine the care setting of the order\"); } order.setCareSetting(careSetting); } if( ! order.getOrderType().getJavaClass().isAssignableFrom(order.getClass())) { throw new APIException(\"Order type class \" + order.getOrderType().getJavaClass() + \" does not match the order class \" + order.getClass().getName()); } if(REVISE == order.getAction()) { if(previousOrder == null) { throw new APIException(\"Previous Order is required for a revised order\"); } stopOrder(previousOrder, order.getStartDate()); } else if(DISCONTINUE == order.getAction()) { discontinueExistingOrdersIfNecessary(order); } if(previousOrder != null) { String query = \"SELECT patient_id, care_setting, concept_id FROM orders WHERE order_id = \"; boolean isPreviousDrugOrder = DrugOrder.class.isAssignableFrom(previousOrder.getClass()); if(isPreviousDrugOrder) { query = \"SELECT o.patient_id, o.care_setting, o.concept_id, d.drug_inventory_id \" + \"FROM orders o, drug_order d WHERE o.order_id = d.order_id AND o.order_id =\"; } List < List < Object > > rows = Context.getAdministrationService().executeSQL(query + previousOrder.getOrderId(), true); List < Object > rowData = rows.get(0); if( ! rowData.get(0).equals(previousOrder.getPatient().getPatientId())) { throw new APIException(\"Cannot change the patient of an order\"); } else if( ! rowData.get(1).equals(previousOrder.getCareSetting().getCareSettingId())) { throw new APIException(\"Cannot change the careSetting of an order\"); } else if( ! rowData.get(2).equals(previousOrder.getConcept().getConceptId())) { throw new APIException(\"Cannot change the concept of an order\"); } else if(isPreviousDrugOrder && ! rowData.get(3).equals(((DrugOrder)previousOrder).getDrug().getDrugId())) { throw new APIException(\"Cannot change the drug of a drug order\"); } boolean isDrugOrderAndHasADrug = isDrugOrder && ((DrugOrder)order).getDrug() != null; if( ! OpenmrsUtil.nullSafeEquals(order.getConcept(), previousOrder.getConcept())) { throw new APIException(\"The concept of the previous order and the new one order don't match\"); } else if(isDrugOrderAndHasADrug) { DrugOrder drugOrder1 = (DrugOrder)order; DrugOrder drugOrder2 = (DrugOrder)previousOrder; if( ! OpenmrsUtil.nullSafeEquals(drugOrder1.getDrug(), drugOrder2.getDrug())) { throw new APIException(\"The drug of the previous order and the new one order don't match\"); } } else if( ! order.getOrderType().equals(previousOrder.getOrderType())) { throw new APIException(\"The order type does not match that of the previous order\"); } else if( ! order.getCareSetting().equals(previousOrder.getCareSetting())) { throw new APIException(\"The care setting does not match that of the previous order\"); } else if( ! getActualType(order).equals(getActualType(previousOrder))) { throw new APIException(\"The class does not match that of the previous order\"); } } return saveOrderInternal(order, orderContext); } ",
        "test_tgt": "@Test public void saveOrder_shouldSetOrderTypeOfTestOrderToTestOrderIfNotSetAndConceptNotMapped()throws Exception { TestOrder testOrder = new TestOrder(); testOrder.setPatient(patientService.getPatient(7)); Concept unmappedConcept = conceptService.getConcept(113); Assert.assertNull(orderService.getOrderTypeByConcept(unmappedConcept)); testOrder.setConcept(unmappedConcept); testOrder.setOrderer(providerService.getProvider(1)); testOrder.setCareSetting(orderService.getCareSetting(1)); Encounter encounter = encounterService.getEncounter(3); testOrder.setEncounter(encounter); testOrder.setDateActivated(encounter.getEncounterDatetime()); testOrder.setClinicalHistory(\"Patient had a negative reaction to the test in the past\"); testOrder.setFrequency(orderService.getOrderFrequency(3)); testOrder.setSpecimenSource(conceptService.getConcept(22)); testOrder.setNumberOfRepeats(3); orderService.saveOrder(testOrder, null); Assert.assertNotNull(testOrder.getOrderType()); Assert.assertEquals(orderService.getOrderTypeByUuid(OrderType.TEST_ORDER_TYPE_UUID), testOrder.getOrderType()); } "
    },
    {
        "test_src": "@Test@LocalAlluxioClusterResource.Config(confParams = { PropertyKey.Name.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\", PropertyKey.Name.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\", PropertyKey.Name.SECURITY_GROUP_MAPPING_CLASS, \"alluxio.security.group.provider.IdentityUserGroupsMapping\", PropertyKey.Name.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, \"test_user_ls\" })public void ls()throws Exception { String testUser = \"test_user_ls\"; clearAndLogin(testUser); URIStatus[]files = createFiles(); mFsShell.run(\"ls\", \"/testRoot\"); String expected = \"\"; expected += getLsResultStr(\"/testRoot/testFileA\", files[0].getCreationTimeMs(), 10, LsCommand.STATE_FILE_IN_MEMORY, testUser, testUser, files[0].getMode(), files[0].isFolder()); expected += getLsResultStr(\"/testRoot/testDir\", files[1].getCreationTimeMs(), 1, LsCommand.STATE_FOLDER, testUser, testUser, files[1].getMode(), files[1].isFolder()); expected += getLsResultStr(\"/testRoot/testFileC\", files[3].getCreationTimeMs(), 30, LsCommand.STATE_FILE_NOT_IN_MEMORY, testUser, testUser, files[3].getMode(), files[3].isFolder()); Assert.assertEquals(expected, mOutput.toString()); } ",
        "focal_tgt": "private void ls(AlluxioURI path, boolean recursive, boolean forceLoadMetadata, boolean dirAsFile, boolean hSize, boolean pinnedOnly)throws AlluxioException, IOException { if(dirAsFile) { URIStatus status = mFileSystem.getStatus(path); if(pinnedOnly && ! status.isPinned()) { return; } printLsString(status, hSize); return; } ListStatusOptions options = ListStatusOptions.defaults(); if(forceLoadMetadata) { options.setLoadMetadataType(LoadMetadataType.Always); } List < URIStatus > statuses = listStatusSortedByIncreasingCreationTime(path, options); for(URIStatus status : statuses) { if( ! pinnedOnly || status.isPinned()) { printLsString(status, hSize); } if(recursive && status.isFolder()) { ls(new AlluxioURI(path.getScheme(), path.getAuthority(), status.getPath()), true, forceLoadMetadata, false, hSize, pinnedOnly); } } } ",
        "focal_src": "private void ls(AlluxioURI path, boolean recursive, boolean forceLoadMetadata, boolean dirAsFile, boolean rawSize, boolean pinnedOnly)throws AlluxioException, IOException { if(dirAsFile) { URIStatus status = mFileSystem.getStatus(path); if(pinnedOnly && ! status.isPinned()) { return; } printLsString(status, rawSize); return; } ListStatusOptions options = ListStatusOptions.defaults(); if(forceLoadMetadata) { options.setLoadMetadataType(LoadMetadataType.Always); } List < URIStatus > statuses = listStatusSortedByIncreasingCreationTime(path, options); for(URIStatus status : statuses) { if( ! pinnedOnly || status.isPinned()) { printLsString(status, rawSize); } if(recursive && status.isFolder()) { ls(new AlluxioURI(path.getScheme(), path.getAuthority(), status.getPath()), true, forceLoadMetadata, false, rawSize, pinnedOnly); } } } ",
        "test_tgt": "@Test@LocalAlluxioClusterResource.Config(confParams = { PropertyKey.Name.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\", PropertyKey.Name.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\", PropertyKey.Name.SECURITY_GROUP_MAPPING_CLASS, \"alluxio.security.group.provider.IdentityUserGroupsMapping\", PropertyKey.Name.SECURITY_AUTHORIZATION_PERMISSION_SUPERGROUP, \"test_user_ls\" })public void ls()throws Exception { String testUser = \"test_user_ls\"; clearAndLogin(testUser); URIStatus[]files = createFiles(); mFsShell.run(\"ls\", \"/testRoot\"); String expected = \"\"; expected += getLsResultStr(\"/testRoot/testFileA\", files[0].getCreationTimeMs(), String.valueOf(10), LsCommand.STATE_FILE_IN_MEMORY, testUser, testUser, files[0].getMode(), files[0].isFolder()); expected += getLsResultStr(\"/testRoot/testDir\", files[1].getCreationTimeMs(), String.valueOf(1), LsCommand.STATE_FOLDER, testUser, testUser, files[1].getMode(), files[1].isFolder()); expected += getLsResultStr(\"/testRoot/testFileC\", files[3].getCreationTimeMs(), String.valueOf(30), LsCommand.STATE_FILE_NOT_IN_MEMORY, testUser, testUser, files[3].getMode(), files[3].isFolder()); Assert.assertEquals(expected, mOutput.toString()); } "
    },
    {
        "test_src": "@Test public void testGt() { assertTrue(instance.gt(\"id\", 5).getQueryCriterions().contains(new GtCriterion(\"id\", 5))); } ",
        "focal_tgt": "public CriteriaQuery gt(String propName, Comparable < ? > value) { criterion = criterion.and(criterionBuilder.gt(propName, value)); return this; } ",
        "focal_src": "public CriteriaQuery gt(String propName, Comparable < ? > value) { addCriterion(criterionBuilder.gt(propName, value)); return this; } ",
        "test_tgt": "@Test public void testGt() { assertEquals(new GtCriterion(\"id\", 5), instance.gt(\"id\", 5).getQueryCriterion()); } "
    },
    {
        "test_src": "@Test public void testExtract() { logger.info(\"extract\"); String text = \"In publishing and graphic design, lorem ipsum[1] is a placeholder text (filler text) commonly used to demonstrate the graphic elements of a document or visual presentation, such as font, typography, and layout, by removing the distraction of meaningful content. The lorem ipsum text is typically a section of a Latin text by Cicero with words altered, added, and removed that make it nonsensical and not proper Latin.[1] In publishing and graphic design, lorem ipsum[1] is a placeholder text (filler text) commonly used to demonstrate the graphic elements of a document or visual presentation, such as font, typography, and layout, by removing the distraction of meaningful content. The lorem ipsum text is typically a section of a Latin text by Cicero with words altered, added, and removed that make it nonsensical and not proper Latin.[1]\"; NgramsExtractor instance = new NgramsExtractor(new NgramsExtractor.Parameters()); Map < String, Double > expResult = new HashMap < > (); expResult.put(\"In\", 2.0); expResult.put(\"publishing\", 2.0); expResult.put(\"and\", 8.0); expResult.put(\"graphic\", 4.0); expResult.put(\"design,\", 2.0); expResult.put(\"lorem\", 4.0); expResult.put(\"ipsum[1]\", 2.0); expResult.put(\"is\", 4.0); expResult.put(\"a\", 8.0); expResult.put(\"placeholder\", 2.0); expResult.put(\"text\", 6.0); expResult.put(\"(filler\", 2.0); expResult.put(\"text)\", 2.0); expResult.put(\"commonly\", 2.0); expResult.put(\"used\", 2.0); expResult.put(\"to\", 2.0); expResult.put(\"demonstrate\", 2.0); expResult.put(\"the\", 4.0); expResult.put(\"elements\", 2.0); expResult.put(\"of\", 6.0); expResult.put(\"document\", 2.0); expResult.put(\"or\", 2.0); expResult.put(\"visual\", 2.0); expResult.put(\"presentation,\", 2.0); expResult.put(\"such\", 2.0); expResult.put(\"as\", 2.0); expResult.put(\"font,\", 2.0); expResult.put(\"typography,\", 2.0); expResult.put(\"layout,\", 2.0); expResult.put(\"by\", 4.0); expResult.put(\"removing\", 2.0); expResult.put(\"distraction\", 2.0); expResult.put(\"meaningful\", 2.0); expResult.put(\"content.\", 2.0); expResult.put(\"The\", 2.0); expResult.put(\"ipsum\", 2.0); expResult.put(\"typically\", 2.0); expResult.put(\"section\", 2.0); expResult.put(\"Latin\", 2.0); expResult.put(\"Cicero\", 2.0); expResult.put(\"with\", 2.0); expResult.put(\"words\", 2.0); expResult.put(\"altered,\", 2.0); expResult.put(\"added,\", 2.0); expResult.put(\"removed\", 2.0); expResult.put(\"that\", 2.0); expResult.put(\"make\", 2.0); expResult.put(\"it\", 2.0); expResult.put(\"nonsensical\", 2.0); expResult.put(\"not\", 2.0); expResult.put(\"proper\", 2.0); expResult.put(\"Latin.[1]\", 2.0); expResult.put(\"In publishing\", 2.0); expResult.put(\"publishing and\", 2.0); expResult.put(\"and graphic\", 2.0); expResult.put(\"graphic design,\", 2.0); expResult.put(\"design, lorem\", 2.0); expResult.put(\"lorem ipsum[1]\", 2.0); expResult.put(\"ipsum[1] is\", 2.0); expResult.put(\"is a\", 2.0); expResult.put(\"a placeholder\", 2.0); expResult.put(\"placeholder text\", 2.0); expResult.put(\"text (filler\", 2.0); expResult.put(\"(filler text)\", 2.0); expResult.put(\"text) commonly\", 2.0); expResult.put(\"commonly used\", 2.0); expResult.put(\"used to\", 2.0); expResult.put(\"to demonstrate\", 2.0); expResult.put(\"demonstrate the\", 2.0); expResult.put(\"the graphic\", 2.0); expResult.put(\"graphic elements\", 2.0); expResult.put(\"elements of\", 2.0); expResult.put(\"of a\", 4.0); expResult.put(\"a document\", 2.0); expResult.put(\"document or\", 2.0); expResult.put(\"or visual\", 2.0); expResult.put(\"visual presentation,\", 2.0); expResult.put(\"presentation, such\", 2.0); expResult.put(\"such as\", 2.0); expResult.put(\"as font,\", 2.0); expResult.put(\"font, typography,\", 2.0); expResult.put(\"typography, and\", 2.0); expResult.put(\"and layout,\", 2.0); expResult.put(\"layout, by\", 2.0); expResult.put(\"by removing\", 2.0); expResult.put(\"removing the\", 2.0); expResult.put(\"the distraction\", 2.0); expResult.put(\"distraction of\", 2.0); expResult.put(\"of meaningful\", 2.0); expResult.put(\"meaningful content.\", 2.0); expResult.put(\"content. The\", 2.0); expResult.put(\"The lorem\", 2.0); expResult.put(\"lorem ipsum\", 2.0); expResult.put(\"ipsum text\", 2.0); expResult.put(\"text is\", 2.0); expResult.put(\"is typically\", 2.0); expResult.put(\"typically a\", 2.0); expResult.put(\"a section\", 2.0); expResult.put(\"section of\", 2.0); expResult.put(\"a Latin\", 2.0); expResult.put(\"Latin text\", 2.0); expResult.put(\"text by\", 2.0); expResult.put(\"by Cicero\", 2.0); expResult.put(\"Cicero with\", 2.0); expResult.put(\"with words\", 2.0); expResult.put(\"words altered,\", 2.0); expResult.put(\"altered, added,\", 2.0); expResult.put(\"added, and\", 2.0); expResult.put(\"and removed\", 2.0); expResult.put(\"removed that\", 2.0); expResult.put(\"that make\", 2.0); expResult.put(\"make it\", 2.0); expResult.put(\"it nonsensical\", 2.0); expResult.put(\"nonsensical and\", 2.0); expResult.put(\"and not\", 2.0); expResult.put(\"not proper\", 2.0); expResult.put(\"proper Latin.[1]\", 2.0); expResult.put(\"Latin.[1] In\", 1.0); expResult.put(\"In publishing and\", 2.0); expResult.put(\"publishing and graphic\", 2.0); expResult.put(\"and graphic design,\", 2.0); expResult.put(\"graphic design, lorem\", 2.0); expResult.put(\"design, lorem ipsum[1]\", 2.0); expResult.put(\"lorem ipsum[1] is\", 2.0); expResult.put(\"ipsum[1] is a\", 2.0); expResult.put(\"is a placeholder\", 2.0); expResult.put(\"a placeholder text\", 2.0); expResult.put(\"placeholder text (filler\", 2.0); expResult.put(\"text (filler text)\", 2.0); expResult.put(\"(filler text) commonly\", 2.0); expResult.put(\"text) commonly used\", 2.0); expResult.put(\"commonly used to\", 2.0); expResult.put(\"used to demonstrate\", 2.0); expResult.put(\"to demonstrate the\", 2.0); expResult.put(\"demonstrate the graphic\", 2.0); expResult.put(\"the graphic elements\", 2.0); expResult.put(\"graphic elements of\", 2.0); expResult.put(\"elements of a\", 2.0); expResult.put(\"of a document\", 2.0); expResult.put(\"a document or\", 2.0); expResult.put(\"document or visual\", 2.0); expResult.put(\"or visual presentation,\", 2.0); expResult.put(\"visual presentation, such\", 2.0); expResult.put(\"presentation, such as\", 2.0); expResult.put(\"such as font,\", 2.0); expResult.put(\"as font, typography,\", 2.0); expResult.put(\"font, typography, and\", 2.0); expResult.put(\"typography, and layout,\", 2.0); expResult.put(\"and layout, by\", 2.0); expResult.put(\"layout, by removing\", 2.0); expResult.put(\"by removing the\", 2.0); expResult.put(\"removing the distraction\", 2.0); expResult.put(\"the distraction of\", 2.0); expResult.put(\"distraction of meaningful\", 2.0); expResult.put(\"of meaningful content.\", 2.0); expResult.put(\"meaningful content. The\", 2.0); expResult.put(\"content. The lorem\", 2.0); expResult.put(\"The lorem ipsum\", 2.0); expResult.put(\"lorem ipsum text\", 2.0); expResult.put(\"ipsum text is\", 2.0); expResult.put(\"text is typically\", 2.0); expResult.put(\"is typically a\", 2.0); expResult.put(\"typically a section\", 2.0); expResult.put(\"a section of\", 2.0); expResult.put(\"section of a\", 2.0); expResult.put(\"of a Latin\", 2.0); expResult.put(\"a Latin text\", 2.0); expResult.put(\"Latin text by\", 2.0); expResult.put(\"text by Cicero\", 2.0); expResult.put(\"by Cicero with\", 2.0); expResult.put(\"Cicero with words\", 2.0); expResult.put(\"with words altered,\", 2.0); expResult.put(\"words altered, added,\", 2.0); expResult.put(\"altered, added, and\", 2.0); expResult.put(\"added, and removed\", 2.0); expResult.put(\"and removed that\", 2.0); expResult.put(\"removed that make\", 2.0); expResult.put(\"that make it\", 2.0); expResult.put(\"make it nonsensical\", 2.0); expResult.put(\"it nonsensical and\", 2.0); expResult.put(\"nonsensical and not\", 2.0); expResult.put(\"and not proper\", 2.0); expResult.put(\"not proper Latin.[1]\", 2.0); expResult.put(\"proper Latin.[1] In\", 1.0); expResult.put(\"Latin.[1] In publishing\", 1.0); Map < String, Double > result = instance.extract(text); assertEquals(expResult, result); } ",
        "focal_tgt": "@Override public Map < String, Double > extract(final String text) { Map < Integer, String > ID2word = new HashMap < > (); Map < Integer, Double > ID2occurrences = new HashMap < > (); Map < Integer, Integer > position2ID = new LinkedHashMap < > (); int numberOfWordsInDoc = buildInternalArrays(text, ID2word, ID2occurrences, position2ID); int maxCombinations = parameters.getMaxCombinations(); Map < String, Double > keywordsMap = new HashMap < > (); for(Map.Entry < Integer, Integer > entry : position2ID.entrySet()) { Integer wordID = entry.getValue(); if( ! useThisWord(wordID, ID2word, ID2occurrences)) { continue; } Integer position = entry.getKey(); Map < LinkedList < Integer > , Double > positionCombinationsWithScores = getPositionCombinationsWithinWindow(position, maxCombinations, ID2word, ID2occurrences, position2ID, numberOfWordsInDoc); for(Map.Entry < LinkedList < Integer > , Double > entry2 : positionCombinationsWithScores.entrySet()) { LinkedList < Integer > positionCombination = entry2.getKey(); StringBuilder sb = new StringBuilder(positionCombination.size() * 6); for(Integer pos : positionCombination) { sb.append(ID2word.get(position2ID.get(pos))).append(\" \"); } if(sb.length() > 0) { String key = sb.toString().trim(); double score = entry2.getValue(); keywordsMap.put(key, keywordsMap.getOrDefault(key, 0.0) + score); } } } double minScore = parameters.getMinWordOccurrence(); Iterator < Map.Entry < String, Double > > it = keywordsMap.entrySet().iterator(); while(it.hasNext()) { Map.Entry < String, Double > entry = it.next(); if(entry.getValue() < minScore) { it.remove(); } } return keywordsMap; } ",
        "focal_src": "@Override public Map < String, Double > extract(final String text) { Map < Integer, String > ID2word = new HashMap < > (); Map < Integer, Double > ID2occurrences = new HashMap < > (); Map < Integer, Integer > position2ID = new LinkedHashMap < > (); int numberOfWordsInDoc = buildInternalArrays(text, ID2word, ID2occurrences, position2ID); Map < String, Double > keywordProximityScores = new HashMap < > (); for(Map.Entry < Integer, Integer > entry : position2ID.entrySet()) { Integer wordID = entry.getValue(); if( ! useThisWord(wordID, ID2word, ID2occurrences)) { continue; } Integer position = entry.getKey(); Map < String, Integer > wordCombinations = getCombinationsWithinWindow(position, parameters.getMaxCombinations(), ID2word, ID2occurrences, position2ID, numberOfWordsInDoc); for(Map.Entry < String, Integer > entry2 : wordCombinations.entrySet()) { String IDcombinationReverse = entry2.getKey(); Integer wordsBetween = entry2.getValue(); int numberOfWords = PHPMethods.substr_count(IDcombinationReverse, SEPARATOR) - 1; int extraWords = wordsBetween - numberOfWords; Double proximityScore = keywordProximityScores.get(IDcombinationReverse); if(proximityScore == null) { proximityScore = 0.0; } if(extraWords <= 0) { ++ proximityScore; } else { proximityScore += 0.5 * extraWords; } keywordProximityScores.put(IDcombinationReverse, proximityScore); } } Map < String, Double > keywordsMap = new HashMap < > (); for(Map.Entry < String, Double > entry : keywordProximityScores.entrySet()) { Double proximityScore = entry.getValue(); if(proximityScore >= parameters.getMinWordOccurrence()) { String IDcombinationReverse = entry.getKey(); String[]listOfWordIDsReverse = StringUtils.split(IDcombinationReverse, SEPARATOR); StringBuilder sb = new StringBuilder(listOfWordIDsReverse.length * 6); for(int i = listOfWordIDsReverse.length - 1; i >= 0; -- i) { Integer ID = Integer.valueOf(listOfWordIDsReverse[i]); sb.append(ID2word.get(ID)).append(\" \"); } if(sb.length() > 0) { keywordsMap.put(sb.toString().trim(), proximityScore); } } } return keywordsMap; } ",
        "test_tgt": "@Test public void testExtract() { logger.info(\"extract\"); String text = \"In publishing and graphic design, lorem ipsum[1] is a placeholder text (filler text) commonly used to demonstrate the graphic elements of a document or visual presentation, such as font, typography, and layout, by removing the distraction of meaningful content. The lorem ipsum text is typically a section of a Latin text by Cicero with words altered, added, and removed that make it nonsensical and not proper Latin.[1] In publishing and graphic design, lorem ipsum[1] is a placeholder text (filler text) commonly used to demonstrate the graphic elements of a document or visual presentation, such as font, typography, and layout, by removing the distraction of meaningful content. The lorem ipsum text is typically a section of a Latin text by Cicero with words altered, added, and removed that make it nonsensical and not proper Latin.[1]\"; NgramsExtractor.Parameters p = new NgramsExtractor.Parameters(); p.setMaxDistanceBetweenKwds(0); NgramsExtractor instance = new NgramsExtractor(p); Map < String, Double > expResult = new HashMap < > (); expResult.put(\"In\", 2.0); expResult.put(\"publishing\", 2.0); expResult.put(\"and\", 8.0); expResult.put(\"graphic\", 4.0); expResult.put(\"design,\", 2.0); expResult.put(\"lorem\", 4.0); expResult.put(\"ipsum[1]\", 2.0); expResult.put(\"is\", 4.0); expResult.put(\"a\", 8.0); expResult.put(\"placeholder\", 2.0); expResult.put(\"text\", 6.0); expResult.put(\"(filler\", 2.0); expResult.put(\"text)\", 2.0); expResult.put(\"commonly\", 2.0); expResult.put(\"used\", 2.0); expResult.put(\"to\", 2.0); expResult.put(\"demonstrate\", 2.0); expResult.put(\"the\", 4.0); expResult.put(\"elements\", 2.0); expResult.put(\"of\", 6.0); expResult.put(\"document\", 2.0); expResult.put(\"or\", 2.0); expResult.put(\"visual\", 2.0); expResult.put(\"presentation,\", 2.0); expResult.put(\"such\", 2.0); expResult.put(\"as\", 2.0); expResult.put(\"font,\", 2.0); expResult.put(\"typography,\", 2.0); expResult.put(\"layout,\", 2.0); expResult.put(\"by\", 4.0); expResult.put(\"removing\", 2.0); expResult.put(\"distraction\", 2.0); expResult.put(\"meaningful\", 2.0); expResult.put(\"content.\", 2.0); expResult.put(\"The\", 2.0); expResult.put(\"ipsum\", 2.0); expResult.put(\"typically\", 2.0); expResult.put(\"section\", 2.0); expResult.put(\"Latin\", 2.0); expResult.put(\"Cicero\", 2.0); expResult.put(\"with\", 2.0); expResult.put(\"words\", 2.0); expResult.put(\"altered,\", 2.0); expResult.put(\"added,\", 2.0); expResult.put(\"removed\", 2.0); expResult.put(\"that\", 2.0); expResult.put(\"make\", 2.0); expResult.put(\"it\", 2.0); expResult.put(\"nonsensical\", 2.0); expResult.put(\"not\", 2.0); expResult.put(\"proper\", 2.0); expResult.put(\"Latin.[1]\", 2.0); expResult.put(\"In publishing\", 2.0); expResult.put(\"publishing and\", 2.0); expResult.put(\"and graphic\", 2.0); expResult.put(\"graphic design,\", 2.0); expResult.put(\"design, lorem\", 2.0); expResult.put(\"lorem ipsum[1]\", 2.0); expResult.put(\"ipsum[1] is\", 2.0); expResult.put(\"is a\", 2.0); expResult.put(\"a placeholder\", 2.0); expResult.put(\"placeholder text\", 2.0); expResult.put(\"text (filler\", 2.0); expResult.put(\"(filler text)\", 2.0); expResult.put(\"text) commonly\", 2.0); expResult.put(\"commonly used\", 2.0); expResult.put(\"used to\", 2.0); expResult.put(\"to demonstrate\", 2.0); expResult.put(\"demonstrate the\", 2.0); expResult.put(\"the graphic\", 2.0); expResult.put(\"graphic elements\", 2.0); expResult.put(\"elements of\", 2.0); expResult.put(\"of a\", 4.0); expResult.put(\"a document\", 2.0); expResult.put(\"document or\", 2.0); expResult.put(\"or visual\", 2.0); expResult.put(\"visual presentation,\", 2.0); expResult.put(\"presentation, such\", 2.0); expResult.put(\"such as\", 2.0); expResult.put(\"as font,\", 2.0); expResult.put(\"font, typography,\", 2.0); expResult.put(\"typography, and\", 2.0); expResult.put(\"and layout,\", 2.0); expResult.put(\"layout, by\", 2.0); expResult.put(\"by removing\", 2.0); expResult.put(\"removing the\", 2.0); expResult.put(\"the distraction\", 2.0); expResult.put(\"distraction of\", 2.0); expResult.put(\"of meaningful\", 2.0); expResult.put(\"meaningful content.\", 2.0); expResult.put(\"content. The\", 2.0); expResult.put(\"The lorem\", 2.0); expResult.put(\"lorem ipsum\", 2.0); expResult.put(\"ipsum text\", 2.0); expResult.put(\"text is\", 2.0); expResult.put(\"is typically\", 2.0); expResult.put(\"typically a\", 2.0); expResult.put(\"a section\", 2.0); expResult.put(\"section of\", 2.0); expResult.put(\"a Latin\", 2.0); expResult.put(\"Latin text\", 2.0); expResult.put(\"text by\", 2.0); expResult.put(\"by Cicero\", 2.0); expResult.put(\"Cicero with\", 2.0); expResult.put(\"with words\", 2.0); expResult.put(\"words altered,\", 2.0); expResult.put(\"altered, added,\", 2.0); expResult.put(\"added, and\", 2.0); expResult.put(\"and removed\", 2.0); expResult.put(\"removed that\", 2.0); expResult.put(\"that make\", 2.0); expResult.put(\"make it\", 2.0); expResult.put(\"it nonsensical\", 2.0); expResult.put(\"nonsensical and\", 2.0); expResult.put(\"and not\", 2.0); expResult.put(\"not proper\", 2.0); expResult.put(\"proper Latin.[1]\", 2.0); expResult.put(\"Latin.[1] In\", 1.0); expResult.put(\"In publishing and\", 2.0); expResult.put(\"publishing and graphic\", 2.0); expResult.put(\"and graphic design,\", 2.0); expResult.put(\"graphic design, lorem\", 2.0); expResult.put(\"design, lorem ipsum[1]\", 2.0); expResult.put(\"lorem ipsum[1] is\", 2.0); expResult.put(\"ipsum[1] is a\", 2.0); expResult.put(\"is a placeholder\", 2.0); expResult.put(\"a placeholder text\", 2.0); expResult.put(\"placeholder text (filler\", 2.0); expResult.put(\"text (filler text)\", 2.0); expResult.put(\"(filler text) commonly\", 2.0); expResult.put(\"text) commonly used\", 2.0); expResult.put(\"commonly used to\", 2.0); expResult.put(\"used to demonstrate\", 2.0); expResult.put(\"to demonstrate the\", 2.0); expResult.put(\"demonstrate the graphic\", 2.0); expResult.put(\"the graphic elements\", 2.0); expResult.put(\"graphic elements of\", 2.0); expResult.put(\"elements of a\", 2.0); expResult.put(\"of a document\", 2.0); expResult.put(\"a document or\", 2.0); expResult.put(\"document or visual\", 2.0); expResult.put(\"or visual presentation,\", 2.0); expResult.put(\"visual presentation, such\", 2.0); expResult.put(\"presentation, such as\", 2.0); expResult.put(\"such as font,\", 2.0); expResult.put(\"as font, typography,\", 2.0); expResult.put(\"font, typography, and\", 2.0); expResult.put(\"typography, and layout,\", 2.0); expResult.put(\"and layout, by\", 2.0); expResult.put(\"layout, by removing\", 2.0); expResult.put(\"by removing the\", 2.0); expResult.put(\"removing the distraction\", 2.0); expResult.put(\"the distraction of\", 2.0); expResult.put(\"distraction of meaningful\", 2.0); expResult.put(\"of meaningful content.\", 2.0); expResult.put(\"meaningful content. The\", 2.0); expResult.put(\"content. The lorem\", 2.0); expResult.put(\"The lorem ipsum\", 2.0); expResult.put(\"lorem ipsum text\", 2.0); expResult.put(\"ipsum text is\", 2.0); expResult.put(\"text is typically\", 2.0); expResult.put(\"is typically a\", 2.0); expResult.put(\"typically a section\", 2.0); expResult.put(\"a section of\", 2.0); expResult.put(\"section of a\", 2.0); expResult.put(\"of a Latin\", 2.0); expResult.put(\"a Latin text\", 2.0); expResult.put(\"Latin text by\", 2.0); expResult.put(\"text by Cicero\", 2.0); expResult.put(\"by Cicero with\", 2.0); expResult.put(\"Cicero with words\", 2.0); expResult.put(\"with words altered,\", 2.0); expResult.put(\"words altered, added,\", 2.0); expResult.put(\"altered, added, and\", 2.0); expResult.put(\"added, and removed\", 2.0); expResult.put(\"and removed that\", 2.0); expResult.put(\"removed that make\", 2.0); expResult.put(\"that make it\", 2.0); expResult.put(\"make it nonsensical\", 2.0); expResult.put(\"it nonsensical and\", 2.0); expResult.put(\"nonsensical and not\", 2.0); expResult.put(\"and not proper\", 2.0); expResult.put(\"not proper Latin.[1]\", 2.0); expResult.put(\"proper Latin.[1] In\", 1.0); expResult.put(\"Latin.[1] In publishing\", 1.0); Map < String, Double > result = instance.extract(text); assertEquals(expResult, result); } "
    },
    {
        "test_src": "@Test public void testTrainAndValidate() { logger.info(\"testTrainAndValidate\"); Configuration conf = Configuration.getConfiguration(); Dataframe[]data = Datasets.carsNumeric(conf); Dataframe trainingData = data[0]; Dataframe validationData = data[1]; String dbName = this.getClass().getSimpleName(); Modeler instance = new Modeler(dbName, conf); Modeler.TrainingParameters trainingParameters = new Modeler.TrainingParameters(); trainingParameters.setModelerClass(MultinomialNaiveBayes.class); MultinomialNaiveBayes.TrainingParameters modelTrainingParameters = new MultinomialNaiveBayes.TrainingParameters(); modelTrainingParameters.setMultiProbabilityWeighted(true); trainingParameters.setModelerTrainingParameters(modelTrainingParameters); trainingParameters.setDataTransformerClass(DummyXMinMaxNormalizer.class); DummyXMinMaxNormalizer.TrainingParameters dtParams = new DummyXMinMaxNormalizer.TrainingParameters(); trainingParameters.setDataTransformerTrainingParameters(dtParams); trainingParameters.setFeatureSelectorClass(null); trainingParameters.setFeatureSelectorTrainingParameters(null); instance.fit(trainingData, trainingParameters); instance.predict(trainingData); ClassificationMetrics vm = new ClassificationMetrics(trainingData); double expResult2 = 0.8; assertEquals(expResult2, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); instance.close(); logger.info(\"validate\"); instance = new Modeler(dbName, conf); instance.predict(validationData); Map < Integer, Object > expResult = new HashMap < > (); Map < Integer, Object > result = new HashMap < > (); for(Map.Entry < Integer, Record > e : validationData.entries()) { Integer rId = e.getKey(); Record r = e.getValue(); expResult.put(rId, r.getY()); result.put(rId, r.getYPredicted()); } assertEquals(expResult, result); instance.delete(); trainingData.delete(); validationData.delete(); } ",
        "focal_tgt": "private < ML extends AbstractClassifier, FS extends AbstractFeatureSelector > void trainAndValidate(Class < ML > modelerClass, ML.AbstractTrainingParameters modelerTrainingParameters, Class < FS > featureSelectorClass, FS.AbstractTrainingParameters featureSelectorTrainingParameters, double expectedF1score) { Configuration conf = Configuration.getConfiguration(); String dbName = this.getClass().getSimpleName(); Map < Object, URI > dataset = new HashMap < > (); try { dataset.put(\"negative\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.neg.txt\").toURI()); dataset.put(\"positive\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.pos.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } TextClassifier.TrainingParameters trainingParameters = new TextClassifier.TrainingParameters(); trainingParameters.setModelerClass(modelerClass); trainingParameters.setModelerTrainingParameters(modelerTrainingParameters); trainingParameters.setDataTransformerClass(null); trainingParameters.setDataTransformerTrainingParameters(null); trainingParameters.setFeatureSelectorClass(featureSelectorClass); trainingParameters.setFeatureSelectorTrainingParameters(featureSelectorTrainingParameters); trainingParameters.setTextExtractorClass(NgramsExtractor.class); NgramsExtractor.Parameters exParams = new NgramsExtractor.Parameters(); exParams.setMaxDistanceBetweenKwds(2); exParams.setExaminationWindowLength(6); trainingParameters.setTextExtractorParameters(exParams); TextClassifier instance = new TextClassifier(dbName, conf, trainingParameters); instance.fit(dataset); ClassificationMetrics vm = instance.validate(dataset); assertEquals(expectedF1score, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); instance.close(); instance = new TextClassifier(dbName, conf); Dataframe validationData = null; try { validationData = instance.predict(this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.unlabelled.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } List < Object > expResult = Arrays.asList(\"negative\", \"positive\"); int i = 0; for(Record r : validationData.values()) { assertEquals(expResult.get(i), r.getYPredicted()); ++ i; } instance.delete(); validationData.delete(); } ",
        "focal_src": "private < ML extends AbstractClassifier, FS extends AbstractFeatureSelector > void trainAndValidate(Class < ML > modelerClass, ML.AbstractTrainingParameters modelerTrainingParameters, Class < FS > featureSelectorClass, FS.AbstractTrainingParameters featureSelectorTrainingParameters, double expectedF1score) { Configuration conf = Configuration.getConfiguration(); String dbName = this.getClass().getSimpleName(); Map < Object, URI > dataset = new HashMap < > (); try { dataset.put(\"negative\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.neg.txt\").toURI()); dataset.put(\"positive\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.pos.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } TextClassifier instance = new TextClassifier(dbName, conf); TextClassifier.TrainingParameters trainingParameters = new TextClassifier.TrainingParameters(); trainingParameters.setModelerClass(modelerClass); trainingParameters.setModelerTrainingParameters(modelerTrainingParameters); trainingParameters.setDataTransformerClass(null); trainingParameters.setDataTransformerTrainingParameters(null); trainingParameters.setFeatureSelectorClass(featureSelectorClass); trainingParameters.setFeatureSelectorTrainingParameters(featureSelectorTrainingParameters); trainingParameters.setTextExtractorClass(NgramsExtractor.class); NgramsExtractor.Parameters exParams = new NgramsExtractor.Parameters(); exParams.setMaxDistanceBetweenKwds(2); exParams.setExaminationWindowLength(6); trainingParameters.setTextExtractorParameters(exParams); instance.fit(dataset, trainingParameters); ClassificationMetrics vm = instance.validate(dataset); assertEquals(expectedF1score, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); instance.close(); instance = new TextClassifier(dbName, conf); Dataframe validationData = null; try { validationData = instance.predict(this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.unlabelled.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } List < Object > expResult = Arrays.asList(\"negative\", \"positive\"); int i = 0; for(Record r : validationData.values()) { assertEquals(expResult.get(i), r.getYPredicted()); ++ i; } instance.delete(); validationData.delete(); } ",
        "test_tgt": "@Test public void testTrainAndValidate() { logger.info(\"testTrainAndValidate\"); Configuration conf = Configuration.getConfiguration(); Dataframe[]data = Datasets.carsNumeric(conf); Dataframe trainingData = data[0]; Dataframe validationData = data[1]; String dbName = this.getClass().getSimpleName(); Modeler.TrainingParameters trainingParameters = new Modeler.TrainingParameters(); trainingParameters.setModelerClass(MultinomialNaiveBayes.class); MultinomialNaiveBayes.TrainingParameters modelTrainingParameters = new MultinomialNaiveBayes.TrainingParameters(); modelTrainingParameters.setMultiProbabilityWeighted(true); trainingParameters.setModelerTrainingParameters(modelTrainingParameters); trainingParameters.setDataTransformerClass(DummyXMinMaxNormalizer.class); DummyXMinMaxNormalizer.TrainingParameters dtParams = new DummyXMinMaxNormalizer.TrainingParameters(); trainingParameters.setDataTransformerTrainingParameters(dtParams); trainingParameters.setFeatureSelectorClass(null); trainingParameters.setFeatureSelectorTrainingParameters(null); Modeler instance = new Modeler(dbName, conf, trainingParameters); instance.fit(trainingData); instance.close(); instance = new Modeler(dbName, conf); instance.predict(trainingData); ClassificationMetrics vm = new ClassificationMetrics(trainingData); double expResult2 = 0.8; assertEquals(expResult2, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); instance.close(); logger.info(\"validate\"); instance = new Modeler(dbName, conf); instance.predict(validationData); Map < Integer, Object > expResult = new HashMap < > (); Map < Integer, Object > result = new HashMap < > (); for(Map.Entry < Integer, Record > e : validationData.entries()) { Integer rId = e.getKey(); Record r = e.getValue(); expResult.put(rId, r.getY()); result.put(rId, r.getYPredicted()); } assertEquals(expResult, result); instance.delete(); trainingData.delete(); validationData.delete(); } "
    },
    {
        "test_src": "@Test public void refreshToken_expiredAccessToken() { refreshToken(\"expired-access-token\", \"refresh-token\", \"auth-code\"); verify(credSink).setLoggedIn(true); verify(listener).onNewAuthToken(argThat(hasProperty(\"accessToken\", is(\"refreshed-access-token\")))); verify(listener).onNewAuthToken(argThat(hasProperty(\"refreshToken\", is(\"refresh-token\")))); } ",
        "focal_tgt": "private void refreshToken(String accessToken, String refreshToken, String authCode) { Retrofit retrofit = GhostApiUtils.getRetrofit(BLOG_URL, Helpers.getProdHttpClient()); MockRetrofit mockRetrofit = Helpers.getMockRetrofit(retrofit, Helpers.getIdealNetworkBehavior()); BehaviorDelegate < GhostApiService > delegate = mockRetrofit.create(GhostApiService.class); GhostApiService api = new MockGhostApiService(delegate, true); when(credSource.getGhostAuthCode(any())).thenReturn(Observable.just(authCode)); AuthToken token = new AuthToken(); token.setAccessToken(accessToken); token.setRefreshToken(refreshToken); AuthService authService = new AuthService(BLOG_URL, api, credSource, credSink); authService.listen(listener); authService.refreshToken(token); } ",
        "focal_src": "private void refreshToken(String accessToken, String refreshToken, String authCode) { Retrofit retrofit = GhostApiUtils.getRetrofit(\"http://blog.com\", Helpers.getProdHttpClient()); MockRetrofit mockRetrofit = Helpers.getMockRetrofit(retrofit, Helpers.getIdealNetworkBehavior()); BehaviorDelegate < GhostApiService > delegate = mockRetrofit.create(GhostApiService.class); GhostApiService api = new MockGhostApiService(delegate, true); when(credSource.getGhostAuthCode(any())).thenReturn(Observable.just(authCode)); AuthToken token = new AuthToken(); token.setAccessToken(accessToken); token.setRefreshToken(refreshToken); AuthService authService = new AuthService(api, credSource, credSink); authService.listen(listener); authService.refreshToken(token); } ",
        "test_tgt": "@Test public void refreshToken_expiredAccessToken() { refreshToken(\"expired-access-token\", \"refresh-token\", \"auth-code\"); verify(credSink).setLoggedIn(BLOG_URL, true); verify(listener).onNewAuthToken(argThat(hasProperty(\"accessToken\", is(\"refreshed-access-token\")))); verify(listener).onNewAuthToken(argThat(hasProperty(\"refreshToken\", is(\"refresh-token\")))); } "
    },
    {
        "test_src": "@Test public void testQuery()throws Exception { PersistenceManager < Job > pm = new PersistenceManager < Job > (); Job initial = new Job(); UUID uuid = UUID.randomUUID(); initial.setId(uuid.toString()); initial.setJobName(\"My test job\"); initial.setJobStatus(JobStatus.FAILED); initial.setUpdateTime(System.currentTimeMillis()); initial.setUserName(\"myUserName\"); initial.setCmdArgs(\"commandArg\"); pm.createEntity(initial); ClauseBuilder cb = new ClauseBuilder(ClauseBuilder.AND); cb.append(\"id='\" + initial.getId() + \"'\"); cb.append(\"userName='myUserName'\"); QueryBuilder qb = new QueryBuilder().table(\"Job\").clause(cb.toString()); Object[]results = pm.query(qb); Assert.assertEquals(1, results.length); Assert.assertEquals(results[0]instanceof Job, true); } ",
        "focal_tgt": "@SuppressWarnings(\"unchecked\")public T[]query(QueryBuilder builder) { LOG.debug(\"called\"); EntityManager em = createEntityManager(); try { String strQuery; String table = builder.getTable(); String criteria = builder.getClause(); strQuery = ((criteria == null) || criteria.isEmpty()) ? String.format(\"select %s from %s %s\", ENTITY_ALIAS, table, ENTITY_ALIAS) : String.format(\"select %s from %s %s where %s\", ENTITY_ALIAS, table, ENTITY_ALIAS, criteria); boolean orderByUpdateTime = builder.isOrderByUpdateTime(); if(orderByUpdateTime) { boolean desc = builder.isDesc(); if(desc) { strQuery += String.format(\" order by %s.updated desc\", ENTITY_ALIAS); } else { strQuery += String.format(\" order by %s.updated asc\", ENTITY_ALIAS); } } Query q = em.createQuery(strQuery); LOG.debug(\"Query string: \" + strQuery); Integer limit = builder.getLimit(); if((limit == null) || (limit > MAX_PAGE_SIZE)) { limit = MAX_PAGE_SIZE; } boolean paginate = builder.isPaginate(); if(paginate) { q.setMaxResults(limit); } Integer page = builder.getPage(); if(paginate && (page != null)) { int startPos = getStartPosition(page, limit); q.setFirstResult(startPos); } List < T > records = (List < T > )q.getResultList(); T[]results = (T[])new Object[records.size()]; results = (T[])records.toArray(results); return results; } finally { em.close(); } } ",
        "focal_src": "@SuppressWarnings(\"unchecked\")public T[]query(QueryBuilder builder) { LOG.debug(\"called\"); EntityManager em = createEntityManager(); try { String strQuery; String table = builder.getTable(); String criteria = builder.getClause(); strQuery = ((criteria == null) || criteria.isEmpty()) ? String.format(\"select %s from %s %s\", ENTITY_ALIAS, table, ENTITY_ALIAS) : String.format(\"select %s from %s %s where %s\", ENTITY_ALIAS, table, ENTITY_ALIAS, criteria); boolean orderByUpdateTime = builder.isOrderByUpdateTime(); if(orderByUpdateTime) { boolean desc = builder.isDesc(); if(desc) { strQuery += String.format(\" order by %s.updateTime desc\", ENTITY_ALIAS); } else { strQuery += String.format(\" order by %s.updateTime asc\", ENTITY_ALIAS); } } Query q = em.createQuery(strQuery); LOG.debug(\"Query string: \" + strQuery); Integer limit = builder.getLimit(); if((limit == null) || (limit > MAX_PAGE_SIZE)) { limit = MAX_PAGE_SIZE; } boolean paginate = builder.isPaginate(); if(paginate) { q.setMaxResults(limit); } Integer page = builder.getPage(); if(paginate && (page != null)) { int startPos = getStartPosition(page, limit); q.setFirstResult(startPos); } List < T > records = (List < T > )q.getResultList(); T[]results = (T[])new Object[records.size()]; results = (T[])records.toArray(results); return results; } finally { em.close(); } } ",
        "test_tgt": "@Test public void testQuery()throws Exception { PersistenceManager < Job > pm = new PersistenceManager < Job > (); Job initial = new Job(); UUID uuid = UUID.randomUUID(); initial.setId(uuid.toString()); initial.setJobName(\"My test job\"); initial.setJobStatus(JobStatus.FAILED); initial.setUserName(\"myUserName\"); initial.setCmdArgs(\"commandArg\"); pm.createEntity(initial); ClauseBuilder cb = new ClauseBuilder(ClauseBuilder.AND); cb.append(\"id='\" + initial.getId() + \"'\"); cb.append(\"userName='myUserName'\"); QueryBuilder qb = new QueryBuilder().table(\"Job\").clause(cb.toString()); Object[]results = pm.query(qb); Assert.assertEquals(1, results.length); Assert.assertEquals(results[0]instanceof Job, true); } "
    },
    {
        "test_src": "@Test public void testAnd() { QueryCriterion criterion1 = new EqCriterion(\"name\", \"abc\"); QueryCriterion criterion2 = new GtCriterion(\"id\", 5); QueryCriterion criterion3 = new AndCriterion(criterion1, criterion2); assertTrue(instance.and(criterion1, criterion2).getQueryCriterions().contains(criterion3)); } ",
        "focal_tgt": "public CriteriaQuery and(QueryCriterion ... queryCriterions) { criterion = criterion.and(criterionBuilder.and(queryCriterions)); return this; } ",
        "focal_src": "public CriteriaQuery and(QueryCriterion ... queryCriterions) { addCriterion(criterionBuilder.and(queryCriterions)); return this; } ",
        "test_tgt": "@Test public void testAnd() { QueryCriterion criterion1 = new EqCriterion(\"name\", \"abc\"); QueryCriterion criterion2 = new GtCriterion(\"id\", 5); QueryCriterion criterion3 = new AndCriterion(criterion1, criterion2); assertEquals(criterion3, instance.and(criterion1, criterion2).getQueryCriterion()); } "
    },
    {
        "test_src": "@Test public void testPut()throws ExecutionException, InterruptedException { int count = 4000000; HugeConfig config = HugeConfig.DEFAULT.clone().setSegments(256).setSmallEntrySize(72).setCapacity(count); final HugeHashMap < CharSequence, SampleValues > map = new HugeHashMap < CharSequence, SampleValues > (config, CharSequence.class, SampleValues.class); long start = System.nanoTime(); final SampleValues value = new SampleValues(); StringBuilder user = new StringBuilder(); for(int i = 0; i < count; i ++ ) { value.ee = i; value.gg = i; value.ii = i; map.put(users(user, i), value); } for(int i = 0; i < count; i ++ ) { assertNotNull(map.get(users(user, i), value)); assertEquals(i, value.ee); assertEquals(i, value.gg, 0.0); assertEquals(i, value.ii); } for(int i = 0; i < count; i ++ )assertNotNull(map.get(users(user, i), value)); for(int i = 0; i < count; i ++ )map.remove(users(user, i)); long time = System.nanoTime() - start; System.out.printf(\"Put/get %,d K operations per second%n\", (int)(count * 4 * 1e6 / time)); } ",
        "focal_tgt": "V put(final DirectBytes keyBytes, final V value, int hash2, boolean replaceIfPresent) { lock(); try { hash2 = hashLookup.startSearch(hash2); while(true) { final int pos = hashLookup.nextPos(); if(pos < 0) { putEntry(keyBytes, value, hash2); return null; } else { final long offset = entriesOffset + pos * entrySize; tmpBytes.storePositionAndSize(bytes, offset, entrySize); if( ! keyEquals(keyBytes, tmpBytes))continue; final long keyLength = keyBytes.remaining(); tmpBytes.skip(keyLength); if(replaceIfPresent) { if(putReturnsNull) { appendInstance(keyBytes, value); return null; } long valuePosition = tmpBytes.position(); tmpBytes.readStopBit(); final long alignPosition = align(tmpBytes.position()); tmpBytes.position(alignPosition); final V v = readObjectUsing(null, offset + alignPosition); tmpBytes.position(valuePosition); appendInstance(keyBytes, value); return v; } else { if(putReturnsNull) { return null; } return readObjectUsing(null, offset + keyLength); } } } } finally { unlock(); } } ",
        "focal_src": "V put(final DirectBytes keyBytes, final V value, int hash2, boolean replaceIfPresent) { lock(); try { hash2 = hashLookup.startSearch(hash2); while(true) { final int pos = hashLookup.nextPos(); if(pos < 0) { putEntry(keyBytes, value, hash2); return null; } else { final long offset = entriesOffset + pos * entrySize; tmpBytes.storePositionAndSize(bytes, offset, entrySize); if( ! keyEquals(keyBytes, tmpBytes))continue; final long keyLength = keyBytes.remaining(); tmpBytes.skip(keyLength); final long alignPosition = align(tmpBytes.position()); tmpBytes.position(alignPosition); if(replaceIfPresent) { if(putReturnsNull) { appendInstance(keyBytes, value); return null; } final V v = readObjectUsing(null, offset + alignPosition); tmpBytes.position(alignPosition); appendInstance(keyBytes, value); return v; } else { if(putReturnsNull) { return null; } return readObjectUsing(null, offset + keyLength); } } } } finally { unlock(); } } ",
        "test_tgt": "@Test@Ignore public void testPut()throws ExecutionException, InterruptedException { int count = 4000000; HugeConfig config = HugeConfig.DEFAULT.clone().setSegments(256).setSmallEntrySize(72).setCapacity(count); final HugeHashMap < CharSequence, SampleValues > map = new HugeHashMap < CharSequence, SampleValues > (config, CharSequence.class, SampleValues.class); long start = System.nanoTime(); final SampleValues value = new SampleValues(); StringBuilder user = new StringBuilder(); for(int i = 0; i < count; i ++ ) { value.ee = i; value.gg = i; value.ii = i; map.put(users(user, i), value); } for(int i = 0; i < count; i ++ ) { assertNotNull(map.get(users(user, i), value)); assertEquals(i, value.ee); assertEquals(i, value.gg, 0.0); assertEquals(i, value.ii); } for(int i = 0; i < count; i ++ )assertNotNull(map.get(users(user, i), value)); for(int i = 0; i < count; i ++ )map.remove(users(user, i)); long time = System.nanoTime() - start; System.out.printf(\"Put/get %,d K operations per second%n\", (int)(count * 4 * 1e6 / time)); } "
    },
    {
        "test_src": "@Test public void createDB()throws BaseXException { new CreateDB(NAME).execute(context); assertEquals(db(), NAME); } ",
        "focal_tgt": "static void createDB() { execute(new CreateDB(COLL, DOCPATH + DOC1)); execute(new Close()); } ",
        "focal_src": "static void createDB()throws BaseXException { new CreateDB(COLL, DOCPATH + DOC1).execute(context); new Close().execute(context); } ",
        "test_tgt": "@Test public void createDB() { execute(new CreateDB(NAME)); assertEquals(db(), NAME); } "
    },
    {
        "test_src": "@Test public void testCreateCoord() { CoordData c = new CoordData(); c.id = \"herp.derp\"; c.name = \"Herp McDerpson\"; c.email = \"ching@chang.com\"; try { accountsDb.createCoord(c); } catch(EntityAlreadyExistsException e) { fail(); } try { accountsDb.createCoord(c); fail(); } catch(EntityAlreadyExistsException e) { } c.id = \"herp mc derp\"; try { accountsDb.createCoord(c); fail(); } catch(AssertionError a) { } catch(EntityAlreadyExistsException e) { fail(); } } ",
        "focal_tgt": "public void createCoord(String coordId, String coordName, String coordEmail)throws EntityAlreadyExistsException, InvalidParametersException { Assumption.assertNotNull(ERROR_NULL_PARAMETER, coordId); Assumption.assertNotNull(ERROR_NULL_PARAMETER, coordName); Assumption.assertNotNull(ERROR_NULL_PARAMETER, coordEmail); verifyAdminLoggedIn(); CoordData coordToAdd = new CoordData(coordId, coordName, coordEmail); if( ! coordToAdd.isValid()) { throw new InvalidParametersException(coordToAdd.getInvalidStateInfo()); } AccountsStorage.inst().getDb().createCoord(coordToAdd); } ",
        "focal_src": "public void createCoord(String coordId, String coordName, String coordEmail)throws EntityAlreadyExistsException, InvalidParametersException { verifyAdminLoggedIn(); CoordData coordToAdd = new CoordData(coordId, coordName, coordEmail); if( ! coordToAdd.isValid()) { throw new InvalidParametersException(coordToAdd.getInvalidStateInfo()); } AccountsStorage.inst().getDb().createCoord(coordToAdd); } ",
        "test_tgt": "@Test public void testCreateCoord()throws EntityAlreadyExistsException { CoordData c = new CoordData(); c.id = \"valid.id\"; c.name = \"John Doe\"; c.email = \"john.doe@coordinator.com\"; accountsDb.createCoord(c); try { accountsDb.createCoord(c); fail(); } catch(EntityAlreadyExistsException e) { assertContains(AccountsDb.ERROR_CREATE_COORD_ALREADY_EXISTS, e.getMessage()); } c.id = \"invalid id with spaces\"; try { accountsDb.createCoord(c); fail(); } catch(AssertionError a) { assertEquals(a.getMessage(), CoordData.ERROR_FIELD_ID); } catch(EntityAlreadyExistsException e) { fail(); } try { accountsDb.createCoord(null); fail(); } catch(AssertionError a) { assertEquals(Common.ERROR_DBLEVEL_NULL_INPUT, a.getMessage()); } } "
    },
    {
        "test_src": "@Test public void testDump() { System.out.println(\"dump\"); RunsTable instance = createHorizontalInstance(); instance.dump(System.out); instance = createVerticalInstance(); instance.dump(System.out); } ",
        "focal_tgt": "public void dump() { StringBuilder sb = new StringBuilder(String.format(\"%n\")); if(name != null) { sb.append(name); } sb.append(String.format(\" Check Suite: threshold=%d%n\", threshold)); dumpSpecific(sb); sb.append(String.format(\"Weight Name Covariant Low High%n\")); sb.append(String.format(\"------ ---- ------ --- ----%n\")); int index = 0; for(Check < C > check : checks) { sb.append(String.format(\"%4.1f %-19s %5b % 6.2f % 6.2f %n\", weights.get(index ++ ), check.getName(), check.isCovariant(), check.getLow(), check.getHigh())); } logger.info(sb.toString()); } ",
        "focal_src": "public void dump() { System.out.println(); if(name != null) { System.out.print(name); } System.out.println(\" Check Suite: threshold=\" + threshold); dumpSpecific(); System.out.println(\"Weight Name Covariant Low High\"); System.out.println(\"------ ---- ------ --- ----\"); int index = 0; for(Check < C > check : checks) { System.out.printf(\"%4.1f %-19s %5b % 6.2f % 6.2f %n\", weights.get(index ++ ), check.getName(), check.isCovariant(), check.getLow(), check.getHigh()); } } ",
        "test_tgt": "@Test public void testDump() { System.out.println(\"dump\"); RunsTable instance = createHorizontalInstance(); System.out.println(instance.dumpOf()); instance = createVerticalInstance(); System.out.println(instance.dumpOf()); } "
    },
    {
        "test_src": "@Test public void testRepairSurvivors()throws InterruptedException, ExecutionException { InitiatorMailbox mailbox = mock(MpInitiatorMailbox.class); doReturn(4L).when(mailbox).getHSId(); ArrayList < Long > masters = new ArrayList < Long > (); masters.add(1L); masters.add(2L); masters.add(3L); MpPromoteAlgo algo = new MpPromoteAlgo(masters, mailbox, \"Test\"); long requestId = algo.getRequestId(); Future < Pair < Boolean, Long > > result = algo.start(); verify(mailbox, times(1)).send(any(long[].class), any(Iv2RepairLogRequestMessage.class)); algo.deliver(makeRealAckResponse(requestId, 1L, 0, 2, txnEgo(1000L), m_hashinatorConfig)); algo.deliver(makeRealFragResponse(requestId, 1L, 1, 2, txnEgo(1000L))); algo.deliver(makeRealAckResponse(requestId, 2L, 0, 1, Long.MAX_VALUE, m_hashinatorConfig)); Pair < Long, byte[] > torv3 = Pair.of(m_hashinatorConfig.getFirst() + 1, m_hashinatorConfig.getSecond()); algo.deliver(makeRealAckResponse(requestId, 3L, 0, 3, txnEgo(1000L), torv3)); algo.deliver(makeRealFragResponse(requestId, 3L, 1, 3, txnEgo(1000L))); algo.deliver(makeRealCompleteResponse(requestId, 3L, 2, 3, txnEgo(1000L))); algo.deliver(makeRealAckResponse(requestId, 4L, 0, 2, txnEgo(1000L), m_hashinatorConfig)); algo.deliver(makeRealCompleteResponse(requestId, 4L, 1, 2, txnEgo(1000L))); List < Long > needsRepair = new ArrayList < Long > (); needsRepair.add(1L); needsRepair.add(2L); needsRepair.add(3L); verify(mailbox, times(1)).repairReplicasWith(eq(needsRepair), any(Iv2RepairLogResponseMessage.class)); Pair < Boolean, Long > real_result = result.get(); assertEquals(txnEgo(1000L), (long)real_result.getSecond()); assertEquals(torv3.getFirst(), TheHashinator.getCurrentVersionedConfig().getFirst()); } ",
        "focal_tgt": "public void repairSurvivors() { if(this.m_promotionResult.isCancelled()) { tmLog.debug(m_whoami + \"Skipping repair message creation for cancelled Term.\"); return; } int queued = 0; tmLog.debug(m_whoami + \"received all repair logs and is repairing surviving replicas.\"); for(Iv2RepairLogResponseMessage li : m_repairLogUnion) { List < Long > needsRepair = new ArrayList < Long > (5); for(Entry < Long, ReplicaRepairStruct > entry : m_replicaRepairStructs.entrySet()) { if(entry.getValue().needs(li.getHandle())) { ++ queued; tmLog.debug(m_whoami + \"repairing \" + CoreUtils.hsIdToString(entry.getKey()) + \". Max seen \" + entry.getValue().m_maxSpHandleSeen + \". Repairing with \" + li.getHandle()); needsRepair.add(entry.getKey()); } } if( ! needsRepair.isEmpty()) { if(tmLog.isTraceEnabled()) { tmLog.trace(m_whoami + \"repairing: \" + CoreUtils.hsIdCollectionToString(needsRepair) + \" with message: \" + li.getPayload()); } m_mailbox.repairReplicasWith(needsRepair, li.getPayload()); } } tmLog.debug(m_whoami + \"finished queuing \" + queued + \" replica repair messages.\"); m_promotionResult.set(m_maxSeenTxnId); } ",
        "focal_src": "public void repairSurvivors() { if(this.m_promotionResult.isCancelled()) { tmLog.debug(m_whoami + \"Skipping repair message creation for cancelled Term.\"); return; } int queued = 0; tmLog.debug(m_whoami + \"received all repair logs and is repairing surviving replicas.\"); for(Iv2RepairLogResponseMessage li : m_repairLogUnion) { List < Long > needsRepair = new ArrayList < Long > (5); for(Entry < Long, ReplicaRepairStruct > entry : m_replicaRepairStructs.entrySet()) { if(entry.getValue().needs(li.getHandle())) { ++ queued; tmLog.debug(m_whoami + \"repairing \" + CoreUtils.hsIdToString(entry.getKey()) + \". Max seen \" + entry.getValue().m_maxSpHandleSeen + \". Repairing with \" + li.getHandle()); needsRepair.add(entry.getKey()); } } if( ! needsRepair.isEmpty()) { if(tmLog.isTraceEnabled()) { tmLog.trace(m_whoami + \"repairing: \" + CoreUtils.hsIdCollectionToString(needsRepair) + \" with message: \" + li.getPayload()); } m_mailbox.repairReplicasWith(needsRepair, li.getPayload()); } } tmLog.debug(m_whoami + \"finished queuing \" + queued + \" replica repair messages.\"); m_promotionResult.done(m_maxSeenTxnId); } ",
        "test_tgt": "@Test public void testRepairSurvivors()throws InterruptedException, ExecutionException { InitiatorMailbox mailbox = mock(MpInitiatorMailbox.class); doReturn(4L).when(mailbox).getHSId(); ArrayList < Long > masters = new ArrayList < Long > (); masters.add(1L); masters.add(2L); masters.add(3L); MpPromoteAlgo algo = new MpPromoteAlgo(masters, mailbox, \"Test\"); long requestId = algo.getRequestId(); Future < Long > result = algo.start(); verify(mailbox, times(1)).send(any(long[].class), any(Iv2RepairLogRequestMessage.class)); algo.deliver(makeRealAckResponse(requestId, 1L, 0, 2, txnEgo(1000L), m_hashinatorConfig)); algo.deliver(makeRealFragResponse(requestId, 1L, 1, 2, txnEgo(1000L))); algo.deliver(makeRealAckResponse(requestId, 2L, 0, 1, Long.MAX_VALUE, m_hashinatorConfig)); Pair < Long, byte[] > torv3 = Pair.of(m_hashinatorConfig.getFirst() + 1, m_hashinatorConfig.getSecond()); algo.deliver(makeRealAckResponse(requestId, 3L, 0, 3, txnEgo(1000L), torv3)); algo.deliver(makeRealFragResponse(requestId, 3L, 1, 3, txnEgo(1000L))); algo.deliver(makeRealCompleteResponse(requestId, 3L, 2, 3, txnEgo(1000L))); algo.deliver(makeRealAckResponse(requestId, 4L, 0, 2, txnEgo(1000L), m_hashinatorConfig)); algo.deliver(makeRealCompleteResponse(requestId, 4L, 1, 2, txnEgo(1000L))); List < Long > needsRepair = new ArrayList < Long > (); needsRepair.add(1L); needsRepair.add(2L); needsRepair.add(3L); verify(mailbox, times(1)).repairReplicasWith(eq(needsRepair), any(Iv2RepairLogResponseMessage.class)); Long real_result = result.get(); assertEquals(txnEgo(1000L), (long)real_result); assertEquals(torv3.getFirst(), TheHashinator.getCurrentVersionedConfig().getFirst()); } "
    },
    {
        "test_src": "@Test public void addOrReplace_update() { assertThat(candidateRepository.retrieveLatestMatch(mkStockUntilSegment(now)).isPresent(), is(true)); assertThat(toCandidateWithoutIds(candidateRepository.retrieveLatestMatch(mkStockUntilSegment(now)).get()), is(stockCandidate)); final List < Candidate > stockBeforeReplacement = candidateRepository.retrieveMatches(mkStockFromSegment(now)); assertThat(stockBeforeReplacement.size(), is(2)); assertThat(stockBeforeReplacement.stream().map(c -> toCandidateWithoutIds(c)).collect(Collectors.toList()), contains(stockCandidate, laterStockCandidate)); final Candidate replacementCandidate = stockCandidate.withQuantity(BigDecimal.ONE); candidateRepository.addOrReplace(replacementCandidate); assertThat(toCandidateWithoutIds(candidateRepository.retrieveLatestMatch(mkStockUntilSegment(now)).get()), is(replacementCandidate)); final List < Candidate > stockAfterReplacement = candidateRepository.retrieveMatches(mkStockFromSegment(now)); assertThat(stockAfterReplacement.size(), is(2)); assertThat(stockAfterReplacement.stream().map(c -> toCandidateWithoutIds(c)).collect(Collectors.toList()), contains(replacementCandidate, laterStockCandidate)); } ",
        "focal_tgt": "public Candidate addOrReplace(@NonNull final Candidate candidate) { return addOrReplace(candidate, false); } ",
        "focal_src": "public Candidate addOrReplace(@NonNull final Candidate candidate) { final Optional < I_MD_Candidate > oldCandidateRecord = retrieveExact(candidate); final BigDecimal oldqty = oldCandidateRecord.isPresent() ? oldCandidateRecord.get().getQty() : BigDecimal.ZERO; final BigDecimal qtyDelta = candidate.getQuantity().subtract(oldqty); final I_MD_Candidate synchedRecord = syncToRecord(oldCandidateRecord, candidate); InterfaceWrapperHelper.save(synchedRecord); if(candidate.getType() != Type.STOCK && synchedRecord.getMD_Candidate_GroupId() <= 0) { synchedRecord.setMD_Candidate_GroupId(synchedRecord.getMD_Candidate_ID()); InterfaceWrapperHelper.save(synchedRecord); } return candidate.withId(synchedRecord.getMD_Candidate_ID()).withGroupId(synchedRecord.getMD_Candidate_GroupId()).withQuantity(qtyDelta); } ",
        "test_tgt": "@Test public void addOrReplace_update() { assertThat(candidateRepository.retrieveLatestMatch(mkStockUntilSegment(now)).isPresent(), is(true)); assertThat(candidateRepository.retrieveLatestMatch(mkStockUntilSegment(now)).get(), is(stockCandidate)); final List < Candidate > stockBeforeReplacement = candidateRepository.retrieveMatches(mkStockFromSegment(now)); assertThat(stockBeforeReplacement.size(), is(2)); assertThat(stockBeforeReplacement.stream().collect(Collectors.toList()), contains(stockCandidate, laterStockCandidate)); final Candidate replacementCandidate = stockCandidate.withQuantity(BigDecimal.ONE); candidateRepository.addOrReplace(replacementCandidate); assertThat(candidateRepository.retrieveLatestMatch(mkStockUntilSegment(now)).get(), is(replacementCandidate)); final List < Candidate > stockAfterReplacement = candidateRepository.retrieveMatches(mkStockFromSegment(now)); assertThat(stockAfterReplacement.size(), is(2)); assertThat(stockAfterReplacement.stream().collect(Collectors.toList()), contains(replacementCandidate, laterStockCandidate)); } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void test_compareTo_time() { OffsetTime a = OffsetTime.of(11, 29, OFFSET_PONE); OffsetTime b = OffsetTime.of(11, 30, OFFSET_PONE); assertEquals(a.compareTo(b) < 0, true); assertEquals(b.compareTo(a) > 0, true); assertEquals(a.compareTo(a) == 0, true); assertEquals(b.compareTo(b) == 0, true); assertEquals(DATE.atTime(a).toInstant().compareTo(DATE.atTime(b).toInstant()) < 0, true); } ",
        "focal_tgt": "@Override public int compareTo(ChronoZonedDateTime < ? > other) { int cmp = Long.compare(toEpochSecond(), other.toEpochSecond()); if(cmp == 0) { cmp = getTime().getNano() - other.getTime().getNano(); if(cmp == 0) { cmp = getDateTime().compareTo(other.getDateTime()); if(cmp == 0) { cmp = getZone().getId().compareTo(other.getZone().getId()); if(cmp == 0) { cmp = getDate().getChrono().compareTo(other.getDate().getChrono()); } } } } return cmp; } ",
        "focal_src": "@Override public int compareTo(ChronoZonedDateTime < ? > other) { int cmp = getOffsetDateTime().compareTo(other.getOffsetDateTime()); if(cmp == 0) { cmp = getZone().getId().compareTo(other.getZone().getId()); } return cmp; } ",
        "test_tgt": "@Test(groups = { \"tck\" })public void test_compareTo_time() { OffsetTime a = OffsetTime.of(11, 29, OFFSET_PONE); OffsetTime b = OffsetTime.of(11, 30, OFFSET_PONE); assertEquals(a.compareTo(b) < 0, true); assertEquals(b.compareTo(a) > 0, true); assertEquals(a.compareTo(a) == 0, true); assertEquals(b.compareTo(b) == 0, true); assertEquals(convertInstant(a).compareTo(convertInstant(b)) < 0, true); } "
    },
    {
        "test_src": "@Test public void testReconcile_withResource_withKafka_noPrivate_configsReconcilable(TestContext context) { Topic kubeTopic = new Topic.Builder(topicName.toString(), 10, (short)2, map(\"cleanup.policy\", \"bar\"), metadata).build(); Topic kafkaTopic = new Topic.Builder(topicName.toString(), 10, (short)2, map(\"unclean.leader.election.enable\", \"true\"), metadata).build(); Topic privateTopic = null; Topic mergedTopic = new Topic.Builder(topicName.toString(), 10, (short)2, map(\"unclean.leader.election.enable\", \"true\", \"cleanup.policy\", \"bar\"), metadata).build(); Async async0 = context.async(2); mockKafka.setCreateTopicResponse(topicName -> Future.succeededFuture()); mockKafka.createTopic(kafkaTopic, ar -> async0.countDown()); mockKafka.setUpdateTopicResponse(topicName -> Future.succeededFuture()); KafkaTopic topic = TopicSerialization.toTopicResource(kubeTopic, resourcePredicate); mockK8s.setCreateResponse(topicName.asMapName(), null); mockK8s.createResource(topic, ar -> async0.countDown()); mockK8s.setModifyResponse(topicName.asMapName(), null); mockTopicStore.setCreateTopicResponse(topicName, null); async0.await(); Async async = context.async(2); topicOperator.reconcile(topic, kubeTopic, kafkaTopic, privateTopic, reconcileResult -> { assertSucceeded(context, reconcileResult); mockTopicStore.assertExists(context, topicName); mockK8s.assertExists(context, topicName.asMapName()); mockKafka.assertExists(context, topicName); mockTopicStore.read(topicName, readResult -> { assertSucceeded(context, readResult); context.assertEquals(mergedTopic, readResult.result()); async.countDown(); }); mockK8s.getFromName(topicName.asMapName(), readResult -> { assertSucceeded(context, readResult); context.assertEquals(mergedTopic, TopicSerialization.fromTopicResource(readResult.result())); async.countDown(); }); context.assertEquals(mergedTopic, mockKafka.getTopicState(topicName)); }); } ",
        "focal_tgt": "void reconcile(final HasMetadata involvedObject, final Topic k8sTopic, final Topic kafkaTopic, final Topic privateTopic, final Handler < AsyncResult < Void > > reconciliationResultHandler) { { TopicName topicName = k8sTopic != null ? k8sTopic.getTopicName() : kafkaTopic != null ? kafkaTopic.getTopicName() : privateTopic != null ? privateTopic.getTopicName() : null; LOGGER.info(\"Reconciling topic {}, k8sTopic:{}, kafkaTopic:{}, privateTopic:{}\", topicName, k8sTopic == null ? \"null\" : \"nonnull\", kafkaTopic == null ? \"null\" : \"nonnull\", privateTopic == null ? \"null\" : \"nonnull\"); } if(privateTopic == null) { if(k8sTopic == null) { if(kafkaTopic == null) { LOGGER.debug(\"All three topics null during reconciliation.\"); reconciliationResultHandler.handle(Future.succeededFuture()); } else { LOGGER.debug(\"topic created in kafka, will create KafkaTopic in k8s and topicStore\"); enqueue(new CreateResource(kafkaTopic, ar -> { if(ar.succeeded()) { enqueue(new CreateInTopicStore(kafkaTopic, involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } } else if(kafkaTopic == null) { LOGGER.debug(\"KafkaTopic created in k8s, will create topic in kafka and topicStore\"); enqueue(new CreateKafkaTopic(k8sTopic, involvedObject, ar -> { if(ar.succeeded()) { enqueue(new CreateInTopicStore(k8sTopic, involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } else { update2Way(involvedObject, k8sTopic, kafkaTopic, reconciliationResultHandler); } } else { if(k8sTopic == null) { if(kafkaTopic == null) { LOGGER.debug(\"KafkaTopic deleted in k8s and topic deleted in kafka => delete from topicStore\"); enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); reconciliationResultHandler.handle(Future.succeededFuture()); } else { LOGGER.debug(\"KafkaTopic deleted in k8s => delete topic from kafka and from topicStore\"); enqueue(new DeleteKafkaTopic(kafkaTopic.getTopicName(), ar -> { if(ar.succeeded()) { enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } } else if(kafkaTopic == null) { LOGGER.debug(\"topic deleted in kafkas => delete KafkaTopic from k8s and from topicStore\"); enqueue(new DeleteResource(privateTopic.getOrAsKubeName(), ar -> { if(ar.succeeded()) { enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } else { LOGGER.debug(\"3 way diff\"); update3Way(involvedObject, k8sTopic, kafkaTopic, privateTopic, reconciliationResultHandler); } } } ",
        "focal_src": "void reconcile(final HasMetadata involvedObject, final Topic k8sTopic, final Topic kafkaTopic, final Topic privateTopic, final Handler < AsyncResult < Void > > reconciliationResultHandler) { { TopicName topicName = k8sTopic != null ? k8sTopic.getTopicName() : kafkaTopic != null ? kafkaTopic.getTopicName() : privateTopic != null ? privateTopic.getTopicName() : null; LOGGER.info(\"Reconciling topic {}, k8sTopic:{}, kafkaTopic:{}, privateTopic:{}\", topicName, k8sTopic == null ? \"null\" : \"nonnull\", kafkaTopic == null ? \"null\" : \"nonnull\", privateTopic == null ? \"null\" : \"nonnull\"); } if(privateTopic == null) { if(k8sTopic == null) { if(kafkaTopic == null) { LOGGER.debug(\"All three topics null during reconciliation.\"); reconciliationResultHandler.handle(Future.succeededFuture()); } else { LOGGER.debug(\"topic created in kafka, will create KafkaTopic in k8s and topicStore\"); enqueue(new CreateResource(kafkaTopic, ar -> { if(ar.succeeded()) { enqueue(new CreateInTopicStore(kafkaTopic, involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } } else if(kafkaTopic == null) { LOGGER.debug(\"KafkaTopic created in k8s, will create topic in kafka and topicStore\"); enqueue(new CreateKafkaTopic(k8sTopic, involvedObject, ar -> { if(ar.succeeded()) { enqueue(new CreateInTopicStore(k8sTopic, involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } else { update2Way(involvedObject, k8sTopic, kafkaTopic, reconciliationResultHandler); } } else { if(k8sTopic == null) { if(kafkaTopic == null) { LOGGER.debug(\"KafkaTopic deleted in k8s and topic deleted in kafka => delete from topicStore\"); enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); reconciliationResultHandler.handle(Future.succeededFuture()); } else { LOGGER.debug(\"KafkaTopic deleted in k8s => delete topic from kafka and from topicStore\"); enqueue(new DeleteKafkaTopic(kafkaTopic.getTopicName(), ar -> { if(ar.succeeded()) { enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } } else if(kafkaTopic == null) { LOGGER.debug(\"topic deleted in kafkas => delete KafkaTopic from k8s and from topicStore\"); enqueue(new DeleteResource(privateTopic.getOrAsMapName(), ar -> { if(ar.succeeded()) { enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } else { LOGGER.debug(\"3 way diff\"); update3Way(involvedObject, k8sTopic, kafkaTopic, privateTopic, reconciliationResultHandler); } } } ",
        "test_tgt": "@Test public void testReconcile_withResource_withKafka_noPrivate_configsReconcilable(TestContext context) { Topic kubeTopic = new Topic.Builder(topicName.toString(), 10, (short)2, map(\"cleanup.policy\", \"bar\"), metadata).build(); Topic kafkaTopic = new Topic.Builder(topicName.toString(), 10, (short)2, map(\"unclean.leader.election.enable\", \"true\"), metadata).build(); Topic privateTopic = null; Topic mergedTopic = new Topic.Builder(topicName.toString(), 10, (short)2, map(\"unclean.leader.election.enable\", \"true\", \"cleanup.policy\", \"bar\"), metadata).build(); Async async0 = context.async(2); mockKafka.setCreateTopicResponse(topicName -> Future.succeededFuture()); mockKafka.createTopic(kafkaTopic, ar -> async0.countDown()); mockKafka.setUpdateTopicResponse(topicName -> Future.succeededFuture()); KafkaTopic topic = TopicSerialization.toTopicResource(kubeTopic, resourcePredicate); mockK8s.setCreateResponse(topicName.asKubeName(), null); mockK8s.createResource(topic, ar -> async0.countDown()); mockK8s.setModifyResponse(topicName.asKubeName(), null); mockTopicStore.setCreateTopicResponse(topicName, null); async0.await(); Async async = context.async(2); topicOperator.reconcile(topic, kubeTopic, kafkaTopic, privateTopic, reconcileResult -> { assertSucceeded(context, reconcileResult); mockTopicStore.assertExists(context, topicName); mockK8s.assertExists(context, topicName.asKubeName()); mockKafka.assertExists(context, topicName); mockTopicStore.read(topicName, readResult -> { assertSucceeded(context, readResult); context.assertEquals(mergedTopic, readResult.result()); async.countDown(); }); mockK8s.getFromName(topicName.asKubeName(), readResult -> { assertSucceeded(context, readResult); context.assertEquals(mergedTopic, TopicSerialization.fromTopicResource(readResult.result())); async.countDown(); }); context.assertEquals(mergedTopic, mockKafka.getTopicState(topicName)); }); } "
    },
    {
        "test_src": "@Test public void testGetRecognizeStatus() { SpeechSession session = service.createSession(SpeechModel.EN_BROADBAND16K).execute(); SessionStatus status = service.getRecognizeStatus(session).execute(); try { assertNotNull(status); assertNotNull(status.getModel()); assertNotNull(status.getState()); } finally { service.deleteSession(session).execute(); } } ",
        "focal_tgt": "public ServiceCall < SpeechSessionStatus > getRecognizeStatus(final SpeechSession session) { Validator.notNull(session, \"session cannot be null\"); Validator.notNull(session.getSessionId(), \"session.sessionId cannot be null\"); Request request = RequestBuilder.get(String.format(PATH_SESSION_RECOGNIZE, session.getSessionId())).build(); ResponseConverter < SpeechSessionStatus > converter = ResponseConverterUtils.getGenericObject(TYPE_SESSION_STATUS, \"session\"); return createServiceCall(request, converter); } ",
        "focal_src": "public ServiceCall < SessionStatus > getRecognizeStatus(final SpeechSession session) { if(session == null)throw new IllegalArgumentException(\"Session was not specified\"); Request request = RequestBuilder.get(String.format(PATH_SESSION_RECOGNIZE, session.getSessionId())).build(); return createServiceCall(request, ResponseConverterUtils.getObject(SessionStatus.class)); } ",
        "test_tgt": "@Test public void testGetRecognizeStatus() { SpeechSession session = service.createSession(SpeechModel.EN_US_BROADBANDMODEL).execute(); SpeechSessionStatus status = service.getRecognizeStatus(session).execute(); try { assertNotNull(status); assertNotNull(status.getModel()); assertNotNull(status.getState()); } finally { service.deleteSession(session).execute(); } } "
    },
    {
        "test_src": "@Test public void toThriftTest() { MountOptions options = MountOptions.defaults(); MountTOptions thriftOptions = options.toThrift(); Assert.assertFalse(thriftOptions.isReadOnly()); options.setReadOnly(true); thriftOptions = options.toThrift(); Assert.assertTrue(thriftOptions.isReadOnly()); } ",
        "focal_tgt": "public MountTOptions toThrift() { MountTOptions options = new MountTOptions(); options.setReadOnly(mReadOnly); if(mProperties != null && ! mProperties.isEmpty()) { options.setProperties(mProperties); } options.setShared(mShared); return options; } ",
        "focal_src": "public MountTOptions toThrift() { MountTOptions options = new MountTOptions(); options.setReadOnly(mReadOnly); if(mProperties != null && ! mProperties.isEmpty()) { options.setProperties(mProperties); } return options; } ",
        "test_tgt": "@Test public void toThriftTest() { MountOptions options = MountOptions.defaults(); MountTOptions thriftOptions = options.toThrift(); Assert.assertFalse(thriftOptions.isReadOnly()); options.setReadOnly(true); options.setShared(true); thriftOptions = options.toThrift(); Assert.assertTrue(thriftOptions.isReadOnly()); Assert.assertTrue(thriftOptions.isShared()); } "
    },
    {
        "test_src": "@Test public void testSetApplicationInfoForJob()throws GenieException { final String id = UUID.randomUUID().toString(); final String name = UUID.randomUUID().toString(); this.service.setApplicationInfoForJob(JOB_1_ID, id, name); final Job job = this.service.getJob(JOB_1_ID); Assert.assertEquals(id, job.getApplicationId()); Assert.assertEquals(name, job.getApplicationName()); } ",
        "focal_tgt": "@Override@Transactional(rollbackFor = { GenieException.class, ConstraintViolationException.class })public void setApplicationInfoForJob(@NotBlank(message = \"No job id entered. Unable to update app info for job.\")final String id, @NotBlank(message = \"No app id entered. Unable to update app info for job.\")final String appId, @NotBlank(message = \"No app name entered. unable to update app info for job.\")final String appName)throws GenieException { if(LOG.isDebugEnabled()) { LOG.debug(\"Setting the application info for job with id \" + id); } final Job job = this.jobRepo.findOne(id); if(job != null) { job.setApplicationId(appId); job.setApplicationName(appName); } else { throw new GenieNotFoundException(\"No job with id \" + id + \" exists\"); } } ",
        "focal_src": "@Override@Transactional(rollbackFor = { GenieException.class, ConstraintViolationException.class })public void setApplicationInfoForJob(@NotBlank(message = \"No job id entered. Unable to update app info for job.\")final String id, @NotBlank(message = \"No app id entered. Unable to update app info for job.\")final String appId, @NotBlank(message = \"No app name entered. unable to update app info for job.\")final String appName)throws GenieException { LOG.debug(\"Setting the application info for job with id \" + id); final Job job = this.jobRepo.findOne(id); if(job != null) { job.setApplicationId(appId); job.setApplicationName(appName); } else { throw new GenieNotFoundException(\"No job with id \" + id + \" exists\"); } } ",
        "test_tgt": "@Test@Ignore public void testSetApplicationInfoForJob()throws GenieException { } "
    },
    {
        "test_src": "@Test public void testGetCategory1() { assertEquals(EhUtils.NON_H, EhUtils.getCategory(\"Non-H\")); assertEquals(EhUtils.ARTIST_CG, EhUtils.getCategory(\"Artist CG Sets\")); assertEquals(EhUtils.DOUJINSHI, EhUtils.getCategory(\"doujinshi\")); assertEquals(EhUtils.UNKNOWN, EhUtils.getCategory(\"HA HI\")); assertEquals(EhUtils.UNKNOWN, EhUtils.getCategory(null)); } ",
        "focal_tgt": "@Nullable public static String getCategory(int type) { for(int i = 0, n = CATEGORY_VALUES.length - 1; i < n; ++ i) { if(CATEGORY_VALUES[i] == type) { return CATEGORY_STRINGS[i][0]; } } return null; } ",
        "focal_src": "public static String getCategory(int type) { int i, n; for(i = 0, n = CATEGORY_VALUES.length - 1; i < n; ++ i) { if(CATEGORY_VALUES[i] == type)break; } return CATEGORY_STRINGS[i][0]; } ",
        "test_tgt": "@Test public void testGetCategory1() { assertEquals(EhUtils.CATEGORY_NON_H, EhUtils.getCategory(\"Non-H\")); assertEquals(EhUtils.CATEGORY_ARTIST_CG, EhUtils.getCategory(\"Artist CG Sets\")); assertEquals(EhUtils.CATEGORY_DOUJINSHI, EhUtils.getCategory(\"doujinshi\")); assertEquals(EhUtils.CATEGORY_UNKNOWN, EhUtils.getCategory(\"HA HI\")); assertEquals(EhUtils.CATEGORY_UNKNOWN, EhUtils.getCategory(null)); } "
    },
    {
        "test_src": "@Test public void findErrorEvaluator() { GrowQueue_I8 syndromes = array(64, 192, 93, 231, 52, 92, 228, 49, 83, 245); GrowQueue_I8 errorLocator = array(3, 1); GrowQueue_I8 found = new GrowQueue_I8(); GrowQueue_I8 expected = array(0, 64); ReidSolomonCodes alg = new ReidSolomonCodes(8, primitive8); alg.findErrorEvaluator(syndromes, errorLocator, found); assertEquals(found.size, expected.size); for(int j = 0; j < found.size; j ++ ) { assertEquals(found.get(j), expected.get(j)); } } ",
        "focal_tgt": "void findErrorEvaluator(GrowQueue_I8 syndromes, GrowQueue_I8 errorLocator, GrowQueue_I8 evaluator) { math.polyMult_flipA(syndromes, errorLocator, evaluator); int N = errorLocator.size - 1; int offset = evaluator.size - N; for(int i = 0; i < N; i ++ ) { evaluator.data[i] = evaluator.data[i + offset]; } evaluator.data[N] = 0; evaluator.size = errorLocator.size; for(int i = 0; i < evaluator.size / 2; i ++ ) { int j = evaluator.size - i - 1; int tmp = evaluator.data[i]; evaluator.data[i] = evaluator.data[j]; evaluator.data[j] = (byte)tmp; } } ",
        "focal_src": "void findErrorEvaluator(GrowQueue_I8 syndromes, GrowQueue_I8 errorLocator, GrowQueue_I8 evaluator) { math.polyMult_flipA(syndromes, errorLocator, evaluator); int offset = evaluator.size - errorLocator.size; for(int i = 0; i < errorLocator.size; i ++ ) { evaluator.data[i] = evaluator.data[i + offset]; } evaluator.size = errorLocator.size; } ",
        "test_tgt": "@Test public void findErrorEvaluator() { findErrorEvaluator(array(64, 192, 93, 231, 52, 92, 228, 49, 83, 2455), array(3, 1), array(0, 64)); findErrorEvaluator(array(62, 101, 255, 19, 236, 196, 112, 227, 174, 215), array(159, 118, 1), array(0, 62, 142)); findErrorEvaluator(array(32, 188, 7, 92, 8, 39, 184, 32, 101, 213), array(97, 138, 194, 1), array(0, 32, 217, 182)); } "
    },
    {
        "test_src": "@Test public void testRemoveDuplicate() { List < String > list = ConvertUtil.toList(\"feilong1\", \"feilong2\", \"feilong2\", \"feilong3\"); List < String > removeDuplicate = CollectionsUtil.removeDuplicate(list); assertSame(3, removeDuplicate.size()); assertThat(removeDuplicate, hasItems(\"feilong1\", \"feilong2\", \"feilong3\")); assertSame(4, list.size()); assertThat(list, hasItems(\"feilong1\", \"feilong2\", \"feilong2\", \"feilong3\")); assertEquals(emptyList(), CollectionsUtil.removeDuplicate(null)); } ",
        "focal_tgt": "public static < O > List < O > removeDuplicate(Collection < O > objectCollection) { return isNullOrEmpty(objectCollection) ? Collections. < O > emptyList() : toList(new LinkedHashSet < O > (objectCollection)); } ",
        "focal_src": "public static < O > List < O > removeDuplicate(Collection < O > objectCollection) { return Validator.isNullOrEmpty(objectCollection) ? Collections. < O > emptyList() : new ArrayList < O > (new LinkedHashSet < O > (objectCollection)); } ",
        "test_tgt": "@Test public void testRemoveDuplicate() { List < String > list = toList(\"feilong1\", \"feilong2\", \"feilong2\", \"feilong3\"); List < String > removeDuplicate = CollectionsUtil.removeDuplicate(list); assertSame(3, removeDuplicate.size()); assertThat(removeDuplicate, hasItems(\"feilong1\", \"feilong2\", \"feilong3\")); assertSame(4, list.size()); assertThat(list, hasItems(\"feilong1\", \"feilong2\", \"feilong2\", \"feilong3\")); assertEquals(emptyList(), CollectionsUtil.removeDuplicate(null)); } "
    },
    {
        "test_src": "@Test(groups = { \"direct\" }, timeOut = TIMEOUT)public void read()throws Exception { Document docDefinition = this.getDocumentDefinition(); Document document = client.createDocument(getCollectionLink(), docDefinition, null, false).toBlocking().single().getResource(); waitIfNeededForReplicasToCatchUp(clientBuilder()); String pkValue = document.getString(PARTITION_KEY_FIELD_NAME); RequestOptions options = new RequestOptions(); options.setPartitionKey(new PartitionKey(pkValue)); String docLink = String.format(\"dbs/%s/colls/%s/docs/%s\", createdDatabase.id(), createdCollection.id(), document.id()); ResourceResponseValidator < Document > validator = new ResourceResponseValidator.Builder < Document > ().withId(docDefinition.id()).build(); validateSuccess(client.readDocument(docLink, options), validator, TIMEOUT); validateNoDocumentOperationThroughGateway(); } ",
        "focal_tgt": "public Mono < CosmosConflictResponse > read(CosmosConflictRequestOptions options) { if(options == null) { options = new CosmosConflictRequestOptions(); } RequestOptions requestOptions = options.toRequestOptions(); return this.container.getDatabase().getDocClientWrapper().readConflict(getLink(), requestOptions).map(response -> new CosmosConflictResponse(response, container)).single(); } ",
        "focal_src": "public Mono < CosmosConflictResponse > read(CosmosConflictRequestOptions options) { if(options == null) { options = new CosmosConflictRequestOptions(); } RequestOptions requestOptions = options.toRequestOptions(); return RxJava2Adapter.singleToMono(RxJavaInterop.toV2Single(this.container.getDatabase().getDocClientWrapper().readConflict(getLink(), requestOptions).map(response -> new CosmosConflictResponse(response, container)).toSingle())); } ",
        "test_tgt": "@Test(groups = { \"direct\" }, timeOut = TIMEOUT)public void read()throws Exception { Document docDefinition = this.getDocumentDefinition(); Document document = client.createDocument(getCollectionLink(), docDefinition, null, false).single().block().getResource(); waitIfNeededForReplicasToCatchUp(clientBuilder()); String pkValue = document.getString(PARTITION_KEY_FIELD_NAME); RequestOptions options = new RequestOptions(); options.setPartitionKey(new PartitionKey(pkValue)); String docLink = String.format(\"dbs/%s/colls/%s/docs/%s\", createdDatabase.id(), createdCollection.id(), document.id()); ResourceResponseValidator < Document > validator = new ResourceResponseValidator.Builder < Document > ().withId(docDefinition.id()).build(); validateSuccess(client.readDocument(docLink, options), validator, TIMEOUT); validateNoDocumentOperationThroughGateway(); } "
    },
    {
        "test_src": "@Test public void testAdjustTLSContext() { PaddingExtensionMessage msg = new PaddingExtensionMessage(); msg.setPaddingLength(6); handler.adjustTLSContext(msg); assertEquals(context.getPaddingExtensionLength(), 6); } ",
        "focal_tgt": "@Override public void adjustTLSContext(PaddingExtensionMessage message) { if(message.getPaddingBytes().getValue().length <= 65535) { LOGGER.warn(\"The Padding Extension length value exceeds the two bytes defined in RFC 7685.\"); } context.setPaddingExtensionLength(message.getPaddingBytes().getValue().length); } ",
        "focal_src": "@Override public void adjustTLSContext(PaddingExtensionMessage message) { if(message.getPaddingLength().getValue() <= 65535) { context.setPaddingExtensionLength(message.getPaddingLength().getValue()); } else { LOGGER.warn(\"The Padding Extension length value exceeds the two bytes defined in RFC 7685.\"); context.setPaddingExtensionLength(message.getPaddingLength().getValue()); } } ",
        "test_tgt": "@Test public void testAdjustTLSContext() { PaddingExtensionMessage msg = new PaddingExtensionMessage(); msg.setPaddingBytes(new byte[6]); handler.adjustTLSContext(msg); assertEquals(context.getPaddingExtensionLength(), 6); } "
    },
    {
        "test_src": "@Test public void addKeyTest() { String key = \"key\"; org.apache.hadoop.conf.Configuration conf = new org.apache.hadoop.conf.Configuration(); Configuration.set(key, \"alluxioKey\"); System.setProperty(key, \"systemKey\"); HdfsUnderFileSystemUtils.addKey(conf, key); Assert.assertEquals(\"systemKey\", conf.get(key)); System.clearProperty(key); HdfsUnderFileSystemUtils.addKey(conf, key); Assert.assertEquals(\"alluxioKey\", conf.get(key)); ConfigurationTestUtils.resetConfiguration(); } ",
        "focal_tgt": "public static void addKey(org.apache.hadoop.conf.Configuration hadoopConf, PropertyKey key) { if(Configuration.containsKey(key)) { hadoopConf.set(key.toString(), Configuration.get(key)); } } ",
        "focal_src": "public static void addKey(org.apache.hadoop.conf.Configuration hadoopConf, String key) { if(System.getProperty(key) != null) { hadoopConf.set(key, System.getProperty(key)); } else if(Configuration.get(key) != null) { hadoopConf.set(key, Configuration.get(key)); } } ",
        "test_tgt": "@Test public void addKeyTest() { PropertyKey key = PropertyKey.HOME; org.apache.hadoop.conf.Configuration conf = new org.apache.hadoop.conf.Configuration(); Configuration.set(key, \"alluxioKey\"); System.setProperty(key.toString(), \"systemKey\"); ConfigurationTestUtils.resetConfiguration(); HdfsUnderFileSystemUtils.addKey(conf, key); Assert.assertEquals(\"systemKey\", conf.get(key.toString())); System.clearProperty(key.toString()); ConfigurationTestUtils.resetConfiguration(); HdfsUnderFileSystemUtils.addKey(conf, key); Assert.assertEquals(\"alluxioKey\", conf.get(key.toString())); ConfigurationTestUtils.resetConfiguration(); } "
    },
    {
        "test_src": "@Test public void updatePathTest3() { build4RouterTopo(false, true, true, true, 100); boolean result = pceManager.setupPath(D1.deviceId(), D2.deviceId(), \"T123\", null, WITH_SIGNALLING); assertThat(result, is(true)); Collection < Tunnel > tunnels = (Collection < Tunnel > )pceManager.queryAllPath(); assertThat(tunnels.size(), is(1)); for(Tunnel tunnel : tunnels) { result = pceManager.updatePath(tunnel.tunnelId(), null); assertThat(result, is(true)); } Iterable < Tunnel > queryTunnelResult = pceManager.queryAllPath(); assertThat((int)queryTunnelResult.spliterator().getExactSizeIfKnown(), is(2)); } ",
        "focal_tgt": "@PUT@Path(\"{path_id}\")@Produces(MediaType.APPLICATION_JSON)@Consumes(MediaType.APPLICATION_JSON)public Response updatePath(@PathParam(\"path_id\")String id, final InputStream stream) { log.debug(\"Update path by identifier {}.\", id); try { ObjectNode jsonTree = (ObjectNode)mapper().readTree(stream); JsonNode pathNode = jsonTree.get(\"path\"); PcePath path = codec(PcePath.class).decode((ObjectNode)pathNode, this); if(path == null) { return Response.status(OK).entity(PCE_SETUP_PATH_FAILED).build(); } List < Constraint > constrntList = new LinkedList < Constraint > (); if(path.bandwidthConstraint() != null) { constrntList.add(path.bandwidthConstraint()); } if(path.costConstraint() != null) { constrntList.add(path.costConstraint()); } Boolean result = nullIsNotFound(get(PceService.class).updatePath(TunnelId.valueOf(id), constrntList), PCE_PATH_NOT_FOUND); return Response.status(OK).entity(result.toString()).build(); } catch(IOException e) { log.error(\"Update path failed because of exception {}.\", e.toString()); throw new IllegalArgumentException(e); } } ",
        "focal_src": "@PUT@Path(\"{path_id}\")@Produces(MediaType.APPLICATION_JSON)@Consumes(MediaType.APPLICATION_JSON)public Response updatePath(@PathParam(\"path_id\")String id, final InputStream stream) { log.debug(\"Update path by identifier {}.\", id); try { ObjectNode jsonTree = (ObjectNode)mapper().readTree(stream); JsonNode pathNode = jsonTree.get(\"path\"); PcePath path = codec(PcePath.class).decode((ObjectNode)pathNode, this); List < Constraint > constrntList = new LinkedList < Constraint > (); if(path.bandwidthConstraint() != null) { constrntList.add(path.bandwidthConstraint()); } if(path.costConstraint() != null) { constrntList.add(path.costConstraint()); } Boolean result = nullIsNotFound(get(PceService.class).updatePath(TunnelId.valueOf(id), constrntList), PCE_PATH_NOT_FOUND); return Response.status(OK).entity(result.toString()).build(); } catch(IOException e) { log.error(\"Update path failed because of exception {}.\", e.toString()); throw new IllegalArgumentException(e); } } ",
        "test_tgt": "@Test public void updatePathTest3() { build4RouterTopo(false, true, true, true, 100); List < Constraint > constraints = new LinkedList < Constraint > (); CostConstraint costConstraint = new CostConstraint(TE_COST); constraints.add(costConstraint); boolean result = pceManager.setupPath(D1.deviceId(), D2.deviceId(), \"T123\", constraints, WITH_SIGNALLING); assertThat(result, is(true)); Collection < Tunnel > tunnels = (Collection < Tunnel > )pceManager.queryAllPath(); assertThat(tunnels.size(), is(1)); for(Tunnel tunnel : tunnels) { result = pceManager.updatePath(tunnel.tunnelId(), null); assertThat(result, is(true)); } Iterable < Tunnel > queryTunnelResult = pceManager.queryAllPath(); assertThat((int)queryTunnelResult.spliterator().getExactSizeIfKnown(), is(2)); } "
    },
    {
        "test_src": "@Test public void tagsToString() { Assert.assertEquals(\"\", initialSetupTask.tagsToString(null)); final String[][]inputs = new String[][] { { }, { \"some.tag:t\" }, { \"foo\", \"bar\" }, { \"bar\", \"foo\" }, { \"foo\", \"bar\", \"tag,with,commas\" }, { \"foo\", \"bar\", \"tag with spaces\" }, { \"foo\", \"bar\", \"tag\\nwith\\nnewlines\" }, { \"foo\", \"bar\", \"\\\"tag-with-double-quotes\\\"\" }, { \"foo\", \"bar\", \"\\'tag-with-single-quotes\\'\" }, }; final String[]outputs = { \"\", \"some.tag:t\", \"bar,foo\", \"bar,foo\", \"bar,foo,tag,with,commas\", \"bar,foo,tag with spaces\", \"bar,foo,tag\\nwith\\nnewlines\", \"\\\"tag-with-double-quotes\\\",bar,foo\", \"\\'tag-with-single-quotes\\',bar,foo\", }; Assert.assertEquals(inputs.length, outputs.length); for(int i = 0; i < inputs.length; i ++ ) { final String expectedOutputString = outputs[i]; final HashSet < String > tags = new HashSet < > (Arrays.asList(inputs[i])); Assert.assertEquals(expectedOutputString, this.initialSetupTask.tagsToString(tags)); } } ",
        "focal_tgt": "@VisibleForTesting String tagsToString(final Set < String > tags) { final ArrayList < String > sortedTags = new ArrayList < > (tags == null ? Collections.emptySet() : tags); sortedTags.sort(Comparator.naturalOrder()); final String joinedString = StringUtils.join(sortedTags, ','); return StringUtils.replaceAll(StringUtils.replaceAll(joinedString, \"\\'\", \"\\\\\\'\"), \"\\\"\", \"\\\\\\\"\"); } ",
        "focal_src": "String tagsToString(final Set < String > tags) { final ArrayList < String > sortedTags = new ArrayList < > (tags == null ? Collections.emptySet() : tags); sortedTags.sort(Comparator.naturalOrder()); final String joinedString = StringUtils.join(sortedTags, ','); return StringUtils.replaceAll(StringUtils.replaceAll(joinedString, \"\\'\", \"\\\\\\'\"), \"\\\"\", \"\\\\\\\"\"); } ",
        "test_tgt": "@Test public void testTagsToString() { Assert.assertEquals(\"\", initialSetupTask.tagsToString(null)); final String[][]inputs = new String[][] { { }, { \"some.tag:t\" }, { \"foo\", \"bar\" }, { \"bar\", \"foo\" }, { \"foo\", \"bar\", \"tag,with,commas\" }, { \"foo\", \"bar\", \"tag with spaces\" }, { \"foo\", \"bar\", \"tag\\nwith\\nnewlines\" }, { \"foo\", \"bar\", \"\\\"tag-with-double-quotes\\\"\" }, { \"foo\", \"bar\", \"\\'tag-with-single-quotes\\'\" }, }; final String[]outputs = { \"\", \"some.tag:t\", \"bar,foo\", \"bar,foo\", \"bar,foo,tag,with,commas\", \"bar,foo,tag with spaces\", \"bar,foo,tag\\nwith\\nnewlines\", \"\\\"tag-with-double-quotes\\\",bar,foo\", \"\\'tag-with-single-quotes\\',bar,foo\", }; Assert.assertEquals(inputs.length, outputs.length); for(int i = 0; i < inputs.length; i ++ ) { final String expectedOutputString = outputs[i]; final HashSet < String > tags = new HashSet < > (Arrays.asList(inputs[i])); Assert.assertEquals(expectedOutputString, this.initialSetupTask.tagsToString(tags)); } } "
    },
    {
        "test_src": "@Test public void stripNS()throws Exception { final IO io = IO.get(\"<a xmlns:a='a'><b><c/><c/><c/></b></a>\"); final ANode root = new DBNode(io, context.prop); final QueryProcessor qp = new QueryProcessor(\"/*:a/*:b\", context).context(root); final ANode sub = (ANode)qp.iter().next(); DataBuilder.stripNS(sub, token(\"a\"), context); } ",
        "focal_tgt": "public static ANode stripNS(final ANode node, final byte[]ns, final Context ctx) { if(node.type != NodeType.ELM)return node; final MemData md = new MemData(ctx.options); final DataBuilder db = new DataBuilder(md); db.build(node); boolean del = true; for(int pre = 0; pre < md.meta.size; pre ++ ) { final int kind = md.kind(pre); if(kind != Data.ELEM && kind != Data.ATTR)continue; final byte[]uri = md.nspaces.uri(md.uri(pre, kind)); if(uri == null || ! eq(uri, ns))continue; final byte[]name = md.name(pre, kind); if(prefix(name).length == 0) { if(kind == Data.ELEM) { md.update(pre, kind, name, EMPTY); md.nsFlag(pre, false); } } else { del = false; } } if(del)md.nspaces.delete(ns); return new DBNode(md); } ",
        "focal_src": "public static ANode stripNS(final ANode node, final byte[]ns, final Context ctx) { if(node.type != NodeType.ELM)return node; final MemData md = new MemData(ctx.prop); final DataBuilder db = new DataBuilder(md); db.build(node); boolean del = true; for(int pre = 0; pre < md.meta.size; pre ++ ) { final int kind = md.kind(pre); if(kind != Data.ELEM && kind != Data.ATTR)continue; final byte[]uri = md.nspaces.uri(md.uri(pre, kind)); if(uri == null || ! eq(uri, ns))continue; final byte[]name = md.name(pre, kind); if(prefix(name).length == 0) { if(kind == Data.ELEM) { md.update(pre, kind, name, EMPTY); md.nsFlag(pre, false); } } else { del = false; } } if(del)md.nspaces.delete(ns); return new DBNode(md); } ",
        "test_tgt": "@Test public void stripNS()throws Exception { final IO io = IO.get(\"<a xmlns:a='a'><b><c/><c/><c/></b></a>\"); final ANode root = new DBNode(io, context.options); final QueryProcessor qp = new QueryProcessor(\"/*:a/*:b\", context).context(root); final ANode sub = (ANode)qp.iter().next(); DataBuilder.stripNS(sub, token(\"a\"), context); } "
    },
    {
        "test_src": "@Test public void testAdd()throws Exception { String id = \"key\"; String url = new File(\"target/test-classes/nvdcve-2.0-2012.xml\").toURI().toString(); UpdateableNvdCve instance = new UpdateableNvdCve(); instance.add(id, url, url, false); boolean expResult = false; boolean result = instance.isUpdateNeeded(); assertEquals(expResult, result); instance.add(\"nextId\", url, url, false); NvdCveInfo results = instance.get(id); assertEquals(id, results.getId()); assertEquals(url, results.getUrl()); assertEquals(url, results.getOldSchemaVersionUrl()); } ",
        "focal_tgt": "public void add(String id, String url, String oldUrl, long timestamp, boolean needsUpdate) { final NvdCveInfo item = new NvdCveInfo(); item.setNeedsUpdate(needsUpdate); item.setId(id); item.setUrl(url); item.setOldSchemaVersionUrl(oldUrl); item.setTimestamp(timestamp); collection.put(id, item); } ",
        "focal_src": "public void add(String id, String url, String oldUrl, boolean needsUpdate)throws MalformedURLException, DownloadFailedException { final NvdCveInfo item = new NvdCveInfo(); item.setNeedsUpdate(needsUpdate); item.setId(id); item.setUrl(url); item.setOldSchemaVersionUrl(oldUrl); LOGGER.debug(\"Checking for updates from: {}\", url); item.setTimestamp(Downloader.getLastModified(new URL(url))); collection.put(id, item); } ",
        "test_tgt": "@Test public void testAdd()throws Exception { String id = \"key\"; String url = new File(\"target/test-classes/nvdcve-2.0-2012.xml\").toURI().toString(); long timestamp = 42; UpdateableNvdCve instance = new UpdateableNvdCve(); instance.add(id, url, url, timestamp, false); boolean expResult = false; boolean result = instance.isUpdateNeeded(); assertEquals(expResult, result); instance.add(\"nextId\", url, url, 23, false); NvdCveInfo results = instance.get(id); assertEquals(id, results.getId()); assertEquals(url, results.getUrl()); assertEquals(url, results.getOldSchemaVersionUrl()); assertEquals(timestamp, results.getTimestamp()); } "
    },
    {
        "test_src": "@Test public void testBuildTripOptions() { ObaRegion tampa = MockRegion.getTampa(getTargetContext()); assertNotNull(tampa); Application.get().setCurrentRegion(tampa); ObaArrivalInfoResponse response = new ObaArrivalInfoRequest.Builder(getTargetContext(), \"Hillsborough Area Regional Transit_3105\").build().call(); assertOK(response); ObaStop stop = response.getStop(); assertNotNull(stop); assertEquals(\"Hillsborough Area Regional Transit_3105\", stop.getId()); List < ObaRoute > routes = response.getRoutes(stop.getRouteIds()); assertTrue(routes.size() > 0); ObaAgency agency = response.getAgency(routes.get(0).getAgencyId()); assertEquals(\"Hillsborough Area Regional Transit\", agency.getId()); ObaArrivalInfo[]arrivals = response.getArrivalInfo(); assertNotNull(arrivals); ArrayList < ArrivalInfo > arrivalInfo = ArrivalInfoUtils.convertObaArrivalInfo(getTargetContext(), arrivals, null, response.getCurrentTime(), true); ObaRoute route = response.getRoute(arrivalInfo.get(0).getInfo().getRouteId()); String url = route != null ? route.getUrl() : null; boolean hasUrl = ! TextUtils.isEmpty(url); boolean isReminderVisible = false; boolean isRouteFavorite = false; List < String > options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl, isReminderVisible); assertEquals(options.get(0), \"Add star to route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Set a reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Show route schedule\"); assertEquals(options.get(6), \"Report arrival time problem\"); isReminderVisible = true; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl, isReminderVisible); assertEquals(options.get(0), \"Add star to route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Show route schedule\"); assertEquals(options.get(6), \"Report arrival time problem\"); ObaArrivalInfoResponse response2 = new ObaArrivalInfoRequest.Builder(getTargetContext(), \"PSTA_4077\").build().call(); assertOK(response2); stop = response2.getStop(); assertNotNull(stop); assertEquals(\"PSTA_4077\", stop.getId()); routes = response2.getRoutes(stop.getRouteIds()); assertTrue(routes.size() > 0); agency = response2.getAgency(routes.get(0).getAgencyId()); assertEquals(\"PSTA\", agency.getId()); arrivals = response2.getArrivalInfo(); assertNotNull(arrivals); arrivalInfo = ArrivalInfoUtils.convertObaArrivalInfo(getTargetContext(), arrivals, null, response2.getCurrentTime(), true); route = response2.getRoute(arrivalInfo.get(0).getInfo().getRouteId()); url = route != null ? route.getUrl() : null; boolean hasUrl2 = ! TextUtils.isEmpty(url); isReminderVisible = false; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible); assertEquals(options.get(0), \"Add star to route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Set a reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); isReminderVisible = true; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible); assertEquals(options.get(0), \"Add star to route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); isRouteFavorite = true; isReminderVisible = false; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl, isReminderVisible); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Set a reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Show route schedule\"); assertEquals(options.get(6), \"Report arrival time problem\"); isReminderVisible = true; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl, isReminderVisible); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Show route schedule\"); assertEquals(options.get(6), \"Report arrival time problem\"); isReminderVisible = false; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Set a reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); isReminderVisible = true; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); } ",
        "focal_tgt": "public static List < String > buildTripOptions(Context c, boolean isRouteFavorite, boolean hasUrl, boolean isReminderVisible, Occupancy occupancy, OccupancyState occupancyState) { ArrayList < String > list = new ArrayList < > (); if( ! isRouteFavorite) { list.add(c.getString(R.string.bus_options_menu_add_star)); } else { list.add(c.getString(R.string.bus_options_menu_remove_star)); } list.add(c.getString(R.string.bus_options_menu_show_route_on_map)); list.add(c.getString(R.string.bus_options_menu_show_trip_details)); if( ! isReminderVisible) { list.add(c.getString(R.string.bus_options_menu_set_reminder)); } else { list.add(c.getString(R.string.bus_options_menu_edit_reminder)); } list.add(c.getString(R.string.bus_options_menu_show_only_this_route)); if(hasUrl) { list.add(c.getString(R.string.bus_options_menu_show_route_schedule)); } list.add(c.getString(R.string.bus_options_menu_report_trip_problem)); ObaRegion currentRegion = Application.get().getCurrentRegion(); if(currentRegion != null && EmbeddedSocialUtils.isSocialEnabled()) { list.add(c.getString(R.string.join_discussion)); } if(occupancy != null) { if(occupancyState == OccupancyState.HISTORICAL) { list.add(c.getString(R.string.menu_title_about_historical_occupancy)); } else { list.add(c.getString(R.string.menu_title_about_occupancy)); } } return list; } ",
        "focal_src": "public static List < String > buildTripOptions(Context c, boolean isRouteFavorite, boolean hasUrl, boolean isReminderVisible) { ArrayList < String > list = new ArrayList < > (); if( ! isRouteFavorite) { list.add(c.getString(R.string.bus_options_menu_add_star)); } else { list.add(c.getString(R.string.bus_options_menu_remove_star)); } list.add(c.getString(R.string.bus_options_menu_show_route_on_map)); list.add(c.getString(R.string.bus_options_menu_show_trip_details)); if( ! isReminderVisible) { list.add(c.getString(R.string.bus_options_menu_set_reminder)); } else { list.add(c.getString(R.string.bus_options_menu_edit_reminder)); } list.add(c.getString(R.string.bus_options_menu_show_only_this_route)); if(hasUrl) { list.add(c.getString(R.string.bus_options_menu_show_route_schedule)); } list.add(c.getString(R.string.bus_options_menu_report_trip_problem)); ObaRegion currentRegion = Application.get().getCurrentRegion(); if(currentRegion != null && EmbeddedSocialUtils.isSocialEnabled()) { list.add(c.getString(R.string.join_discussion)); } return list; } ",
        "test_tgt": "@Test public void testBuildTripOptions() { ObaRegion tampa = MockRegion.getTampa(getTargetContext()); assertNotNull(tampa); Application.get().setCurrentRegion(tampa); ObaArrivalInfoResponse response = new ObaArrivalInfoRequest.Builder(getTargetContext(), \"Hillsborough Area Regional Transit_3105\").build().call(); assertOK(response); ObaStop stop = response.getStop(); assertNotNull(stop); assertEquals(\"Hillsborough Area Regional Transit_3105\", stop.getId()); List < ObaRoute > routes = response.getRoutes(stop.getRouteIds()); assertTrue(routes.size() > 0); ObaAgency agency = response.getAgency(routes.get(0).getAgencyId()); assertEquals(\"Hillsborough Area Regional Transit\", agency.getId()); ObaArrivalInfo[]arrivals = response.getArrivalInfo(); assertNotNull(arrivals); ArrayList < ArrivalInfo > arrivalInfo = ArrivalInfoUtils.convertObaArrivalInfo(getTargetContext(), arrivals, null, response.getCurrentTime(), true); ObaRoute route = response.getRoute(arrivalInfo.get(0).getInfo().getRouteId()); String url = route != null ? route.getUrl() : null; boolean hasUrl = ! TextUtils.isEmpty(url); boolean isReminderVisible = false; boolean isRouteFavorite = false; Occupancy occupancy = null; OccupancyState occupancyState = null; if(arrivalInfo.get(0).getInfo().getPredictedOccupancy() != null) { occupancy = arrivalInfo.get(0).getInfo().getPredictedOccupancy(); occupancyState = OccupancyState.PREDICTED; } else if(arrivalInfo.get(0).getInfo().getHistoricalOccupancy() != null) { occupancy = arrivalInfo.get(0).getInfo().getHistoricalOccupancy(); occupancyState = OccupancyState.HISTORICAL; } List < String > options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl, isReminderVisible, occupancy, occupancyState); assertEquals(8, options.size()); assertEquals(options.get(0), \"Add star to route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Set a reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Show route schedule\"); assertEquals(options.get(6), \"Report arrival time problem\"); assertEquals(options.get(7), \"Join discussion\"); isReminderVisible = true; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl, isReminderVisible, occupancy, occupancyState); assertEquals(8, options.size()); assertEquals(options.get(0), \"Add star to route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Show route schedule\"); assertEquals(options.get(6), \"Report arrival time problem\"); assertEquals(options.get(7), \"Join discussion\"); ObaArrivalInfoResponse response2 = new ObaArrivalInfoRequest.Builder(getTargetContext(), \"PSTA_4077\").build().call(); assertOK(response2); stop = response2.getStop(); assertNotNull(stop); assertEquals(\"PSTA_4077\", stop.getId()); routes = response2.getRoutes(stop.getRouteIds()); assertTrue(routes.size() > 0); agency = response2.getAgency(routes.get(0).getAgencyId()); assertEquals(\"PSTA\", agency.getId()); arrivals = response2.getArrivalInfo(); assertNotNull(arrivals); arrivalInfo = ArrivalInfoUtils.convertObaArrivalInfo(getTargetContext(), arrivals, null, response2.getCurrentTime(), true); route = response2.getRoute(arrivalInfo.get(0).getInfo().getRouteId()); url = route != null ? route.getUrl() : null; boolean hasUrl2 = ! TextUtils.isEmpty(url); isReminderVisible = false; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible, occupancy, occupancyState); assertEquals(7, options.size()); assertEquals(options.get(0), \"Add star to route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Set a reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); assertEquals(options.get(6), \"Join discussion\"); isReminderVisible = true; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible, occupancy, occupancyState); assertEquals(7, options.size()); assertEquals(options.get(0), \"Add star to route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); assertEquals(options.get(6), \"Join discussion\"); isRouteFavorite = true; isReminderVisible = false; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl, isReminderVisible, occupancy, occupancyState); assertEquals(8, options.size()); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Set a reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Show route schedule\"); assertEquals(options.get(6), \"Report arrival time problem\"); assertEquals(options.get(7), \"Join discussion\"); isReminderVisible = true; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl, isReminderVisible, occupancy, occupancyState); assertEquals(8, options.size()); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Show route schedule\"); assertEquals(options.get(6), \"Report arrival time problem\"); assertEquals(options.get(7), \"Join discussion\"); isReminderVisible = false; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible, occupancy, occupancyState); assertEquals(7, options.size()); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Set a reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); assertEquals(options.get(6), \"Join discussion\"); isReminderVisible = true; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible, occupancy, occupancyState); assertEquals(7, options.size()); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); assertEquals(options.get(6), \"Join discussion\"); occupancy = Occupancy.EMPTY; occupancyState = OccupancyState.HISTORICAL; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible, occupancy, occupancyState); assertEquals(8, options.size()); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); assertEquals(options.get(6), \"Join discussion\"); assertEquals(options.get(7), \"About historical occupancy\"); occupancy = Occupancy.EMPTY; occupancyState = OccupancyState.PREDICTED; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible, occupancy, occupancyState); assertEquals(8, options.size()); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); assertEquals(options.get(6), \"Join discussion\"); assertEquals(options.get(7), \"About occupancy\"); occupancy = Occupancy.EMPTY; occupancyState = OccupancyState.REALTIME; options = UIUtils.buildTripOptions(getTargetContext(), isRouteFavorite, hasUrl2, isReminderVisible, occupancy, occupancyState); assertEquals(8, options.size()); assertEquals(options.get(0), \"Remove star from route\"); assertEquals(options.get(1), \"Show route on map\"); assertEquals(options.get(2), \"Show trip status\"); assertEquals(options.get(3), \"Edit this reminder\"); assertEquals(options.get(4), \"Show only this route\"); assertEquals(options.get(5), \"Report arrival time problem\"); assertEquals(options.get(6), \"Join discussion\"); assertEquals(options.get(7), \"About occupancy\"); } "
    },
    {
        "test_src": "@Test public void testIdentify() { Map < String, Object > response = new HashMap < String, Object > (); List < IdentifiedLanguage > langs = new ArrayList < IdentifiedLanguage > (); langs.add(new IdentifiedLanguage(\"en\", 0.877159)); langs.add(new IdentifiedLanguage(\"af\", 0.0752636)); langs.add(new IdentifiedLanguage(\"nl\", 0.0301593)); response.put(\"languages\", langs); mockServer.when(request().withMethod(\"POST\").withPath(IDENTITY_PATH).withBody(text)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, MediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGson().toJson(response))); List < IdentifiedLanguage > identifiedLanguages = service.identify(text); assertNotNull(identifiedLanguages); assertFalse(identifiedLanguages.isEmpty()); assertNotNull(identifiedLanguages.containsAll(langs)); } ",
        "focal_tgt": "public List < IdentifiedLanguage > identify(final String text) { final Request request = RequestBuilder.post(\"/v2/identify\").withBodyContent(text, HttpMediaType.TEXT_PLAIN).withHeader(HttpHeaders.ACCEPT, HttpMediaType.APPLICATION_JSON).build(); final Response response = execute(request); final JsonObject jsonObject = ResponseUtil.getJsonObject(response); final List < IdentifiedLanguage > identifiedLanguages = GsonSingleton.getGson().fromJson(jsonObject.get(LANGUAGES), translationModelListType); return identifiedLanguages; } ",
        "focal_src": "public List < IdentifiedLanguage > identify(final String text) { HttpRequestBase request = Request.Post(\"/v2/identify\").withContent(text, MediaType.TEXT_PLAIN).withHeader(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON).build(); try { HttpResponse response = execute(request); JsonObject jsonObject = ResponseUtil.getJsonObject(response); List < IdentifiedLanguage > identifiedLanguages = GsonSingleton.getGson().fromJson(jsonObject.get(LANGUAGES), translationModelListType); return identifiedLanguages; } catch(IOException e) { throw new RuntimeException(e); } } ",
        "test_tgt": "@Test public void testIdentify() { final Map < String, Object > response = new HashMap < String, Object > (); final List < IdentifiedLanguage > langs = new ArrayList < IdentifiedLanguage > (); langs.add(new IdentifiedLanguage(\"en\", 0.877159)); langs.add(new IdentifiedLanguage(\"af\", 0.0752636)); langs.add(new IdentifiedLanguage(\"nl\", 0.0301593)); response.put(\"languages\", langs); mockServer.when(request().withMethod(\"POST\").withPath(IDENTITY_PATH).withBody(text)).respond(response().withHeaders(new Header(HttpHeaders.Names.CONTENT_TYPE, HttpMediaType.APPLICATION_JSON)).withBody(GsonSingleton.getGson().toJson(response))); final List < IdentifiedLanguage > identifiedLanguages = service.identify(text); assertNotNull(identifiedLanguages); assertFalse(identifiedLanguages.isEmpty()); assertNotNull(identifiedLanguages.containsAll(langs)); } "
    },
    {
        "test_src": "@Test public void testDelete()throws IOException, SQLException { File f = new File(testProps.get(\"test.bitstream\").toString()); Bitstream delBS = Bitstream.create(context, new FileInputStream(f)); assertFalse(\"testIsDeleted 0\", delBS.isDeleted()); delBS.delete(); assertTrue(\"testDelete 0\", delBS.isDeleted()); } ",
        "focal_tgt": "public static void delete(Context ctx, int type, UUID id, String handle, List < String > identifiers)throws SQLException, RDFMissingIdentifierException { String uri = RDFConfiguration.getURIGenerator().generateIdentifier(ctx, type, id, handle, identifiers); if(uri != null) { RDFConfiguration.getRDFStorage().delete(uri); } else { throw new RDFMissingIdentifierException(type, id); } } ",
        "focal_src": "public static void delete(Context ctx, int type, int id, String handle, String[]identifiers)throws SQLException, RDFMissingIdentifierException { String uri = RDFConfiguration.getURIGenerator().generateIdentifier(ctx, type, id, handle, identifiers); if(uri != null) { RDFConfiguration.getRDFStorage().delete(uri); } else { throw new RDFMissingIdentifierException(type, id); } } ",
        "test_tgt": "@Test public void testDelete()throws IOException, SQLException, AuthorizeException { new NonStrictExpectations(authorizeService.getClass()) { { authorizeService.authorizeAction((Context)any, (Bitstream)any, Constants.WRITE); result = null; authorizeService.authorizeAction((Context)any, (Bitstream)any, Constants.DELETE); result = null; } }; File f = new File(testProps.get(\"test.bitstream\").toString()); Bitstream delBS = bitstreamService.create(context, new FileInputStream(f)); assertFalse(\"testIsDeleted 0\", delBS.isDeleted()); bitstreamService.delete(context, delBS); assertTrue(\"testDelete 0\", delBS.isDeleted()); } "
    },
    {
        "test_src": "@Test public void createSSOToken_TokenCreationFailedException()throws Exception { mock.checking(new Expectations() { { one(testTokenService).createToken(testTokenData); will(throwException(new TokenCreationFailedException(\"Expected test exception\"))); } }); try { tokenManager.createToken(TEST_TOKEN_TYPE, testTokenData); fail(\"createToken should have throw an TokenCreationFailedException as per the mock setting\"); } catch(TokenCreationFailedException e) { } } ",
        "focal_tgt": "public SingleSignonToken createSSOToken(Map < String, Object > tokenData)throws TokenCreationFailedException { try { TokenService tokenService = getTokenServiceForType(ssoTokenType); SingleSignonTokenImpl ssoToken = new SingleSignonTokenImpl(tokenService); Token ssoLtpaToken = tokenService.createToken(tokenData); ssoToken.initializeToken(ssoLtpaToken); return ssoToken; } catch(IllegalArgumentException e) { throw new TokenCreationFailedException(e.getMessage(), e); } } ",
        "focal_src": "@Override public SingleSignonToken createSSOToken(Map < String, Object > tokenData)throws TokenCreationFailedException { try { TokenService tokenService = getTokenServiceForType(ssoTokenType); SingleSignonTokenImpl ssoToken = new SingleSignonTokenImpl(tokenService); Token ssoLtpaToken = tokenService.createToken(tokenData); ssoToken.initializeToken(ssoLtpaToken); return ssoToken; } catch(IllegalArgumentException e) { throw new TokenCreationFailedException(e.getMessage(), e); } } ",
        "test_tgt": "@Test public void createSSOToken_TokenCreationFailedException()throws Exception { mock.checking(new Expectations() { { one(testTokenService).createToken(testTokenData); will(throwException(new TokenCreationFailedException(\"Expected test exception\"))); } }); try { tokenManager.createToken(TEST_TOKEN_TYPE, testTokenData); fail(\"createToken should have throw an TokenCreationFailedException as per the mock setting\"); } catch(TokenCreationFailedException e) { } } "
    },
    {
        "test_src": "@Test(dataProvider = \"calendars\")public void test_date_comparisons(Chrono chrono) { List < ChronoLocalDate < ? > > dates = new ArrayList < > (); ChronoLocalDate < ? > date = chrono.date(LocalDate.of(1900, 1, 1)); dates.add(date.minus(1000, ChronoUnit.YEARS)); dates.add(date.minus(100, ChronoUnit.YEARS)); dates.add(date.minus(10, ChronoUnit.YEARS)); dates.add(date.minus(1, ChronoUnit.YEARS)); dates.add(date.minus(1, ChronoUnit.MONTHS)); dates.add(date.minus(1, ChronoUnit.WEEKS)); dates.add(date.minus(1, ChronoUnit.DAYS)); dates.add(date); dates.add(date.plus(1, ChronoUnit.DAYS)); dates.add(date.plus(1, ChronoUnit.WEEKS)); dates.add(date.plus(1, ChronoUnit.MONTHS)); dates.add(date.plus(1, ChronoUnit.YEARS)); dates.add(date.plus(10, ChronoUnit.YEARS)); dates.add(date.plus(100, ChronoUnit.YEARS)); dates.add(date.plus(1000, ChronoUnit.YEARS)); for(Chrono[]clist : data_of_calendars()) { List < ChronoLocalDate < ? > > otherDates = new ArrayList < > (); Chrono chrono2 = clist[0]; for(ChronoLocalDate < ? > d : dates) { otherDates.add(chrono2.date(d)); } for(int i = 0; i < dates.size(); i ++ ) { ChronoLocalDate < ? > a = dates.get(i); for(int j = 0; j < otherDates.size(); j ++ ) { ChronoLocalDate < ? > b = otherDates.get(j); int cmp = ChronoLocalDate.DATE_COMPARATOR.compare(a, b); if(i < j) { assertTrue(cmp < 0, a + \" compare \" + b); assertEquals(a.isBefore(b), true, a + \" isBefore \" + b); assertEquals(a.isAfter(b), false, a + \" isAfter \" + b); assertEquals(a.isEqual(b), false, a + \" isEqual \" + b); } else if(i > j) { assertTrue(cmp > 0, a + \" compare \" + b); assertEquals(a.isBefore(b), false, a + \" isBefore \" + b); assertEquals(a.isAfter(b), true, a + \" isAfter \" + b); assertEquals(a.isEqual(b), false, a + \" isEqual \" + b); } else { assertTrue(cmp == 0, a + \" compare \" + b); assertEquals(a.isBefore(b), false, a + \" isBefore \" + b); assertEquals(a.isAfter(b), false, a + \" isAfter \" + b); assertEquals(a.isEqual(b), true, a + \" isEqual \" + b); } } } } } ",
        "focal_tgt": "@Override public ChronoLocalDate < HijrahChronology > date(int year, int month, int day) { return getChronology().date(this, year, month, day); } ",
        "focal_src": "@Override public ChronoLocalDate < HijrahChrono > date(int year, int month, int day) { return getChrono().date(this, year, month, day); } ",
        "test_tgt": "@Test(dataProvider = \"calendars\")public void test_date_comparisons(Chronology chrono) { List < ChronoLocalDate < ? > > dates = new ArrayList < > (); ChronoLocalDate < ? > date = chrono.date(LocalDate.of(1900, 1, 1)); dates.add(date.minus(1000, ChronoUnit.YEARS)); dates.add(date.minus(100, ChronoUnit.YEARS)); dates.add(date.minus(10, ChronoUnit.YEARS)); dates.add(date.minus(1, ChronoUnit.YEARS)); dates.add(date.minus(1, ChronoUnit.MONTHS)); dates.add(date.minus(1, ChronoUnit.WEEKS)); dates.add(date.minus(1, ChronoUnit.DAYS)); dates.add(date); dates.add(date.plus(1, ChronoUnit.DAYS)); dates.add(date.plus(1, ChronoUnit.WEEKS)); dates.add(date.plus(1, ChronoUnit.MONTHS)); dates.add(date.plus(1, ChronoUnit.YEARS)); dates.add(date.plus(10, ChronoUnit.YEARS)); dates.add(date.plus(100, ChronoUnit.YEARS)); dates.add(date.plus(1000, ChronoUnit.YEARS)); for(Chronology[]clist : data_of_calendars()) { List < ChronoLocalDate < ? > > otherDates = new ArrayList < > (); Chronology chrono2 = clist[0]; for(ChronoLocalDate < ? > d : dates) { otherDates.add(chrono2.date(d)); } for(int i = 0; i < dates.size(); i ++ ) { ChronoLocalDate < ? > a = dates.get(i); for(int j = 0; j < otherDates.size(); j ++ ) { ChronoLocalDate < ? > b = otherDates.get(j); int cmp = ChronoLocalDate.DATE_COMPARATOR.compare(a, b); if(i < j) { assertTrue(cmp < 0, a + \" compare \" + b); assertEquals(a.isBefore(b), true, a + \" isBefore \" + b); assertEquals(a.isAfter(b), false, a + \" isAfter \" + b); assertEquals(a.isEqual(b), false, a + \" isEqual \" + b); } else if(i > j) { assertTrue(cmp > 0, a + \" compare \" + b); assertEquals(a.isBefore(b), false, a + \" isBefore \" + b); assertEquals(a.isAfter(b), true, a + \" isAfter \" + b); assertEquals(a.isEqual(b), false, a + \" isEqual \" + b); } else { assertTrue(cmp == 0, a + \" compare \" + b); assertEquals(a.isBefore(b), false, a + \" isBefore \" + b); assertEquals(a.isAfter(b), false, a + \" isAfter \" + b); assertEquals(a.isEqual(b), true, a + \" isEqual \" + b); } } } } } "
    },
    {
        "test_src": "@Test public void testUpdateStream()throws ExecutionException, InterruptedException { String resourceURI = getURI() + \"v1/scopes/\" + scope1 + \"/streams/\" + stream1; when(mockControllerService.updateStream(any())).thenReturn(updateStreamStatus); Response response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest)).invoke(); assertEquals(\"Update Stream Status\", 200, response.getStatus()); StreamProperty streamResponseActual = response.readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); response.close(); response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(createStreamRequest)).invoke(); assertEquals(\"Update Stream Status\", 200, response.getStatus()); streamResponseActual = response.readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); response.close(); when(mockControllerService.updateStream(any())).thenReturn(updateStreamStatus2); response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest2)).invoke(); assertEquals(\"Update Stream Status\", 404, response.getStatus()); response.close(); when(mockControllerService.updateStream(any())).thenReturn(updateStreamStatus3); response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest3)).invoke(); assertEquals(\"Update Stream Status\", 500, response.getStatus()); response.close(); when(mockControllerService.updateStream(any())).thenReturn(updateStreamStatus4); response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest)).invoke(); assertEquals(\"Update Stream Status\", 404, response.getStatus()); response.close(); } ",
        "focal_tgt": "CompletableFuture < Boolean > updateStream(final String scope, final String streamName, final StreamConfiguration streamConfig); ",
        "focal_src": "CompletableFuture < Boolean > updateStream(final StreamConfiguration streamConfig); ",
        "test_tgt": "@Test public void testUpdateStream()throws ExecutionException, InterruptedException { String resourceURI = getURI() + \"v1/scopes/\" + scope1 + \"/streams/\" + stream1; when(mockControllerService.updateStream(any(), any(), any())).thenReturn(updateStreamStatus); Response response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest)).invoke(); assertEquals(\"Update Stream Status\", 200, response.getStatus()); StreamProperty streamResponseActual = response.readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); response.close(); response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(createStreamRequest)).invoke(); assertEquals(\"Update Stream Status\", 200, response.getStatus()); streamResponseActual = response.readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); response.close(); when(mockControllerService.updateStream(any(), any(), any())).thenReturn(updateStreamStatus2); response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest2)).invoke(); assertEquals(\"Update Stream Status\", 404, response.getStatus()); response.close(); when(mockControllerService.updateStream(any(), any(), any())).thenReturn(updateStreamStatus3); response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest3)).invoke(); assertEquals(\"Update Stream Status\", 500, response.getStatus()); response.close(); when(mockControllerService.updateStream(any(), any(), any())).thenReturn(updateStreamStatus4); response = addAuthHeaders(client.target(resourceURI).request()).buildPut(Entity.json(updateStreamRequest)).invoke(); assertEquals(\"Update Stream Status\", 404, response.getStatus()); response.close(); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should unvoid the orders and encounters associated with the patient\", method = \"handle(Patient,User,Date,String)\")public void handle_shouldUnvoidTheOrdersAndEncountersAssociatedWithThePatient()throws Exception { Patient patient = Context.getPatientService().getPatient(7); patient = Context.getPatientService().voidPatient(patient, \"Void Reason\"); Assert.assertTrue(patient.isVoided()); EncounterService es = Context.getEncounterService(); EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setPatient(patient).setIncludeVoided(true).createEncounterSearchCriteria(); List < Encounter > encounters = es.getEncounters(encounterSearchCriteria); Assert.assertTrue(CollectionUtils.isNotEmpty(encounters)); for(Encounter encounter : encounters) { Assert.assertTrue(encounter.isVoided()); Assert.assertNotNull(encounter.getDateVoided()); Assert.assertNotNull(encounter.getVoidedBy()); Assert.assertNotNull(encounter.getVoidReason()); } OrderService os = Context.getOrderService(); List < Order > orders = os.getAllOrdersByPatient(patient); Assert.assertFalse(orders.isEmpty()); for(Order order : orders) { Assert.assertTrue(order.isVoided()); Assert.assertNotNull(order.getDateVoided()); Assert.assertNotNull(order.getVoidedBy()); Assert.assertNotNull(order.getVoidReason()); } User user = Context.getUserService().getUser(1); new PatientDataUnvoidHandler().handle(patient, user, patient.getDateVoided(), null); for(Encounter encounter : encounters) { Assert.assertFalse(encounter.isVoided()); Assert.assertNull(encounter.getDateVoided()); Assert.assertNull(encounter.getVoidedBy()); Assert.assertNull(encounter.getVoidReason()); } for(Order order : orders) { Assert.assertFalse(order.isVoided()); Assert.assertNull(order.getDateVoided()); Assert.assertNull(order.getVoidedBy()); Assert.assertNull(order.getVoidReason()); } } ",
        "focal_tgt": "@Override public void handle(Voidable voidableObject, User voidingUser, Date origParentVoidedDate, String unused) { if(voidableObject.getVoided() && (origParentVoidedDate == null || origParentVoidedDate.equals(voidableObject.getDateVoided()))) { voidableObject.setVoided(false); voidableObject.setVoidedBy(null); voidableObject.setDateVoided(null); voidableObject.setVoidReason(null); } } ",
        "focal_src": "@Override public void handle(Voidable voidableObject, User voidingUser, Date origParentVoidedDate, String unused) { if(voidableObject.isVoided() && (origParentVoidedDate == null || origParentVoidedDate.equals(voidableObject.getDateVoided()))) { voidableObject.setVoided(false); voidableObject.setVoidedBy(null); voidableObject.setDateVoided(null); voidableObject.setVoidReason(null); } } ",
        "test_tgt": "@Test@Verifies(value = \"should unvoid the orders and encounters associated with the patient\", method = \"handle(Patient,User,Date,String)\")public void handle_shouldUnvoidTheOrdersAndEncountersAssociatedWithThePatient()throws Exception { Patient patient = Context.getPatientService().getPatient(7); patient = Context.getPatientService().voidPatient(patient, \"Void Reason\"); Assert.assertTrue(patient.getVoided()); EncounterService es = Context.getEncounterService(); EncounterSearchCriteria encounterSearchCriteria = new EncounterSearchCriteriaBuilder().setPatient(patient).setIncludeVoided(true).createEncounterSearchCriteria(); List < Encounter > encounters = es.getEncounters(encounterSearchCriteria); Assert.assertTrue(CollectionUtils.isNotEmpty(encounters)); for(Encounter encounter : encounters) { Assert.assertTrue(encounter.getVoided()); Assert.assertNotNull(encounter.getDateVoided()); Assert.assertNotNull(encounter.getVoidedBy()); Assert.assertNotNull(encounter.getVoidReason()); } OrderService os = Context.getOrderService(); List < Order > orders = os.getAllOrdersByPatient(patient); Assert.assertFalse(orders.isEmpty()); for(Order order : orders) { Assert.assertTrue(order.getVoided()); Assert.assertNotNull(order.getDateVoided()); Assert.assertNotNull(order.getVoidedBy()); Assert.assertNotNull(order.getVoidReason()); } User user = Context.getUserService().getUser(1); new PatientDataUnvoidHandler().handle(patient, user, patient.getDateVoided(), null); for(Encounter encounter : encounters) { Assert.assertFalse(encounter.getVoided()); Assert.assertNull(encounter.getDateVoided()); Assert.assertNull(encounter.getVoidedBy()); Assert.assertNull(encounter.getVoidReason()); } for(Order order : orders) { Assert.assertFalse(order.getVoided()); Assert.assertNull(order.getDateVoided()); Assert.assertNull(order.getVoidedBy()); Assert.assertNull(order.getVoidReason()); } } "
    },
    {
        "test_src": "@Test public void testPatchCommand()throws GenieException, IOException { final Command getCommand = this.service.getCommand(COMMAND_1_ID); Assert.assertThat(getCommand.getName(), Matchers.is(COMMAND_1_NAME)); final Date updateTime = getCommand.getUpdated().orElseThrow(IllegalArgumentException :: new); final String patchString = \"[{ \\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/name\\\", \\\"value\\\": \\\"\" + COMMAND_2_NAME + \"\\\" }]\"; final ObjectMapper mapper = new ObjectMapper(); final JsonPatch patch = JsonPatch.fromJson(mapper.readTree(patchString)); this.service.patchCommand(COMMAND_1_ID, patch); final Command updated = this.service.getCommand(COMMAND_1_ID); Assert.assertNotEquals(updated.getUpdated(), Matchers.is(updateTime)); Assert.assertThat(updated.getName(), Matchers.is(COMMAND_2_NAME)); } ",
        "focal_tgt": "@Override public void patchCommand(@NotBlank final String id, @NotNull final JsonPatch patch)throws GenieException { final CommandEntity commandEntity = this.findCommand(id); try { final Command commandToPatch = JpaServiceUtils.toCommandDto(commandEntity); log.debug(\"Will patch command {}. Original state: {}\", id, commandToPatch); final JsonNode commandNode = GenieObjectMapper.getMapper().readTree(commandToPatch.toString()); final JsonNode postPatchNode = patch.apply(commandNode); final Command patchedCommand = GenieObjectMapper.getMapper().treeToValue(postPatchNode, Command.class); log.debug(\"Finished patching command {}. New state: {}\", id, patchedCommand); this.updateEntityWithDtoContents(commandEntity, patchedCommand); } catch(final JsonPatchException | IOException e) { log.error(\"Unable to patch cluster {} with patch {} due to exception.\", id, patch, e); throw new GenieServerException(e.getLocalizedMessage(), e); } } ",
        "focal_src": "@Override public void patchCommand(@NotBlank final String id, @NotNull final JsonPatch patch)throws GenieException { final CommandEntity commandEntity = this.findCommand(id); try { final Command commandToPatch = JpaServiceUtils.toCommandDto(commandEntity); log.debug(\"Will patch command {}. Original state: {}\", id, commandToPatch); final JsonNode commandNode = MAPPER.readTree(commandToPatch.toString()); final JsonNode postPatchNode = patch.apply(commandNode); final Command patchedCommand = MAPPER.treeToValue(postPatchNode, Command.class); log.debug(\"Finished patching command {}. New state: {}\", id, patchedCommand); this.updateEntityWithDtoContents(commandEntity, patchedCommand); } catch(final JsonPatchException | IOException e) { log.error(\"Unable to patch cluster {} with patch {} due to exception.\", id, patch, e); throw new GenieServerException(e.getLocalizedMessage(), e); } } ",
        "test_tgt": "@Test public void testPatchCommand()throws GenieException, IOException { final Command getCommand = this.service.getCommand(COMMAND_1_ID); Assert.assertThat(getCommand.getName(), Matchers.is(COMMAND_1_NAME)); final Date updateTime = getCommand.getUpdated().orElseThrow(IllegalArgumentException :: new); final String patchString = \"[{ \\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/name\\\", \\\"value\\\": \\\"\" + COMMAND_2_NAME + \"\\\" }]\"; final JsonPatch patch = JsonPatch.fromJson(GenieObjectMapper.getMapper().readTree(patchString)); this.service.patchCommand(COMMAND_1_ID, patch); final Command updated = this.service.getCommand(COMMAND_1_ID); Assert.assertNotEquals(updated.getUpdated(), Matchers.is(updateTime)); Assert.assertThat(updated.getName(), Matchers.is(COMMAND_2_NAME)); } "
    },
    {
        "test_src": "@Test public void copy() { List < SquareBlob > all = new ArrayList < SquareBlob > (); all.add(createSquare(50, 60, 10, 12)); all.add(createSquare(51, 61, 11, 13)); all.add(createSquare(52, 62, 12, 14)); all.add(createSquare(53, 63, 13, 15)); connect(0, 1, all); connect(0, 2, all); connect(0, 3, all); connect(1, 3, all); connect(2, 3, all); List < SquareBlob > sub = new ArrayList < SquareBlob > (); sub.add(all.get(0)); sub.add(all.get(1)); sub.add(all.get(2)); List < SquareBlob > found = ConnectGridSquares.copy(sub); checkSquare(found.get(0), 50, 60, 10, 12, 2); checkSquare(found.get(1), 51, 61, 11, 13, 1); checkSquare(found.get(2), 52, 62, 12, 14, 1); } ",
        "focal_tgt": "public static List < QuadBlob > copy(List < QuadBlob > input) { List < QuadBlob > output = new ArrayList < QuadBlob > (); for(QuadBlob i : input) { QuadBlob o = new QuadBlob(); o.contour = i.contour; o.corners = i.corners; o.center = i.center; o.largestSide = i.largestSide; o.smallestSide = i.smallestSide; output.add(o); } for(int index = 0; index < input.size(); index ++ ) { QuadBlob in = input.get(index); QuadBlob out = output.get(index); for(QuadBlob c : in.conn) { int i = input.indexOf(c); if(i >= 0) { out.conn.add(output.get(i)); } } } return output; } ",
        "focal_src": "public static List < SquareBlob > copy(List < SquareBlob > input) { List < SquareBlob > output = new ArrayList < SquareBlob > (); for(SquareBlob i : input) { SquareBlob o = new SquareBlob(); o.contour = i.contour; o.corners = i.corners; o.center = i.center; o.largestSide = i.largestSide; o.smallestSide = i.smallestSide; output.add(o); } for(int index = 0; index < input.size(); index ++ ) { SquareBlob in = input.get(index); SquareBlob out = output.get(index); for(SquareBlob c : in.conn) { int i = input.indexOf(c); if(i >= 0) { out.conn.add(output.get(i)); } } } return output; } ",
        "test_tgt": "@Test public void copy() { List < QuadBlob > all = new ArrayList < QuadBlob > (); all.add(createSquare(50, 60, 10, 12)); all.add(createSquare(51, 61, 11, 13)); all.add(createSquare(52, 62, 12, 14)); all.add(createSquare(53, 63, 13, 15)); connect(0, 1, all); connect(0, 2, all); connect(0, 3, all); connect(1, 3, all); connect(2, 3, all); List < QuadBlob > sub = new ArrayList < QuadBlob > (); sub.add(all.get(0)); sub.add(all.get(1)); sub.add(all.get(2)); List < QuadBlob > found = ConnectGridSquares.copy(sub); checkSquare(found.get(0), 50, 60, 10, 12, 2); checkSquare(found.get(1), 51, 61, 11, 13, 1); checkSquare(found.get(2), 52, 62, 12, 14, 1); } "
    },
    {
        "test_src": "@Test public void testUpdateEntity() { PersistenceManager < Job > pm = new PersistenceManager < Job > (); Job initial = new Job(); UUID uuid = UUID.randomUUID(); initial.setJobID(uuid.toString()); pm.createEntity(initial); initial.setJobStatus(JobStatus.FAILED); Job updated = pm.updateEntity(initial); Assert.assertEquals(\"FAILED\", updated.getStatus()); } ",
        "focal_tgt": "public T updateEntity(T entity) { LOG.debug(\"called\"); EntityManager em = createEntityManager(); try { em.getTransaction().begin(); T result = em.merge(entity); em.getTransaction().commit(); return result; } finally { em.close(); } } ",
        "focal_src": "public T updateEntity(T entity) { logger.debug(\"called\"); EntityManager em = createEntityManager(); try { em.getTransaction().begin(); T result = em.merge(entity); em.getTransaction().commit(); return result; } finally { em.close(); } } ",
        "test_tgt": "@Test public void testUpdateEntity() { PersistenceManager < Job > pm = new PersistenceManager < Job > (); Job initial = new Job(); UUID uuid = UUID.randomUUID(); initial.setJobID(uuid.toString()); initial.setUserName(\"myUserName\"); pm.createEntity(initial); initial.setJobStatus(JobStatus.FAILED); Job updated = pm.updateEntity(initial); Assert.assertEquals(JobStatus.FAILED, updated.getStatus()); } "
    },
    {
        "test_src": "@Test public void reportLostFileTest()throws Exception { TachyonURI path = new TachyonURI(\"test\"); mTachyonLineageFileSystem.reportLostFile(path); Mockito.verify(mLineageMasterClient).reportLostFile(\"test\"); Mockito.verify(mLineageContext).releaseMasterClient(mLineageMasterClient); } ",
        "focal_tgt": "public void reportLostFile(AlluxioURI path)throws IOException, FileDoesNotExistException, AlluxioException { LineageMasterClient masterClient = mLineageContext.acquireMasterClient(); try { masterClient.reportLostFile(path.getPath()); } finally { mLineageContext.releaseMasterClient(masterClient); } } ",
        "focal_src": "public void reportLostFile(TachyonURI path)throws IOException, FileDoesNotExistException, TachyonException { LineageMasterClient masterClient = mLineageContext.acquireMasterClient(); try { masterClient.reportLostFile(path.getPath()); } finally { mLineageContext.releaseMasterClient(masterClient); } } ",
        "test_tgt": "@Test public void reportLostFileTest()throws Exception { AlluxioURI path = new AlluxioURI(\"test\"); mTachyonLineageFileSystem.reportLostFile(path); Mockito.verify(mLineageMasterClient).reportLostFile(\"test\"); Mockito.verify(mLineageContext).releaseMasterClient(mLineageMasterClient); } "
    },
    {
        "test_src": "@Test public void testShouldFireNow() { fail(\"Not yet implemented\"); } ",
        "focal_tgt": "@Override public boolean shouldFireNow()throws SchedulerException { long currentTime = System.currentTimeMillis(); for(IBlockoutTrigger blockOut : getBlockouts()) { if( ! (blockOut instanceof Trigger)) { throw new SchedulerException(Messages.getInstance().getString(ERR_WRONG_BLOCKER_TYPE)); } Trigger blockOutTrigger = (Trigger)blockOut; long lastFireTime = blockOutTrigger.getPreviousFireTime() != null ? blockOutTrigger.getPreviousFireTime().getTime() : blockOutTrigger.getStartTime().getTime(); long endLastFireTime = lastFireTime + blockOut.getBlockDuration(); if(lastFireTime <= currentTime && currentTime <= endLastFireTime) { return false; } } return true; } ",
        "focal_src": "@Override public boolean shouldFireNow() { return true; } ",
        "test_tgt": "@Test public void testShouldFireNow() { try { Date blockOutStartDate = new Date(System.currentTimeMillis()); SimpleBlockoutTrigger blockOutTrigger = new SimpleBlockoutTrigger(\"blockOut1\", blockOutStartDate, null, - 1, TIME.WEEK.time * 2, TIME.HOUR.time * 2); this.blockOutManager.addBlockout(blockOutTrigger); assertFalse(this.blockOutManager.shouldFireNow()); this.blockOutManager.deleteBlockout(blockOutTrigger.getName()); blockOutStartDate = new Date(System.currentTimeMillis() + TIME.HOUR.time); blockOutTrigger = new SimpleBlockoutTrigger(\"blockOut1\", blockOutStartDate, null, - 1, TIME.WEEK.time * 2, TIME.HOUR.time * 2); this.blockOutManager.addBlockout(blockOutTrigger); assertTrue(this.blockOutManager.shouldFireNow()); } catch(SchedulerException e) { throw new RuntimeException(e); } } "
    },
    {
        "test_src": "@Test public void createUser() { User user = UserData.randomUser(); UserDTO userDTO = new UserDTO(); userDTO.setLoginName(user.getLoginName()); userDTO.setName(user.getName()); userDTO.setEmail(user.getEmail()); IdResponse result = accountWebServiceClient.createUser(userDTO); assertNotNull(result.getId()); } ",
        "focal_tgt": "@Override public IdResponse createUser(UserDTO user) { IdResponse response = new IdResponse(); try { Validate.notNull(user, \"\u7528\u6237\u53c2\u6570\u4e3a\u7a7a\"); User userEntity = BeanMapper.map(user, User.class); BeanValidators.validateWithException(validator, userEntity); accountService.saveUser(userEntity); return new IdResponse(userEntity.getId()); } catch(ConstraintViolationException e) { String message = StringUtils.join(BeanValidators.extractPropertyAndMessageAsList(e, \" \"), \"\\n\"); return handleParameterError(response, e, message); } catch(RuntimeException e) { if(Exceptions.isCausedBy(e, org.hibernate.exception.ConstraintViolationException.class)) { String message = \"\u65b0\u5efa\u7528\u6237\u53c2\u6570\u5b58\u5728\u552f\u4e00\u6027\u51b2\u7a81(\u7528\u6237:\" + user + \")\"; return handleParameterError(response, e, message); } else { return handleGeneralError(response, e); } } } ",
        "focal_src": "@Override public IdResponse createUser(UserDTO user) { IdResponse response = new IdResponse(); try { Validate.notNull(user, \"\u7528\u6237\u53c2\u6570\u4e3a\u7a7a\"); User userEntity = BeanMapper.map(user, User.class); BeanValidators.validateWithException(validator, userEntity); accountDao.saveUser(userEntity); return new IdResponse(userEntity.getId()); } catch(ConstraintViolationException e) { String message = StringUtils.join(BeanValidators.extractPropertyAndMessageAsList(e, \" \"), \"\\n\"); return handleParameterError(response, e, message); } catch(DataIntegrityViolationException e) { String message = \"\u65b0\u5efa\u7528\u6237\u53c2\u6570\u5b58\u5728\u552f\u4e00\u6027\u51b2\u7a81(\u7528\u6237:\" + user + \")\"; return handleParameterError(response, e, message); } catch(RuntimeException e) { return handleGeneralError(response, e); } } ",
        "test_tgt": "@Test public void createUser() { User user = UserData.randomUser(); UserDTO userDTO = BeanMapper.map(user, UserDTO.class); IdResponse response = accountWebServiceClient.createUser(userDTO); assertNotNull(response.getId()); GetUserResponse response2 = accountWebServiceClient.getUser(response.getId()); assertEquals(user.getLoginName(), response2.getUser().getLoginName()); } "
    },
    {
        "test_src": "@Test public void testConnect()throws SQLException { final Properties info = new Properties(); assertNull(\"connect\", driver.connect(null, info)); info.put(\"driver\", \"sun.jdbc.odbc.JdbcOdbcDriver\"); try { driver.connect(null, info); } catch(final SQLException e) { assertNotNull(\"connect\", e); } info.put(\"driver\", \"nimporte.quoi\"); try { driver.connect(null, info); } catch(final SQLException e) { assertNotNull(\"connect\", e); } } ",
        "focal_tgt": "@Override public Connection connect(String url, Properties info)throws SQLException { if(\"false\".equals(info.get(\"javamelody\"))) { return null; } final Properties myInfo = (Properties)info.clone(); myInfo.put(\"javamelody\", \"false\"); String myUrl = url; String proxiedDriver = myInfo.getProperty(\"driver\"); if(proxiedDriver != null) { myInfo.remove(\"driver\"); } else if(myUrl != null) { final int index = myUrl.indexOf(\"driver=\"); if(index != - 1) { proxiedDriver = myUrl.substring(index + \"driver=\".length()); myUrl = myUrl.substring(0, index - 1); } } if(proxiedDriver != null) { try { Class.forName(proxiedDriver, true, Thread.currentThread().getContextClassLoader()); } catch(final ClassNotFoundException e) { throw new SQLException(e.getMessage(), e); } } Parameters.initJdbcDriverParameters(myUrl, myInfo); return JdbcWrapper.SINGLETON.createConnectionProxy(DriverManager.getConnection(myUrl, myInfo)); } ",
        "focal_src": "@Override public Connection connect(String url, Properties info)throws SQLException { final String proxiedDriver = info.getProperty(\"driver\"); if(proxiedDriver == null) { return null; } try { Class.forName(proxiedDriver, true, Thread.currentThread().getContextClassLoader()); } catch(final ClassNotFoundException e) { throw new SQLException(e.getMessage(), e); } final Properties tmp = (Properties)info.clone(); tmp.remove(\"driver\"); Parameters.initJdbcDriverParameters(url, tmp); return JdbcWrapper.SINGLETON.createConnectionProxy(DriverManager.getConnection(url, tmp)); } ",
        "test_tgt": "@Test public void testConnect()throws SQLException { final Properties info = new Properties(); try { driver.connect(null, info); } catch(final SQLException e) { assertNotNull(\"connect\", e); } driver.connect(\"jdbc:h2:mem:?driver=org.h2.Driver\", info); info.put(\"driver\", \"org.h2.Driver\"); driver.connect(\"jdbc:h2:mem:\", info); info.put(\"driver\", \"nimporte.quoi\"); try { driver.connect(null, info); } catch(final SQLException e) { assertNotNull(\"connect\", e); } } "
    },
    {
        "test_src": "@Test@Ignore@Verifies(value = \"should always return unique orderNumbers when called multiple times without saving orders\", method = \"getNewOrderNumber()\")public void getNewOrderNumber_shouldAlwaysReturnUniqueOrderNumbersWhenCalledMultipleTimesWithoutSavingOrders()throws Exception { executeDataSet(\"org/openmrs/api/include/OrderServiceTest-globalProperties.xml\"); int N = 50; final Set < String > uniqueOrderNumbers = new HashSet < String > (50); List < Thread > threads = new ArrayList < Thread > (); for(int i = 0; i < N; i ++ ) { threads.add(new Thread(new Runnable() { @Override public void run() { try { Context.openSession(); Context.addProxyPrivilege(PrivilegeConstants.ADD_ORDERS); uniqueOrderNumbers.add(((OrderNumberGenerator)Context.getOrderService()).getNewOrderNumber()); } finally { Context.removeProxyPrivilege(PrivilegeConstants.ADD_ORDERS); Context.closeSession(); } } })); } for(int i = 0; i < N; ++ i) { threads.get(i).start(); } for(int i = 0; i < N; ++ i) { threads.get(i).join(); } Assert.assertEquals(N, uniqueOrderNumbers.size()); } ",
        "focal_tgt": "@Override public String getNewOrderNumber() { return ORDER_NUMBER_PREFIX + Context.getOrderService().getNextOrderNumberSeedSequenceValue(); } ",
        "focal_src": "@Override public synchronized String getNewOrderNumber() { return ORDER_NUMBER_PREFIX + Context.getOrderService().getNextOrderNumberSeedSequenceValue(); } ",
        "test_tgt": "@Test@Verifies(value = \"should always return unique orderNumbers when called multiple times without saving orders\", method = \"getNewOrderNumber()\")public void getNewOrderNumber_shouldAlwaysReturnUniqueOrderNumbersWhenCalledMultipleTimesWithoutSavingOrders()throws Exception { executeDataSet(\"org/openmrs/api/include/OrderServiceTest-globalProperties.xml\"); int N = 50; final Set < String > uniqueOrderNumbers = new HashSet < String > (50); List < Thread > threads = new ArrayList < Thread > (); for(int i = 0; i < N; i ++ ) { threads.add(new Thread(new Runnable() { @Override public void run() { try { Context.openSession(); Context.addProxyPrivilege(PrivilegeConstants.ADD_ORDERS); uniqueOrderNumbers.add(((OrderNumberGenerator)Context.getOrderService()).getNewOrderNumber()); } finally { Context.removeProxyPrivilege(PrivilegeConstants.ADD_ORDERS); Context.closeSession(); } } })); } for(int i = 0; i < N; ++ i) { threads.get(i).start(); } for(int i = 0; i < N; ++ i) { threads.get(i).join(); } Assert.assertEquals(N, uniqueOrderNumbers.size()); } "
    },
    {
        "test_src": "@Test public void testGetTemporaryFile()throws Exception { getContext().setDatabase(\"wiki\"); createEmptyFile(\"temp/module/wiki/Space/Page/file.txt\"); Assert.assertNotNull(action.getTemporaryFile(\"/xwiki/bin/temp/Space/Page/module/file.txt\", getContext())); } ",
        "focal_tgt": "protected File getTemporaryFile(String uri, XWikiContext context) { Matcher matcher = URI_PATTERN.matcher(uri); File result = null; if(matcher.find()) { String wiki = context.getWikiId(); try { wiki = URLEncoder.encode(wiki, URL_ENCODING); } catch(UnsupportedEncodingException e) { } String space = withMinimalURLEncoding(matcher.group(1)); String page = withMinimalURLEncoding(matcher.group(2)); String module = withMinimalURLEncoding(matcher.group(3)); String filePath = matcher.group(4); String prefix = String.format(\"temp/%s/%s/%s/%s/\", module, wiki, space, page); String path = URI.create(prefix + filePath).normalize().toString(); if(path.startsWith(prefix)) { result = new File(this.environment.getTemporaryDirectory(), path); result = result.exists() ? result : null; } } return result; } ",
        "focal_src": "protected File getTemporaryFile(String uri, XWikiContext context) { Matcher matcher = URI_PATTERN.matcher(uri); File result = null; if(matcher.find()) { String wiki = context.getDatabase(); try { wiki = URLEncoder.encode(wiki, URL_ENCODING); } catch(UnsupportedEncodingException e) { } String space = withMinimalURLEncoding(matcher.group(1)); String page = withMinimalURLEncoding(matcher.group(2)); String module = withMinimalURLEncoding(matcher.group(3)); String filePath = matcher.group(4); String prefix = String.format(\"temp/%s/%s/%s/%s/\", module, wiki, space, page); String path = URI.create(prefix + filePath).normalize().toString(); if(path.startsWith(prefix)) { result = new File(this.environment.getTemporaryDirectory(), path); result = result.exists() ? result : null; } } return result; } ",
        "test_tgt": "@Test public void testGetTemporaryFile()throws Exception { getContext().setWikiId(\"wiki\"); createEmptyFile(\"temp/module/wiki/Space/Page/file.txt\"); Assert.assertNotNull(action.getTemporaryFile(\"/xwiki/bin/temp/Space/Page/module/file.txt\", getContext())); } "
    },
    {
        "test_src": "@Test public void matchUdpDstTest() { Criterion criterion = Criteria.matchUdpDst(40000); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result, matchesCriterion(criterion)); } ",
        "focal_tgt": "public static Criterion matchUdpDst(TpPort udpPort) { return new UdpPortCriterion(udpPort, Type.UDP_DST); } ",
        "focal_src": "public static Criterion matchUdpDst(int udpPort) { return new UdpPortCriterion(udpPort, Type.UDP_DST); } ",
        "test_tgt": "@Test public void matchUdpDstTest() { Criterion criterion = Criteria.matchUdpDst(tpPort); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result, matchesCriterion(criterion)); } "
    },
    {
        "test_src": "@Test public void testGetGraphsRelatedConcepts() { Map < String, Object > params = new HashMap < String, Object > (); params.put(ConceptInsights.ACCOUNT_ID, \"wikipedia\"); params.put(\"graph\", \"en-20120601\"); List < String > concepts = new ArrayList < String > (); concepts.add(\"/graphs/wikipedia/en-20120601/concepts/IBM_Watson\"); params.put(ConceptInsights.CONCEPTS, concepts); params.put(ConceptInsights.LIMIT, 10); params.put(ConceptInsights.LEVEL, 1); RequestedFields fs = new RequestedFields(); fs.include(\"abstract\"); params.put(\"concept_fields\", fs); Concepts concepts1 = service.getGraphsRelatedConcepts(params); Assert.assertNotNull(concepts1); } ",
        "focal_tgt": "public Concepts getGraphsRelatedConcepts(final Graph graph, final Map < String, Object > parameters) { String graphId = IDValidator.getGraphId(graph, getAccountId()); if(parameters.get(CONCEPTS) == null && parameters.get(CONCEPT) == null)throw new MissingFormatArgumentException(\"concept or concepts should be identified\"); Map < String, Object > queryParameters = new HashMap < String, Object > (); String[]queryParms = new String[] { LEVEL, LIMIT }; for(String param : queryParms) { if(parameters.containsKey(param))queryParameters.put(param, parameters.get(param)); } if(parameters.get(CONCEPT_FIELDS) != null) { RequestedFields fields = (RequestedFields)parameters.get(CONCEPT_FIELDS); if(fields != null && ! fields.isEmpty())queryParameters.put(CONCEPT_FIELDS, fields.toString()); } if(parameters.get(CONCEPTS) != null) { JsonObject contentJson = new JsonObject(); JsonArray conceptsJson = new JsonArray(); @SuppressWarnings(\"unchecked\")List < String > concepts = (List < String > )parameters.get(CONCEPTS); for(String value : concepts) { conceptsJson.add(new JsonPrimitive(value)); } contentJson.add(CONCEPTS, conceptsJson); queryParameters.put(CONCEPTS, conceptsJson.toString()); return executeRequest(API_VERSION + graphId + RELATED_CONCEPTS_PATH, queryParameters, Concepts.class); } else { Concept concept = new Concept(graph, (String)parameters.get(CONCEPT)); return executeRequest(API_VERSION + concept.getId() + RELATED_CONCEPTS_PATH + RELATED_CONCEPTS_PATH, queryParameters, Concepts.class); } } ",
        "focal_src": "public Concepts getGraphsRelatedConcepts(String graphName, List < String > concepts, String conceptName, RequestedFields conceptFields, int level, int limit) { Validate.notNull(graphName, \"graphName can't be null\"); if(concepts == null && conceptName == null)throw new MissingFormatArgumentException(\"conceptName or concepts should be identified\"); Graph graph = new Graph(getAccountId(), graphName); Map < String, Object > queryParameters = new HashMap < String, Object > (); if(level >= 0) { queryParameters.put(LEVEL, level); } if(limit >= 0) { queryParameters.put(LIMIT, limit); } if(conceptFields != null) { if(conceptFields != null && conceptFields.getFields() != null && ! conceptFields.getFields().isEmpty())queryParameters.put(CONCEPT_FIELDS, conceptFields); } if(concepts != null) { JsonObject contentJson = new JsonObject(); JsonArray conceptsJson = new JsonArray(); for(String value : concepts) { conceptsJson.add(new JsonPrimitive(value)); } contentJson.add(CONCEPTS, conceptsJson); queryParameters.put(CONCEPTS, conceptsJson.toString()); return executeRequest(version + graph.getId() + RELATED_CONCEPTS_PATH, queryParameters, Concepts.class); } else { Concept concept = new Concept(graph, conceptName); return executeRequest(version + concept.getId() + RELATED_CONCEPTS_PATH, queryParameters, Concepts.class); } } ",
        "test_tgt": "@Test public void testGetGraphsRelatedConcepts() { Map < String, Object > params = new HashMap < String, Object > (); List < String > concepts = new ArrayList < String > (); concepts.add(EXAMPLE_CONCEPT.getId()); params.put(ConceptInsights.CONCEPTS, concepts); params.put(ConceptInsights.LIMIT, 10); params.put(ConceptInsights.LEVEL, 1); RequestedFields fs = new RequestedFields(); fs.include(\"abstract\"); params.put(\"concept_fields\", fs); Concepts concepts1 = service.getGraphsRelatedConcepts(Graph.WIKIPEDIA, params); Assert.assertNotNull(concepts1); } "
    },
    {
        "test_src": "@Test public void textEntry() { check(_ZIP_TEXT_ENTRY); query(_ZIP_TEXT_ENTRY.args(ZIP, ENTRY1)); query(_ZIP_TEXT_ENTRY.args(ZIP, ENTRY1, \"US-ASCII\")); error(_ZIP_TEXT_ENTRY.args(ZIP, ENTRY1, \"xyz\"), Err.ZIP_FAIL); contains(_ZIP_TEXT_ENTRY.args(ZIP, ENTRY1), \"aaboutab\"); } ",
        "focal_tgt": "private Str textEntry(final QueryContext ctx)throws QueryException { final String enc = expr.length < 3 ? null : string(checkStr(expr[2], ctx)); final IO io = new IOContent(entry(ctx)); try { return Str.get(new NewlineInput(io).encoding(enc).content()); } catch(final IOException ex) { throw ZIP_FAIL.thrw(info, ex); } } ",
        "focal_src": "private Str textEntry(final QueryContext ctx)throws QueryException { final String enc = expr.length < 3 ? null : string(checkStr(expr[2], ctx)); final IO io = new IOContent(entry(ctx)); try { return Str.get(new NewlineInput(io).encoding(enc).content()); } catch(final IOException ex) { throw ZIP_FAIL.thrw(info, ex.getMessage()); } } ",
        "test_tgt": "@Test public void zipTextEntry() { check(_ZIP_TEXT_ENTRY); query(_ZIP_TEXT_ENTRY.args(ZIP, ENTRY1)); query(_ZIP_TEXT_ENTRY.args(ZIP, ENTRY1, \"US-ASCII\")); error(_ZIP_TEXT_ENTRY.args(ZIP, ENTRY1, \"xyz\"), Err.ZIP_FAIL); contains(_ZIP_TEXT_ENTRY.args(ZIP, ENTRY1), \"aaboutab\"); } "
    },
    {
        "test_src": "@Test public void testUpdate()throws Exception { List < Metric > metrics = new ArrayList < Metric > (NUM_METRICS); for(int i = 0; i < NUM_METRICS; i ++ ) { metrics.add(new Metric(\"test\", BasicTagList.EMPTY, System.currentTimeMillis(), VALUE)); } try { observer.update(metrics); } catch(AmazonClientException e) { e.printStackTrace(); } } ",
        "focal_tgt": "public void update(List < Metric > metrics) { Preconditions.checkNotNull(metrics, \"metrics\"); LOGGER.debug(\"received {} metrics\", metrics.size()); final List < Metric > newMetrics = new ArrayList < > (metrics.size()); for(Metric m : metrics) { if(isCounter(m)) { final MonitorConfig rateConfig = toRateConfig(m.getConfig()); final CounterValue prev = cache.get(rateConfig); if(prev != null) { final double rate = prev.computeRate(m); newMetrics.add(new Metric(rateConfig, m.getTimestamp(), rate)); } else { CounterValue current = new CounterValue(m); cache.put(rateConfig, current); if(intervalMillis > 0L) { final double delta = m.getNumberValue().doubleValue(); final double rate = current.computeRate(intervalMillis, delta); newMetrics.add(new Metric(rateConfig, m.getTimestamp(), rate)); } } } else { newMetrics.add(m); } } LOGGER.debug(\"writing {} metrics to downstream observer\", newMetrics.size()); observer.update(newMetrics); } ",
        "focal_src": "public void update(List < Metric > metrics) { Preconditions.checkNotNull(metrics, \"metrics\"); LOGGER.debug(\"received {} metrics\", metrics.size()); final List < Metric > newMetrics = new ArrayList < Metric > (metrics.size()); for(Metric m : metrics) { if(isCounter(m)) { final MonitorConfig rateConfig = toRateConfig(m.getConfig()); final CounterValue prev = cache.get(rateConfig); if(prev != null) { final double rate = prev.computeRate(m); newMetrics.add(new Metric(rateConfig, m.getTimestamp(), rate)); } else { CounterValue current = new CounterValue(m); cache.put(rateConfig, current); if(intervalMillis > 0L) { final double delta = m.getNumberValue().doubleValue(); final double rate = current.computeRate(intervalMillis, delta); newMetrics.add(new Metric(rateConfig, m.getTimestamp(), rate)); } } } else { newMetrics.add(m); } } LOGGER.debug(\"writing {} metrics to downstream observer\", newMetrics.size()); observer.update(newMetrics); } ",
        "test_tgt": "@Test public void testUpdate()throws Exception { List < Metric > metrics = new ArrayList < > (NUM_METRICS); for(int i = 0; i < NUM_METRICS; i ++ ) { metrics.add(new Metric(\"test\", BasicTagList.EMPTY, System.currentTimeMillis(), VALUE)); } try { observer.update(metrics); } catch(AmazonClientException e) { e.printStackTrace(); } } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void test_minusSeconds_one() { LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT); LocalDate d = t.toLocalDate().minusDays(1); int hour = 0; int min = 0; int sec = 0; for(int i = 0; i < 3700; i ++ ) { t = t.minusSeconds(1); sec -- ; if(sec == - 1) { min -- ; sec = 59; if(min == - 1) { hour -- ; min = 59; if(hour == - 1) { hour = 23; } } } assertEquals(t.toLocalDate(), d); assertEquals(t.getHour(), hour); assertEquals(t.getMinute(), min); assertEquals(t.getSecond(), sec); } } ",
        "focal_tgt": "ChronoZonedDateTime < C > minusSeconds(long seconds) { ChronoDateTime newDT = dateTime.getDateTime().minusSeconds(seconds); return(newDT == dateTime.getDateTime() ? this : resolve(newDT, zone, dateTime, ZoneResolvers.retainOffset())); } ",
        "focal_src": "ChronoZonedDateTime < C > minusSeconds(long seconds) { ChronoDateTime newDT = dateTime.toDateTime().minusSeconds(seconds); return(newDT == dateTime.toDateTime() ? this : resolve(newDT, zone, dateTime, ZoneResolvers.retainOffset())); } ",
        "test_tgt": "@Test(groups = { \"tck\" })public void test_minusSeconds_one() { LocalDateTime t = TEST_2007_07_15_12_30_40_987654321.with(LocalTime.MIDNIGHT); LocalDate d = t.getDate().minusDays(1); int hour = 0; int min = 0; int sec = 0; for(int i = 0; i < 3700; i ++ ) { t = t.minusSeconds(1); sec -- ; if(sec == - 1) { min -- ; sec = 59; if(min == - 1) { hour -- ; min = 59; if(hour == - 1) { hour = 23; } } } assertEquals(t.getDate(), d); assertEquals(t.getHour(), hour); assertEquals(t.getMinute(), min); assertEquals(t.getSecond(), sec); } } "
    },
    {
        "test_src": "@Test public void defaults()throws IOException { AlluxioStorageType alluxioType = AlluxioStorageType.STORE; UnderStorageType ufsType = UnderStorageType.SYNC_PERSIST; mConf.set(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, \"64MB\"); mConf.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.CACHE_THROUGH.toString()); mConf.set(PropertyKey.USER_FILE_WRITE_TIER_DEFAULT, Constants.LAST_TIER); OutStreamOptions options = OutStreamOptions.defaults(mConf); assertEquals(alluxioType, options.getAlluxioStorageType()); assertEquals(64 * Constants.MB, options.getBlockSizeBytes()); assertTrue(options.getLocationPolicy()instanceof LocalFirstPolicy); assertEquals(\"test_user\", options.getOwner()); assertEquals(\"test_group\", options.getGroup()); assertEquals(ModeUtils.applyFileUMask(Mode.defaults(), mConf.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK)), options.getMode()); assertEquals(Constants.NO_TTL, options.getCommonOptions().getTtl()); assertEquals(TtlAction.DELETE, options.getCommonOptions().getTtlAction()); assertEquals(ufsType, options.getUnderStorageType()); assertEquals(WriteType.CACHE_THROUGH, options.getWriteType()); assertEquals(Constants.LAST_TIER, options.getWriteTier()); } ",
        "focal_tgt": "public static OutStreamOptions defaults(ClientContext context, AlluxioConfiguration alluxioConf) { return new OutStreamOptions(context, alluxioConf); } ",
        "focal_src": "public static OutStreamOptions defaults(AlluxioConfiguration alluxioConf) { return new OutStreamOptions(alluxioConf); } ",
        "test_tgt": "@Test public void defaults()throws IOException { AlluxioStorageType alluxioType = AlluxioStorageType.STORE; UnderStorageType ufsType = UnderStorageType.SYNC_PERSIST; mConf.set(PropertyKey.USER_BLOCK_SIZE_BYTES_DEFAULT, \"64MB\"); mConf.set(PropertyKey.USER_FILE_WRITE_TYPE_DEFAULT, WriteType.CACHE_THROUGH.toString()); mConf.set(PropertyKey.USER_FILE_WRITE_TIER_DEFAULT, Constants.LAST_TIER); mConf.set(PropertyKey.SECURITY_GROUP_MAPPING_CLASS, FakeUserGroupsMapping.class.getName()); Subject subject = new Subject(); subject.getPrincipals().add(new User(\"test_user\")); ClientContext clientContext = ClientContext.create(subject, mConf); OutStreamOptions options = OutStreamOptions.defaults(clientContext); assertEquals(alluxioType, options.getAlluxioStorageType()); assertEquals(64 * Constants.MB, options.getBlockSizeBytes()); assertTrue(options.getLocationPolicy()instanceof LocalFirstPolicy); assertEquals(\"test_user\", options.getOwner()); assertEquals(\"test_group\", options.getGroup()); assertEquals(ModeUtils.applyFileUMask(Mode.defaults(), mConf.get(PropertyKey.SECURITY_AUTHORIZATION_PERMISSION_UMASK)), options.getMode()); assertEquals(Constants.NO_TTL, options.getCommonOptions().getTtl()); assertEquals(TtlAction.DELETE, options.getCommonOptions().getTtlAction()); assertEquals(ufsType, options.getUnderStorageType()); assertEquals(WriteType.CACHE_THROUGH, options.getWriteType()); assertEquals(Constants.LAST_TIER, options.getWriteTier()); } "
    },
    {
        "test_src": "@Test(expected = GenieNotFoundException.class)public void testUpdateDependenciesForCommand()throws GenieException { final String id = UUID.randomUUID().toString(); Mockito.when(this.jpaCommandRepository.findOne(id)).thenReturn(null); this.service.updateDependenciesForCommand(id, Sets.newHashSet()); } ",
        "focal_tgt": "@Override public void updateDependenciesForCommand(@NotBlank(message = \"No command id entered. Unable to update dependencies.\")final String id, @NotNull(message = \"No dependencies entered. Unable to update.\")final Set < String > dependencies)throws GenieException { this.findCommand(id).setDependencies(this.createAndGetFileEntities(dependencies)); } ",
        "focal_src": "@Override public void updateDependenciesForCommand(@NotBlank(message = \"No command id entered. Unable to update dependencies.\")final String id, @NotNull(message = \"No dependencies entered. Unable to update.\")final Set < String > dependencies)throws GenieException { this.findCommand(id).setDependencies(dependencies); } ",
        "test_tgt": "@Test(expected = GenieNotFoundException.class)public void testUpdateDependenciesForCommand()throws GenieException { final String id = UUID.randomUUID().toString(); Mockito.when(this.jpaCommandRepository.findByUniqueId(id)).thenReturn(Optional.empty()); this.service.updateDependenciesForCommand(id, Sets.newHashSet()); } "
    },
    {
        "test_src": "@Test public void testSaveOrUpdateUserDetail() { ModelMap model = new ModelMap(); User currUser = getTestUser(); currUser.setUserName(\"new name\"); userController.saveOrUpdateUserDetail(currUser, model, currUser); userController.getUserDetail(getTestUser(), model, currUser.getUserId()); User user = (User)model.get(\"user\"); assertThat(user.getUserName(), is(\"new name\")); assertThat(user.getPassword(), is(currUser.getPassword())); } ",
        "focal_tgt": "@RequestMapping(\"/save\")@PreAuthorize(\"hasAnyRole('A', 'S') or #user.id == #updatedUser.id\")public String saveOrUpdateUserDetail(User user, ModelMap model, @ModelAttribute(\"user\")User updatedUser, @RequestParam(required = false)String followersStr) { checkArgument(updatedUser.validate()); if(user.getRole() == Role.USER) { User updatedUserInDb = userService.getUserById(updatedUser.getUserId()); checkNotNull(updatedUserInDb); updatedUser.setRole(updatedUserInDb.getRole()); checkArgument(updatedUserInDb.getId().equals(updatedUser.getId()), \"Illegal request to update user:%s\", updatedUser); } if(updatedUser.exist()) { userService.modifyUser(updatedUser, followersStr); } else { userService.saveUser(updatedUser); } if(user.getId() == updatedUser.getId()) { return \"redirect:/\"; } else { return \"redirect:/user/list\"; } } ",
        "focal_src": "@RequestMapping(\"/save\")@PreAuthorize(\"hasAnyRole('A', 'S') or #user.id == #updatedUser.id\")public String saveOrUpdateUserDetail(User user, ModelMap model, @ModelAttribute(\"user\")User updatedUser, @RequestParam(required = false)String followers) { checkArgument(updatedUser.validate()); if(user.getRole() == Role.USER) { User updatedUserInDb = userService.getUserById(updatedUser.getUserId()); checkNotNull(updatedUserInDb); updatedUser.setRole(updatedUserInDb.getRole()); checkArgument(updatedUserInDb.getId().equals(updatedUser.getId()), \"Illegal request to update user:%s\", updatedUser); } if(updatedUser.exist()) { userService.modifyUser(updatedUser); } else { userService.saveUser(updatedUser); } if(user.getId() == updatedUser.getId()) { return \"redirect:/\"; } else { return \"redirect:/user/list\"; } } ",
        "test_tgt": "@Test public void testSaveOrUpdateUserDetail() { ModelMap model = new ModelMap(); User currUser = getTestUser(); currUser.setUserName(\"new name\"); userController.saveOrUpdateUserDetail(currUser, model, currUser, null); userController.getUserDetail(getTestUser(), model, currUser.getUserId()); User user = (User)model.get(\"user\"); assertThat(user.getUserName(), is(\"new name\")); assertThat(user.getPassword(), is(currUser.getPassword())); } "
    },
    {
        "test_src": "@Test public void testClear() { map.put(key1, value1); map.put(key2, value1); map.clear(); assertEquals(0, map.size()); assertEquals(0, map.deleted); assertEquals(0, map.assigned); testPutWithExpansions(); } ",
        "focal_tgt": "@Override public void clear() { assigned = 0; Arrays.fill(states, EMPTY); Arrays.fill(values, null); Arrays.fill(keys, null); } ",
        "focal_src": "@Override public void clear() { assigned = deleted = 0; Arrays.fill(states, EMPTY); Arrays.fill(values, null); Arrays.fill(keys, null); } ",
        "test_tgt": "@Test public void testClear() { map.put(key1, value1); map.put(key2, value1); map.clear(); assertEquals(0, map.size()); assertEquals(0, map.assigned); testPutWithExpansions(); } "
    },
    {
        "test_src": "@Test public void testGetCipherType() { } ",
        "focal_tgt": "public static CipherType getCipherType(CipherSuite cipherSuite) { String cipher = cipherSuite.toString().toUpperCase(); if(cipherSuite.isAEAD()) { return CipherType.AEAD; } else if(cipher.contains(\"AES\") || cipher.contains(\"DES\") || cipher.contains(\"IDEA\") || cipher.contains(\"WITH_FORTEZZA\") || cipher.contains(\"CAMELLIA\") || cipher.contains(\"GOST\") || cipher.contains(\"WITH_SEED\") || cipher.contains(\"WITH_ARIA\") || cipher.contains(\"RC2\")) { return CipherType.BLOCK; } else if(cipher.contains(\"RC4\") || cipher.contains(\"WITH_NULL\") || cipher.contains(\"CHACHA\")) { return CipherType.STREAM; } if(cipherSuite == CipherSuite.TLS_FALLBACK_SCSV || cipherSuite == CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV || cipherSuite == CipherSuite.TLS_UNKNOWN_CIPHER) { throw new IllegalArgumentException(\"The CipherSuite:\" + cipherSuite.name() + \" does not specify a CipherType\"); } throw new UnsupportedOperationException(\"Cipher suite \" + cipherSuite + \" is not supported yet.\"); } ",
        "focal_src": "public static CipherType getCipherType(CipherSuite cipherSuite) { String cipher = cipherSuite.toString().toUpperCase(); if(cipherSuite.isAEAD()) { return CipherType.AEAD; } else if(cipher.contains(\"AES\") || cipher.contains(\"DES\") || cipher.contains(\"IDEA\") || cipher.contains(\"WITH_FORTEZZA\") || cipher.contains(\"CAMELLIA\") || cipher.contains(\"GOST\") || cipher.contains(\"WITH_SEED\") || cipher.contains(\"WITH_ARIA\") || cipher.contains(\"RC2\")) { return CipherType.BLOCK; } else if(cipher.contains(\"RC4\") || cipher.contains(\"WITH_NULL\") || cipher.contains(\"CHACHA\")) { return CipherType.STREAM; } throw new UnsupportedOperationException(\"Cipher suite \" + cipherSuite + \" is not supported yet.\"); } ",
        "test_tgt": "@Test public void testGetCipherType() { assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_NULL_WITH_NULL_NULL) == CipherType.STREAM); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_IDEA_CBC_SHA) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_RC4_128_SHA) == CipherType.STREAM); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_256_CBC_SHA) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_128_CCM) == CipherType.AEAD); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_256_CCM) == CipherType.AEAD); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256) == CipherType.AEAD); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DH_anon_WITH_AES_256_GCM_SHA384) == CipherType.AEAD); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256) == CipherType.AEAD); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384) == CipherType.AEAD); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_SEED_CBC_SHA) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_DES_CBC_SHA) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.SSL_FORTEZZA_KEA_WITH_FORTEZZA_CBC_SHA) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_ARIA_128_CBC_SHA256) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_ARIA_128_GCM_SHA256) == CipherType.AEAD); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_DH_anon_WITH_ARIA_256_CBC_SHA384) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_RSA_WITH_ARIA_256_GCM_SHA384) == CipherType.AEAD); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_GOSTR341094_WITH_28147_CNT_IMIT) == CipherType.BLOCK); assertTrue(AlgorithmResolver.getCipherType(CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256) == CipherType.STREAM); } "
    },
    {
        "test_src": "@Test(dependsOnMethods = \"getRecentArticles\")public void getArticleContent()throws Exception { final ArticleQueryService articleQueryService = getArticleQueryService(); final List < JSONObject > articles = articleQueryService.getRecentArticles(10); Assert.assertEquals(articles.size(), 1); final String articleId = articles.get(0).getString(Keys.OBJECT_ID); Assert.assertNotNull(articleQueryService.getArticleContent(articleId)); } ",
        "focal_tgt": "@RequestProcessing(value = \"/get-article-content\", method = HTTPRequestMethod.GET)public void getArticleContent(final HTTPRequestContext context, final HttpServletRequest request) { final String articleId = request.getParameter(\"id\"); if(Strings.isEmptyOrNull(articleId)) { return; } final TextHTMLRenderer renderer = new TextHTMLRenderer(); context.setRenderer(renderer); String content; try { content = articleQueryService.getArticleContent(request, articleId); } catch(final ServiceException e) { LOGGER.log(Level.ERROR, \"Can not get article content\", e); return; } if(null == content) { return; } renderer.setContent(content); } ",
        "focal_src": "@RequestProcessing(value = \"/get-article-content\", method = HTTPRequestMethod.GET)public void getArticleContent(final HTTPRequestContext context, final HttpServletRequest request) { final String articleId = request.getParameter(\"id\"); if(Strings.isEmptyOrNull(articleId)) { return; } final TextHTMLRenderer renderer = new TextHTMLRenderer(); context.setRenderer(renderer); String content; try { content = articleQueryService.getArticleContent(articleId); } catch(final ServiceException e) { LOGGER.log(Level.ERROR, \"Can not get article content\", e); return; } if(null == content) { return; } renderer.setContent(content); } ",
        "test_tgt": "@Test(dependsOnMethods = \"getRecentArticles\")public void getArticleContent()throws Exception { final ArticleQueryService articleQueryService = getArticleQueryService(); final List < JSONObject > articles = articleQueryService.getRecentArticles(10); Assert.assertEquals(articles.size(), 1); final String articleId = articles.get(0).getString(Keys.OBJECT_ID); Assert.assertNotNull(articleQueryService.getArticleContent(null, articleId)); } "
    },
    {
        "test_src": "@Test public void testNetworkInterfaces()throws Exception { new TestNetworkInterface().runTest(azure.networkInterfaces(), azure.resourceGroups()); } ",
        "focal_tgt": "public NetworkInterfaces networkInterfaces() { if(networkInterfaces == null) { this.networkInterfaces = new NetworkInterfacesImpl(this.networkManagementClient.networkInterfaces(), this.networks(), this.publicIpAddresses(), this.resourceManager); } return this.networkInterfaces; } ",
        "focal_src": "public NetworkInterfaces networkInterfaces() { if(networkInterfaces == null) { this.networkInterfaces = new NetworkInterfacesImpl(this.networkManagementClient.networkInterfaces(), this.networks(), this.publicIpAddresses(), this.resourceManager.resourceGroups()); } return this.networkInterfaces; } ",
        "test_tgt": "@Test public void testNetworkInterfaces()throws Exception { new TestNetworkInterface().runTest(azure2.networkInterfaces(), azure2.resourceGroups()); } "
    },
    {
        "test_src": "@Test public void testSpatialRangeQuery()throws Exception { LineStringRDD spatialRDD = new LineStringRDD(sc, InputLocation, splitter, true); for(int i = 0; i < loopTimes; i ++ ) { long resultSize = RangeQuery.SpatialRangeQuery(spatialRDD, queryEnvelope, false, false).count(); assert resultSize > - 1; } assert RangeQuery.SpatialRangeQuery(spatialRDD, queryEnvelope, false, false).take(10).get(1).getUserData().toString() != null; } ",
        "focal_tgt": "public static JavaRDD < Polygon > SpatialRangeQuery(PolygonRDD spatialRDD, Polygon originalQueryWindow, boolean considerBoundaryIntersection, boolean useIndex)throws Exception { Polygon queryWindow = originalQueryWindow; if(spatialRDD.getCRStransformation()) { queryWindow = CRSTransformation.Transform(spatialRDD.getSourceEpsgCode(), spatialRDD.getTargetEpgsgCode(), originalQueryWindow); } if(useIndex == true) { if(spatialRDD.indexedRawRDD == null) { throw new Exception(\"[RangeQuery][SpatialRangeQuery] Index doesn't exist. Please build index on rawSpatialRDD.\"); } JavaRDD < Object > result = spatialRDD.indexedRawRDD.mapPartitions(new RangeFilterUsingIndex(queryWindow, considerBoundaryIntersection)); return result.map(new Function < Object, Polygon > () { @Override public Polygon call(Object spatialObject)throws Exception { return(Polygon)spatialObject; } }); } else { JavaRDD < Object > result = spatialRDD.getRawSpatialRDD().filter(new RangeFilter(queryWindow, considerBoundaryIntersection)); return result.map(new Function < Object, Polygon > () { @Override public Polygon call(Object spatialObject)throws Exception { return(Polygon)spatialObject; } }); } } ",
        "focal_src": "public static JavaRDD < Polygon > SpatialRangeQuery(PolygonRDD spatialRDD, Polygon queryWindow, boolean considerBoundaryIntersection, boolean useIndex)throws Exception { if(useIndex == true) { if(spatialRDD.indexedRawRDD == null) { throw new Exception(\"[RangeQuery][SpatialRangeQuery] Index doesn't exist. Please build index on rawSpatialRDD.\"); } JavaRDD < Object > result = spatialRDD.indexedRawRDD.mapPartitions(new RangeFilterUsingIndex(queryWindow, considerBoundaryIntersection)); return result.map(new Function < Object, Polygon > () { @Override public Polygon call(Object spatialObject)throws Exception { return(Polygon)spatialObject; } }); } else { JavaRDD < Object > result = spatialRDD.getRawSpatialRDD().filter(new RangeFilter(queryWindow, considerBoundaryIntersection)); return result.map(new Function < Object, Polygon > () { @Override public Polygon call(Object spatialObject)throws Exception { return(Polygon)spatialObject; } }); } } ",
        "test_tgt": "@Test public void testSpatialRangeQuery()throws Exception { LineStringRDD spatialRDD = new LineStringRDD(sc, InputLocation, splitter, true, StorageLevel.MEMORY_ONLY()); for(int i = 0; i < loopTimes; i ++ ) { long resultSize = RangeQuery.SpatialRangeQuery(spatialRDD, queryEnvelope, false, false).count(); assert resultSize > - 1; } assert RangeQuery.SpatialRangeQuery(spatialRDD, queryEnvelope, false, false).take(10).get(1).getUserData().toString() != null; } "
    },
    {
        "test_src": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"getCreationTime\", args = { })@KnownFailure(\"Time returned is corrupted\")@AndroidOnly(\"Uses bks key store. Change useBKS to false to run on the RI\")public void test_getCreationTime() { try { long diff = new Date().getTime() - clientSession.getCreationTime(); assertTrue(diff < 10000); } catch(Exception ex) { fail(\"Unexpected exception \" + ex); } } ",
        "focal_tgt": "public native long getCreationTime(); ",
        "focal_src": "public long getCreationTime() { return nativegetcreationtime(); } ",
        "test_tgt": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"getCreationTime\", args = { })@AndroidOnly(\"Uses bks key store. Change useBKS to false to run on the RI\")public void test_getCreationTime() { try { long diff = new Date().getTime() - clientSession.getCreationTime(); assertTrue(diff < 10000); } catch(Exception ex) { fail(\"Unexpected exception \" + ex); } } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void test_with_DateAdjuster() { LocalDateTime ldt = LocalDateTime.of(2008, 6, 30, 23, 30, 59, 0); ZonedDateTime base = ZonedDateTime.of(ldt, ZONE_0100); ZonedDateTime test = base.with(Year.of(2007)); assertEquals(test, ZonedDateTime.of(ldt.withYear(2007), ZONE_0100)); } ",
        "focal_tgt": "@Override public ZonedDateTime with(DateTimeField field, long newValue) { if(field instanceof ChronoField) { ChronoField f = (ChronoField)field; switch(f) { case INSTANT_SECONDS : return create(newValue, getNano(), zoneId); case OFFSET_SECONDS : { ZoneOffset offset = ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)); return resolveOffset(offset); } } return resolveLocal(dateTime.with(field, newValue)); } return field.doWith(this, newValue); } ",
        "focal_src": "@Override public ZonedDateTime with(DateTimeField field, long newValue) { if(field instanceof ChronoField) { ChronoField f = (ChronoField)field; switch(f) { case INSTANT_SECONDS : return create(newValue, getNano(), zoneId); case OFFSET_SECONDS : { ZoneOffset offset = ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)); OffsetDateTime odt = dateTime.withOffsetSameLocal(offset); return ofInstant(odt, zoneId); } } return withDateTime(getDateTime().with(field, newValue)); } return field.doWith(this, newValue); } ",
        "test_tgt": "@Test(groups = { \"tck\" })public void test_with_WithAdjuster_Year() { LocalDateTime ldt = LocalDateTime.of(2008, 6, 30, 23, 30, 59, 0); ZonedDateTime base = ZonedDateTime.of(ldt, ZONE_0100); ZonedDateTime test = base.with(Year.of(2007)); assertEquals(test, ZonedDateTime.of(ldt.withYear(2007), ZONE_0100)); } "
    },
    {
        "test_src": "@Test public void testCompile() { sut.activate(); List < Intent > compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet()); assertThat(compiled, hasSize(1)); Collection < FlowRule > rules = ((FlowRuleIntent)compiled.get(0)).flowRules(); FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get(); assertThat(rule1.deviceId(), is(d1p0.deviceId())); assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build())); assertThat(rule1.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d1p1.port()).build())); assertThat(rule1.priority(), is(intent.priority())); FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get(); assertThat(rule2.deviceId(), is(d2p0.deviceId())); assertThat(rule2.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d2p0.port()).build())); assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d2p1.port()).build())); assertThat(rule2.priority(), is(intent.priority())); FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get(); assertThat(rule3.deviceId(), is(d3p1.deviceId())); assertThat(rule3.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d3p1.port()).build())); assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder(treatment).setOutput(d3p0.port()).build())); assertThat(rule3.priority(), is(intent.priority())); sut.deactivate(); } ",
        "focal_tgt": "public void compile(PathCompilerCreateFlow < T > creator, PathIntent intent, List < T > flows, List < DeviceId > devices) { List < Link > links = intent.path().links(); Optional < EncapsulationConstraint > encapConstraint = intent.constraints().stream().filter(constraint -> constraint instanceof EncapsulationConstraint).map(x -> (EncapsulationConstraint)x).findAny(); if( ! encapConstraint.isPresent() || links.size() == 1) { for(int i = 0; i < links.size() - 1; i ++ ) { ConnectPoint ingress = links.get(i).dst(); ConnectPoint egress = links.get(i + 1).src(); creator.createFlow(intent.selector(), intent.treatment(), ingress, egress, intent.priority(), isLast(links, i), flows, devices); } } encapConstraint.map(EncapsulationConstraint :: encapType).map(type -> { switch(type) { case VLAN : manageVlanEncap(creator, flows, devices, intent); break; case MPLS : manageMplsEncap(creator, flows, devices, intent); break; default : } return 0; }); } ",
        "focal_src": "public void compile(PathCompilerCreateFlow < T > creator, PathIntent intent, List < T > flows, List < DeviceId > devices) { List < Link > links = intent.path().links(); Optional < EncapsulationConstraint > encapConstraint = intent.constraints().stream().filter(constraint -> constraint instanceof EncapsulationConstraint).map(x -> (EncapsulationConstraint)x).findAny(); if( ! encapConstraint.isPresent() || links.size() == 1) { for(int i = 0; i < links.size() - 1; i ++ ) { ConnectPoint ingress = links.get(i).dst(); ConnectPoint egress = links.get(i + 1).src(); creator.createFlow(intent.selector(), intent.treatment(), ingress, egress, intent.priority(), isLast(links, i), flows, devices); } } encapConstraint.map(EncapsulationConstraint :: encapType).map(type -> { switch(type) { case VLAN : manageVlanEncap(creator, flows, devices, intent); default : } return 0; }); } ",
        "test_tgt": "@Test public void testCompile() { sut.activate(); List < Intent > compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet()); assertThat(compiled, hasSize(1)); Collection < FlowRule > rules = ((FlowRuleIntent)compiled.get(0)).flowRules(); FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get(); verifyIdAndPriority(rule1, d1p0.deviceId()); assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build())); assertThat(rule1.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d1p1.port()).build())); FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get(); verifyIdAndPriority(rule2, d2p0.deviceId()); assertThat(rule2.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d2p0.port()).build())); assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d2p1.port()).build())); FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get(); verifyIdAndPriority(rule3, d3p1.deviceId()); assertThat(rule3.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d3p1.port()).build())); assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder(treatment).setOutput(d3p0.port()).build())); sut.deactivate(); } "
    },
    {
        "test_src": "@Test public void testPCA() { INDArray m = Nd4j.randn(10000, 6); m.getColumn(0).muli(4.84); m.getColumn(1).muli(4.84); m.getColumn(2).muli(4.09); m.getColumn(1).addi(m.getColumn(2).div(2.0)); m.getColumn(2).addi(34.286); m.getColumn(3).muli(3.0); m.getColumn(1).addi(m.getColumn(4)); m.getColumn(4).subi(m.getColumn(5).div(2.0)); m.getColumn(5).addi(3.4); PCA myPCA = new PCA(m); INDArray reduced70 = myPCA.reducedBasis(0.70); INDArray reduced99 = myPCA.reducedBasis(0.99); assertTrue(\"Major variance differences should change number of basis vectors\", reduced99.columns() > reduced70.columns()); INDArray reduced100 = myPCA.reducedBasis(1.0); assertTrue(\"100% variance coverage should include all eigenvectors\", reduced100.columns() == m.columns()); NDArrayStrings ns = new NDArrayStrings(5); System.out.println(\"Eigenvectors:\\n\" + ns.format(myPCA.getEigenvectors())); System.out.println(\"Eigenvalues:\\n\" + ns.format(myPCA.getEigenvalues())); double variance = 0.0; for(int i = 0; i < 100; i ++ )variance += myPCA.estimateVariance(m.getRow(i), reduced70.columns()); variance /= 100.0; System.out.println(\"Fraction of variance using 70% variance with \" + reduced70.columns() + \" columns: \" + variance); assertTrue(\"Variance does not cover intended 70% variance\", variance > 0.70); } ",
        "focal_tgt": "public static INDArray pca(INDArray in, double variance) { INDArray[]covmean = covarianceMatrix(in); INDArray[]pce = principalComponents(covmean[0]); INDArray vars = Transforms.pow(pce[1], - 0.5, true); double res = vars.sumNumber().doubleValue(); double total = 0.0; int ndims = 0; for(int i = 0; i < vars.columns(); i ++ ) { ndims ++ ; total += vars.getDouble(i); if(total / res > variance)break; } INDArray result = Nd4j.create(in.columns(), ndims); for(int i = 0; i < ndims; i ++ )result.putColumn(i, pce[0].getColumn(i)); return result; } ",
        "focal_src": "public static INDArray pca(INDArray in, double variance) { INDArray[]covmean = covarianceMatrix(in); INDArray[]pce = principalComponents(covmean[0]); INDArray vars = Transforms.pow(Transforms.sqrt(pce[1], true), - 1, true); double res = vars.sumNumber().doubleValue(); double total = 0.0; int ndims = 0; for(int i = 0; i < vars.columns(); i ++ ) { ndims ++ ; total += vars.getDouble(i); if(total / res > variance)break; } INDArray result = Nd4j.create(in.columns(), ndims); for(int i = 0; i < ndims; i ++ )result.putColumn(i, pce[0].getColumn(i)); return result; } ",
        "test_tgt": "@Test public void testPCA() { INDArray m = Nd4j.randn(10000, 16); m.getColumn(0).muli(4.84); m.getColumn(1).muli(4.84); m.getColumn(2).muli(4.09); m.getColumn(1).addi(m.getColumn(2).div(2.0)); m.getColumn(2).addi(34.286); m.getColumn(1).addi(m.getColumn(4)); m.getColumn(4).subi(m.getColumn(5).div(2.0)); m.getColumn(5).addi(3.4); m.getColumn(6).muli(6.0); m.getColumn(7).muli(0.2); m.getColumn(8).muli(2.0); m.getColumn(9).muli(6.0); m.getColumn(9).addi(m.getColumn(6).mul(1.0)); m.getColumn(10).muli(0.2); m.getColumn(11).muli(2.0); m.getColumn(12).muli(0.2); m.getColumn(13).muli(4.0); m.getColumn(14).muli(3.2); m.getColumn(14).addi(m.getColumn(2).mul(1.0)).subi(m.getColumn(13).div(2.0)); m.getColumn(15).muli(1.0); m.getColumn(13).subi(12.0); m.getColumn(15).addi(30.0); PCA myPCA = new PCA(m); INDArray reduced70 = myPCA.reducedBasis(0.70); INDArray reduced99 = myPCA.reducedBasis(0.99); assertTrue(\"Major variance differences should change number of basis vectors\", reduced99.columns() > reduced70.columns()); INDArray reduced100 = myPCA.reducedBasis(1.0); assertTrue(\"100% variance coverage should include all eigenvectors\", reduced100.columns() == m.columns()); NDArrayStrings ns = new NDArrayStrings(5); System.out.println(\"Eigenvectors:\\n\" + ns.format(myPCA.getEigenvectors())); System.out.println(\"Eigenvalues:\\n\" + ns.format(myPCA.getEigenvalues())); double variance = 0.0; for(int i = 0; i < 1000; i ++ )variance += myPCA.estimateVariance(m.getRow(i), reduced70.columns()); variance /= 1000.0; System.out.println(\"Fraction of variance using 70% variance with \" + reduced70.columns() + \" columns: \" + variance); assertTrue(\"Variance does not cover intended 70% variance\", variance > 0.70); INDArray testSample = myPCA.generateGaussianSamples(10000); PCA analyzePCA = new PCA(testSample); for(int i = 0; i < testSample.columns(); i ++ ) { assertEquals(myPCA.getMean().getDouble(i), analyzePCA.getMean().getDouble(i), 0.3); assertEquals(myPCA.getCovarianceMatrix().getRow(i).getColumn(i).getDouble(0), analyzePCA.getCovarianceMatrix().getRow(i).getColumn(i).getDouble(0), 2.0); assertEquals(myPCA.getEigenvalues().getDouble(i), analyzePCA.getEigenvalues().getDouble(i), 1.0); } System.out.println(ns.format(myPCA.getCovarianceMatrix()) + \"\\n\" + ns.format(analyzePCA.getCovarianceMatrix())); } "
    },
    {
        "test_src": "@Test public void testQueryHistoryLog() { List < HistoryLogVo > vos = getJBPMApplication().queryHistoryLog(1l); Assert.assertTrue(vos.size() > 0); } ",
        "focal_tgt": "public List < HistoryLogVo > queryHistoryLog(long processInstanceId); ",
        "focal_src": "public List < HistoryLogVo > queryHistoryLog(long processId); ",
        "test_tgt": "@Test public void testQueryHistoryLog() { long i = getJBPMApplication().startProcess(\"defaultPackage.Trade\", \"aaa\", null); List < HistoryLogVo > vos = getJBPMApplication().queryHistoryLog(i); Assert.assertTrue(vos.size() > 0); getJBPMApplication().removeProcessInstance(i); } "
    },
    {
        "test_src": "@Test public void testRemoveAll() { list.add(asArray(0, 1, 0, 1, 0)); assertEquals(0, list.removeAllOccurrences(k2)); assertEquals(3, list.removeAllOccurrences(k0)); assertListEquals(list.toArray(), 1, 1); assertEquals(2, list.removeAllOccurrences(k1)); assertTrue(list.isEmpty()); list.clear(); list.add(newArray(k0, null, k2, null, k0)); assertEquals(2, list.removeAllOccurrences(null)); assertEquals(0, list.removeAllOccurrences(null)); assertListEquals(list.toArray(), 0, 2, 0); } ",
        "focal_tgt": "@Override public int removeAll(KTypePredicate < ? super KType > predicate) { final KType[]keys = this.keys; final boolean[]allocated = this.allocated; int before = size(); for(int i = 0; i < allocated.length; ) { if(allocated[i]) { if(predicate.apply(keys[i])) { shiftConflictingKeys(i); assigned -- ; continue; } } i ++ ; } return before - size(); } ",
        "focal_src": "@Override public int removeAll(KTypePredicate < ? super KType > predicate) { final KType[]keys = this.keys; final boolean[]allocated = this.allocated; int before = assigned; for(int i = 0; i < allocated.length; ) { if(allocated[i]) { if(predicate.apply(keys[i])) { assigned -- ; shiftConflictingKeys(i); continue; } } i ++ ; } return before - this.assigned; } ",
        "test_tgt": "@Test public void testRemoveAll() { list.add(asArray(0, 1, 0, 1, 0)); assertEquals(0, list.removeAllOccurrences(k2)); assertEquals(3, list.removeAllOccurrences(k0)); assertListEquals(list.toArray(), 1, 1); assertEquals(2, list.removeAllOccurrences(k1)); assertTrue(list.isEmpty()); list.clear(); list.add(newArray(k0, null, k2, null, k0)); assertEquals(2, list.removeAllOccurrences(null)); assertEquals(0, list.removeAllOccurrences(null)); assertListEquals(list.toArray(), 0, 2, 0); } "
    },
    {
        "test_src": "@Test public void event()throws BaseXException { event(RETURN_VALUE1, true); event(RETURN_VALUE2, false); } ",
        "focal_tgt": "private Iter event(final QueryContext ctx)throws QueryException { String name = expr[0].toString(); String msg = \"\"; Value v = expr[1].value(ctx); if(expr.length < 3) { ctx.updating = true; msg = ctx.value(expr[1]).toString(); } else { msg = ctx.value(expr[2]).toString(); } ctx.context.events.notify(ctx.context.session, name, msg); return v.iter(); } ",
        "focal_src": "private Iter event(final QueryContext ctx)throws QueryException { String name = expr[0].toString(); String q2 = expr[2].toString(); String msg = \"\"; Value v = expr[1].value(ctx); if(q2.replaceAll(\"\\\"\", \"\").trim().isEmpty()) { ctx.updating = true; msg = ctx.value(expr[1]).toString(); } else { msg = ctx.value(expr[2]).toString(); } ctx.context.events.notify(ctx.context.session, name, msg); return v.iter(); } ",
        "test_tgt": "@Test public void event()throws BaseXException { event(RETURN_VALUE, true); event(null, false); } "
    },
    {
        "test_src": "@Test public void testPutAll() { map.put(key1, value1); map.put(key2, value1); KTypeVTypeOpenHashMap < KType, VType > map2 = new KTypeVTypeOpenHashMap < KType, VType > (); map2.put(key2, value2); map2.put(key3, value1); assertEquals(1, map.putAll(map2)); assertEquals2(value2, map.get(key2)); assertEquals2(value1, map.get(key3)); assertEquals(3, map.size()); } ",
        "focal_tgt": "@Override public int putAll(KTypeVTypeAssociativeContainer < ? extends KType, ? extends VType > container) { final int count = size(); for(KTypeVTypeCursor < ? extends KType, ? extends VType > c : container) { put(c.key, c.value); } return size() - count; } ",
        "focal_src": "@Override public int putAll(KTypeVTypeAssociativeContainer < ? extends KType, ? extends VType > container) { final int count = this.assigned; for(KTypeVTypeCursor < ? extends KType, ? extends VType > c : container) { put(c.key, c.value); } return this.assigned - count; } ",
        "test_tgt": "@Test public void testPutAll() { map.put(key1, value1); map.put(key2, value1); KTypeVTypeOpenHashMap < KType, VType > map2 = new KTypeVTypeOpenHashMap < KType, VType > (); map2.put(key2, value2); map2.put(keyE, value1); assertEquals(1, map.putAll(map2)); assertEquals2(value2, map.get(key2)); assertEquals2(value1, map.get(keyE)); assertEquals(3, map.size()); } "
    },
    {
        "test_src": "@Test public void commitBlock()throws Exception { long blockId = mRandom.nextLong(); long length = mRandom.nextLong(); long lockId = mRandom.nextLong(); long sessionId = mRandom.nextLong(); long usedBytes = mRandom.nextLong(); String tierAlias = \"MEM\"; HashMap < String, Long > usedBytesOnTiers = new HashMap < > (); usedBytesOnTiers.put(tierAlias, usedBytes); BlockMeta blockMeta = PowerMockito.mock(BlockMeta.class); BlockStoreLocation blockStoreLocation = PowerMockito.mock(BlockStoreLocation.class); BlockStoreMeta blockStoreMeta = mock(BlockStoreMeta.class); when(mBlockStore.lockBlock(sessionId, blockId)).thenReturn(lockId); when(mBlockStore.getBlockMeta(sessionId, blockId, lockId)).thenReturn(blockMeta); when(mBlockStore.getBlockStoreMeta()).thenReturn(blockStoreMeta); when(mBlockStore.getBlockStoreMetaFull()).thenReturn(blockStoreMeta); when(blockMeta.getBlockLocation()).thenReturn(blockStoreLocation); when(blockStoreLocation.tierAlias()).thenReturn(tierAlias); when(blockMeta.getBlockSize()).thenReturn(length); when(blockStoreMeta.getUsedBytesOnTiers()).thenReturn(usedBytesOnTiers); mBlockWorker.commitBlock(sessionId, blockId); verify(mBlockMasterClient).commitBlock(anyLong(), eq(usedBytes), eq(tierAlias), eq(blockId), eq(length)); verify(mBlockStore).unlockBlock(lockId); } ",
        "focal_tgt": "void commitBlock(long workerId, long usedBytesOnTier, String tierAlias, String mediumType, long blockId, long length)throws NotFoundException, UnavailableException; ",
        "focal_src": "void commitBlock(long workerId, long usedBytesOnTier, String tierAlias, long blockId, long length)throws NotFoundException, UnavailableException; ",
        "test_tgt": "@Test public void commitBlock()throws Exception { long blockId = mRandom.nextLong(); long length = mRandom.nextLong(); long lockId = mRandom.nextLong(); long sessionId = mRandom.nextLong(); long usedBytes = mRandom.nextLong(); String tierAlias = \"MEM\"; String mediumType = \"MEM\"; HashMap < String, Long > usedBytesOnTiers = new HashMap < > (); usedBytesOnTiers.put(tierAlias, usedBytes); BlockMeta blockMeta = PowerMockito.mock(BlockMeta.class); BlockStoreLocation blockStoreLocation = PowerMockito.mock(BlockStoreLocation.class); BlockStoreMeta blockStoreMeta = mock(BlockStoreMeta.class); when(mBlockStore.lockBlock(sessionId, blockId)).thenReturn(lockId); when(mBlockStore.getBlockMeta(sessionId, blockId, lockId)).thenReturn(blockMeta); when(mBlockStore.getBlockStoreMeta()).thenReturn(blockStoreMeta); when(mBlockStore.getBlockStoreMetaFull()).thenReturn(blockStoreMeta); when(blockMeta.getBlockLocation()).thenReturn(blockStoreLocation); when(blockStoreLocation.tierAlias()).thenReturn(tierAlias); when(blockStoreLocation.mediumType()).thenReturn(mediumType); when(blockMeta.getBlockSize()).thenReturn(length); when(blockStoreMeta.getUsedBytesOnTiers()).thenReturn(usedBytesOnTiers); mBlockWorker.commitBlock(sessionId, blockId); verify(mBlockMasterClient).commitBlock(anyLong(), eq(usedBytes), eq(tierAlias), eq(mediumType), eq(blockId), eq(length)); verify(mBlockStore).unlockBlock(lockId); } "
    },
    {
        "test_src": "@Test public void parse() { set(MainOptions.STRIPNS, true); set(MainOptions.SERIALIZER, SerializerOptions.get(false)); final String doc = \"<e xmlns='A'><b:f xmlns:b='B'/></e>\"; for(final boolean b : new boolean[] { false, true }) { set(MainOptions.INTPARSE, b); execute(new CreateDB(NAME, doc)); assertEquals(\"<e><f/></e>\", query(\".\")); assertEquals(\"<f/>\", query(\"e/f\")); } } ",
        "focal_tgt": "private static < O extends Options > O parse(final O opts, final Ann ann)throws Exception { for(final Item arg : ann.args)opts.assign(string(arg.string(ann.info))); return opts; } ",
        "focal_src": "private static < O extends Options > O parse(final O opts, final Ann ann)throws Exception { for(final Item arg : ann.args)opts.parse(string(arg.string(ann.info))); return opts; } ",
        "test_tgt": "@Test public void parse() { set(MainOptions.STRIPNS, true); set(MainOptions.SERIALIZER, SerializerMode.NOINDENT.get()); final String doc = \"<e xmlns='A'><b:f xmlns:b='B'/></e>\"; for(final boolean b : new boolean[] { false, true }) { set(MainOptions.INTPARSE, b); execute(new CreateDB(NAME, doc)); assertEquals(\"<e><f/></e>\", query(\".\")); assertEquals(\"<f/>\", query(\"e/f\")); } } "
    },
    {
        "test_src": "@Test public void testGet() { Thread.currentThread().setName(\"TestGet\"); CircularBuffer < Integer > instance = new CircularBuffer < Integer > (0); try { instance.get(); Assert.fail(\"exception should be raised for getting from buffer which does not have data\"); } catch(Exception bue) { assert(bue instanceof BufferUnderflowException); } instance = new CircularBuffer < Integer > (10); try { instance.get(); Assert.fail(\"exception should be raised for getting from buffer which does not have data\"); } catch(Exception bue) { assert(bue instanceof BufferUnderflowException); } for(int i = 0; i < 10; i ++ ) { instance.add(i); } Integer i = instance.get(); Integer j = instance.get(); assert(i == 0 && j == 1); instance.add(10); assert(instance.size() == 9); assert(instance.get() == 2); } ",
        "focal_tgt": "@Override public T remove() { if(head > tail) { T t = buffer[(int)(tail & buffermask)]; tail ++ ; return t; } throw new BufferUnderflowException(); } ",
        "focal_src": "@Override public T get() { if(head > tail) { T t = buffer[(int)(tail & buffermask)]; tail ++ ; return t; } throw new BufferUnderflowException(); } ",
        "test_tgt": "@Test public void testGet() { Thread.currentThread().setName(\"TestGet\"); CircularBuffer < Integer > instance = new CircularBuffer < Integer > (0); try { instance.remove(); Assert.fail(\"exception should be raised for getting from buffer which does not have data\"); } catch(Exception bue) { assert(bue instanceof BufferUnderflowException); } instance = new CircularBuffer < Integer > (10); try { instance.remove(); Assert.fail(\"exception should be raised for getting from buffer which does not have data\"); } catch(Exception bue) { assert(bue instanceof BufferUnderflowException); } for(int i = 0; i < 10; i ++ ) { instance.add(i); } Integer i = instance.remove(); Integer j = instance.remove(); assert(i == 0 && j == 1); instance.add(10); assert(instance.size() == 9); assert(instance.remove() == 2); } "
    },
    {
        "test_src": "@Test public void testApplyDeltaToLaterStockCandidates() { final Candidate earlierCandidate; final Candidate candidate; final Candidate evenLaterCandidate; final Candidate evenLaterCandidateWithDifferentWarehouse; { final MaterialDescriptor materialDescr = MaterialDescriptor.builder().complete(true).productDescriptor(createProductDescriptor()).warehouseId(WAREHOUSE_ID).quantity(new BigDecimal(\"10\")).date(t2).build(); candidate = Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescr(materialDescr).build(); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(candidate); final MaterialDescriptor earlierMaterialDescr = materialDescr.withDate(t1); earlierCandidate = candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescr(earlierMaterialDescr).build()); final MaterialDescriptor laterMaterialDescr = materialDescr.withDate(t3); final Candidate laterCandidate = Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescr(laterMaterialDescr).build(); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(laterCandidate); final MaterialDescriptor evenLatermaterialDescr = materialDescr.withQuantity(new BigDecimal(\"12\")).withDate(t4); evenLaterCandidate = Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescr(evenLatermaterialDescr).build(); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(evenLaterCandidate); final MaterialDescriptor evenLatermaterialDescrWithDifferentWarehouse = evenLatermaterialDescr.withWarehouseId(OTHER_WAREHOUSE_ID); evenLaterCandidateWithDifferentWarehouse = Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescr(evenLatermaterialDescrWithDifferentWarehouse).build(); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(evenLaterCandidateWithDifferentWarehouse); } stockCandidateService.applyDeltaToLaterStockCandidates(createProductDescriptor(), WAREHOUSE_ID, t2, earlierCandidate.getGroupId(), new BigDecimal(\"3\")); DispoTestUtils.retrieveAllRecords().forEach(r -> assertThat(r.getMD_Candidate_GroupId(), greaterThan(0))); final Candidate earlierCandidateAfterChange = candidateRepository.retrieveLatestMatchOrNull(mkStockUntilSegment(t1, WAREHOUSE_ID)); assertThat(earlierCandidateAfterChange).isNotNull(); assertThat(earlierCandidateAfterChange.getQuantity()).isEqualTo(earlierCandidate.getQuantity()); assertThat(earlierCandidateAfterChange.getGroupId()).isEqualTo(earlierCandidate.getGroupId()); final I_MD_Candidate candidateRecordAfterChange = DispoTestUtils.filter(CandidateType.STOCK, t2).get(0); assertThat(candidateRecordAfterChange.getQty()).isEqualByComparingTo(\"10\"); assertThat(candidateRecordAfterChange.getMD_Candidate_GroupId(), not(is(earlierCandidate.getGroupId()))); final Candidate laterCandidateAfterChange = candidateRepository.retrieveLatestMatchOrNull(mkStockUntilSegment(t3, WAREHOUSE_ID)); assertThat(laterCandidateAfterChange).isNotNull(); assertThat(laterCandidateAfterChange.getQuantity()).isEqualByComparingTo(\"13\"); assertThat(laterCandidateAfterChange.getGroupId()).isEqualTo(earlierCandidate.getGroupId()); final I_MD_Candidate evenLaterCandidateRecordAfterChange = DispoTestUtils.filter(CandidateType.STOCK, t4, PRODUCT_ID, WAREHOUSE_ID).get(0); assertThat(evenLaterCandidateRecordAfterChange.getQty()).isEqualByComparingTo(\"15\"); assertThat(evenLaterCandidateRecordAfterChange.getMD_Candidate_GroupId()).isEqualTo(earlierCandidate.getGroupId()); final I_MD_Candidate evenLaterCandidateWithDifferentWarehouseAfterChange = DispoTestUtils.filter(CandidateType.STOCK, t4, PRODUCT_ID, OTHER_WAREHOUSE_ID).get(0); assertThat(evenLaterCandidateWithDifferentWarehouseAfterChange.getQty()).isEqualByComparingTo(\"12\"); assertThat(evenLaterCandidateWithDifferentWarehouseAfterChange.getMD_Candidate_GroupId(), not(is(earlierCandidate.getGroupId()))); } ",
        "focal_tgt": "@VisibleForTesting void applyDeltaToLaterStockCandidates(@NonNull final ProductDescriptor productDescriptor, @NonNull final Integer warehouseId, @NonNull final Date date, @NonNull final Integer groupId, @NonNull final BigDecimal delta) { final CandidatesQuery segment = CandidatesQuery.builder().type(CandidateType.STOCK).materialDescriptor(MaterialDescriptor.builderForQuery().date(date).productDescriptor(productDescriptor).warehouseId(warehouseId).dateOperator(DateOperator.AFTER).build()).build(); final List < Candidate > candidatesToUpdate = candidateRepository.retrieveOrderedByDateAndSeqNo(segment); for(final Candidate candidate : candidatesToUpdate) { final BigDecimal newQty = candidate.getQuantity().add(delta); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(candidate.withQuantity(newQty).withGroupId(groupId)); } } ",
        "focal_src": "@VisibleForTesting void applyDeltaToLaterStockCandidates(@NonNull final ProductDescriptor productDescriptor, @NonNull final Integer warehouseId, @NonNull final Date date, @NonNull final Integer groupId, @NonNull final BigDecimal delta) { final CandidatesQuery segment = CandidatesQuery.builder().type(CandidateType.STOCK).materialDescr(MaterialDescriptor.builderForQuery().date(date).productDescriptor(productDescriptor).warehouseId(warehouseId).dateOperator(DateOperator.AFTER).build()).build(); final List < Candidate > candidatesToUpdate = candidateRepository.retrieveOrderedByDateAndSeqNo(segment); for(final Candidate candidate : candidatesToUpdate) { final BigDecimal newQty = candidate.getQuantity().add(delta); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(candidate.withQuantity(newQty).withGroupId(groupId)); } } ",
        "test_tgt": "@Test public void testApplyDeltaToLaterStockCandidates() { final Candidate earlierCandidate; final Candidate candidate; final Candidate evenLaterCandidate; final Candidate evenLaterCandidateWithDifferentWarehouse; { final MaterialDescriptor materialDescriptor = MaterialDescriptor.builder().complete(true).productDescriptor(createProductDescriptor()).warehouseId(WAREHOUSE_ID).quantity(new BigDecimal(\"10\")).date(t2).build(); candidate = Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescriptor(materialDescriptor).build(); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(candidate); final MaterialDescriptor earlierMaterialDescriptor = materialDescriptor.withDate(t1); earlierCandidate = candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescriptor(earlierMaterialDescriptor).build()); final MaterialDescriptor laterMaterialDescriptor = materialDescriptor.withDate(t3); final Candidate laterCandidate = Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescriptor(laterMaterialDescriptor).build(); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(laterCandidate); final MaterialDescriptor evenLatermaterialDescriptor = materialDescriptor.withQuantity(new BigDecimal(\"12\")).withDate(t4); evenLaterCandidate = Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescriptor(evenLatermaterialDescriptor).build(); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(evenLaterCandidate); final MaterialDescriptor evenLatermaterialDescrWithDifferentWarehouse = evenLatermaterialDescriptor.withWarehouseId(OTHER_WAREHOUSE_ID); evenLaterCandidateWithDifferentWarehouse = Candidate.builder().type(CandidateType.STOCK).clientId(org.getAD_Client_ID()).orgId(org.getAD_Org_ID()).materialDescriptor(evenLatermaterialDescrWithDifferentWarehouse).build(); candidateRepositoryCommands.addOrUpdateOverwriteStoredSeqNo(evenLaterCandidateWithDifferentWarehouse); } stockCandidateService.applyDeltaToLaterStockCandidates(createProductDescriptor(), WAREHOUSE_ID, t2, earlierCandidate.getGroupId(), new BigDecimal(\"3\")); DispoTestUtils.retrieveAllRecords().forEach(r -> assertThat(r.getMD_Candidate_GroupId(), greaterThan(0))); final Candidate earlierCandidateAfterChange = candidateRepository.retrieveLatestMatchOrNull(mkStockUntilSegment(t1, WAREHOUSE_ID)); assertThat(earlierCandidateAfterChange).isNotNull(); assertThat(earlierCandidateAfterChange.getQuantity()).isEqualTo(earlierCandidate.getQuantity()); assertThat(earlierCandidateAfterChange.getGroupId()).isEqualTo(earlierCandidate.getGroupId()); final I_MD_Candidate candidateRecordAfterChange = DispoTestUtils.filter(CandidateType.STOCK, t2).get(0); assertThat(candidateRecordAfterChange.getQty()).isEqualByComparingTo(\"10\"); assertThat(candidateRecordAfterChange.getMD_Candidate_GroupId(), not(is(earlierCandidate.getGroupId()))); final Candidate laterCandidateAfterChange = candidateRepository.retrieveLatestMatchOrNull(mkStockUntilSegment(t3, WAREHOUSE_ID)); assertThat(laterCandidateAfterChange).isNotNull(); assertThat(laterCandidateAfterChange.getQuantity()).isEqualByComparingTo(\"13\"); assertThat(laterCandidateAfterChange.getGroupId()).isEqualTo(earlierCandidate.getGroupId()); final I_MD_Candidate evenLaterCandidateRecordAfterChange = DispoTestUtils.filter(CandidateType.STOCK, t4, PRODUCT_ID, WAREHOUSE_ID).get(0); assertThat(evenLaterCandidateRecordAfterChange.getQty()).isEqualByComparingTo(\"15\"); assertThat(evenLaterCandidateRecordAfterChange.getMD_Candidate_GroupId()).isEqualTo(earlierCandidate.getGroupId()); final I_MD_Candidate evenLaterCandidateWithDifferentWarehouseAfterChange = DispoTestUtils.filter(CandidateType.STOCK, t4, PRODUCT_ID, OTHER_WAREHOUSE_ID).get(0); assertThat(evenLaterCandidateWithDifferentWarehouseAfterChange.getQty()).isEqualByComparingTo(\"12\"); assertThat(evenLaterCandidateWithDifferentWarehouseAfterChange.getMD_Candidate_GroupId(), not(is(earlierCandidate.getGroupId()))); } "
    },
    {
        "test_src": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"clone\", args = { })public void test_clone() { try { DecimalFormatSymbols fs = new DecimalFormatSymbols(Locale.US); DecimalFormatSymbols fsc = (DecimalFormatSymbols)fs.clone(); assertEquals(fs.getCurrency(), fsc.getCurrency()); fs = new DecimalFormatSymbols(); DecimalFormatSymbols fsc2 = (DecimalFormatSymbols)(fs.clone()); assertTrue(\"Object's clone isn't equal!\", fs.equals(fsc2)); fs.setNaN(\"not-a-number\"); assertTrue(\"Object's changed clone should not be equal!\", ! fs.equals(fsc2)); } catch(Exception e) { fail(\"Unexpected exception \" + e.toString()); } } ",
        "focal_tgt": "public Object clone() { try { CopyOnWriteArrayList c = (CopyOnWriteArrayList)(super.clone()); c.resetLock(); return c; } catch(CloneNotSupportedException e) { throw new InternalError(); } } ",
        "focal_src": "@Override public Object clone() { try { CopyOnWriteArrayList thisClone = (CopyOnWriteArrayList)super.clone(); thisClone.setData(this.getData()); return thisClone; } catch(CloneNotSupportedException e) { throw new RuntimeException(\"CloneNotSupportedException is not expected here\"); } } ",
        "test_tgt": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"clone\", args = { })public void test_clone() { try { DecimalFormatSymbols fs = new DecimalFormatSymbols(Locale.US); DecimalFormatSymbols fsc = (DecimalFormatSymbols)fs.clone(); assertEquals(fs.getCurrency(), fsc.getCurrency()); fs = new DecimalFormatSymbols(); DecimalFormatSymbols fsc2 = (DecimalFormatSymbols)(fs.clone()); assertTrue(\"Object's clone isn't equal!\", fs.equals(fsc2)); fs.setNaN(\"not-a-number\"); assertTrue(\"Object's changed clone should not be equal!\", ! fs.equals(fsc2)); } catch(Exception e) { fail(\"Unexpected exception \" + e.toString()); } } "
    },
    {
        "test_src": "@Test public void reportOrphanedSpans_afterGC() { TraceContext context1 = context.toBuilder().spanId(1).build(); map.getOrCreate(context1); TraceContext context2 = context.toBuilder().spanId(2).build(); map.getOrCreate(context2); TraceContext context3 = context.toBuilder().spanId(3).build(); map.getOrCreate(context3); TraceContext context4 = context.toBuilder().spanId(4).build(); map.getOrCreate(context4); context1 = context2 = null; blockOnGC(); assertThat(map.delegate.keySet()).extracting(o -> ((Reference)o).get()).containsExactlyInAnyOrder(null, null, context3, context4); map.reportOrphanedSpans(); assertThat(map.delegate.keySet()).extracting(o -> ((Reference)o).get()).containsExactlyInAnyOrder(context3, context4); assertThat(spans).flatExtracting(Span :: annotations).extracting(Annotation :: value).containsExactly(\"brave.flush\", \"brave.flush\"); assertThat(spans).extracting(Span :: localEndpoint).containsExactly(endpoint, endpoint); } ",
        "focal_tgt": "void reportOrphanedSpans() { Reference < ? extends TraceContext > reference; long flushTime = 0L; while((reference = poll()) != null) { MutableSpan value = delegate.remove(reference); if(value == null || noop.get())continue; if(flushTime == 0L)flushTime = clock.currentTimeMicroseconds(); value.annotate(flushTime, \"brave.flush\"); reporter.report(value.toSpan(endpoint)); } } ",
        "focal_src": "void reportOrphanedSpans() { Reference < ? extends TraceContext > reference; while((reference = poll()) != null) { TraceContext context = reference.get(); MutableSpan value = delegate.remove(reference); if(value == null || noop.get())continue; try { value.annotate(value.clock.currentTimeMicroseconds(), \"brave.flush\"); reporter.report(value.toSpan(endpoint)); } catch(RuntimeException e) { if(context != null && logger.isLoggable(Level.FINE)) { logger.log(Level.FINE, \"error flushing \" + context, e); } } } } ",
        "test_tgt": "@Test public void reportOrphanedSpans_afterGC() { TraceContext context1 = context.toBuilder().spanId(1).build(); map.getOrCreate(context1); TraceContext context2 = context.toBuilder().spanId(2).build(); map.getOrCreate(context2); TraceContext context3 = context.toBuilder().spanId(3).build(); map.getOrCreate(context3); TraceContext context4 = context.toBuilder().spanId(4).build(); map.getOrCreate(context4); int initialClockVal = clock.get(); context1 = context2 = null; blockOnGC(); assertThat(map.delegate.keySet()).extracting(o -> ((Reference)o).get()).containsExactlyInAnyOrder(null, null, context3, context4); map.reportOrphanedSpans(); assertThat(map.delegate.keySet()).extracting(o -> ((Reference)o).get()).containsExactlyInAnyOrder(context3, context4); assertThat(spans).flatExtracting(Span :: annotations).extracting(Annotation :: value).containsExactly(\"brave.flush\", \"brave.flush\"); assertThat(spans).extracting(Span :: localEndpoint).containsExactly(endpoint, endpoint); assertThat(spans).flatExtracting(Span :: annotations).extracting(Annotation :: timestamp).allSatisfy(t -> assertThat(t).isEqualTo((initialClockVal + 1) * 1000)); } "
    },
    {
        "test_src": "@Test public void testChisquareCdf() { logger.info(\"ChisquareCdf\"); double x = 3.0; int df = 10; double expResult = 0.018575928421771; double result = ContinuousDistributions.ChisquareCdf(x, df); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } ",
        "focal_tgt": "public static double chisquareCdf(double x, int df) { if(df <= 0) { throw new IllegalArgumentException(\"The degrees of freedom need to be positive.\"); } return ContinuousDistributions.gammaCdf(x / 2.0, df / 2.0); } ",
        "focal_src": "public static double ChisquareCdf(double x, int df) { if(df <= 0) { throw new IllegalArgumentException(\"The degrees of freedom need to be positive.\"); } return GammaCdf(x / 2.0, df / 2.0); } ",
        "test_tgt": "@Test public void testChisquareCdf() { logger.info(\"ChisquareCdf\"); double x = 3.0; int df = 10; double expResult = 0.018575928421771; double result = ContinuousDistributions.chisquareCdf(x, df); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } "
    },
    {
        "test_src": "@Test void sortEdgesCCW_shift() { FastQueue < Node > corners = new FastQueue < > (Node.class, true); for(int jump = 0; jump < 3; jump ++ ) { Node target = corners.grow(); target.x = 10; target.y = 12; for(int i = 0; i < 3; i ++ ) { double theta = i * Math.PI / 2; if(i > jump)theta += Math.PI / 2; double c = Math.cos(theta); double s = Math.sin(theta); double r = 4; Node n = new Node(); n.x = target.x + r * c; n.y = target.y + r * s; target.edges[i] = n; } } ChessboardCornerClusterToGrid alg = new ChessboardCornerClusterToGrid(); alg.sortEdgesCCW(corners); for(Node n : corners.toList()) { System.out.println(); Node m0 = n.edges[0]; double theta0 = Math.atan2(m0.y - n.y, m0.x - n.x); for(int i = 0; i < 4; i ++ ) { Node m = n.edges[i]; if(m == null)continue; double thetaI = Math.atan2(m.y - n.y, m.x - n.x); assertEquals(i * Math.PI / 2.0, UtilAngle.distanceCCW(theta0, thetaI), 0.001); } } } ",
        "focal_tgt": "void sortEdgesCCW(FastQueue < Node > corners) { for(int nodeIdx = 0; nodeIdx < corners.size; nodeIdx ++ ) { Node na = corners.get(nodeIdx); double ref = Double.NaN; int count = 0; for(int i = 0; i < 4; i ++ ) { order[i] = i; tmpEdges[i] = na.edges[i]; if(na.edges[i] == null) { directions[i] = Double.MAX_VALUE; } else { Node nb = na.edges[i]; double angleB = Math.atan2(nb.y - na.y, nb.x - na.x); if(Double.isNaN(ref)) { ref = angleB; directions[i] = 0; } else { directions[i] = UtilAngle.distanceCCW(ref, angleB); } count ++ ; } } sorter.sort(directions, 0, 4, order); for(int i = 0; i < 4; i ++ ) { na.edges[i] = tmpEdges[order[i]]; } if(count == 2) { if(directions[order[1]] > Math.PI) { na.edges[0] = tmpEdges[order[1]]; na.edges[1] = tmpEdges[order[0]]; } else { na.edges[0] = tmpEdges[order[0]]; na.edges[1] = tmpEdges[order[1]]; } } else if(count == 3) { double tail = UtilAngle.distanceCCW(directions[order[2]], directions[order[0]]); for(int i = 1; i < 3; i ++ ) { double ccw = UtilAngle.distanceCCW(directions[order[i - 1]], directions[order[i]]); if(tail < ccw) { for(int j = 3; j >= i + 1; j -- ) { na.edges[j] = na.edges[j - 1]; } na.edges[i] = null; break; } } } for(int i = 0; i < 4; i ++ ) { if(na.edges[i] == null)continue; } } } ",
        "focal_src": "void sortEdgesCCW(FastQueue < Node > corners) { for(int nodeIdx = 0; nodeIdx < corners.size; nodeIdx ++ ) { Node na = corners.get(nodeIdx); int count = 0; for(int i = 0; i < 4; i ++ ) { order[i] = i; tmpEdges[i] = na.edges[i]; if(na.edges[i] == null) { directions[i] = Double.MAX_VALUE; } else { count ++ ; Node nb = na.edges[i]; directions[i] = Math.atan2(nb.y - na.y, nb.x - na.x); } } sorter.sort(directions, 0, 4, order); for(int i = 0; i < 4; i ++ ) { na.edges[i] = tmpEdges[order[i]]; } if(count == 3) { double tail = UtilAngle.distanceCCW(directions[order[2]], directions[order[0]]); for(int i = 1; i < 3; i ++ ) { double ccw = UtilAngle.distanceCCW(directions[order[i - 1]], directions[order[i]]); if(tail < ccw) { for(int j = 3; j >= i + 1; j -- ) { na.edges[j] = na.edges[j - 1]; } na.edges[i] = null; break; } } } } } ",
        "test_tgt": "@Test void sortEdgesCCW_shift() { FastQueue < Node > corners = new FastQueue < > (Node.class, true); for(int jump = 0; jump < 3; jump ++ ) { Node target = corners.grow(); target.x = 10; target.y = 12; for(int i = 0; i < 3; i ++ ) { double theta = i * Math.PI / 2; if(i > jump)theta += Math.PI / 2; double c = Math.cos(theta); double s = Math.sin(theta); double r = 4; Node n = new Node(); n.x = target.x + r * c; n.y = target.y + r * s; target.edges[i] = n; } shuffle(target.edges); } for(int count = 0; count < 10; count ++ ) { Node target = corners.grow(); target.x = 10; target.y = 12; for(int i = 0; i < 2; i ++ ) { double theta = i * Math.PI / 2; double c = Math.cos(theta); double s = Math.sin(theta); double r = 4; Node n = new Node(); n.x = target.x + r * c; n.y = target.y + r * s; target.edges[i] = n; } shuffle(target.edges); } ChessboardCornerClusterToGrid alg = new ChessboardCornerClusterToGrid(); alg.sortEdgesCCW(corners); for(Node n : corners.toList()) { Node m0 = n.edges[0]; double theta0 = Math.atan2(m0.y - n.y, m0.x - n.x); for(int i = 0; i < 4; i ++ ) { Node m = n.edges[i]; if(m == null)continue; double thetaI = Math.atan2(m.y - n.y, m.x - n.x); assertEquals(i * Math.PI / 2.0, UtilAngle.distanceCCW(theta0, thetaI), 0.001); } } } "
    },
    {
        "test_src": "@Test public void findErrorLocatorPolynomialBM_compareToDirect() { GrowQueue_I8 found = new GrowQueue_I8(); GrowQueue_I8 expected = new GrowQueue_I8(); for(int i = 0; i < 30; i ++ ) { int N = 50; GrowQueue_I8 message = randomMessage(N); GrowQueue_I8 ecc = new GrowQueue_I8(); int nsyn = 10; int syndromes[] = new int[nsyn]; ReidSolomonCodes alg = new ReidSolomonCodes(8, primitive8); alg.generator(nsyn); alg.computeECC(message, ecc); int where = rand.nextInt(N); message.data[where] ^= 0x12; alg.computeSyndromes(message, ecc, syndromes); GrowQueue_I32 whereList = new GrowQueue_I32(1); whereList.add(where); alg.findErrorLocatorPolynomialBM(syndromes, nsyn, found); alg.findErrorLocatorPolynomial(N + ecc.size, whereList, expected); assertEquals(found.size, expected.size); for(int j = 0; j < found.size; j ++ ) { assertEquals(found.get(j), expected.get(j)); } } } ",
        "focal_tgt": "void findErrorLocatorPolynomialBM(GrowQueue_I8 syndromes, GrowQueue_I8 errorLocator) { GrowQueue_I8 C = errorLocator; GrowQueue_I8 B = new GrowQueue_I8(); initToOne(C, syndromes.size + 1); initToOne(B, syndromes.size + 1); GrowQueue_I8 tmp = new GrowQueue_I8(syndromes.size); int b = 1; for(int n = 0; n < syndromes.size; n ++ ) { int delta = syndromes.data[n] & 0xFF; for(int j = 1; j < C.size; j ++ ) { delta ^= math.multiply(C.data[C.size - j - 1] & 0xFF, syndromes.data[n - j] & 0xFF); } B.data[B.size ++ ] = 0; if(delta != 0) { int scale = math.multiply(delta, math.inverse(b)); math.polyAddScaleB(C, B, scale, tmp); if(2 * C.size > syndromes.size) { } else { B.setTo(C); b = delta; } C.setTo(tmp); } } removeLeadingZeros(C); } ",
        "focal_src": "void findErrorLocatorPolynomialBM(int syndromes[], int length, GrowQueue_I8 errorLocator) { GrowQueue_I8 C = errorLocator; GrowQueue_I8 B = new GrowQueue_I8(); initToOne(C, length + 1); initToOne(B, length + 1); GrowQueue_I8 tmp = new GrowQueue_I8(length); int b = 1; for(int n = 0; n < length; n ++ ) { int delta = syndromes[n]; for(int j = 1; j < C.size; j ++ ) { delta ^= math.multiply(C.data[C.size - j - 1] & 0xFF, syndromes[n - j]); } B.data[B.size ++ ] = 0; if(delta != 0) { int scale = math.multiply(delta, math.inverse(b)); math.polyAddScaleB(C, B, scale, tmp); if(2 * C.size > length) { } else { B.setTo(C); b = delta; } C.setTo(tmp); } } removeLeadingZeros(C); } ",
        "test_tgt": "@Test public void findErrorLocatorPolynomialBM_compareToDirect() { GrowQueue_I8 found = new GrowQueue_I8(); GrowQueue_I8 expected = new GrowQueue_I8(); for(int i = 0; i < 30; i ++ ) { int N = 50; GrowQueue_I8 message = randomMessage(N); GrowQueue_I8 ecc = new GrowQueue_I8(); int nsyn = 10; GrowQueue_I8 syndromes = GrowQueue_I8.zeros(nsyn); ReidSolomonCodes alg = new ReidSolomonCodes(8, primitive8); alg.generator(nsyn); alg.computeECC(message, ecc); int where = rand.nextInt(N); message.data[where] ^= 0x12; alg.computeSyndromes(message, ecc, syndromes); GrowQueue_I32 whereList = new GrowQueue_I32(1); whereList.add(where); alg.findErrorLocatorPolynomialBM(syndromes, found); alg.findErrorLocatorPolynomial(N + ecc.size, whereList, expected); assertEquals(found.size, expected.size); for(int j = 0; j < found.size; j ++ ) { assertEquals(found.get(j), expected.get(j)); } } } "
    },
    {
        "test_src": "@Test public void testParseServiceRequestQueryParams() { Map < String, String > paramMap = GatewayServlet.parseServiceRequestQueryParams(null); Assert.assertNotNull(paramMap); paramMap = GatewayServlet.parseServiceRequestQueryParams(\"param1\"); Assert.assertNull(paramMap.get(\"param1\")); paramMap = GatewayServlet.parseServiceRequestQueryParams(\"param1=value1\"); Assert.assertEquals(\"value1\", paramMap.get(\"param1\")); paramMap = GatewayServlet.parseServiceRequestQueryParams(\"param1=value1&param2\"); Assert.assertEquals(\"value1\", paramMap.get(\"param1\")); Assert.assertNull(paramMap.get(\"param2\")); paramMap = GatewayServlet.parseServiceRequestQueryParams(\"param1=value1&param2=value2\"); Assert.assertEquals(\"value1\", paramMap.get(\"param1\")); Assert.assertEquals(\"value2\", paramMap.get(\"param2\")); paramMap = GatewayServlet.parseServiceRequestQueryParams(\"param1=value1&param2=value2&param3=value3\"); Assert.assertEquals(\"value1\", paramMap.get(\"param1\")); Assert.assertEquals(\"value2\", paramMap.get(\"param2\")); Assert.assertEquals(\"value3\", paramMap.get(\"param3\")); paramMap = GatewayServlet.parseServiceRequestQueryParams(\"param1=hello%20world&param2=hello+world&param3=hello world\"); Assert.assertEquals(\"hello world\", paramMap.get(\"param1\")); Assert.assertEquals(\"hello world\", paramMap.get(\"param2\")); Assert.assertEquals(\"hello world\", paramMap.get(\"param3\")); } ",
        "focal_tgt": "protected static final Map < String, String > parseApiRequestQueryParams(String queryString) { Map < String, String > rval = new LinkedHashMap < > (); if(queryString != null) { try { queryString = URLDecoder.decode(queryString, \"UTF-8\"); } catch(UnsupportedEncodingException e) { throw new RuntimeException(e); } String[]pairSplit = queryString.split(\"&\"); for(String paramPair : pairSplit) { int idx = paramPair.indexOf(\"=\"); if(idx != - 1) { String key = paramPair.substring(0, idx); String val = paramPair.substring(idx + 1); rval.put(key, val); } else { rval.put(paramPair, null); } } } return rval; } ",
        "focal_src": "protected static final Map < String, String > parseServiceRequestQueryParams(String queryString) { Map < String, String > rval = new LinkedHashMap < > (); if(queryString != null) { try { queryString = URLDecoder.decode(queryString, \"UTF-8\"); } catch(UnsupportedEncodingException e) { throw new RuntimeException(e); } String[]pairSplit = queryString.split(\"&\"); for(String paramPair : pairSplit) { int idx = paramPair.indexOf(\"=\"); if(idx != - 1) { String key = paramPair.substring(0, idx); String val = paramPair.substring(idx + 1); rval.put(key, val); } else { rval.put(paramPair, null); } } } return rval; } ",
        "test_tgt": "@Test public void testParseApiRequestQueryParams() { Map < String, String > paramMap = GatewayServlet.parseApiRequestQueryParams(null); Assert.assertNotNull(paramMap); paramMap = GatewayServlet.parseApiRequestQueryParams(\"param1\"); Assert.assertNull(paramMap.get(\"param1\")); paramMap = GatewayServlet.parseApiRequestQueryParams(\"param1=value1\"); Assert.assertEquals(\"value1\", paramMap.get(\"param1\")); paramMap = GatewayServlet.parseApiRequestQueryParams(\"param1=value1&param2\"); Assert.assertEquals(\"value1\", paramMap.get(\"param1\")); Assert.assertNull(paramMap.get(\"param2\")); paramMap = GatewayServlet.parseApiRequestQueryParams(\"param1=value1&param2=value2\"); Assert.assertEquals(\"value1\", paramMap.get(\"param1\")); Assert.assertEquals(\"value2\", paramMap.get(\"param2\")); paramMap = GatewayServlet.parseApiRequestQueryParams(\"param1=value1&param2=value2&param3=value3\"); Assert.assertEquals(\"value1\", paramMap.get(\"param1\")); Assert.assertEquals(\"value2\", paramMap.get(\"param2\")); Assert.assertEquals(\"value3\", paramMap.get(\"param3\")); paramMap = GatewayServlet.parseApiRequestQueryParams(\"param1=hello%20world&param2=hello+world&param3=hello world\"); Assert.assertEquals(\"hello world\", paramMap.get(\"param1\")); Assert.assertEquals(\"hello world\", paramMap.get(\"param2\")); Assert.assertEquals(\"hello world\", paramMap.get(\"param3\")); } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void test_getID() { ZoneOffset offset = ZoneOffset.ofHoursMinutesSeconds(1, 0, 0); assertEquals(offset.getId(), \"+01:00\"); offset = ZoneOffset.ofHoursMinutesSeconds(1, 2, 3); assertEquals(offset.getId(), \"+01:02:03\"); offset = ZoneOffset.UTC; assertEquals(offset.getId(), \"Z\"); } ",
        "focal_tgt": "@Override public String getId() { if(groupId.equals(GROUP_TZDB)) { return regionId; } return groupId + ':' + regionId; } ",
        "focal_src": "@Override public String getId() { if(groupID.equals(GROUP_TZDB)) { return regionID; } return groupID + ':' + regionID; } ",
        "test_tgt": "@Test(groups = { \"tck\" })public void test_getId() { ZoneOffset offset = ZoneOffset.ofHoursMinutesSeconds(1, 0, 0); assertEquals(offset.getId(), \"+01:00\"); offset = ZoneOffset.ofHoursMinutesSeconds(1, 2, 3); assertEquals(offset.getId(), \"+01:02:03\"); offset = ZoneOffset.UTC; assertEquals(offset.getId(), \"Z\"); } "
    },
    {
        "test_src": "@Test public void init()throws Exception { final InitService initService = getInitService(); final JSONObject requestJSONObject = new JSONObject(); requestJSONObject.put(User.USER_EMAIL, \"test@gmail.com\"); requestJSONObject.put(User.USER_NAME, \"Admin\"); requestJSONObject.put(User.USER_PASSWORD, \"pass\"); requestJSONObject.put(Keys.LOCALE, Preference.Default.DEFAULT_LANGUAGE); initService.init(requestJSONObject); final UserQueryService userQueryService = getUserQueryService(); Assert.assertNotNull(userQueryService.getUserByEmail(\"test@gmail.com\")); } ",
        "focal_tgt": "public void init(final JSONObject requestJSONObject)throws ServiceException { if(SoloServletListener.isInited()) { return; } final RuntimeEnv runtimeEnv = Latkes.getRuntimeEnv(); if(RuntimeEnv.LOCAL == runtimeEnv || RuntimeEnv.BAE == runtimeEnv) { LOGGER.log(Level.INFO, \"B3log Solo is running on [\" + runtimeEnv + \"] environment, database [{0}], creates all tables\", Latkes.getRuntimeDatabase()); final List < CreateTableResult > createTableResults = JdbcRepositories.initAllTables(); for(final CreateTableResult createTableResult : createTableResults) { LOGGER.log(Level.INFO, \"Create table result[tableName={0}, isSuccess={1}]\", new Object[] { createTableResult.getName(), createTableResult.isSuccess() }); } } int retries = MAX_RETRIES_CNT; while(true) { final Transaction transaction = userRepository.beginTransaction(); try { final JSONObject statistic = statisticRepository.get(Statistic.STATISTIC); if(null == statistic) { initStatistic(); initPreference(requestJSONObject); initReplyNotificationTemplate(); initAdmin(requestJSONObject); } transaction.commit(); break; } catch(final Exception e) { if(0 == retries) { LOGGER.log(Level.SEVERE, \"Initialize B3log Solo error\", e); throw new ServiceException(\"Initailize B3log Solo error: \" + e.getMessage()); } -- retries; LOGGER.log(Level.WARNING, \"Retrying to init B3log Solo[retries={0}]\", retries); } finally { if(transaction.isActive()) { transaction.rollback(); } } } final Transaction transaction = userRepository.beginTransaction(); try { helloWorld(); transaction.commit(); } catch(final Exception e) { if(transaction.isActive()) { transaction.rollback(); } LOGGER.log(Level.SEVERE, \"Hello World error?!\", e); } } ",
        "focal_src": "public void init(final JSONObject requestJSONObject)throws ServiceException { if(SoloServletListener.isInited()) { return; } final RuntimeEnv runtimeEnv = Latkes.getRuntimeEnv(); if(RuntimeEnv.LOCAL == runtimeEnv || RuntimeEnv.BAE == runtimeEnv) { LOGGER.log(Level.INFO, \"B3log Solo is running on [\" + runtimeEnv + \"] environment, database [{0}], creates all tables\", Latkes.getRuntimeDatabase()); final List < CreateTableResult > createTableResults = JdbcRepositories.initAllTables(); for(final CreateTableResult createTableResult : createTableResults) { LOGGER.log(Level.INFO, \"Create table result[tableName={0}, isSuccess={1}]\", new Object[] { createTableResult.getName(), createTableResult.isSuccess() }); } } int retries = MAX_RETRIES_CNT; while(true) { final Transaction transaction = userRepository.beginTransaction(); try { final JSONObject statistic = statisticRepository.get(Statistic.STATISTIC); if(null == statistic) { initStatistic(); initPreference(requestJSONObject); initReplyNotificationTemplate(); initAdmin(requestJSONObject); } transaction.commit(); break; } catch(final Exception e) { if(0 == retries) { LOGGER.log(Level.SEVERE, \"Initialize B3log Solo error\", e); throw new ServiceException(\"Initailize B3log Solo error: \" + e.getMessage()); } -- retries; LOGGER.log(Level.WARNING, \"Retrying to init B3log Solo[retries={0}]\", retries); } finally { if(transaction.isActive()) { transaction.rollback(); } } } final Transaction transaction = userRepository.beginTransaction(); try { helloWorld(requestJSONObject.getString(Keys.LOCALE)); transaction.commit(); } catch(final Exception e) { if(transaction.isActive()) { transaction.rollback(); } LOGGER.log(Level.SEVERE, \"Hello World error?!\", e); } } ",
        "test_tgt": "@Test public void init()throws Exception { final InitService initService = getInitService(); final JSONObject requestJSONObject = new JSONObject(); requestJSONObject.put(User.USER_EMAIL, \"test@gmail.com\"); requestJSONObject.put(User.USER_NAME, \"Admin\"); requestJSONObject.put(User.USER_PASSWORD, \"pass\"); initService.init(requestJSONObject); final UserQueryService userQueryService = getUserQueryService(); Assert.assertNotNull(userQueryService.getUserByEmail(\"test@gmail.com\")); } "
    },
    {
        "test_src": "@Test public void testSearch() { System.out.println(\"search 'romantic'\"); Iterator < Relevance > hits = corpus.search(new BM25(), \"romantic\"); while(hits.hasNext()) { Relevance hit = hits.next(); System.out.println(hit.doc() + \"\\t\" + hit.score()); } } ",
        "focal_tgt": "Iterator < Relevance > search(RelevanceRanker ranker, String term); ",
        "focal_src": "public Iterator < Relevance > search(RelevanceRanker ranker, String term); ",
        "test_tgt": "@Test public void testSearch() { System.out.println(\"search 'romantic'\"); Iterator < Relevance > hits = corpus.search(new BM25(), \"romantic\"); while(hits.hasNext()) { Relevance hit = hits.next(); System.out.println(hit.text + \"\\t\" + hit.score); } } "
    },
    {
        "test_src": "@Test public void testSetCommands()throws GeniePreconditionException { Assert.assertNotNull(this.c.getCommands()); Assert.assertTrue(this.c.getCommands().isEmpty()); final CommandEntity one = new CommandEntity(); one.setId(\"one\"); final CommandEntity two = new CommandEntity(); two.setId(\"two\"); final List < CommandEntity > commands = new ArrayList < > (); commands.add(one); commands.add(two); this.c.setCommands(commands); Assert.assertEquals(commands, this.c.getCommands()); Assert.assertTrue(one.getClusters().contains(this.c)); Assert.assertTrue(two.getClusters().contains(this.c)); this.c.setCommands(null); Assert.assertThat(this.c.getCommands(), Matchers.empty()); Assert.assertFalse(one.getClusters().contains(this.c)); Assert.assertFalse(two.getClusters().contains(this.c)); } ",
        "focal_tgt": "void setCommands(@Nullable final Set < CommandEntity > commands) { this.commands.clear(); if(commands != null) { this.commands.addAll(commands); } } ",
        "focal_src": "protected void setCommands(final Set < CommandEntity > commands) { this.commands.clear(); if(commands != null) { this.commands.addAll(commands); } } ",
        "test_tgt": "@Test public void testSetCommands()throws GeniePreconditionException { Assert.assertNotNull(this.c.getCommands()); Assert.assertTrue(this.c.getCommands().isEmpty()); final CommandEntity one = new CommandEntity(); one.setUniqueId(\"one\"); final CommandEntity two = new CommandEntity(); two.setUniqueId(\"two\"); final List < CommandEntity > commands = new ArrayList < > (); commands.add(one); commands.add(two); this.c.setCommands(commands); Assert.assertEquals(commands, this.c.getCommands()); Assert.assertTrue(one.getClusters().contains(this.c)); Assert.assertTrue(two.getClusters().contains(this.c)); this.c.setCommands(null); Assert.assertThat(this.c.getCommands(), Matchers.empty()); Assert.assertFalse(one.getClusters().contains(this.c)); Assert.assertFalse(two.getClusters().contains(this.c)); } "
    },
    {
        "test_src": "@Test public final void testGetExtentToday() { Date[]dates = DateExtensionUtil.getExtentToday(); LOGGER.debug(JsonUtil.format(dates)); } ",
        "focal_tgt": "public static Date[]getResetTodayAndTomorrow() { Calendar calendar = CalendarUtil.resetCalendarByDay(new Date()); Date today = calendar.getTime(); calendar.add(Calendar.DATE, 1); Date tomorrow = calendar.getTime(); return new Date[] { today, tomorrow }; } ",
        "focal_src": "@Deprecated public static Date[]getExtentToday() { Calendar calendar = CalendarUtil.resetCalendarByDay(new Date()); Date today = calendar.getTime(); calendar.add(Calendar.DATE, 1); Date tomorrow = calendar.getTime(); return new Date[] { today, tomorrow }; } ",
        "test_tgt": "@Test public final void testGetResetTodayAndTomorrow() { LOGGER.debug(JsonUtil.format(DateExtensionUtil.getResetTodayAndTomorrow())); } "
    },
    {
        "test_src": "@Test public void bitPolyDivide() { int message = 0b00101 << 10; int divisor = 0b10100110111; int found = QrCodePolynomialMath.bitPolyDivide(message, divisor, 15, 5); int expected = 0b0011011100; assertEquals(expected, found); } ",
        "focal_tgt": "public static int bitPolyModulus(int data, int generator, int totalBits, int dataBits) { int errorBits = totalBits - dataBits; for(int i = dataBits - 1; i >= 0; i -- ) { if((data & (1 << (i + errorBits))) != 0) { data ^= generator << i; } } return data; } ",
        "focal_src": "public static int bitPolyDivide(int data, int generator, int totalBits, int dataBits) { int errorBits = totalBits - dataBits; for(int i = dataBits - 1; i >= 0; i -- ) { if((data & (1 << (i + errorBits))) != 0) { data ^= generator << i; } } return data; } ",
        "test_tgt": "@Test public void bitPolyDivide() { int message = 0b00101 << 10; int divisor = 0b10100110111; int found = QrCodePolynomialMath.bitPolyModulus(message, divisor, 15, 5); int expected = 0b0011011100; assertEquals(expected, found); } "
    },
    {
        "test_src": "@Test public void testRecognize()throws URISyntaxException, InterruptedException { final SpeechRecognitionResults speechResults = new SpeechRecognitionResults(); speechResults.setResultIndex(0); final SpeechRecognitionResult transcript = new SpeechRecognitionResult(); transcript.setFinal(true); final SpeechRecognitionAlternative speechAlternative = new SpeechRecognitionAlternative(); speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\"); final List < SpeechRecognitionAlternative > speechAlternatives = ImmutableList.of(speechAlternative); transcript.setAlternatives(speechAlternatives); final List < SpeechRecognitionResult > transcripts = ImmutableList.of(transcript); speechResults.setResults(transcripts); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults))); RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WAV).contentType(RecognizeOptions.ContentType.AUDIO_WAV).build(); final SpeechRecognitionResults result = service.recognize(recognizeOptions).execute(); final RecordedRequest request = server.takeRequest(); assertNotNull(result); assertEquals(result, speechResults); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_RECOGNIZE, request.getPath()); assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE)); } ",
        "focal_tgt": "public ServiceCall < SpeechRecognitionResults > recognize(RecognizeOptions recognizeOptions) { Validator.notNull(recognizeOptions, \"recognizeOptions cannot be null\"); RequestBuilder builder = RequestBuilder.post(\"/v1/recognize\"); if(recognizeOptions.transferEncoding() != null) { builder.header(\"Transfer-Encoding\", recognizeOptions.transferEncoding()); } if(recognizeOptions.contentType() != null) { builder.header(\"Content-Type\", recognizeOptions.contentType()); } if(recognizeOptions.model() != null) { builder.query(\"model\", recognizeOptions.model()); } if(recognizeOptions.customizationId() != null) { builder.query(\"customization_id\", recognizeOptions.customizationId()); } if(recognizeOptions.acousticCustomizationId() != null) { builder.query(\"acoustic_customization_id\", recognizeOptions.acousticCustomizationId()); } if(recognizeOptions.customizationWeight() != null) { builder.query(\"customization_weight\", String.valueOf(recognizeOptions.customizationWeight())); } if(recognizeOptions.version() != null) { builder.query(\"version\", recognizeOptions.version()); } if(recognizeOptions.inactivityTimeout() != null) { builder.query(\"inactivity_timeout\", String.valueOf(recognizeOptions.inactivityTimeout())); } if(recognizeOptions.keywords() != null) { builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\")); } if(recognizeOptions.keywordsThreshold() != null) { builder.query(\"keywords_threshold\", String.valueOf(recognizeOptions.keywordsThreshold())); } if(recognizeOptions.maxAlternatives() != null) { builder.query(\"max_alternatives\", String.valueOf(recognizeOptions.maxAlternatives())); } if(recognizeOptions.wordAlternativesThreshold() != null) { builder.query(\"word_alternatives_threshold\", String.valueOf(recognizeOptions.wordAlternativesThreshold())); } if(recognizeOptions.wordConfidence() != null) { builder.query(\"word_confidence\", String.valueOf(recognizeOptions.wordConfidence())); } if(recognizeOptions.timestamps() != null) { builder.query(\"timestamps\", String.valueOf(recognizeOptions.timestamps())); } if(recognizeOptions.profanityFilter() != null) { builder.query(\"profanity_filter\", String.valueOf(recognizeOptions.profanityFilter())); } if(recognizeOptions.smartFormatting() != null) { builder.query(\"smart_formatting\", String.valueOf(recognizeOptions.smartFormatting())); } if(recognizeOptions.speakerLabels() != null) { builder.query(\"speaker_labels\", String.valueOf(recognizeOptions.speakerLabels())); } if(recognizeOptions.audio() != null) { builder.body(RequestBody.create(MediaType.parse(recognizeOptions.contentType()), recognizeOptions.audio())); } MultipartBody.Builder multipartBuilder = new MultipartBody.Builder(); multipartBuilder.setType(MultipartBody.FORM); if(recognizeOptions.metadata() != null) { multipartBuilder.addFormDataPart(\"metadata\", GsonSingleton.getGson().toJson(recognizeOptions.metadata())); if(recognizeOptions.upload() != null) { RequestBody uploadBody = RequestUtils.inputStreamBody(recognizeOptions.upload(), recognizeOptions.uploadContentType()); multipartBuilder.addFormDataPart(\"upload\", recognizeOptions.uploadFilename(), uploadBody); } builder.body(multipartBuilder.build()); } return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SpeechRecognitionResults.class)); } ",
        "focal_src": "public ServiceCall < SpeechRecognitionResults > recognize(RecognizeOptions recognizeOptions) { Validator.notNull(recognizeOptions, \"recognizeOptions cannot be null\"); Validator.isTrue(((recognizeOptions.audio() != null && recognizeOptions.upload() == null) || (recognizeOptions.audio() == null && recognizeOptions.upload() != null)), \"Exactly one of audio or upload must be supplied.\"); RequestBuilder builder = RequestBuilder.post(\"/v1/recognize\"); builder.header(\"Content-Type\", recognizeOptions.contentType()); if(recognizeOptions.transferEncoding() != null) { builder.header(\"Transfer-Encoding\", recognizeOptions.transferEncoding()); } if(recognizeOptions.model() != null) { builder.query(\"model\", recognizeOptions.model()); } if(recognizeOptions.customizationId() != null) { builder.query(\"customization_id\", recognizeOptions.customizationId()); } if(recognizeOptions.acousticCustomizationId() != null) { builder.query(\"acoustic_customization_id\", recognizeOptions.acousticCustomizationId()); } if(recognizeOptions.customizationWeight() != null) { builder.query(\"customization_weight\", recognizeOptions.customizationWeight()); } if(recognizeOptions.version() != null) { builder.query(\"version\", recognizeOptions.version()); } if(recognizeOptions.inactivityTimeout() != null) { builder.query(\"inactivity_timeout\", recognizeOptions.inactivityTimeout()); } if(recognizeOptions.keywords() != null) { builder.query(\"keywords\", RequestUtils.join(recognizeOptions.keywords(), \",\")); } if(recognizeOptions.keywordsThreshold() != null) { builder.query(\"keywords_threshold\", recognizeOptions.keywordsThreshold()); } if(recognizeOptions.maxAlternatives() != null) { builder.query(\"max_alternatives\", recognizeOptions.maxAlternatives()); } if(recognizeOptions.wordAlternativesThreshold() != null) { builder.query(\"word_alternatives_threshold\", recognizeOptions.wordAlternativesThreshold()); } if(recognizeOptions.wordConfidence() != null) { builder.query(\"word_confidence\", recognizeOptions.wordConfidence()); } if(recognizeOptions.timestamps() != null) { builder.query(\"timestamps\", recognizeOptions.timestamps()); } if(recognizeOptions.profanityFilter() != null) { builder.query(\"profanity_filter\", recognizeOptions.profanityFilter()); } if(recognizeOptions.smartFormatting() != null) { builder.query(\"smart_formatting\", recognizeOptions.smartFormatting()); } if(recognizeOptions.speakerLabels() != null) { builder.query(\"speaker_labels\", recognizeOptions.speakerLabels()); } if(recognizeOptions.audio() != null) { builder.body(RequestBody.create(MediaType.parse(recognizeOptions.contentType()), recognizeOptions.audio())); } MultipartBody.Builder multipartBuilder = new MultipartBody.Builder(); multipartBuilder.setType(MultipartBody.FORM); if(recognizeOptions.upload() != null) { RequestBody fileBody = RequestUtils.inputStreamBody(recognizeOptions.upload(), recognizeOptions.contentType()); multipartBuilder.addFormDataPart(\"upload\", recognizeOptions.uploadFilename(), fileBody); if(recognizeOptions.metadata() != null) { multipartBuilder.addFormDataPart(\"metadata\", GsonSingleton.getGson().toJson(recognizeOptions.metadata())); } builder.body(multipartBuilder.build()); } return createServiceCall(builder.build(), ResponseConverterUtils.getObject(SpeechRecognitionResults.class)); } ",
        "test_tgt": "@Test public void testRecognize()throws URISyntaxException, InterruptedException { final SpeechRecognitionResults speechResults = new SpeechRecognitionResults(); speechResults.setResultIndex(0); final SpeechRecognitionResult transcript = new SpeechRecognitionResult(); transcript.setFinalResults(true); final SpeechRecognitionAlternative speechAlternative = new SpeechRecognitionAlternative(); speechAlternative.setTranscript(\"thunderstorms could produce large hail isolated tornadoes and heavy rain\"); final List < SpeechRecognitionAlternative > speechAlternatives = ImmutableList.of(speechAlternative); transcript.setAlternatives(speechAlternatives); final List < SpeechRecognitionResult > transcripts = ImmutableList.of(transcript); speechResults.setResults(transcripts); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(speechResults))); RecognizeOptions recognizeOptions = new RecognizeOptions.Builder().audio(SAMPLE_WAV).contentType(RecognizeOptions.ContentType.AUDIO_WAV).build(); final SpeechRecognitionResults result = service.recognize(recognizeOptions).execute(); final RecordedRequest request = server.takeRequest(); assertNotNull(result); assertEquals(result, speechResults); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_RECOGNIZE, request.getPath()); assertEquals(HttpMediaType.AUDIO_WAV, request.getHeader(CONTENT_TYPE)); } "
    },
    {
        "test_src": "@Test public void testVRouterId()throws Exception { assertThat(config.vRouterId(), is(VROUTER_ID_1)); } ",
        "focal_tgt": "public Optional < DeviceId > vRouterId() { if( ! object.has(VROUTER_ID)) { return Optional.empty(); } try { return Optional.of(DeviceId.deviceId(object.path(VROUTER_ID).asText())); } catch(IllegalArgumentException e) { return null; } } ",
        "focal_src": "public DeviceId vRouterId() { if( ! object.has(VROUTER_ID)) { return null; } try { return DeviceId.deviceId(object.path(VROUTER_ID).asText()); } catch(IllegalArgumentException e) { return null; } } ",
        "test_tgt": "@Test public void testVRouterId()throws Exception { Optional < DeviceId > vRouterId = config.vRouterId(); assertTrue(vRouterId.isPresent()); assertThat(vRouterId.get(), is(VROUTER_ID_1)); } "
    },
    {
        "test_src": "@Test public void testInitialize()throws Exception { ArchiveAnalyzer instance = new ArchiveAnalyzer(); instance.initialize(); instance.close(); } ",
        "focal_tgt": "@Override public void initialize()throws Exception { final File baseDir = Settings.getTempDirectory(); if( ! baseDir.exists()) { if( ! baseDir.mkdirs()) { final String msg = String.format(\"Unable to make a temporary folder '%s'\", baseDir.getPath()); throw new AnalysisException(msg); } } tempFileLocation = File.createTempFile(\"check\", \"tmp\", baseDir); if( ! tempFileLocation.delete()) { final String msg = String.format(\"Unable to delete temporary file '%s'.\", tempFileLocation.getAbsolutePath()); throw new AnalysisException(msg); } if( ! tempFileLocation.mkdirs()) { final String msg = String.format(\"Unable to create directory '%s'.\", tempFileLocation.getAbsolutePath()); throw new AnalysisException(msg); } } ",
        "focal_src": "@Override public void initialize()throws Exception { final File baseDir = Settings.getTempDirectory(); if( ! baseDir.exists()) { if( ! baseDir.mkdirs()) { final String msg = String.format(\"Unable to make a temporary folder '%s'\", baseDir.getPath()); throw new AnalysisException(msg); } } tempFileLocation = File.createTempFile(\"check\", \"tmp\", baseDir); if( ! tempFileLocation.delete()) { throw new AnalysisException(\"Unable to delete temporary file '\" + tempFileLocation.getAbsolutePath() + \"'.\"); } if( ! tempFileLocation.mkdirs()) { throw new AnalysisException(\"Unable to create directory '\" + tempFileLocation.getAbsolutePath() + \"'.\"); } } ",
        "test_tgt": "@Test public void testInitialize()throws Exception { ArchiveAnalyzer instance = new ArchiveAnalyzer(); instance.initialize(); instance.close(); } "
    },
    {
        "test_src": "@Test public void testBetween() { assertTrue(instance.between(\"name\", \"a\", \"b\").getQueryCriterions().contains(new BetweenCriterion(\"name\", \"a\", \"b\"))); } ",
        "focal_tgt": "public < E > CriteriaQuery between(String propName, Comparable < E > from, Comparable < E > to) { criterion = criterion.and(criterionBuilder.between(propName, from, to)); return this; } ",
        "focal_src": "public < E > CriteriaQuery between(String propName, Comparable < E > from, Comparable < E > to) { addCriterion(criterionBuilder.between(propName, from, to)); return this; } ",
        "test_tgt": "@Test public void testBetween() { assertEquals(new BetweenCriterion(\"name\", \"a\", \"b\"), instance.between(\"name\", \"a\", \"b\").getQueryCriterion()); } "
    },
    {
        "test_src": "@Test public void put()throws Exception { final QueryProcessor qp = new QueryProcessor(\"http:send-request(\" + \"<http:request method='put' status-only='true'>\" + \"<http:body media-type='text/xml'>\" + BOOKS + \"</http:body>\" + \"</http:request>, '\" + URL + \"')\", CONTEXT); checkResponse(qp.execute(), HttpURLConnection.HTTP_CREATED, 1); qp.close(); } ",
        "focal_tgt": "private String put(final String query, final InputStream is)throws IOException { return put(query, is, null); } ",
        "focal_src": "private String put(final String query, final InputStream is)throws IOException { final URL url = new URL(ROOT + query); final HttpURLConnection conn = (HttpURLConnection)url.openConnection(); conn.setDoOutput(true); conn.setRequestMethod(\"PUT\"); final OutputStream bos = new BufferedOutputStream(conn.getOutputStream()); if(is != null) { final BufferedInputStream bis = new BufferedInputStream(is); for(int i; (i = bis.read()) != - 1; )bos.write(i); bis.close(); bos.close(); } try { return read(conn.getInputStream()); } catch(final IOException ex) { throw new IOException(read(conn.getErrorStream())); } finally { conn.disconnect(); } } ",
        "test_tgt": "@Test public void put()throws Exception { final QueryProcessor qp = new QueryProcessor(\"http:send-request(\" + \"<http:request method='put' status-only='true'>\" + \"<http:body media-type='text/xml'>\" + BOOKS + \"</http:body>\" + \"</http:request>, '\" + RESTURL + \"')\", CONTEXT); checkResponse(qp.execute(), HttpURLConnection.HTTP_CREATED, 1); qp.close(); } "
    },
    {
        "test_src": "@Test public void testBetween() { assertEquals(new BetweenCriterion(\"name\", \"a\", \"b\"), instance.between(\"name\", \"a\", \"b\").getQueryCriterion()); } ",
        "focal_tgt": "public < E > CriteriaQuery between(String propName, Comparable < E > from, Comparable < E > to) { criterion = criterion.and(Criteria.between(propName, from, to)); return this; } ",
        "focal_src": "public < E > CriteriaQuery between(String propName, Comparable < E > from, Comparable < E > to) { criterion = criterion.and(criterionBuilder.between(propName, from, to)); return this; } ",
        "test_tgt": "@Test public void testBetween() { assertEquals(Criteria.between(\"name\", \"a\", \"b\"), instance.between(\"name\", \"a\", \"b\").getQueryCriterion()); } "
    },
    {
        "test_src": "@Test public void testDelete()throws Exception { HttpResponse response = doDelete(getVersionedAPIPath(\"apps/XYZ\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); deploy(WordCountApp.class, Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1); Id.Program program = Id.Program.from(TEST_NAMESPACE1, \"WordCountApp\", ProgramType.FLOW, \"WordCountFlow\"); startProgram(program); waitState(program, \"RUNNING\"); response = doDelete(getVersionedAPIPath(\"apps/WordCountApp\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(409, response.getStatusLine().getStatusCode()); Assert.assertEquals(\"'\" + program.getApplication() + \"' could not be deleted. Reason: The following programs are still running: \" + program.getId(), readResponse(response)); stopProgram(program); waitState(program, \"STOPPED\"); startProgram(program); waitState(program, \"RUNNING\"); response = doDelete(getVersionedAPIPath(\"apps\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(409, response.getStatusLine().getStatusCode()); Assert.assertEquals(\"'\" + program.getNamespace() + \"' could not be deleted. Reason: The following programs are still running: \" + program.getApplicationId() + \": \" + program.getId(), readResponse(response)); stopProgram(program); waitState(program, \"STOPPED\"); response = doDelete(getVersionedAPIPath(\"apps/WordCountApp\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE2)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(\"apps/XYZ/versions/\" + VERSION1, Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); Id.Artifact wordCountArtifactId = Id.Artifact.from(Id.Namespace.DEFAULT, \"wordcountapp\", VERSION1); addAppArtifact(wordCountArtifactId, WordCountApp.class); AppRequest < ? extends Config > wordCountRequest = new AppRequest < > (new ArtifactSummary(wordCountArtifactId.getName(), wordCountArtifactId.getVersion().getVersion())); ApplicationId wordCountApp1 = NamespaceId.DEFAULT.app(\"WordCountApp\", VERSION1); Assert.assertEquals(200, deploy(wordCountApp1, wordCountRequest).getStatusLine().getStatusCode()); ProgramId program1 = wordCountApp1.program(ProgramType.FLOW, \"WordCountFlow\"); startProgram(program1, 200); waitState(program1, \"RUNNING\"); response = doDelete(getVersionedAPIPath(String.format(\"apps/%s/versions/%s\", wordCountApp1.getApplication(), wordCountApp1.getVersion()), Constants.Gateway.API_VERSION_3_TOKEN, wordCountApp1.getNamespace())); Assert.assertEquals(409, response.getStatusLine().getStatusCode()); Assert.assertEquals(\"'\" + program1.getParent() + \"' could not be deleted. Reason: The following programs\" + \" are still running: \" + program1.getProgram(), readResponse(response)); stopProgram(program1, null, 200, null); waitState(program1, \"STOPPED\"); response = doDelete(getVersionedAPIPath(String.format(\"apps/%s/versions/%s\", wordCountApp1.getApplication(), wordCountApp1.getVersion()), Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE2)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(String.format(\"apps/%s/versions/%s\", wordCountApp1.getApplication(), wordCountApp1.getVersion()), Constants.Gateway.API_VERSION_3_TOKEN, wordCountApp1.getNamespace())); Assert.assertEquals(200, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(String.format(\"apps/%s/versions/%s\", wordCountApp1.getApplication(), wordCountApp1.getVersion()), Constants.Gateway.API_VERSION_3_TOKEN, wordCountApp1.getNamespace())); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(\"apps/WordCountApp/\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(200, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(\"apps/WordCountApp/\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); response = doGet(getVersionedAPIPath(\"artifacts/WordCountApp\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(200, response.getStatusLine().getStatusCode()); List < ArtifactSummary > summaries = readResponse(response, new TypeToken < List < ArtifactSummary > > () { }.getType()); Assert.assertFalse(summaries.isEmpty()); } ",
        "focal_tgt": "public void delete(final ArtifactId artifactId)throws IOException { try { transactional.execute(new TxRunnable() { @Override public void run(DatasetContext context)throws Exception { ArtifactCell artifactCell = new ArtifactCell(artifactId); Table metaTable = getMetaTable(context); byte[]detailBytes = metaTable.get(artifactCell.rowkey, artifactCell.column); if(detailBytes == null) { return; } deleteMeta(metaTable, artifactId, detailBytes); } }); } catch(TransactionFailureException e) { throw Transactions.propagate(e, IOException.class); } } ",
        "focal_src": "public void delete(final Id.Artifact artifactId)throws IOException { try { transactional.execute(new TxRunnable() { @Override public void run(DatasetContext context)throws Exception { ArtifactCell artifactCell = new ArtifactCell(artifactId); Table metaTable = getMetaTable(context); byte[]detailBytes = metaTable.get(artifactCell.rowkey, artifactCell.column); if(detailBytes == null) { return; } deleteMeta(metaTable, artifactId, detailBytes); } }); } catch(TransactionFailureException e) { throw Transactions.propagate(e, IOException.class); } } ",
        "test_tgt": "@Test public void testDelete()throws Exception { HttpResponse response = doDelete(getVersionedAPIPath(\"apps/XYZ\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); deploy(WordCountApp.class, Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1); ProgramId program = new ProgramId(TEST_NAMESPACE1, \"WordCountApp\", ProgramType.FLOW, \"WordCountFlow\"); startProgram(program); waitState(program, \"RUNNING\"); response = doDelete(getVersionedAPIPath(\"apps/WordCountApp\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(409, response.getStatusLine().getStatusCode()); Assert.assertEquals(\"'\" + program.getApplication() + \"' could not be deleted. Reason: The following programs are still running: \" + program.getEntityName(), readResponse(response)); stopProgram(program); waitState(program, \"STOPPED\"); startProgram(program); waitState(program, \"RUNNING\"); response = doDelete(getVersionedAPIPath(\"apps\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(409, response.getStatusLine().getStatusCode()); Assert.assertEquals(\"'\" + program.getNamespace() + \"' could not be deleted. Reason: The following programs are still running: \" + program.getApplication() + \": \" + program.getEntityName(), readResponse(response)); stopProgram(program); waitState(program, \"STOPPED\"); response = doDelete(getVersionedAPIPath(\"apps/WordCountApp\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE2)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(\"apps/XYZ/versions/\" + VERSION1, Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); ArtifactId wordCountArtifactId = new ArtifactId(NamespaceId.DEFAULT.getNamespace(), \"wordcountapp\", VERSION1); addAppArtifact(wordCountArtifactId, WordCountApp.class); AppRequest < ? extends Config > wordCountRequest = new AppRequest < > (new ArtifactSummary(wordCountArtifactId.getEntityName(), wordCountArtifactId.getVersion())); ApplicationId wordCountApp1 = NamespaceId.DEFAULT.app(\"WordCountApp\", VERSION1); Assert.assertEquals(200, deploy(wordCountApp1, wordCountRequest).getStatusLine().getStatusCode()); ProgramId program1 = wordCountApp1.program(ProgramType.FLOW, \"WordCountFlow\"); startProgram(program1, 200); waitState(program1, \"RUNNING\"); response = doDelete(getVersionedAPIPath(String.format(\"apps/%s/versions/%s\", wordCountApp1.getApplication(), wordCountApp1.getVersion()), Constants.Gateway.API_VERSION_3_TOKEN, wordCountApp1.getNamespace())); Assert.assertEquals(409, response.getStatusLine().getStatusCode()); Assert.assertEquals(\"'\" + program1.getParent() + \"' could not be deleted. Reason: The following programs\" + \" are still running: \" + program1.getProgram(), readResponse(response)); stopProgram(program1, null, 200, null); waitState(program1, \"STOPPED\"); response = doDelete(getVersionedAPIPath(String.format(\"apps/%s/versions/%s\", wordCountApp1.getApplication(), wordCountApp1.getVersion()), Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE2)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(String.format(\"apps/%s/versions/%s\", wordCountApp1.getApplication(), wordCountApp1.getVersion()), Constants.Gateway.API_VERSION_3_TOKEN, wordCountApp1.getNamespace())); Assert.assertEquals(200, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(String.format(\"apps/%s/versions/%s\", wordCountApp1.getApplication(), wordCountApp1.getVersion()), Constants.Gateway.API_VERSION_3_TOKEN, wordCountApp1.getNamespace())); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(\"apps/WordCountApp/\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(200, response.getStatusLine().getStatusCode()); response = doDelete(getVersionedAPIPath(\"apps/WordCountApp/\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(404, response.getStatusLine().getStatusCode()); response = doGet(getVersionedAPIPath(\"artifacts/WordCountApp\", Constants.Gateway.API_VERSION_3_TOKEN, TEST_NAMESPACE1)); Assert.assertEquals(200, response.getStatusLine().getStatusCode()); List < ArtifactSummary > summaries = readResponse(response, new TypeToken < List < ArtifactSummary > > () { }.getType()); Assert.assertFalse(summaries.isEmpty()); } "
    },
    {
        "test_src": "@Test public void voidOrderGroup_shouldVoidOrderGroup()throws Exception { OrderGroup group = Context.getOrderService().getOrderGroup(2); String reason = \"because\"; group = Context.getOrderService().voidOrderGroup(group, reason); Assert.assertNotNull(group); Assert.assertTrue(group.isVoided()); } ",
        "focal_tgt": "@Override public OrderGroup voidOrderGroup(OrderGroup group, String voidReason)throws APIException { if(group.getVoided())return group; if( ! StringUtils.hasLength(voidReason))throw new IllegalArgumentException(\"voidReason cannot be empty or null\"); return dao.saveOrderGroup(group); } ",
        "focal_src": "@Override public OrderGroup voidOrderGroup(OrderGroup group, String voidReason)throws APIException { if(group.getVoided())return group; if( ! StringUtils.hasLength(voidReason))throw new IllegalArgumentException(\"voidReason cannot be empty or null\"); group.setVoided(Boolean.TRUE); group.setVoidReason(voidReason); group.setVoidedBy(Context.getAuthenticatedUser()); if(group.getDateVoided() == null)group.setDateVoided(new Date()); return dao.saveOrderGroup(group); } ",
        "test_tgt": "@Test public void voidOrderGroup_shouldVoidOrdersInGroup()throws Exception { OrderGroup group = Context.getOrderService().getOrderGroup(2); String reason = \"because\"; group = Context.getOrderService().voidOrderGroup(group, reason); Order order = (Order)group.getMembers().toArray()[0]; Assert.assertNotNull(group); Assert.assertTrue(group.isVoided()); Assert.assertNotNull(order); Assert.assertTrue(order.isVoided()); } "
    },
    {
        "test_src": "@Test public void testSetUpdateTime()throws GenieException { final long initialUpdated = this.service.getJob(JOB_1_ID).getUpdated().getTime(); final long newUpdated = this.service.setUpdateTime(JOB_1_ID); Assert.assertNotEquals(initialUpdated, newUpdated); } ",
        "focal_tgt": "@Override@Transactional(rollbackFor = { GenieException.class, ConstraintViolationException.class })@Retryable(JpaOptimisticLockingFailureException.class)public long setUpdateTime(@NotBlank(message = \"No job id entered. Unable to set update time.\")final String id)throws GenieException { if(LOG.isDebugEnabled()) { LOG.debug(\"Updating db for job: \" + id); } final Job job = this.jobRepo.findOne(id); if(job == null) { throw new GenieNotFoundException(\"No job with id \" + id + \" exists\"); } final long lastUpdatedTimeMS = System.currentTimeMillis(); job.setJobStatus(JobStatus.RUNNING, \"Job is running\"); job.setUpdated(new Date(lastUpdatedTimeMS)); return lastUpdatedTimeMS; } ",
        "focal_src": "@Override@Transactional(rollbackFor = { GenieException.class, ConstraintViolationException.class })@Retryable(JpaOptimisticLockingFailureException.class)public long setUpdateTime(@NotBlank(message = \"No job id entered. Unable to set update time.\")final String id)throws GenieException { LOG.debug(\"Updating db for job: \" + id); final Job job = this.jobRepo.findOne(id); if(job == null) { throw new GenieNotFoundException(\"No job with id \" + id + \" exists\"); } final long lastUpdatedTimeMS = System.currentTimeMillis(); job.setJobStatus(JobStatus.RUNNING, \"Job is running\"); job.setUpdated(new Date(lastUpdatedTimeMS)); return lastUpdatedTimeMS; } ",
        "test_tgt": "@Test@Ignore public void testSetUpdateTime()throws GenieException { } "
    },
    {
        "test_src": "@Test public void testDeleteTerminatedClusters()throws GenieException, IOException { Assert.assertThat(this.clusterRepository.count(), Matchers.is(2L)); final String testClusterId = UUID.randomUUID().toString(); final Cluster testCluster = new Cluster.Builder(UUID.randomUUID().toString(), UUID.randomUUID().toString(), UUID.randomUUID().toString(), ClusterStatus.OUT_OF_SERVICE).withId(testClusterId).withConfigs(Sets.newHashSet(UUID.randomUUID().toString())).withDependencies(Sets.newHashSet(UUID.randomUUID().toString())).withSetupFile(UUID.randomUUID().toString()).withTags(Sets.newHashSet(UUID.randomUUID().toString(), UUID.randomUUID().toString())).build(); this.service.createCluster(testCluster); Assert.assertThat(this.service.deleteTerminatedClusters(), Matchers.is(0)); String patchString = \"[{ \\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/status\\\", \\\"value\\\": \\\"UP\\\" }]\"; JsonPatch patch = JsonPatch.fromJson(GenieObjectMapper.getMapper().readTree(patchString)); this.service.patchCluster(testClusterId, patch); Assert.assertThat(this.service.getCluster(testClusterId).getStatus(), Matchers.is(ClusterStatus.UP)); Assert.assertThat(this.service.deleteTerminatedClusters(), Matchers.is(0)); patchString = \"[{ \\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/status\\\", \\\"value\\\": \\\"TERMINATED\\\" }]\"; patch = JsonPatch.fromJson(GenieObjectMapper.getMapper().readTree(patchString)); this.service.patchCluster(testClusterId, patch); Assert.assertThat(this.service.getCluster(testClusterId).getStatus(), Matchers.is(ClusterStatus.TERMINATED)); Assert.assertThat(this.service.deleteTerminatedClusters(), Matchers.is(1)); Assert.assertTrue(this.clusterRepository.existsByUniqueId(CLUSTER_1_ID)); Assert.assertTrue(this.clusterRepository.existsByUniqueId(CLUSTER_2_ID)); Assert.assertFalse(this.clusterRepository.existsByUniqueId(testClusterId)); } ",
        "focal_tgt": "@Override public long deleteTerminatedClusters() { return this.clusterRepository.deleteByIdIn(this.clusterRepository.findTerminatedUnusedClusters().stream().map(Number :: longValue).collect(Collectors.toSet())); } ",
        "focal_src": "@Override public int deleteTerminatedClusters() { return this.clusterRepository.deleteTerminatedClusters(); } ",
        "test_tgt": "@Test public void testDeleteTerminatedClusters()throws GenieException, IOException { Assert.assertThat(this.clusterRepository.count(), Matchers.is(2L)); final String testClusterId = UUID.randomUUID().toString(); final Cluster testCluster = new Cluster.Builder(UUID.randomUUID().toString(), UUID.randomUUID().toString(), UUID.randomUUID().toString(), ClusterStatus.OUT_OF_SERVICE).withId(testClusterId).withConfigs(Sets.newHashSet(UUID.randomUUID().toString())).withDependencies(Sets.newHashSet(UUID.randomUUID().toString())).withSetupFile(UUID.randomUUID().toString()).withTags(Sets.newHashSet(UUID.randomUUID().toString(), UUID.randomUUID().toString())).build(); this.service.createCluster(testCluster); Assert.assertThat(this.service.deleteTerminatedClusters(), Matchers.is(0L)); String patchString = \"[{ \\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/status\\\", \\\"value\\\": \\\"UP\\\" }]\"; JsonPatch patch = JsonPatch.fromJson(GenieObjectMapper.getMapper().readTree(patchString)); this.service.patchCluster(testClusterId, patch); Assert.assertThat(this.service.getCluster(testClusterId).getStatus(), Matchers.is(ClusterStatus.UP)); Assert.assertThat(this.service.deleteTerminatedClusters(), Matchers.is(0L)); patchString = \"[{ \\\"op\\\": \\\"replace\\\", \\\"path\\\": \\\"/status\\\", \\\"value\\\": \\\"TERMINATED\\\" }]\"; patch = JsonPatch.fromJson(GenieObjectMapper.getMapper().readTree(patchString)); this.service.patchCluster(testClusterId, patch); Assert.assertThat(this.service.getCluster(testClusterId).getStatus(), Matchers.is(ClusterStatus.TERMINATED)); Assert.assertThat(this.service.deleteTerminatedClusters(), Matchers.is(1L)); Assert.assertTrue(this.clusterRepository.existsByUniqueId(CLUSTER_1_ID)); Assert.assertTrue(this.clusterRepository.existsByUniqueId(CLUSTER_2_ID)); Assert.assertFalse(this.clusterRepository.existsByUniqueId(testClusterId)); } "
    },
    {
        "test_src": "@Test public void testAddExtension() { final MockImpl m = new MockImpl(); final MockExtension extension = new MockExtension(); m.getExtensionPoint().addExtension(MockExtension.class, extension); assertEquals(1, m.extensionPoint.extensions.size()); final Iterable < Extension < MockInterface > > extensions = m.getExtensionPoint().getExtensions(); assertNotNull(extensions); final Iterator < Extension < MockInterface > > iterator = extensions.iterator(); final Extension < MockInterface > actual = iterator.next(); assertSame(extension, actual); try { iterator.next(); fail(\"Expected NoSuchElementException.\"); } catch(NoSuchElementException e) { } } ",
        "focal_tgt": "void addExtension(Extension < T > extension); ",
        "focal_src": "void addExtension(Object key, Extension < T > extension); ",
        "test_tgt": "@Test public void testAddExtension() { final MockImpl m = new MockImpl(); final MockExtension extension = new MockExtension(); m.getExtensionPoint().addExtension(extension); assertEquals(1, m.extensionPoint.extensions.size()); final Iterable < Extension < MockInterface > > extensions = m.getExtensionPoint().getExtensions(); assertNotNull(extensions); final Iterator < Extension < MockInterface > > iterator = extensions.iterator(); final Extension < MockInterface > actual = iterator.next(); assertSame(extension, actual); try { iterator.next(); fail(\"Expected NoSuchElementException.\"); } catch(NoSuchElementException e) { } } "
    },
    {
        "test_src": "@Test public void testNot() { QueryCriterion criterion1 = new EqCriterion(\"name\", \"abc\"); QueryCriterion criterion2 = new NotCriterion(criterion1); assertEquals(criterion2, instance.not(criterion1).getQueryCriterion()); } ",
        "focal_tgt": "public CriteriaQuery not(QueryCriterion otherCriterion) { criterion = criterion.and(Criteria.not(otherCriterion)); return this; } ",
        "focal_src": "public CriteriaQuery not(QueryCriterion otherCriterion) { criterion = criterion.and(criterionBuilder.not(otherCriterion)); return this; } ",
        "test_tgt": "@Test public void testNot() { QueryCriterion criterion1 = Criteria.eq(\"name\", \"abc\"); QueryCriterion criterion2 = Criteria.not(criterion1); assertEquals(criterion2, instance.not(criterion1).getQueryCriterion()); } "
    },
    {
        "test_src": "@Test public void setShardingKeyTest()throws TestAbortedException, SQLException { assumeTrue(Util.supportJDBC43(connection)); SQLServerConnection connection43 = (SQLServerConnection43)DriverManager.getConnection(connectionString); try { connection43.setShardingKey(shardingKey); } catch(SQLException e) { assert(e.getMessage().contains(TestResource.getResource(\"R_notImplemented\"))); } try { connection43.setShardingKey(shardingKey, superShardingKey); } catch(SQLException e) { assert(e.getMessage().contains(TestResource.getResource(\"R_notImplemented\"))); } } ",
        "focal_tgt": "@Override public void endRequest()throws SQLException; ",
        "focal_src": "public void setShardingKey(ShardingKey shardingKey, ShardingKey superShardingKey)throws SQLServerException; ",
        "test_tgt": "@Test public void setShardingKeyTest()throws TestAbortedException, SQLException { assumeTrue(Util.supportJDBC43(connection)); SQLServerConnection connection43 = (SQLServerConnection43)DriverManager.getConnection(connectionString); try { connection43.setShardingKey(shardingKey); } catch(SQLException e) { assert(e.getMessage().contains(TestResource.getResource(\"R_operationNotSupported\"))); } try { connection43.setShardingKey(shardingKey, superShardingKey); } catch(SQLException e) { assert(e.getMessage().contains(TestResource.getResource(\"R_operationNotSupported\"))); } } "
    },
    {
        "test_src": "@Test public void initialParam() { PlanarCalibrationTarget config = GenericCalibrationGrid.createStandardConfig(); List < Point2D_F64 > grid = config.points; Zhang99Parameters initial = GenericCalibrationGrid.createStandardParam(true, 2, 3, rand); List < List < Point2D_F64 > > observations = GenericCalibrationGrid.createObservations(initial, grid); Helper alg = new Helper(config, true, 2); Zhang99Parameters found = alg.initialParam(observations); checkIntrinsicOnly(initial, found, 0.01, 0.1); } ",
        "focal_tgt": "protected Zhang99ParamAll initialParam(List < List < Point2D_F64 > > observations) { status(\"Estimating Homographies\"); List < DenseMatrix64F > homographies = new ArrayList < DenseMatrix64F > (); List < Se3_F64 > motions = new ArrayList < Se3_F64 > (); for(List < Point2D_F64 > obs : observations) { if( ! computeHomography.computeHomography(obs))return null; DenseMatrix64F H = computeHomography.getHomography(); homographies.add(H); } status(\"Estimating Calibration Matrix\"); computeK.process(homographies); DenseMatrix64F K = computeK.getCalibrationMatrix(); decomposeH.setCalibrationMatrix(K); for(DenseMatrix64F H : homographies) { motions.add(decomposeH.decompose(H)); } status(\"Estimating Radial Distortion\"); computeRadial.process(K, homographies, observations); double distort[] = computeRadial.getParameters(); return convertIntoZhangParam(motions, K, optimized.assumeZeroSkew, distort, optimized.includeTangential); } ",
        "focal_src": "protected Zhang99Parameters initialParam(List < List < Point2D_F64 > > observations) { status(\"Estimating Homographies\"); List < DenseMatrix64F > homographies = new ArrayList < DenseMatrix64F > (); List < Se3_F64 > motions = new ArrayList < Se3_F64 > (); for(List < Point2D_F64 > obs : observations) { if( ! computeHomography.computeHomography(obs))return null; DenseMatrix64F H = computeHomography.getHomography(); homographies.add(H); } status(\"Estimating Calibration Matrix\"); computeK.process(homographies); DenseMatrix64F K = computeK.getCalibrationMatrix(); decomposeH.setCalibrationMatrix(K); for(DenseMatrix64F H : homographies) { motions.add(decomposeH.decompose(H)); } status(\"Estimating Radial Distortion\"); computeRadial.process(K, homographies, observations); double distort[] = computeRadial.getParameters(); return convertIntoZhangParam(motions, K, assumeZeroSkew, distort); } ",
        "test_tgt": "@Test public void initialParam() { PlanarCalibrationTarget config = GenericCalibrationGrid.createStandardConfig(); List < Point2D_F64 > grid = config.points; Zhang99ParamAll initial = GenericCalibrationGrid.createStandardParam(true, 2, false, 3, rand); List < List < Point2D_F64 > > observations = GenericCalibrationGrid.createObservations(initial, grid); Helper alg = new Helper(config, true, 2, false); Zhang99ParamAll found = alg.initialParam(observations); checkIntrinsicOnly(initial, found, 0.01, 0.1, 0.1); } "
    },
    {
        "test_src": "@Test public void testReconcile_withCm_noKafka_withPrivate(TestContext context) { Topic kubeTopic = new Topic.Builder(topicName.toString(), 10, (short)2, map(\"cleanup.policy\", \"bar\")).build(); Topic kafkaTopic = null; Topic privateTopic = kubeTopic; Async async0 = context.async(2); mockK8s.setCreateResponse(mapName, null).createConfigMap(TopicSerialization.toConfigMap(kubeTopic, cmPredicate), ar -> async0.countDown()); mockK8s.setDeleteResponse(topicName, null); mockTopicStore.setCreateTopicResponse(topicName, null).create(privateTopic, ar -> async0.countDown()); mockTopicStore.setDeleteTopicResponse(topicName, null); Async async = context.async(); controller.reconcile(null, kubeTopic, kafkaTopic, privateTopic, reconcileResult -> { assertSucceeded(context, reconcileResult); mockKafka.assertNotExists(context, kubeTopic.getTopicName()); mockTopicStore.assertNotExists(context, kubeTopic.getTopicName()); mockK8s.assertNotExists(context, kubeTopic.getMapName()); mockK8s.assertNoEvents(context); async.complete(); }); } ",
        "focal_tgt": "void reconcile(final HasMetadata involvedObject, final Topic k8sTopic, final Topic kafkaTopic, final Topic privateTopic, final Handler < AsyncResult < Void > > reconciliationResultHandler) { { TopicName topicName = k8sTopic != null ? k8sTopic.getTopicName() : kafkaTopic != null ? kafkaTopic.getTopicName() : privateTopic != null ? privateTopic.getTopicName() : null; logger.info(\"Reconciling topic {}, k8sTopic:{}, kafkaTopic:{}, privateTopic:{}\", topicName, k8sTopic == null ? \"null\" : \"nonnull\", kafkaTopic == null ? \"null\" : \"nonnull\", privateTopic == null ? \"null\" : \"nonnull\"); } if(privateTopic == null) { if(k8sTopic == null) { if(kafkaTopic == null) { logger.debug(\"All three topics null during reconciliation.\"); reconciliationResultHandler.handle(Future.succeededFuture()); } else { logger.debug(\"topic created in kafka, will create cm in k8s and topicStore\"); enqueue(new CreateConfigMap(kafkaTopic, ar -> { if(ar.succeeded()) { enqueue(new CreateInTopicStore(kafkaTopic, involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } } else if(kafkaTopic == null) { logger.debug(\"cm created in k8s, will create topic in kafka and topicStore\"); enqueue(new CreateKafkaTopic(k8sTopic, involvedObject, ar -> { if(ar.succeeded()) { enqueue(new CreateInTopicStore(k8sTopic, involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } else { update2Way(involvedObject, k8sTopic, kafkaTopic, reconciliationResultHandler); } } else { if(k8sTopic == null) { if(kafkaTopic == null) { logger.debug(\"cm deleted in k8s and topic deleted in kafka => delete from topicStore\"); enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); reconciliationResultHandler.handle(Future.succeededFuture()); } else { logger.debug(\"cm deleted in k8s => delete topic from kafka and from topicStore\"); enqueue(new DeleteKafkaTopic(kafkaTopic.getTopicName(), involvedObject, ar -> { if(ar.succeeded()) { enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } } else if(kafkaTopic == null) { logger.debug(\"topic deleted in kafkas => delete cm from k8s and from topicStore\"); enqueue(new DeleteConfigMap(privateTopic.getOrAsMapName(), ar -> { if(ar.succeeded()) { enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } else { logger.debug(\"3 way diff\"); update3Way(involvedObject, k8sTopic, kafkaTopic, privateTopic, reconciliationResultHandler); } } } ",
        "focal_src": "void reconcile(final HasMetadata involvedObject, final Topic k8sTopic, final Topic kafkaTopic, final Topic privateTopic, final Handler < AsyncResult < Void > > reconciliationResultHandler) { { TopicName topicName = k8sTopic != null ? k8sTopic.getTopicName() : kafkaTopic != null ? kafkaTopic.getTopicName() : privateTopic != null ? privateTopic.getTopicName() : null; logger.info(\"Reconciling topic {}, k8sTopic:{}, kafkaTopic:{}, privateTopic:{}\", topicName, k8sTopic == null ? \"null\" : \"nonnull\", kafkaTopic == null ? \"null\" : \"nonnull\", privateTopic == null ? \"null\" : \"nonnull\"); } if(privateTopic == null) { if(k8sTopic == null) { if(kafkaTopic == null) { logger.debug(\"All three topics null during reconciliation.\"); reconciliationResultHandler.handle(Future.succeededFuture()); } else { logger.debug(\"topic created in kafka, will create cm in k8s and topicStore\"); enqueue(new CreateConfigMap(kafkaTopic, ar -> { if(ar.succeeded()) { enqueue(new CreateInTopicStore(kafkaTopic, involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } } else if(kafkaTopic == null) { logger.debug(\"cm created in k8s, will create topic in kafka and topicStore\"); enqueue(new CreateKafkaTopic(k8sTopic, involvedObject, ar -> { if(ar.succeeded()) { enqueue(new CreateInTopicStore(k8sTopic, involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } else { update2Way(involvedObject, k8sTopic, kafkaTopic, reconciliationResultHandler); } } else { if(k8sTopic == null) { if(kafkaTopic == null) { logger.debug(\"cm deleted in k8s and topic deleted in kafka => delete from topicStore\"); enqueue(new DeleteFromTopicStore(privateTopic.getTopicName(), involvedObject, reconciliationResultHandler)); reconciliationResultHandler.handle(Future.succeededFuture()); } else { logger.debug(\"cm deleted in k8s => delete topic from kafka and from topicStore\"); enqueue(new DeleteKafkaTopic(kafkaTopic.getTopicName(), involvedObject, ar -> { if(ar.succeeded()) { enqueue(new DeleteFromTopicStore(kafkaTopic.getTopicName(), involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } } else if(kafkaTopic == null) { logger.debug(\"topic deleted in kafkas => delete cm from k8s and from topicStore\"); enqueue(new DeleteConfigMap(k8sTopic.getTopicName(), ar -> { if(ar.succeeded()) { enqueue(new DeleteFromTopicStore(k8sTopic.getTopicName(), involvedObject, reconciliationResultHandler)); } else { reconciliationResultHandler.handle(ar); } })); } else { logger.debug(\"3 way diff\"); update3Way(involvedObject, k8sTopic, kafkaTopic, privateTopic, reconciliationResultHandler); } } } ",
        "test_tgt": "@Test public void testReconcile_withCm_noKafka_withPrivate(TestContext context) { Topic kubeTopic = new Topic.Builder(topicName.toString(), 10, (short)2, map(\"cleanup.policy\", \"bar\")).build(); Topic kafkaTopic = null; Topic privateTopic = kubeTopic; Async async0 = context.async(2); mockK8s.setCreateResponse(mapName, null).createConfigMap(TopicSerialization.toConfigMap(kubeTopic, cmPredicate), ar -> async0.countDown()); mockK8s.setDeleteResponse(mapName, null); mockTopicStore.setCreateTopicResponse(topicName, null).create(privateTopic, ar -> async0.countDown()); mockTopicStore.setDeleteTopicResponse(topicName, null); Async async = context.async(); controller.reconcile(null, kubeTopic, kafkaTopic, privateTopic, reconcileResult -> { assertSucceeded(context, reconcileResult); mockKafka.assertNotExists(context, kubeTopic.getTopicName()); mockTopicStore.assertNotExists(context, kubeTopic.getTopicName()); mockK8s.assertNotExists(context, kubeTopic.getMapName()); mockK8s.assertNoEvents(context); async.complete(); }); } "
    },
    {
        "test_src": "@Test public void listCertificates()throws Exception { String certificateName = \"listCertificate\"; String certificateContent = \"MIIJOwIBAzCCCPcGCSqGSIb3DQEHAaCCCOgEggjkMIII4DCCBgkGCSqGSIb3DQEHAaCCBfoEggX2MIIF8jCCBe4GCyqGSIb3DQEMCgECoIIE/jCCBPowHAYKKoZIhvcNAQwBAzAOBAj15YH9pOE58AICB9AEggTYLrI+SAru2dBZRQRlJY7XQ3LeLkah2FcRR3dATDshZ2h0IA2oBrkQIdsLyAAWZ32qYR1qkWxLHn9AqXgu27AEbOk35+pITZaiy63YYBkkpR+pDdngZt19Z0PWrGwHEq5z6BHS2GLyyN8SSOCbdzCz7blj3+7IZYoMj4WOPgOm/tQ6U44SFWek46QwN2zeA4i97v7ftNNns27ms52jqfhOvTA9c/wyfZKAY4aKJfYYUmycKjnnRl012ldS2lOkASFt+lu4QCa72IY6ePtRudPCvmzRv2pkLYS6z3cI7omT8nHP3DymNOqLbFqr5O2M1ZYaLC63Q3xt3eVvbcPh3N08D1hHkhz/KDTvkRAQpvrW8ISKmgDdmzN55Pe55xHfSWGB7gPw8sZea57IxFzWHTK2yvTslooWoosmGxanYY2IG/no3EbPOWDKjPZ4ilYJe5JJ2immlxPz+2e2EOCKpDI+7fzQcRz3PTd3BK+budZ8aXX8aW/lOgKS8WmxZoKnOJBNWeTNWQFugmktXfdPHAdxMhjUXqeGQd8wTvZ4EzQNNafovwkI7IV/ZYoa++RGofVR3ZbRSiBNF6TDj/qXFt0wN/CQnsGAmQAGNiN+D4mY7i25dtTu/Jc7OxLdhAUFpHyJpyrYWLfvOiS5WYBeEDHkiPUa/8eZSPA3MXWZR1RiuDvuNqMjct1SSwdXADTtF68l/US1ksU657+XSC+6ly1A/upz+X71+C4Ho6W0751j5ZMT6xKjGh5pee7MVuduxIzXjWIy3YSd0fIT3U0A5NLEvJ9rfkx6JiHjRLx6V1tqsrtT6BsGtmCQR1UCJPLqsKVDvAINx3cPA/CGqr5OX2BGZlAihGmN6n7gv8w4O0k0LPTAe5YefgXN3m9pE867N31GtHVZaJ/UVgDNYS2jused4rw76ZWN41akx2QN0JSeMJqHXqVz6AKfz8ICS/dFnEGyBNpXiMRxrY/QPKi/wONwqsbDxRW7vZRVKs78pBkE0ksaShlZk5GkeayDWC/7Hi/NqUFtIloK9XB3paLxo1DGu5qqaF34jZdktzkXp0uZqpp+FfKZaiovMjt8F7yHCPk+LYpRsU2Cyc9DVoDA6rIgf+uEP4jppgehsxyT0lJHax2t869R2jYdsXwYUXjgwHIV0voj7bJYPGFlFjXOp6ZW86scsHM5xfsGQoK2Fp838VT34SHE1ZXU/puM7rviREHYW72pfpgGZUILQMohuTPnd8tFtAkbrmjLDo+k9xx7HUvgoFTiNNWuq/cRjr70FKNguMMTIrid+HwfmbRoaxENWdLcOTNeascER2a+37UQolKD5ksrPJG6RdNA7O2pzp3micDYRs/+s28cCIxO//J/d4nsgHp6RTuCu4+Jm9k0YTw2Xg75b2cWKrxGnDUgyIlvNPaZTB5QbMid4x44/lE0LLi9kcPQhRgrK07OnnrMgZvVGjt1CLGhKUv7KFc3xV1r1rwKkosxnoG99oCoTQtregcX5rIMjHgkc1IdflGJkZzaWMkYVFOJ4Weynz008i4ddkske5vabZs37Lb8iggUYNBYZyGzalruBgnQyK4fz38Fae4nWYjyildVfgyo/fCePR2ovOfphx9OQJi+M9BoFmPrAg+8ARDZ+R+5yzYuEc9ZoVX7nkp7LTGB3DANBgkrBgEEAYI3EQIxADATBgkqhkiG9w0BCRUxBgQEAQAAADBXBgkqhkiG9w0BCRQxSh5IAGEAOAAwAGQAZgBmADgANgAtAGUAOQA2AGUALQA0ADIAMgA0AC0AYQBhADEAMQAtAGIAZAAxADkANABkADUAYQA2AGIANwA3MF0GCSsGAQQBgjcRATFQHk4ATQBpAGMAcgBvAHMAbwBmAHQAIABTAHQAcgBvAG4AZwAgAEMAcgB5AHAAdABvAGcAcgBhAHAAaABpAGMAIABQAHIAbwB2AGkAZABlAHIwggLPBgkqhkiG9w0BBwagggLAMIICvAIBADCCArUGCSqGSIb3DQEHATAcBgoqhkiG9w0BDAEGMA4ECNX+VL2MxzzWAgIH0ICCAojmRBO+CPfVNUO0s+BVuwhOzikAGNBmQHNChmJ/pyzPbMUbx7tO63eIVSc67iERda2WCEmVwPigaVQkPaumsfp8+L6iV/BMf5RKlyRXcwh0vUdu2Qa7qadD+gFQ2kngf4Dk6vYo2/2HxayuIf6jpwe8vql4ca3ZtWXfuRix2fwgltM0bMz1g59d7x/glTfNqxNlsty0A/rWrPJjNbOPRU2XykLuc3AtlTtYsQ32Zsmu67A7UNBw6tVtkEXlFDqhavEhUEO3dvYqMY+QLxzpZhA0q44ZZ9/ex0X6QAFNK5wuWxCbupHWsgxRwKftrxyszMHsAvNoNcTlqcctee+ecNwTJQa1/MDbnhO6/qHA7cfG1qYDq8Th635vGNMW1w3sVS7l0uEvdayAsBHWTcOC2tlMa5bfHrhY8OEIqj5bN5H9RdFy8G/W239tjDu1OYjBDydiBqzBn8HG1DSj1Pjc0kd/82d4ZU0308KFTC3yGcRad0GnEH0Oi3iEJ9HbriUbfVMbXNHOF+MktWiDVqzndGMKmuJSdfTBKvGFvejAWVO5E4mgLvoaMmbchc3BO7sLeraHnJN5hvMBaLcQI38N86mUfTR8AP6AJ9c2k514KaDLclm4z6J8dMz60nUeo5D3YD09G6BavFHxSvJ8MF0Lu5zOFzEePDRFm9mH8W0N/sFlIaYfD/GWU/w44mQucjaBk95YtqOGRIj58tGDWr8iUdHwaYKGqU24zGeRae9DhFXPzZshV1ZGsBQFRaoYkyLAwdJWIXTi+c37YaC8FRSEnnNmS79Dou1Kc3BvK4EYKAD2KxjtUebrV174gD0Q+9YuJ0GXOTspBvCFd5VT2Rw5zDNrA/J3F5fMCk4wOzAfMAcGBSsOAwIaBBSxgh2xyF+88V4vAffBmZXv8Txt4AQU4O/NX4MjxSodbE7ApNAMIvrtREwCAgfQ\"; String certificatePassword = \"123\"; SecretProperties secretProperties = new SecretProperties(); secretProperties.withContentType(MIME_PKCS12); CertificatePolicy certificatePolicy = new CertificatePolicy(); certificatePolicy.withSecretProperties(secretProperties); HashSet < String > certificates = new HashSet < String > (); for(int i = 0; i < MAX_CERTS; ++ i) { int failureCount = 0; for(; ; ) { try { CertificateBundle certificateBundle = keyVaultClient.importCertificate(new ImportCertificateRequest.Builder(getVaultUri(), certificateName + i, certificateContent).withPassword(certificatePassword).withPolicy(certificatePolicy).build()); CertificateIdentifier id = certificateBundle.certificateIdentifier(); certificates.add(id.baseIdentifier()); break; } catch(KeyVaultErrorException e) { ++ failureCount; if(e.getBody().error().code().equals(\"Throttled\")) { System.out.println(\"Waiting to avoid throttling\"); Thread.sleep(failureCount * 1500); continue; } throw e; } } } PagedList < CertificateItem > listResult = keyVaultClient.listCertificates(getVaultUri(), PAGELIST_MAX_CERTS); Assert.assertTrue(PAGELIST_MAX_CERTS >= listResult.currentPage().getItems().size()); HashSet < String > toDelete = new HashSet < String > (); for(CertificateItem item : listResult) { if(item != null) { CertificateIdentifier id = new CertificateIdentifier(item.id()); toDelete.add(id.name()); certificates.remove(item.id()); } } Assert.assertEquals(0, certificates.size()); for(String toDeleteCertificateName : toDelete) { keyVaultClient.deleteCertificate(getVaultUri(), toDeleteCertificateName); } } ",
        "focal_tgt": "public PagedList < CertificateItem > listCertificates(final String vaultBaseUrl) { return innerKeyVaultClient.getCertificates(vaultBaseUrl); } ",
        "focal_src": "public PagedList < CertificateItem > listCertificates(final String vaultBaseUrl)throws KeyVaultErrorException, IOException, IllegalArgumentException { return innerKeyVaultClient.getCertificates(vaultBaseUrl); } ",
        "test_tgt": "@Test public void listCertificates()throws Exception { String certificateName = \"listCertificate\"; String certificateContent = \"MIIJOwIBAzCCCPcGCSqGSIb3DQEHAaCCCOgEggjkMIII4DCCBgkGCSqGSIb3DQEHAaCCBfoEggX2MIIF8jCCBe4GCyqGSIb3DQEMCgECoIIE/jCCBPowHAYKKoZIhvcNAQwBAzAOBAj15YH9pOE58AICB9AEggTYLrI+SAru2dBZRQRlJY7XQ3LeLkah2FcRR3dATDshZ2h0IA2oBrkQIdsLyAAWZ32qYR1qkWxLHn9AqXgu27AEbOk35+pITZaiy63YYBkkpR+pDdngZt19Z0PWrGwHEq5z6BHS2GLyyN8SSOCbdzCz7blj3+7IZYoMj4WOPgOm/tQ6U44SFWek46QwN2zeA4i97v7ftNNns27ms52jqfhOvTA9c/wyfZKAY4aKJfYYUmycKjnnRl012ldS2lOkASFt+lu4QCa72IY6ePtRudPCvmzRv2pkLYS6z3cI7omT8nHP3DymNOqLbFqr5O2M1ZYaLC63Q3xt3eVvbcPh3N08D1hHkhz/KDTvkRAQpvrW8ISKmgDdmzN55Pe55xHfSWGB7gPw8sZea57IxFzWHTK2yvTslooWoosmGxanYY2IG/no3EbPOWDKjPZ4ilYJe5JJ2immlxPz+2e2EOCKpDI+7fzQcRz3PTd3BK+budZ8aXX8aW/lOgKS8WmxZoKnOJBNWeTNWQFugmktXfdPHAdxMhjUXqeGQd8wTvZ4EzQNNafovwkI7IV/ZYoa++RGofVR3ZbRSiBNF6TDj/qXFt0wN/CQnsGAmQAGNiN+D4mY7i25dtTu/Jc7OxLdhAUFpHyJpyrYWLfvOiS5WYBeEDHkiPUa/8eZSPA3MXWZR1RiuDvuNqMjct1SSwdXADTtF68l/US1ksU657+XSC+6ly1A/upz+X71+C4Ho6W0751j5ZMT6xKjGh5pee7MVuduxIzXjWIy3YSd0fIT3U0A5NLEvJ9rfkx6JiHjRLx6V1tqsrtT6BsGtmCQR1UCJPLqsKVDvAINx3cPA/CGqr5OX2BGZlAihGmN6n7gv8w4O0k0LPTAe5YefgXN3m9pE867N31GtHVZaJ/UVgDNYS2jused4rw76ZWN41akx2QN0JSeMJqHXqVz6AKfz8ICS/dFnEGyBNpXiMRxrY/QPKi/wONwqsbDxRW7vZRVKs78pBkE0ksaShlZk5GkeayDWC/7Hi/NqUFtIloK9XB3paLxo1DGu5qqaF34jZdktzkXp0uZqpp+FfKZaiovMjt8F7yHCPk+LYpRsU2Cyc9DVoDA6rIgf+uEP4jppgehsxyT0lJHax2t869R2jYdsXwYUXjgwHIV0voj7bJYPGFlFjXOp6ZW86scsHM5xfsGQoK2Fp838VT34SHE1ZXU/puM7rviREHYW72pfpgGZUILQMohuTPnd8tFtAkbrmjLDo+k9xx7HUvgoFTiNNWuq/cRjr70FKNguMMTIrid+HwfmbRoaxENWdLcOTNeascER2a+37UQolKD5ksrPJG6RdNA7O2pzp3micDYRs/+s28cCIxO//J/d4nsgHp6RTuCu4+Jm9k0YTw2Xg75b2cWKrxGnDUgyIlvNPaZTB5QbMid4x44/lE0LLi9kcPQhRgrK07OnnrMgZvVGjt1CLGhKUv7KFc3xV1r1rwKkosxnoG99oCoTQtregcX5rIMjHgkc1IdflGJkZzaWMkYVFOJ4Weynz008i4ddkske5vabZs37Lb8iggUYNBYZyGzalruBgnQyK4fz38Fae4nWYjyildVfgyo/fCePR2ovOfphx9OQJi+M9BoFmPrAg+8ARDZ+R+5yzYuEc9ZoVX7nkp7LTGB3DANBgkrBgEEAYI3EQIxADATBgkqhkiG9w0BCRUxBgQEAQAAADBXBgkqhkiG9w0BCRQxSh5IAGEAOAAwAGQAZgBmADgANgAtAGUAOQA2AGUALQA0ADIAMgA0AC0AYQBhADEAMQAtAGIAZAAxADkANABkADUAYQA2AGIANwA3MF0GCSsGAQQBgjcRATFQHk4ATQBpAGMAcgBvAHMAbwBmAHQAIABTAHQAcgBvAG4AZwAgAEMAcgB5AHAAdABvAGcAcgBhAHAAaABpAGMAIABQAHIAbwB2AGkAZABlAHIwggLPBgkqhkiG9w0BBwagggLAMIICvAIBADCCArUGCSqGSIb3DQEHATAcBgoqhkiG9w0BDAEGMA4ECNX+VL2MxzzWAgIH0ICCAojmRBO+CPfVNUO0s+BVuwhOzikAGNBmQHNChmJ/pyzPbMUbx7tO63eIVSc67iERda2WCEmVwPigaVQkPaumsfp8+L6iV/BMf5RKlyRXcwh0vUdu2Qa7qadD+gFQ2kngf4Dk6vYo2/2HxayuIf6jpwe8vql4ca3ZtWXfuRix2fwgltM0bMz1g59d7x/glTfNqxNlsty0A/rWrPJjNbOPRU2XykLuc3AtlTtYsQ32Zsmu67A7UNBw6tVtkEXlFDqhavEhUEO3dvYqMY+QLxzpZhA0q44ZZ9/ex0X6QAFNK5wuWxCbupHWsgxRwKftrxyszMHsAvNoNcTlqcctee+ecNwTJQa1/MDbnhO6/qHA7cfG1qYDq8Th635vGNMW1w3sVS7l0uEvdayAsBHWTcOC2tlMa5bfHrhY8OEIqj5bN5H9RdFy8G/W239tjDu1OYjBDydiBqzBn8HG1DSj1Pjc0kd/82d4ZU0308KFTC3yGcRad0GnEH0Oi3iEJ9HbriUbfVMbXNHOF+MktWiDVqzndGMKmuJSdfTBKvGFvejAWVO5E4mgLvoaMmbchc3BO7sLeraHnJN5hvMBaLcQI38N86mUfTR8AP6AJ9c2k514KaDLclm4z6J8dMz60nUeo5D3YD09G6BavFHxSvJ8MF0Lu5zOFzEePDRFm9mH8W0N/sFlIaYfD/GWU/w44mQucjaBk95YtqOGRIj58tGDWr8iUdHwaYKGqU24zGeRae9DhFXPzZshV1ZGsBQFRaoYkyLAwdJWIXTi+c37YaC8FRSEnnNmS79Dou1Kc3BvK4EYKAD2KxjtUebrV174gD0Q+9YuJ0GXOTspBvCFd5VT2Rw5zDNrA/J3F5fMCk4wOzAfMAcGBSsOAwIaBBSxgh2xyF+88V4vAffBmZXv8Txt4AQU4O/NX4MjxSodbE7ApNAMIvrtREwCAgfQ\"; String certificatePassword = \"123\"; SecretProperties secretProperties = new SecretProperties(); secretProperties.withContentType(MIME_PKCS12); CertificatePolicy certificatePolicy = new CertificatePolicy(); certificatePolicy.withSecretProperties(secretProperties); HashSet < String > certificates = new HashSet < String > (); for(int i = 0; i < MAX_CERTS; ++ i) { int failureCount = 0; for(; ; ) { try { CertificateBundle certificateBundle = keyVaultClient.importCertificate(new ImportCertificateRequest.Builder(getVaultUri(), certificateName + i, certificateContent).withPassword(certificatePassword).withPolicy(certificatePolicy).build()); CertificateIdentifier id = certificateBundle.certificateIdentifier(); certificates.add(id.baseIdentifier()); break; } catch(KeyVaultErrorException e) { ++ failureCount; if(e.body().error().code().equals(\"Throttled\")) { System.out.println(\"Waiting to avoid throttling\"); Thread.sleep(failureCount * 1500); continue; } throw e; } } } PagedList < CertificateItem > listResult = keyVaultClient.listCertificates(getVaultUri(), PAGELIST_MAX_CERTS); Assert.assertTrue(PAGELIST_MAX_CERTS >= listResult.currentPage().items().size()); HashSet < String > toDelete = new HashSet < String > (); for(CertificateItem item : listResult) { if(item != null) { CertificateIdentifier id = new CertificateIdentifier(item.id()); toDelete.add(id.name()); certificates.remove(item.id()); } } Assert.assertEquals(0, certificates.size()); for(String toDeleteCertificateName : toDelete) { keyVaultClient.deleteCertificate(getVaultUri(), toDeleteCertificateName); } } "
    },
    {
        "test_src": "@Test public void testOptimize() { System.out.println(\"optimize\"); Random rand = RandomUtil.getRandom(); Vec x0 = new DenseVector(3); for(int i = 0; i < x0.length(); i ++ )x0.set(i, rand.nextDouble() + 0.5); RosenbrockFunction f = new RosenbrockFunction(); FunctionVec fp = f.getDerivative(); ModifiedOWLQN instance = new ModifiedOWLQN(); instance.setLambda(0.0); instance.setMaximumIterations(500); Vec w = new DenseVector(x0.length()); instance.optimize(1e-8, w, x0, f, fp, null); for(int i = 0; i < w.length(); i ++ )assertEquals(1.0, w.get(i), 1e-2); assertEquals(0.0, f.f(w), 1e-3); } ",
        "focal_tgt": "public Vec optimize(double eps, int iterationLimit, Function f, List < Vec > initalPoints, boolean parallel) { if(initalPoints.isEmpty())throw new ArithmeticException(\"Empty Initial list. Can not determin dimension of problem\"); Vec init = initalPoints.get(0); int N = initalPoints.get(0).length(); List < ProbailityMatch < Vec > > simplex = new ArrayList < > (N); for(Vec vars : initalPoints)simplex.add(new ProbailityMatch < > (f.f(vars, parallel), vars.clone())); Random rand = new Random(initalPoints.hashCode()); while(simplex.size() < N + 1) { DenseVector newSimplex = new DenseVector(N); for(int i = 0; i < newSimplex.length(); i ++ )if(init.get(i) != 0)newSimplex.set(i, init.get(i) * rand.nextGaussian()); else newSimplex.set(i, rand.nextGaussian()); simplex.add(new ProbailityMatch < > (f.f(newSimplex, parallel), newSimplex)); } Collections.sort(simplex); while(simplex.size() > N + 1)simplex.remove(simplex.size() - 1); Vec x0 = new DenseVector(N); Vec xr = new DenseVector(N); Vec xec = new DenseVector(N); Vec tmp = new DenseVector(N); final int lastIndex = simplex.size() - 1; for(int iterationCount = 0; iterationCount < iterationLimit; iterationCount ++ ) { if(Math.abs(simplex.get(lastIndex).getProbability() - simplex.get(0).getProbability()) < eps)break; x0.zeroOut(); for(ProbailityMatch < Vec > pm : simplex)x0.mutableAdd(pm.getMatch()); x0.mutableDivide(simplex.size()); x0.copyTo(xr); x0.copyTo(tmp); tmp.mutableSubtract(simplex.get(lastIndex).getMatch()); xr.mutableAdd(reflection, tmp); double fxr = f.f(xr); if(simplex.get(0).getProbability() <= fxr && fxr < simplex.get(lastIndex - 1).getProbability()) { insertIntoSimplex(simplex, xr, fxr); continue; } if(fxr < simplex.get(0).getProbability()) { x0.copyTo(xec); xec.mutableAdd(expansion, tmp); double fxec = f.f(xec); if(fxec < fxr)insertIntoSimplex(simplex, xec, fxec); else insertIntoSimplex(simplex, xr, fxr); continue; } x0.copyTo(xec); xec.mutableAdd(contraction, tmp); double fxec = f.f(xec); if(fxec < simplex.get(lastIndex).getProbability()) { insertIntoSimplex(simplex, xec, fxec); continue; } Vec xBest = simplex.get(0).getMatch(); for(int i = 1; i < simplex.size(); i ++ ) { ProbailityMatch < Vec > pm = simplex.get(i); Vec xi = pm.getMatch(); xi.mutableSubtract(xBest); xi.mutableMultiply(shrink); xi.mutableAdd(xBest); pm.setProbability(f.f(xi)); } Collections.sort(simplex); } return simplex.get(0).getMatch(); } ",
        "focal_src": "public Vec optimize(double eps, int iterationLimit, Function f, List < Vec > initalPoints) { if(initalPoints.isEmpty())throw new ArithmeticException(\"Empty Initial list. Can not determin dimension of problem\"); Vec init = initalPoints.get(0); int N = initalPoints.get(0).length(); List < ProbailityMatch < Vec > > simplex = new ArrayList < ProbailityMatch < Vec > > (N); for(Vec vars : initalPoints)simplex.add(new ProbailityMatch < Vec > (f.f(vars), vars.clone())); Random rand = new Random(initalPoints.hashCode()); while(simplex.size() < N + 1) { DenseVector newSimplex = new DenseVector(N); for(int i = 0; i < newSimplex.length(); i ++ )if(init.get(i) != 0)newSimplex.set(i, init.get(i) * rand.nextGaussian()); else newSimplex.set(i, rand.nextGaussian()); simplex.add(new ProbailityMatch < Vec > (f.f(newSimplex), newSimplex)); } Collections.sort(simplex); while(simplex.size() > N + 1)simplex.remove(simplex.size() - 1); Vec x0 = new DenseVector(N); Vec xr = new DenseVector(N); Vec xec = new DenseVector(N); Vec tmp = new DenseVector(N); final int lastIndex = simplex.size() - 1; for(int iterationCount = 0; iterationCount < iterationLimit; iterationCount ++ ) { if(Math.abs(simplex.get(lastIndex).getProbability() - simplex.get(0).getProbability()) < eps)break; x0.zeroOut(); for(ProbailityMatch < Vec > pm : simplex)x0.mutableAdd(pm.getMatch()); x0.mutableDivide(simplex.size()); x0.copyTo(xr); x0.copyTo(tmp); tmp.mutableSubtract(simplex.get(lastIndex).getMatch()); xr.mutableAdd(reflection, tmp); double fxr = f.f(xr); if(simplex.get(0).getProbability() <= fxr && fxr < simplex.get(lastIndex - 1).getProbability()) { insertIntoSimplex(simplex, xr, fxr); continue; } if(fxr < simplex.get(0).getProbability()) { x0.copyTo(xec); xec.mutableAdd(expansion, tmp); double fxec = f.f(xec); if(fxec < fxr)insertIntoSimplex(simplex, xec, fxec); else insertIntoSimplex(simplex, xr, fxr); continue; } x0.copyTo(xec); xec.mutableAdd(contraction, tmp); double fxec = f.f(xec); if(fxec < simplex.get(lastIndex).getProbability()) { insertIntoSimplex(simplex, xec, fxec); continue; } Vec xBest = simplex.get(0).getMatch(); for(int i = 1; i < simplex.size(); i ++ ) { ProbailityMatch < Vec > pm = simplex.get(i); Vec xi = pm.getMatch(); xi.mutableSubtract(xBest); xi.mutableMultiply(shrink); xi.mutableAdd(xBest); pm.setProbability(f.f(xi)); } Collections.sort(simplex); } return simplex.get(0).getMatch(); } ",
        "test_tgt": "@Test public void testOptimize() { System.out.println(\"optimize\"); Random rand = RandomUtil.getRandom(); Vec x0 = new DenseVector(3); for(int i = 0; i < x0.length(); i ++ )x0.set(i, rand.nextDouble() + 0.5); RosenbrockFunction f = new RosenbrockFunction(); FunctionVec fp = f.getDerivative(); ModifiedOWLQN instance = new ModifiedOWLQN(); instance.setLambda(0.0); instance.setMaximumIterations(500); Vec w = new DenseVector(x0.length()); instance.optimize(1e-8, w, x0, f, fp); for(int i = 0; i < w.length(); i ++ )assertEquals(1.0, w.get(i), 1e-2); assertEquals(0.0, f.f(w), 1e-3); } "
    },
    {
        "test_src": "@Test public void testCall()throws Exception { NvdCveInfo cve = new NvdCveInfo(); cve.setId(\"modified\"); cve.setNeedsUpdate(true); cve.setUrl(getSettings().getString(Settings.KEYS.CVE_MODIFIED_20_URL)); cve.setOldSchemaVersionUrl(getSettings().getString(Settings.KEYS.CVE_MODIFIED_12_URL)); ExecutorService processExecutor = null; CveDB cveDB = null; DownloadTask instance = new DownloadTask(cve, processExecutor, cveDB, getSettings()); Future < ProcessTask > result = instance.call(); assertNull(result); } ",
        "focal_tgt": "@Override public Void call() { if(shouldAnalyze()) { LOGGER.debug(\"Begin Analysis of '{}' ({})\", dependency.getActualFilePath(), analyzer.getName()); try { analyzer.analyze(dependency, engine); } catch(AnalysisException ex) { LOGGER.warn(\"An error occurred while analyzing '{}' ({}).\", dependency.getActualFilePath(), analyzer.getName()); LOGGER.debug(\"\", ex); exceptions.add(ex); } catch(Throwable ex) { LOGGER.warn(\"An unexpected error occurred during analysis of '{}' ({}): {}\", dependency.getActualFilePath(), analyzer.getName(), ex.getMessage()); LOGGER.error(\"\", ex); exceptions.add(ex); } } return null; } ",
        "focal_src": "@Override public Void call() { if(shouldAnalyze()) { LOGGER.debug(\"Begin Analysis of '{}' ({})\", dependency.getActualFilePath(), analyzer.getName()); try { analyzer.analyze(dependency, engine); } catch(AnalysisException ex) { LOGGER.warn(\"An error occurred while analyzing '{}' ({}).\", dependency.getActualFilePath(), analyzer.getName()); LOGGER.debug(\"\", ex); exceptions.add(ex); } catch(Throwable ex) { LOGGER.warn(\"An unexpected error occurred during analysis of '{}' ({}): {}\", dependency.getActualFilePath(), analyzer.getName(), ex.getMessage()); LOGGER.debug(\"\", ex); exceptions.add(ex); } } return null; } ",
        "test_tgt": "@Test public void testCall()throws Exception { NvdCveInfo cve = new NvdCveInfo(); cve.setId(\"modified\"); cve.setNeedsUpdate(true); cve.setUrl(getSettings().getString(Settings.KEYS.CVE_MODIFIED_JSON)); ExecutorService processExecutor = null; CveDB cveDB = null; DownloadTask instance = new DownloadTask(cve, processExecutor, cveDB, getSettings()); Future < ProcessTask > result = instance.call(); assertNull(result); } "
    },
    {
        "test_src": "@Test public void testIsApplicable()throws Exception { final Cluster cluster = Mockito.mock(Cluster.class); Mockito.when(cluster.getClusterId()).thenReturn(1L); Mockito.when(m_clusters.getCluster(\"cluster\")).thenReturn(cluster); Mockito.when(cluster.getCurrentStackVersion()).thenReturn(new StackId(\"HDP-2.3\")); Map < String, Service > services = new HashMap < > (); Mockito.when(cluster.getServices()).thenReturn(services); ClusterVersionEntity clusterVersionEntity = Mockito.mock(ClusterVersionEntity.class); Mockito.when(cluster.getCurrentClusterVersion()).thenReturn(clusterVersionEntity); PrereqCheckRequest request = new PrereqCheckRequest(\"cluster\"); request.setTargetStackId(new StackId(\"HDP\", \"2.3.1.1\")); request.setSourceStackId(new StackId(\"HDP\", \"2.3.0.0\")); Assert.assertFalse(m_check.isApplicable(request)); services.put(\"MAPREDUCE2\", Mockito.mock(Service.class)); Assert.assertTrue(m_check.isApplicable(request)); } ",
        "focal_tgt": "@Override public boolean isApplicable(PrereqCheckRequest request)throws AmbariException { if( ! super.isApplicable(request, Arrays.asList(\"YARN\"), true)) { return false; } final Cluster cluster = clustersProvider.get().getCluster(request.getClusterName()); String minApplicableStackVersion = null; PrerequisiteCheckConfig prerequisiteCheckConfig = request.getPrerequisiteCheckConfig(); Map < String, String > checkProperties = null; if(prerequisiteCheckConfig != null) { checkProperties = prerequisiteCheckConfig.getCheckProperties(this.getClass().getName()); } if(checkProperties != null && checkProperties.containsKey(MIN_APPLICABLE_STACK_VERSION_PROPERTY_NAME)) { minApplicableStackVersion = checkProperties.get(MIN_APPLICABLE_STACK_VERSION_PROPERTY_NAME); } if(minApplicableStackVersion != null && ! minApplicableStackVersion.isEmpty()) { String[]minStack = minApplicableStackVersion.split(\"-\"); if(minStack.length == 2) { String minStackName = minStack[0]; String minStackVersion = minStack[1]; String stackName = cluster.getCurrentStackVersion().getStackName(); if(minStackName.equals(stackName)) { Service yarnService = cluster.getService(\"YARN\"); String currentRepositoryVersion = yarnService.getDesiredRepositoryVersion().getVersion(); return VersionUtils.compareVersions(currentRepositoryVersion, minStackVersion) >= 0; } } } return true; } ",
        "focal_src": "@Override public boolean isApplicable(PrereqCheckRequest request)throws AmbariException { if( ! super.isApplicable(request, Arrays.asList(\"YARN\"), true)) { return false; } final Cluster cluster = clustersProvider.get().getCluster(request.getClusterName()); String minApplicableStackVersion = null; PrerequisiteCheckConfig prerequisiteCheckConfig = request.getPrerequisiteCheckConfig(); Map < String, String > checkProperties = null; if(prerequisiteCheckConfig != null) { checkProperties = prerequisiteCheckConfig.getCheckProperties(this.getClass().getName()); } if(checkProperties != null && checkProperties.containsKey(MIN_APPLICABLE_STACK_VERSION_PROPERTY_NAME)) { minApplicableStackVersion = checkProperties.get(MIN_APPLICABLE_STACK_VERSION_PROPERTY_NAME); } if(minApplicableStackVersion != null && ! minApplicableStackVersion.isEmpty()) { String[]minStack = minApplicableStackVersion.split(\"-\"); if(minStack.length == 2) { String minStackName = minStack[0]; String minStackVersion = minStack[1]; String stackName = cluster.getCurrentStackVersion().getStackName(); if(minStackName.equals(stackName)) { String currentClusterRepositoryVersion = cluster.getCurrentClusterVersion().getRepositoryVersion().getVersion(); return VersionUtils.compareVersions(currentClusterRepositoryVersion, minStackVersion) >= 0; } } } return true; } ",
        "test_tgt": "@Test public void testIsApplicable()throws Exception { final Cluster cluster = Mockito.mock(Cluster.class); Mockito.when(cluster.getClusterId()).thenReturn(1L); Mockito.when(m_clusters.getCluster(\"cluster\")).thenReturn(cluster); Mockito.when(cluster.getCurrentStackVersion()).thenReturn(new StackId(\"HDP-2.3\")); Map < String, Service > services = new HashMap < > (); Mockito.when(cluster.getServices()).thenReturn(services); PrereqCheckRequest request = new PrereqCheckRequest(\"cluster\"); request.setTargetStackId(new StackId(\"HDP\", \"2.3.1.1\")); request.setSourceStackId(new StackId(\"HDP\", \"2.3.0.0\")); Assert.assertFalse(m_check.isApplicable(request)); services.put(\"MAPREDUCE2\", Mockito.mock(Service.class)); Assert.assertTrue(m_check.isApplicable(request)); } "
    },
    {
        "test_src": "@Test public void computeClusterDistance() { fail(\"implement\"); } ",
        "focal_tgt": "protected void computeClusterDistance() { for(int i = 0; i < pixels.size; i ++ ) { pixels.data[i].reset(); } for(int i = 0; i < clusters.size; i ++ ) { Cluster c = clusters.data[i]; int centerX = (int)(c.x + 0.5f); int centerY = (int)(c.y + 0.5f); int x0 = centerX - gridInterval; int x1 = centerX + gridInterval + 1; int y0 = centerY - gridInterval; int y1 = centerY + gridInterval + 1; if(x0 < 0)x0 = 0; if(y0 < 0)y0 = 0; if(x1 > input.width)x1 = input.width; if(y1 > input.height)y1 = input.height; for(int y = y0; y < y1; y ++ ) { int indexPixel = y * input.width + x0; int indexInput = input.startIndex + y * input.stride + x0; int dy = y - centerY; for(int x = x0; x < x1; x ++ ) { int dx = x - centerX; float distanceColor = colorDistance(c.color, indexInput ++ ); float distanceSpacial = dx * dx + dy * dy; pixels.data[indexPixel ++ ].add(c, distanceColor + adjustSpacial * distanceSpacial); } } clusters.data[i].reset(); } } ",
        "focal_src": "protected void computeClusterDistance() { for(int i = 0; i < pixels.size; i ++ ) { pixels.data[i].reset(); } for(int i = 0; i < clusters.size; i ++ ) { Cluster c = clusters.data[i]; int centerX = (int)(c.x + 0.5f); int centerY = (int)(c.y + 0.5f); int x0 = centerX - gridInterval; int x1 = centerX + gridInterval + 1; int y0 = centerY - gridInterval; int y1 = centerY + gridInterval + 1; if(x0 < 0)x0 = 0; if(y0 < 0)y0 = 0; if(x1 > input.width)x1 = input.width; if(y1 > input.height)y1 = input.height; for(int y = y0; y < y1; y ++ ) { int indexPixel = y * input.width + x0; int indexInput = input.startIndex + y * input.stride + x0; int dy = y - centerY; for(int x = x0; x < x1; x ++ , indexPixel ++ ) { int dx = x - centerX; float distanceColor = colorDistance(c.color, indexInput ++ ); float distanceSpacial = dx * dx + dy * dy; pixels.data[indexPixel ++ ].add(c, distanceColor + adjustSpacial * distanceSpacial); } } clusters.data[i].reset(); } } ",
        "test_tgt": "@Test public void computeClusterDistance() { DummySlic alg = new DummySlic(4, 1, 10, 1); ImageUInt8 input = new ImageUInt8(7, 9); alg.initalize(input); SegmentSlic.Cluster c0 = alg.clusters.grow(); SegmentSlic.Cluster c1 = alg.clusters.grow(); SegmentSlic.Cluster c2 = alg.clusters.grow(); SegmentSlic.Cluster c3 = alg.clusters.grow(); c0.x = 0; c0.y = 0; c1.x = 6; c1.y = 0; c2.x = 6; c2.y = 8; c3.x = 0; c3.y = 8; alg.gridInterval = 2; alg.computeClusterDistance(); checkPixelContains(0, 2, 0, 2, c0, alg); checkPixelContains(5, 7, 0, 2, c1, alg); checkPixelContains(5, 7, 7, 9, c2, alg); checkPixelContains(0, 2, 7, 9, c3, alg); } "
    },
    {
        "test_src": "@Test public void toThriftTest()throws IOException { CreateUfsFileOptions options = CreateUfsFileOptions.defaults(); String owner = \"test-owner\"; String group = \"test-group\"; short mode = Constants.DEFAULT_FILE_SYSTEM_MODE; options.setOwner(owner); options.setGroup(group); options.setMode(mode); CreateUfsFileTOptions thriftOptions = options.toThrift(); Assert.assertEquals(owner, thriftOptions.getOwner()); Assert.assertEquals(group, thriftOptions.getGroup()); Assert.assertEquals(mode, thriftOptions.getMode()); } ",
        "focal_tgt": "public CompleteUfsFileTOptions toThrift() { CompleteUfsFileTOptions options = new CompleteUfsFileTOptions(); if( ! mPermission.getOwner().isEmpty()) { options.setOwner(mPermission.getOwner()); } if( ! mPermission.getGroup().isEmpty()) { options.setGroup(mPermission.getGroup()); } short mode = mPermission.getMode().toShort(); if(mode != Constants.INVALID_MODE) { options.setMode(mode); } return options; } ",
        "focal_src": "public CompleteUfsFileTOptions toThrift() { CompleteUfsFileTOptions options = new CompleteUfsFileTOptions(); if(hasGroup()) { options.setGroup(mGroup); } if(hasOwner()) { options.setOwner(mOwner); } if(hasMode()) { options.setMode(mMode); } return options; } ",
        "test_tgt": "@Test public void toThriftTest()throws IOException { CreateUfsFileOptions options = CreateUfsFileOptions.defaults(); String owner = \"test-owner\"; String group = \"test-group\"; short mode = Constants.DEFAULT_FILE_SYSTEM_MODE; options.setPermission(new Permission(owner, group, mode)); CreateUfsFileTOptions thriftOptions = options.toThrift(); Assert.assertEquals(owner, thriftOptions.getOwner()); Assert.assertEquals(group, thriftOptions.getGroup()); Assert.assertEquals(mode, thriftOptions.getMode()); } "
    },
    {
        "test_src": "@Test public void testIsInterface() { assertEquals(false, ClassUtil.isInterface(this.getClass())); assertEquals(false, ClassUtil.isInterface(DatePattern.class)); } ",
        "focal_tgt": "public static boolean isInterface(Class < ? > ownerClass) { if(null == ownerClass) { return false; } int modifiers = ownerClass.getModifiers(); return Modifier.isInterface(modifiers); } ",
        "focal_src": "public static boolean isInterface(Class < ? > ownerClass) { int flag = ownerClass.getModifiers(); return Modifier.isInterface(flag); } ",
        "test_tgt": "@Test public void testIsInterface() { assertEquals(false, ClassUtil.isInterface(null)); assertEquals(false, ClassUtil.isInterface(this.getClass())); assertEquals(false, ClassUtil.isInterface(DatePattern.class)); } "
    },
    {
        "test_src": "@Test public void add() { assertEquals(SIZE, set.size()); for(final byte[]t : LIST)assertTrue(\"Token is missing.\", set.contains(t)); } ",
        "focal_tgt": "public Constr add(final QueryContext qc, final Expr ... exprs)throws QueryException { final int size = sc.ns.size(); try { for(final Expr expr : exprs) { more = false; final Iter iter = expr.iter(qc); for(Item item; (item = qc.next(iter)) != null && add(qc, item); ); } if( ! text.isEmpty())children.add(new FTxt(text.toArray())); return this; } finally { sc.ns.size(size); } } ",
        "focal_src": "public Constr add(final QueryContext qc, final Expr ... exprs)throws QueryException { final int s = sc.ns.size(); try { for(final Expr expr : exprs) { more = false; final Iter iter = expr.iter(qc); for(Item item; (item = qc.next(iter)) != null && add(qc, item); ); } if( ! text.isEmpty())children.add(new FTxt(text.toArray())); return this; } finally { sc.ns.size(s); } } ",
        "test_tgt": "@Test public void add() { assertEquals(SIZE, set.size()); for(final byte[]token : LIST)assertTrue(\"Token is missing.\", set.contains(token)); } "
    },
    {
        "test_src": "@Test public void testGet() { BytesRef ref = new BytesRef(); for(int j = 0; j < 2 * RANDOM_MULTIPLIER; j ++ ) { Map < String, Integer > strings = new HashMap < String, Integer > (); for(int i = 0; i < 797; i ++ ) { String str; do { str = _TestUtil.randomRealisticUnicodeString(random, 1000); } while(str.length() == 0); ref.copy(str); int count = hash.size(); int key = hash.add(ref); if(key >= 0) { assertNull(strings.put(str, Integer.valueOf(key))); assertEquals(i, key); assertEquals(hash.size(), count + 1); } else { assertTrue(( - key) - 1 < count); assertEquals(hash.size(), count); } } for(Entry < String, Integer > entry : strings.entrySet()) { ref.copy(entry.getKey()); assertEquals(ref, hash.get(entry.getValue().intValue())); } hash.clear(); assertEquals(0, hash.size()); hash.reinit(); } } ",
        "focal_tgt": "public BytesRef get(int ord, BytesRef ref) { assert bytesStart != null : \"bytesStart is null - not initialized\"; assert ord < bytesStart.length : \"ord exceeeds byteStart len: \" + bytesStart.length; return pool.setBytesRef(ref, bytesStart[ord]); } ",
        "focal_src": "public BytesRef get(int ord) { assert bytesStart != null : \"bytesStart is null - not initialized\"; assert ord < bytesStart.length : \"ord exceeeds byteStart len: \" + bytesStart.length; return pool.setBytesRef(scratch1, bytesStart[ord]); } ",
        "test_tgt": "@Test public void testGet() { BytesRef ref = new BytesRef(); BytesRef scratch = new BytesRef(); for(int j = 0; j < 2 * RANDOM_MULTIPLIER; j ++ ) { Map < String, Integer > strings = new HashMap < String, Integer > (); for(int i = 0; i < 797; i ++ ) { String str; do { str = _TestUtil.randomRealisticUnicodeString(random, 1000); } while(str.length() == 0); ref.copy(str); int count = hash.size(); int key = hash.add(ref); if(key >= 0) { assertNull(strings.put(str, Integer.valueOf(key))); assertEquals(i, key); assertEquals(hash.size(), count + 1); } else { assertTrue(( - key) - 1 < count); assertEquals(hash.size(), count); } } for(Entry < String, Integer > entry : strings.entrySet()) { ref.copy(entry.getKey()); assertEquals(ref, hash.get(entry.getValue().intValue(), scratch)); } hash.clear(); assertEquals(0, hash.size()); hash.reinit(); } } "
    },
    {
        "test_src": "@Test public void notTest1() { final short[]content = { 1, 3, 5, 7, 9 }; final MappeableContainer c = makeContainer(content); final MappeableContainer c1 = c.not(0, 65536); final short[]s = new short[65536 - content.length]; int pos = 0; for(int i = 0; i < 65536; ++ i)if(Arrays.binarySearch(content, (short)i) < 0)s[pos ++ ] = (short)i; assertTrue(checkContent(c1, s)); assertTrue(checkContent(c, content)); } ",
        "focal_tgt": "private Container not(BitmapContainer answer, final int firstOfRange, final int lastOfRange) { assert bitmap.length == MAX_CAPACITY / 64; if(lastOfRange - firstOfRange == MAX_CAPACITY) { final int newCardinality = MAX_CAPACITY - cardinality; for(int k = 0; k < this.bitmap.length; ++ k) { answer.bitmap[k] = ~ this.bitmap[k]; } answer.cardinality = newCardinality; if(newCardinality <= ArrayContainer.DEFAULT_MAX_SIZE) { return answer.toArrayContainer(); } return answer; } int cardinalityChange = 0; final int rangeFirstWord = firstOfRange / 64; final int rangeFirstBitPos = firstOfRange & 63; final int rangeLastWord = (lastOfRange - 1) / 64; final long rangeLastBitPos = (lastOfRange - 1) & 63; if(answer != this) { System.arraycopy(bitmap, 0, answer.bitmap, 0, rangeFirstWord); System.arraycopy(bitmap, rangeLastWord + 1, answer.bitmap, rangeLastWord + 1, bitmap.length - (rangeLastWord + 1)); } final long maskOnLeft = (rangeLastBitPos == 63) ? - 1L : (1L << (rangeLastBitPos + 1)) - 1; long mask = - 1L; mask ^= ((1L << rangeFirstBitPos) - 1); if(rangeFirstWord == rangeLastWord) { mask &= maskOnLeft; cardinalityChange = - Long.bitCount(bitmap[rangeFirstWord]); answer.bitmap[rangeFirstWord] = bitmap[rangeFirstWord] ^ mask; cardinalityChange += Long.bitCount(answer.bitmap[rangeFirstWord]); answer.cardinality = cardinality + cardinalityChange; if(answer.cardinality <= ArrayContainer.DEFAULT_MAX_SIZE) { return answer.toArrayContainer(); } return answer; } cardinalityChange += - Long.bitCount(bitmap[rangeFirstWord]); answer.bitmap[rangeFirstWord] = bitmap[rangeFirstWord] ^ mask; cardinalityChange += Long.bitCount(answer.bitmap[rangeFirstWord]); cardinalityChange += - Long.bitCount(bitmap[rangeLastWord]); answer.bitmap[rangeLastWord] = bitmap[rangeLastWord] ^ maskOnLeft; cardinalityChange += Long.bitCount(answer.bitmap[rangeLastWord]); for(int i = rangeFirstWord + 1; i < rangeLastWord; ++ i) { cardinalityChange += (64 - 2 * Long.bitCount(bitmap[i])); answer.bitmap[i] = ~ bitmap[i]; } answer.cardinality = cardinality + cardinalityChange; if(answer.cardinality <= ArrayContainer.DEFAULT_MAX_SIZE) { return answer.toArrayContainer(); } return answer; } ",
        "focal_src": "private Container not(BitmapContainer answer, final int firstOfRange, final int lastOfRange) { assert bitmap.length == MAX_CAPACITY / 64; if(lastOfRange - firstOfRange == MAX_CAPACITY) { final int newCardinality = MAX_CAPACITY - cardinality; for(int k = 0; k < this.bitmap.length; ++ k)answer.bitmap[k] = ~ this.bitmap[k]; answer.cardinality = newCardinality; if(newCardinality <= ArrayContainer.DEFAULT_MAX_SIZE)return answer.toArrayContainer(); return answer; } int cardinalityChange = 0; final int rangeFirstWord = firstOfRange / 64; final int rangeFirstBitPos = firstOfRange & 63; final int rangeLastWord = (lastOfRange - 1) / 64; final long rangeLastBitPos = (lastOfRange - 1) & 63; if(answer != this) { System.arraycopy(bitmap, 0, answer.bitmap, 0, rangeFirstWord); System.arraycopy(bitmap, rangeLastWord + 1, answer.bitmap, rangeLastWord + 1, bitmap.length - (rangeLastWord + 1)); } final long maskOnLeft = (rangeLastBitPos == 63) ? - 1L : (1L << (rangeLastBitPos + 1)) - 1; long mask = - 1L; mask ^= ((1L << rangeFirstBitPos) - 1); if(rangeFirstWord == rangeLastWord) { mask &= maskOnLeft; cardinalityChange = - Long.bitCount(bitmap[rangeFirstWord]); answer.bitmap[rangeFirstWord] = bitmap[rangeFirstWord] ^ mask; cardinalityChange += Long.bitCount(answer.bitmap[rangeFirstWord]); answer.cardinality = cardinality + cardinalityChange; if(answer.cardinality <= ArrayContainer.DEFAULT_MAX_SIZE)return answer.toArrayContainer(); return answer; } cardinalityChange += - Long.bitCount(bitmap[rangeFirstWord]); answer.bitmap[rangeFirstWord] = bitmap[rangeFirstWord] ^ mask; cardinalityChange += Long.bitCount(answer.bitmap[rangeFirstWord]); cardinalityChange += - Long.bitCount(bitmap[rangeLastWord]); answer.bitmap[rangeLastWord] = bitmap[rangeLastWord] ^ maskOnLeft; cardinalityChange += Long.bitCount(answer.bitmap[rangeLastWord]); for(int i = rangeFirstWord + 1; i < rangeLastWord; ++ i) { cardinalityChange += (64 - 2 * Long.bitCount(bitmap[i])); answer.bitmap[i] = ~ bitmap[i]; } answer.cardinality = cardinality + cardinalityChange; if(answer.cardinality <= ArrayContainer.DEFAULT_MAX_SIZE)return answer.toArrayContainer(); return answer; } ",
        "test_tgt": "@Test public void notTest1() { final short[]content = { 1, 3, 5, 7, 9 }; final MappeableContainer c = makeContainer(content); final MappeableContainer c1 = c.not(0, 65536); final short[]s = new short[65536 - content.length]; int pos = 0; for(int i = 0; i < 65536; ++ i) { if(Arrays.binarySearch(content, (short)i) < 0) { s[pos ++ ] = (short)i; } } assertTrue(checkContent(c1, s)); assertTrue(checkContent(c, content)); } "
    },
    {
        "test_src": "@Test public void reportLostFileTest()throws Exception { AlluxioURI path = new AlluxioURI(\"test\"); mTachyonLineageFileSystem.reportLostFile(path); Mockito.verify(mLineageMasterClient).reportLostFile(\"test\"); Mockito.verify(mLineageContext).releaseMasterClient(mLineageMasterClient); } ",
        "focal_tgt": "public synchronized void reportLostFile(final String path)throws IOException, AlluxioException { retryRPC(new RpcCallableThrowsAlluxioTException < Void > () { @Override public Void call()throws AlluxioTException, TException { mClient.reportLostFile(path); return null; } }); } ",
        "focal_src": "public synchronized void reportLostFile(final String path)throws IOException, AlluxioException { retryRPC(new RpcCallableThrowsTachyonTException < Void > () { @Override public Void call()throws AlluxioTException, TException { mClient.reportLostFile(path); return null; } }); } ",
        "test_tgt": "@Test public void reportLostFileTest()throws Exception { AlluxioURI path = new AlluxioURI(\"test\"); mAlluxioLineageFileSystem.reportLostFile(path); Mockito.verify(mLineageMasterClient).reportLostFile(\"test\"); Mockito.verify(mLineageContext).releaseMasterClient(mLineageMasterClient); } "
    },
    {
        "test_src": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"toString\", args = { })public final void testToString()throws NoSuchAlgorithmException { for(int k = 0; k < algorithmName.length; k ++ ) { try { ByteArrayOutputStream bos = new ByteArrayOutputStream(MY_MESSAGE_LEN); MessageDigest md = MessageDigest.getInstance(algorithmName[k]); DigestOutputStream dos = new DigestOutputStream(bos, md); assertNotNull(dos.toString()); return; } catch(NoSuchAlgorithmException e) { } } fail(getName() + \": no MessageDigest algorithms available - test not performed\"); } ",
        "focal_tgt": "@Override public final String toString() { if( ! initialized) { return null; } return spiImpl.engineToString(); } ",
        "focal_src": "public final String toString() { if( ! initialized) { return null; } return spiImpl.engineToString(); } ",
        "test_tgt": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"toString\", args = { })public final void testToString()throws NoSuchAlgorithmException { for(int k = 0; k < algorithmName.length; k ++ ) { try { ByteArrayOutputStream bos = new ByteArrayOutputStream(MY_MESSAGE_LEN); MessageDigest md = MessageDigest.getInstance(algorithmName[k]); DigestOutputStream dos = new DigestOutputStream(bos, md); assertNotNull(dos.toString()); return; } catch(NoSuchAlgorithmException e) { } } fail(getName() + \": no MessageDigest algorithms available - test not performed\"); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should pass validation if all required fields have proper values\", method = \"validate(Object,Errors)\")public void validate_shouldPassValidationIfAllRequiredFieldsHaveProperValues()throws Exception { Program prog = new Program(); prog.setName(\"Hypochondriasis program\"); prog.setConcept(Context.getConceptService().getConcept(3)); Errors errors = new BindException(prog, \"prog\"); new ProgramValidator().validate(prog, errors); Assert.assertFalse(errors.hasErrors()); } ",
        "focal_tgt": "public void validate(Object obj, Errors errors) { Program p = (Program)obj; if(p == null) { errors.rejectValue(\"program\", \"error.general\"); } else { ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\"); ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"description\", \"error.description\"); List < Program > programs = Context.getProgramWorkflowService().getAllPrograms(false); for(Program program : programs) { if(program.getName().equals(p.getName()) && ! program.getProgramId().equals(p.getProgramId())) { errors.rejectValue(\"name\", \"general.error.nameAlreadyInUse\"); break; } } ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"concept\", \"error.concept\"); } } ",
        "focal_src": "public void validate(Object obj, Errors errors) { Program p = (Program)obj; if(p == null) { errors.rejectValue(\"program\", \"error.general\"); } else { ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\"); List < Program > programs = Context.getProgramWorkflowService().getAllPrograms(false); for(Program program : programs) { if(program.getName().equals(p.getName()) && ! program.getProgramId().equals(p.getProgramId())) { errors.rejectValue(\"name\", \"general.error.nameAlreadyInUse\"); break; } } ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"concept\", \"error.concept\"); } } ",
        "test_tgt": "@Test@Verifies(value = \"should pass validation if all required fields have proper values\", method = \"validate(Object,Errors)\")public void validate_shouldPassValidationIfAllRequiredFieldsHaveProperValues()throws Exception { Program prog = new Program(); prog.setName(\"Hypochondriasis program\"); prog.setDescription(\"This is Hypochondriasis program\"); prog.setConcept(Context.getConceptService().getConcept(3)); Errors errors = new BindException(prog, \"prog\"); new ProgramValidator().validate(prog, errors); Assert.assertFalse(errors.hasErrors()); } "
    },
    {
        "test_src": "@Test public void getProviderbyUuid_shouldGetProviderGivenUuid()throws Exception { Provider provider = service.getProviderbyUuid(\"a2c3868a-6b90-11e0-93c3-18a905e044dc\"); Assert.assertNotNull(provider); assertEquals(\"RobertClive\", provider.getName()); } ",
        "focal_tgt": "@Transactional(readOnly = true)@Authorized( { PrivilegeConstants.VIEW_PROVIDERS })public Provider getProviderByUuid(String uuid); ",
        "focal_src": "@Transactional(readOnly = true)@Authorized( { PrivilegeConstants.VIEW_PROVIDERS })public Provider getProviderbyUuid(String uuid); ",
        "test_tgt": "@Test public void getProviderByUuid_shouldGetProviderGivenUuid()throws Exception { Provider provider = service.getProviderByUuid(\"a2c3868a-6b90-11e0-93c3-18a905e044dc\"); Assert.assertNotNull(provider); assertEquals(\"RobertClive\", provider.getName()); } "
    },
    {
        "test_src": "@Test public void deleteAll()throws Exception { flushTestUsers(); repository.deleteAll(); assertEquals(0L, repository.count()); } ",
        "focal_tgt": "@Transactional public void deleteAll() { em.createQuery(getDeleteAllQueryString()).executeUpdate(); } ",
        "focal_src": "@Transactional public void deleteAll() { em.createQuery(getDeleteAllQueryString()).executeUpdate(); em.clear(); } ",
        "test_tgt": "@Test public void deleteAll()throws Exception { flushTestUsers(); repository.deleteAll(); assertThat(repository.count(), is(0L)); } "
    },
    {
        "test_src": "@Test public void testHexStringToByteArray() { byte[]temp = { (byte)0x12, (byte)0xaf }; assertTrue(Arrays.equals(temp, ParseUtil.hexStringToByteArray(\"12af\"))); } ",
        "focal_tgt": "public static byte[]hexStringToByteArray(String digits) { int len = digits.length(); if( ! VALID_HEX.matcher(digits).matches() || (len & 0x1) != 0) { LOG.error(\"Invalid hexadecimal string: {}\", digits); return null; } byte[]data = new byte[len / 2]; for(int i = 0; i < len; i += 2) { data[i / 2] = (byte)((Character.digit(digits.charAt(i), 16) << 4) | Character.digit(digits.charAt(i + 1), 16)); } return data; } ",
        "focal_src": "public static byte[]hexStringToByteArray(String digits) { if( ! VALID_HEX.matcher(digits).matches()) { LOG.error(\"Invalid hexadecimal string: {}\", digits); return null; } int len = digits.length(); byte[]data = new byte[len / 2]; for(int i = 0; i < len; i += 2) { data[i / 2] = (byte)((Character.digit(digits.charAt(i), 16) << 4) | Character.digit(digits.charAt(i + 1), 16)); } return data; } ",
        "test_tgt": "@Test public void testHexStringToByteArray() { byte[]temp = { (byte)0x12, (byte)0xaf }; assertTrue(Arrays.equals(temp, ParseUtil.hexStringToByteArray(\"12af\"))); assertEquals(null, ParseUtil.hexStringToByteArray(\"abcde\")); assertEquals(null, ParseUtil.hexStringToByteArray(\"not hex\")); } "
    },
    {
        "test_src": "@Test public void testDeleteScope()throws ExecutionException, InterruptedException { final String resourceURI = getURI() + \"v1/scopes/scope1\"; when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.SUCCESS).build())); Response response = client.target(resourceURI).request().buildDelete().invoke(); assertEquals(\"Delete Scope response code\", 204, response.getStatus()); response.close(); when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.SCOPE_NOT_EMPTY).build())); response = client.target(resourceURI).request().buildDelete().invoke(); assertEquals(\"Delete Scope response code\", 412, response.getStatus()); response.close(); when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.SCOPE_NOT_FOUND).build())); response = client.target(resourceURI).request().buildDelete().invoke(); assertEquals(\"Delete Scope response code\", 404, response.getStatus()); response.close(); when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.FAILURE).build())); response = client.target(resourceURI).request().buildDelete().invoke(); assertEquals(\"Delete Scope response code\", 500, response.getStatus()); response.close(); } ",
        "focal_tgt": "@Override public void deleteScope(final String scopeName, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"deleteScope\"); try { authenticate(scopeName, READ_UPDATE); } catch(AuthenticationException e) { log.warn(\"Delete scope for {} failed due to authentication failure.\", scopeName); asyncResponse.resume(Response.status(Status.UNAUTHORIZED).build()); LoggerHelpers.traceLeave(log, \"createStream\", traceId); return; } controllerService.deleteScope(scopeName).thenApply(scopeStatus -> { if(scopeStatus.getStatus() == DeleteScopeStatus.Status.SUCCESS) { log.info(\"Successfully deleted scope: {}\", scopeName); return Response.status(Status.NO_CONTENT).build(); } else if(scopeStatus.getStatus() == DeleteScopeStatus.Status.SCOPE_NOT_FOUND) { log.warn(\"Scope: {} not found\", scopeName); return Response.status(Status.NOT_FOUND).build(); } else if(scopeStatus.getStatus() == DeleteScopeStatus.Status.SCOPE_NOT_EMPTY) { log.warn(\"Cannot delete scope: {} with non-empty streams\", scopeName); return Response.status(Status.PRECONDITION_FAILED).build(); } else { log.warn(\"deleteScope for {} failed\", scopeName); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).exceptionally(exception -> { log.warn(\"deleteScope for {} failed with exception: {}\", scopeName, exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); }).thenApply(asyncResponse :: resume).thenAccept(x -> LoggerHelpers.traceLeave(log, \"deleteScope\", traceId)); } ",
        "focal_src": "@Override public void deleteScope(final String scopeName, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"deleteScope\"); controllerService.deleteScope(scopeName).thenApply(scopeStatus -> { if(scopeStatus.getStatus() == DeleteScopeStatus.Status.SUCCESS) { log.info(\"Successfully deleted scope: {}\", scopeName); return Response.status(Status.NO_CONTENT).build(); } else if(scopeStatus.getStatus() == DeleteScopeStatus.Status.SCOPE_NOT_FOUND) { log.warn(\"Scope: {} not found\", scopeName); return Response.status(Status.NOT_FOUND).build(); } else if(scopeStatus.getStatus() == DeleteScopeStatus.Status.SCOPE_NOT_EMPTY) { log.warn(\"Cannot delete scope: {} with non-empty streams\", scopeName); return Response.status(Status.PRECONDITION_FAILED).build(); } else { log.warn(\"deleteScope for {} failed\", scopeName); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).exceptionally(exception -> { log.warn(\"deleteScope for {} failed with exception: {}\", scopeName, exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); }).thenApply(asyncResponse :: resume).thenAccept(x -> LoggerHelpers.traceLeave(log, \"deleteScope\", traceId)); } ",
        "test_tgt": "@Test public void testDeleteScope()throws ExecutionException, InterruptedException { final String resourceURI = getURI() + \"v1/scopes/scope1\"; when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.SUCCESS).build())); Response response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke(); assertEquals(\"Delete Scope response code\", 204, response.getStatus()); response.close(); when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.SCOPE_NOT_EMPTY).build())); response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke(); assertEquals(\"Delete Scope response code\", 412, response.getStatus()); response.close(); when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.SCOPE_NOT_FOUND).build())); response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke(); assertEquals(\"Delete Scope response code\", 404, response.getStatus()); response.close(); when(mockControllerService.deleteScope(scope1)).thenReturn(CompletableFuture.completedFuture(DeleteScopeStatus.newBuilder().setStatus(DeleteScopeStatus.Status.FAILURE).build())); response = addAuthHeaders(client.target(resourceURI).request()).buildDelete().invoke(); assertEquals(\"Delete Scope response code\", 500, response.getStatus()); response.close(); } "
    },
    {
        "test_src": "@Test(description = \"GET /vApp/{id}\")public void testGetVm() { vm = vmApi.getVm(vmURI); checkVm(vm); assertEquals(vm.isDeployed(), Boolean.FALSE, String.format(OBJ_FIELD_EQ, VM, \"deployed\", \"FALSE\", vm.isDeployed().toString())); assertVmStatus(vm.getHref(), Status.POWERED_OFF); } ",
        "focal_tgt": "Vm get(URI vmURI); ",
        "focal_src": "Vm getVm(URI vmURI); ",
        "test_tgt": "@Test(description = \"GET /vApp/{id}\")public void testGetVm() { vm = vmApi.get(vmURI); checkVm(vm); assertEquals(vm.isDeployed(), Boolean.FALSE, String.format(OBJ_FIELD_EQ, VM, \"deployed\", \"FALSE\", vm.isDeployed().toString())); assertVmStatus(vm.getHref(), Status.POWERED_OFF); } "
    },
    {
        "test_src": "@Test public void matchUdpSrcTest() { Criterion criterion = Criteria.matchUdpSrc(40000); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result, matchesCriterion(criterion)); } ",
        "focal_tgt": "public static Criterion matchUdpSrc(TpPort udpPort) { return new UdpPortCriterion(udpPort, Type.UDP_SRC); } ",
        "focal_src": "public static Criterion matchUdpSrc(int udpPort) { return new UdpPortCriterion(udpPort, Type.UDP_SRC); } ",
        "test_tgt": "@Test public void matchUdpSrcTest() { Criterion criterion = Criteria.matchUdpSrc(tpPort); ObjectNode result = criterionCodec.encode(criterion, context); assertThat(result, matchesCriterion(criterion)); } "
    },
    {
        "test_src": "@Test public void restartTest()throws Exception { final int PORT_0 = 9000; Process corfuServer = runSinglePersistentServer(corfuSingleNodeHost, PORT_0); CorfuRuntime corfuRuntime = createDefaultRuntime(); Layout l = incrementClusterEpoch(corfuRuntime); corfuRuntime.getRouter(\"localhost:9000\").getClient(BaseClient.class).restart().get(); restartServer(corfuRuntime, DEFAULT_ENDPOINT); assertThat(corfuRuntime.getLayoutView().getLayout().getEpoch()).isGreaterThanOrEqualTo(l.getEpoch() + 1); assertThat(shutdownCorfuServer(corfuServer)).isTrue(); } ",
        "focal_tgt": "public CompletableFuture < Boolean > restart() { return router.sendMessageAndGetCompletable(new CorfuMsg(CorfuMsgType.RESTART).setEpoch(epoch)); } ",
        "focal_src": "public CompletableFuture < Boolean > restart() { return router.sendMessageAndGetCompletable(new CorfuMsg(CorfuMsgType.RESTART)); } ",
        "test_tgt": "@Test public void restartTest()throws Exception { final int PORT_0 = 9000; Process corfuServer = runSinglePersistentServer(corfuSingleNodeHost, PORT_0); CorfuRuntime corfuRuntime = createDefaultRuntime(); Layout l = incrementClusterEpoch(corfuRuntime); corfuRuntime.getLayoutView().getEpochedClient(l).getBaseClient(\"localhost:9000\").restart().get(); restartServer(corfuRuntime, DEFAULT_ENDPOINT); assertThat(corfuRuntime.getLayoutView().getLayout().getEpoch()).isGreaterThanOrEqualTo(l.getEpoch() + 1); assertThat(shutdownCorfuServer(corfuServer)).isTrue(); } "
    },
    {
        "test_src": "@Test public void testAdd()throws QueryException { final String fun = check(Function.ADD); query(fun + \"('db', document { <root/> }, 'test1.xml')\"); query(\"count(collection('db/test1.xml')/root) eq 1\", \"true\"); query(fun + \"('db', document { <root/> }, 'test2.xml', 'test')\"); query(\"count(collection('db/test/test2.xml')/root) eq 1\", \"true\"); query(fun + \"('db', 'etc/test/input.xml', '', 'test')\"); query(\"count(collection('db/test/input.xml')/html) eq 1\", \"true\"); query(fun + \"('db', 'etc/test/input.xml', 'test3.xml', 'test')\"); query(\"count(collection('db/test/test3.xml')/html) eq 1\", \"true\"); query(fun + \"('db', 'etc/test/dir', '', 'test/dir')\"); query(\"count(collection('db/test/dir')) gt 0\", \"true\"); } ",
        "focal_tgt": "public static String add(final String name, final String target, final InputSource input, final Context ctx, final Add cmd, final boolean lock)throws BaseXException { final Data data = ctx.data; if(data == null)return PROCNODB; String trg = path(target); if( ! trg.isEmpty())trg += '/'; final SAXSource sax = new SAXSource(input); final Parser parser = new SAXWrapper(sax, name, trg, ctx.prop); try { if(lock)ctx.register(true); return add(parser, ctx, trg, name, cmd); } finally { if(lock)ctx.unregister(true); } } ",
        "focal_src": "public static String add(final String name, final String target, final InputSource input, final Context ctx, final Add cmd, final boolean lock)throws BaseXException { final Data data = ctx.data; if(data == null)return PROCNODB; String trg = path(target); if( ! trg.isEmpty())trg = trg + '/'; final SAXSource sax = new SAXSource(input); final Parser parser = new SAXWrapper(sax, name, trg, ctx.prop); try { if(lock)ctx.register(true); return add(parser, ctx, trg, name, cmd); } finally { if(lock)ctx.unregister(true); } } ",
        "test_tgt": "@Test public void testAdd()throws QueryException { final String fun = check(Function.DBADD); query(fun + \"('db', document { <root/> }, 'test1.xml')\"); query(\"count(collection('db/test1.xml')/root) eq 1\", \"true\"); query(fun + \"('db', document { <root/> }, 'test2.xml', 'test')\"); query(\"count(collection('db/test/test2.xml')/root) eq 1\", \"true\"); query(fun + \"('db', 'etc/test/input.xml', '', 'test')\"); query(\"count(collection('db/test/input.xml')/html) eq 1\", \"true\"); query(fun + \"('db', 'etc/test/input.xml', 'test3.xml', 'test')\"); query(\"count(collection('db/test/test3.xml')/html) eq 1\", \"true\"); query(fun + \"('db', 'etc/test/dir', '', 'test/dir')\"); query(\"count(collection('db/test/dir')) gt 0\", \"true\"); } "
    },
    {
        "test_src": "@Test public void testBernoulli() { logger.info(\"Bernoulli\"); boolean k = true; double p = 0.5; double expResult = 0.5; double result = DiscreteDistributions.Bernoulli(k, p); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } ",
        "focal_tgt": "public static double bernoulli(boolean k, double p) { if(p < 0) { throw new IllegalArgumentException(\"The probability p can't be negative.\"); } return(k) ? p : (1 - p); } ",
        "focal_src": "public static double Bernoulli(boolean k, double p) { if(p < 0) { throw new IllegalArgumentException(\"The probability p can't be negative.\"); } return(k) ? p : (1 - p); } ",
        "test_tgt": "@Test public void testBernoulli() { logger.info(\"Bernoulli\"); boolean k = true; double p = 0.5; double expResult = 0.5; double result = DiscreteDistributions.bernoulli(k, p); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } "
    },
    {
        "test_src": "@Test public void testSetTags()throws GenieException { Assert.assertNotNull(this.c.getTags()); final Set < String > tags = new HashSet < > (); tags.add(\"prod\"); tags.add(\"sla\"); this.c.setTags(tags); Assert.assertEquals(tags, this.c.getTags()); } ",
        "focal_tgt": "public void setTags(final Set < String > tags) { this.tags = tags; } ",
        "focal_src": "public void setTags(final Set < String > tags)throws GenieException { this.tags = tags; } ",
        "test_tgt": "@Test public void testSetTags()throws GeniePreconditionException { Assert.assertNotNull(this.c.getTags()); final Set < String > tags = new HashSet < > (); tags.add(\"prod\"); tags.add(\"sla\"); this.c.setTags(tags); Assert.assertEquals(tags, this.c.getTags()); } "
    },
    {
        "test_src": "@Test public void lockWriteAndCheckFullPath()throws Exception { String name = \"file\"; InodeFile inode1 = createInodeFile(1); InodeDirectory dir1 = createInodeDirectory(); inode1.setName(name); inode1.setParentId(dir1.getId()); inode1.lockWriteAndCheckFullPath(dir1, name); Assert.assertTrue(inode1.isWriteLocked()); inode1.unlockWrite(); } ",
        "focal_tgt": "public void lockWriteAndCheckNameAndParent(Inode parent, String name)throws InvalidPathException { lockWriteAndCheckParent(parent); if( ! mName.equals(name)) { unlockWrite(); throw new InvalidPathException(ExceptionMessage.PATH_INVALID_CONCURRENT_RENAME.getMessage()); } } ",
        "focal_src": "public void lockWriteAndCheckFullPath(Inode parent, String name)throws InvalidPathException { lockWriteAndCheckParent(parent); if( ! mName.equals(name)) { unlockWrite(); throw new InvalidPathException(ExceptionMessage.PATH_INVALID_CONCURRENT_RENAME.getMessage()); } } ",
        "test_tgt": "@Test public void lockWriteAndCheckNameAndParent()throws Exception { String name = \"file\"; InodeFile inode1 = createInodeFile(1); InodeDirectory dir1 = createInodeDirectory(); inode1.setName(name); inode1.setParentId(dir1.getId()); inode1.lockWriteAndCheckNameAndParent(dir1, name); Assert.assertTrue(inode1.isWriteLocked()); inode1.unlockWrite(); } "
    },
    {
        "test_src": "@Test public void applyExtraGroupBitsTest() { Mode mode = new Mode((short)0640); mode.applyExtraGroupBits(Mode.Bits.READ_EXECUTE); Assert.assertEquals(Mode.Bits.READ_EXECUTE, mode.getGroupBits()); mode.applyExtraGroupBits(Mode.Bits.WRITE); Assert.assertEquals(Mode.Bits.ALL, mode.getGroupBits()); } ",
        "focal_tgt": "public void setGroupBits(Bits bits) { mGroupBits = bits; } ",
        "focal_src": "public void applyExtraGroupBits(Bits bits) { mGroupBits = mGroupBits.or(bits); } ",
        "test_tgt": "@Test public void setGroupBitsTest() { Mode mode = new Mode((short)0640); mode.setGroupBits(Mode.Bits.READ_EXECUTE); Assert.assertEquals(Mode.Bits.READ_EXECUTE, mode.getGroupBits()); mode.setGroupBits(Mode.Bits.WRITE); Assert.assertEquals(Mode.Bits.WRITE, mode.getGroupBits()); mode.setGroupBits(Mode.Bits.ALL); Assert.assertEquals(Mode.Bits.ALL, mode.getGroupBits()); } "
    },
    {
        "test_src": "@Test public void predicatedCollection() { Predicate < Object > predicate = PredicateUtils.instanceofPredicate(Integer.class); Collection < Number > collection = CollectionUtils.predicatedCollection(new ArrayList < Number > (), predicate); assertTrue(\"returned object should be a PredicatedCollection\", collection instanceof PredicatedCollection); try { collection = CollectionUtils.predicatedCollection(new ArrayList < Number > (), null); fail(\"Expecting IllegalArgumentException for null predicate.\"); } catch(IllegalArgumentException ex) { } try { CollectionUtils.predicatedCollection(null, predicate); fail(\"Expecting IllegalArgumentException for null collection.\"); } catch(IllegalArgumentException ex) { } } ",
        "focal_tgt": "public static < C > Collection < C > predicatedCollection(final Collection < C > collection, final Predicate < ? super C > predicate) { return PredicatedCollection.predicatedCollection(collection, predicate); } ",
        "focal_src": "public static < C > Collection < C > predicatedCollection(Collection < C > collection, Predicate < ? super C > predicate) { return PredicatedCollection.predicatedCollection(collection, predicate); } ",
        "test_tgt": "@Test public void predicatedCollection() { final Predicate < Object > predicate = PredicateUtils.instanceofPredicate(Integer.class); Collection < Number > collection = CollectionUtils.predicatedCollection(new ArrayList < Number > (), predicate); assertTrue(\"returned object should be a PredicatedCollection\", collection instanceof PredicatedCollection); try { collection = CollectionUtils.predicatedCollection(new ArrayList < Number > (), null); fail(\"Expecting IllegalArgumentException for null predicate.\"); } catch(final IllegalArgumentException ex) { } try { CollectionUtils.predicatedCollection(null, predicate); fail(\"Expecting IllegalArgumentException for null collection.\"); } catch(final IllegalArgumentException ex) { } } "
    },
    {
        "test_src": "@Test public void testGetIdentifiableLanguages() { final List < IdentifiableLanguage > languages = service.getIdentifiableLanguages(); assertNotNull(languages); assertTrue( ! languages.isEmpty()); } ",
        "focal_tgt": "public ServiceCall < List < IdentifiableLanguage > > getIdentifiableLanguages() { final RequestBuilder requestBuilder = RequestBuilder.get(PATH_IDENTIFIABLE_LANGUAGES); return createServiceCall(createCall(requestBuilder.build3()), ResponseUtil.getLanguageListConverter()); } ",
        "focal_src": "public List < IdentifiableLanguage > getIdentifiableLanguages() { final RequestBuilder requestBuilder = RequestBuilder.get(PATH_IDENTIFIABLE_LANGUAGES); final LanguageList languages = executeRequest(requestBuilder.build(), LanguageList.class); return languages.getLanguages(); } ",
        "test_tgt": "@Test public void testGetIdentifiableLanguages() { final List < IdentifiableLanguage > languages = service.getIdentifiableLanguages().execute(); assertNotNull(languages); assertTrue( ! languages.isEmpty()); } "
    },
    {
        "test_src": "@Test public void testSpatialRangeQuery()throws Exception { RectangleRDD spatialRDD = new RectangleRDD(sc, InputLocation, offset, splitter); for(int i = 0; i < loopTimes; i ++ ) { long resultSize = RangeQuery.SpatialRangeQuery(spatialRDD, queryEnvelope, 0, false).count(); assert resultSize > - 1; } assert RangeQuery.SpatialRangeQuery(spatialRDD, queryEnvelope, 0, false).take(10).get(1).getUserData().toString() != null; } ",
        "focal_tgt": "public static JavaRDD < Point > SpatialRangeQuery(PointRDD spatialRDD, Polygon queryWindow, Integer condition, boolean useIndex)throws Exception { if(useIndex == true) { if(spatialRDD.indexedRawRDD == null) { throw new Exception(\"[RangeQuery][SpatialRangeQuery] Index doesn't exist. Please build index on rawSpatialRDD.\"); } JavaRDD < Object > result = spatialRDD.indexedRawRDD.mapPartitions(new RangeFilterUsingIndex(queryWindow)); return result.map(new Function < Object, Point > () { @Override public Point call(Object spatialObject)throws Exception { return(Point)spatialObject; } }); } else { JavaRDD < Object > result = spatialRDD.getRawSpatialRDD().filter(new GeometryRangeFilter(queryWindow, condition)); return result.map(new Function < Object, Point > () { @Override public Point call(Object spatialObject)throws Exception { return(Point)spatialObject; } }); } } ",
        "focal_src": "public static JavaRDD < Point > SpatialRangeQuery(PointRDD spatialRDD, Polygon queryWindow, Integer condition, boolean useIndex)throws Exception { if(useIndex == true) { if(spatialRDD.indexedRawRDD == null) { throw new Exception(\"[RangeQuery][SpatialRangeQuery] Index doesn't exist. Please build index.\"); } JavaRDD < Object > result = spatialRDD.indexedRawRDD.mapPartitions(new RangeFilterUsingIndex(queryWindow)); return result.map(new Function < Object, Point > () { @Override public Point call(Object spatialObject)throws Exception { return(Point)spatialObject; } }); } else { JavaRDD < Object > result = spatialRDD.getRawSpatialRDD().filter(new GeometryRangeFilter(queryWindow, condition)); return result.map(new Function < Object, Point > () { @Override public Point call(Object spatialObject)throws Exception { return(Point)spatialObject; } }); } } ",
        "test_tgt": "@Test public void testSpatialRangeQuery()throws Exception { RectangleRDD spatialRDD = new RectangleRDD(sc, InputLocation, offset, splitter, true); for(int i = 0; i < loopTimes; i ++ ) { long resultSize = RangeQuery.SpatialRangeQuery(spatialRDD, queryEnvelope, 0, false).count(); assert resultSize > - 1; } assert RangeQuery.SpatialRangeQuery(spatialRDD, queryEnvelope, 0, false).take(10).get(1).getUserData().toString() != null; } "
    },
    {
        "test_src": "@Test public void testStartsWithText() { assertEquals(new StartsWithTextCriterion(\"name\", \"a\"), instance.startsWithText(\"name\", \"a\").getQueryCriterion()); } ",
        "focal_tgt": "public CriteriaQuery startsWithText(String propName, String value) { criterion = criterion.and(Criteria.startsWithText(propName, value)); return this; } ",
        "focal_src": "public CriteriaQuery startsWithText(String propName, String value) { criterion = criterion.and(criterionBuilder.startsWithText(propName, value)); return this; } ",
        "test_tgt": "@Test public void testStartsWithText() { assertEquals(Criteria.startsWithText(\"name\", \"a\"), instance.startsWithText(\"name\", \"a\").getQueryCriterion()); } "
    },
    {
        "test_src": "@Test public void testBelongTo() { BlockStoreLocation anyTier = BlockStoreLocation.anyTier(); BlockStoreLocation anyDirInTierMEM = BlockStoreLocation.anyDirInTier(\"MEM\"); BlockStoreLocation anyDirInTierHDD = BlockStoreLocation.anyDirInTier(\"HDD\"); BlockStoreLocation dirInMEM = new BlockStoreLocation(\"MEM\", 1); BlockStoreLocation dirInHDD = new BlockStoreLocation(\"HDD\", 2); Assert.assertTrue(anyTier.belongTo(anyTier)); Assert.assertFalse(anyTier.belongTo(anyDirInTierMEM)); Assert.assertFalse(anyTier.belongTo(anyDirInTierHDD)); Assert.assertFalse(anyTier.belongTo(dirInMEM)); Assert.assertFalse(anyTier.belongTo(dirInHDD)); Assert.assertTrue(anyDirInTierMEM.belongTo(anyTier)); Assert.assertTrue(anyDirInTierMEM.belongTo(anyDirInTierMEM)); Assert.assertFalse(anyDirInTierMEM.belongTo(anyDirInTierHDD)); Assert.assertFalse(anyDirInTierMEM.belongTo(dirInMEM)); Assert.assertFalse(anyDirInTierMEM.belongTo(dirInHDD)); Assert.assertTrue(anyDirInTierHDD.belongTo(anyTier)); Assert.assertFalse(anyDirInTierHDD.belongTo(anyDirInTierMEM)); Assert.assertTrue(anyDirInTierHDD.belongTo(anyDirInTierHDD)); Assert.assertFalse(anyDirInTierHDD.belongTo(dirInMEM)); Assert.assertFalse(anyDirInTierHDD.belongTo(dirInHDD)); Assert.assertTrue(dirInMEM.belongTo(anyTier)); Assert.assertTrue(dirInMEM.belongTo(anyDirInTierMEM)); Assert.assertFalse(dirInMEM.belongTo(anyDirInTierHDD)); Assert.assertTrue(dirInMEM.belongTo(dirInMEM)); Assert.assertFalse(dirInMEM.belongTo(dirInHDD)); Assert.assertTrue(dirInHDD.belongTo(anyTier)); Assert.assertFalse(dirInHDD.belongTo(anyDirInTierMEM)); Assert.assertTrue(dirInHDD.belongTo(anyDirInTierHDD)); Assert.assertFalse(dirInHDD.belongTo(dirInMEM)); Assert.assertTrue(dirInHDD.belongTo(dirInHDD)); } ",
        "focal_tgt": "public boolean belongsTo(BlockStoreLocation location) { boolean tierInRange = tierAlias().equals(location.tierAlias()) || location.tierAlias().equals(ANY_TIER); boolean dirInRange = (dir() == location.dir()) || (location.dir() == ANY_DIR); return tierInRange && dirInRange; } ",
        "focal_src": "public boolean belongTo(BlockStoreLocation location) { boolean tierInRange = tierAlias().equals(location.tierAlias()) || location.tierAlias().equals(ANY_TIER); boolean dirInRange = (dir() == location.dir()) || (location.dir() == ANY_DIR); return tierInRange && dirInRange; } ",
        "test_tgt": "@Test public void testBelongTo() { BlockStoreLocation anyTier = BlockStoreLocation.anyTier(); BlockStoreLocation anyDirInTierMEM = BlockStoreLocation.anyDirInTier(\"MEM\"); BlockStoreLocation anyDirInTierHDD = BlockStoreLocation.anyDirInTier(\"HDD\"); BlockStoreLocation dirInMEM = new BlockStoreLocation(\"MEM\", 1); BlockStoreLocation dirInHDD = new BlockStoreLocation(\"HDD\", 2); Assert.assertTrue(anyTier.belongsTo(anyTier)); Assert.assertFalse(anyTier.belongsTo(anyDirInTierMEM)); Assert.assertFalse(anyTier.belongsTo(anyDirInTierHDD)); Assert.assertFalse(anyTier.belongsTo(dirInMEM)); Assert.assertFalse(anyTier.belongsTo(dirInHDD)); Assert.assertTrue(anyDirInTierMEM.belongsTo(anyTier)); Assert.assertTrue(anyDirInTierMEM.belongsTo(anyDirInTierMEM)); Assert.assertFalse(anyDirInTierMEM.belongsTo(anyDirInTierHDD)); Assert.assertFalse(anyDirInTierMEM.belongsTo(dirInMEM)); Assert.assertFalse(anyDirInTierMEM.belongsTo(dirInHDD)); Assert.assertTrue(anyDirInTierHDD.belongsTo(anyTier)); Assert.assertFalse(anyDirInTierHDD.belongsTo(anyDirInTierMEM)); Assert.assertTrue(anyDirInTierHDD.belongsTo(anyDirInTierHDD)); Assert.assertFalse(anyDirInTierHDD.belongsTo(dirInMEM)); Assert.assertFalse(anyDirInTierHDD.belongsTo(dirInHDD)); Assert.assertTrue(dirInMEM.belongsTo(anyTier)); Assert.assertTrue(dirInMEM.belongsTo(anyDirInTierMEM)); Assert.assertFalse(dirInMEM.belongsTo(anyDirInTierHDD)); Assert.assertTrue(dirInMEM.belongsTo(dirInMEM)); Assert.assertFalse(dirInMEM.belongsTo(dirInHDD)); Assert.assertTrue(dirInHDD.belongsTo(anyTier)); Assert.assertFalse(dirInHDD.belongsTo(anyDirInTierMEM)); Assert.assertTrue(dirInHDD.belongsTo(anyDirInTierHDD)); Assert.assertFalse(dirInHDD.belongsTo(dirInMEM)); Assert.assertTrue(dirInHDD.belongsTo(dirInHDD)); } "
    },
    {
        "test_src": "@Test public void testThreshold() { float inten[] = new float[] { 0, 1, 0, 0, 3, 4, 4, 0, 0, 1, 0, 2, 0, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; ImageFloat32 img = new ImageFloat32(9, 8); img.data = inten; BoofTesting.checkSubImage(this, \"testThreshold\", true, img); } ",
        "focal_tgt": "public static < T extends ImageGray > GrayU8 threshold(T input, GrayU8 output, double threshold, boolean down) { if(input instanceof GrayF32) { return ThresholdImageOps.threshold((GrayF32)input, output, (float)threshold, down); } else if(input instanceof GrayU8) { return ThresholdImageOps.threshold((GrayU8)input, output, (int)threshold, down); } else if(input instanceof GrayU16) { return ThresholdImageOps.threshold((GrayU16)input, output, (int)threshold, down); } else if(input instanceof GrayS16) { return ThresholdImageOps.threshold((GrayS16)input, output, (int)threshold, down); } else if(input instanceof GrayS32) { return ThresholdImageOps.threshold((GrayS32)input, output, (int)threshold, down); } else if(input instanceof GrayF64) { return ThresholdImageOps.threshold((GrayF64)input, output, threshold, down); } else { throw new IllegalArgumentException(\"Unknown image type: \" + input.getClass().getSimpleName()); } } ",
        "focal_src": "public static < T extends ImageSingleBand > ImageUInt8 threshold(T input, ImageUInt8 output, double threshold, boolean down) { if(input instanceof ImageFloat32) { return ThresholdImageOps.threshold((ImageFloat32)input, output, (float)threshold, down); } else if(input instanceof ImageUInt8) { return ThresholdImageOps.threshold((ImageUInt8)input, output, (int)threshold, down); } else if(input instanceof ImageUInt16) { return ThresholdImageOps.threshold((ImageUInt16)input, output, (int)threshold, down); } else if(input instanceof ImageSInt16) { return ThresholdImageOps.threshold((ImageSInt16)input, output, (int)threshold, down); } else if(input instanceof ImageSInt32) { return ThresholdImageOps.threshold((ImageSInt32)input, output, (int)threshold, down); } else if(input instanceof ImageFloat64) { return ThresholdImageOps.threshold((ImageFloat64)input, output, threshold, down); } else { throw new IllegalArgumentException(\"Unknown image type: \" + input.getClass().getSimpleName()); } } ",
        "test_tgt": "@Test public void testThreshold() { float inten[] = new float[] { 0, 1, 0, 0, 3, 4, 4, 0, 0, 1, 0, 2, 0, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; GrayF32 img = new GrayF32(9, 8); img.data = inten; BoofTesting.checkSubImage(this, \"testThreshold\", true, img); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should pass validation if description is null or empty or whitespace\", method = \"validate(Object,Errors)\")public void validate_shouldPassValidationIfDescriptionIsNullOrEmptyOrWhitespace()throws Exception { ConceptSource conceptSource = new ConceptSource(); conceptSource.setName(\"New name\"); conceptSource.setDescription(null); Errors errors = new BindException(conceptSource, \"conceptSource\"); new ConceptSourceValidator().validate(conceptSource, errors); Assert.assertFalse(errors.hasFieldErrors(\"description\")); conceptSource.setDescription(\"\"); errors = new BindException(conceptSource, \"conceptSource\"); new ConceptSourceValidator().validate(conceptSource, errors); Assert.assertFalse(errors.hasFieldErrors(\"description\")); conceptSource.setDescription(\" \"); errors = new BindException(conceptSource, \"conceptSource\"); new ConceptSourceValidator().validate(conceptSource, errors); Assert.assertFalse(errors.hasFieldErrors(\"description\")); } ",
        "focal_tgt": "public void validate(Object obj, Errors errors)throws IllegalArgumentException { if(obj == null || ! (obj instanceof ConceptSource)) { throw new IllegalArgumentException(\"The parameter obj should not be null and must be of type \" + ConceptSource.class); } else { ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\"); ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"description\", \"error.null\"); ValidateUtil.validateFieldLengths(errors, obj.getClass(), \"name\", \"hl7Code\", \"uniqueId\", \"description\", \"retireReason\"); } } ",
        "focal_src": "public void validate(Object obj, Errors errors)throws IllegalArgumentException { if(obj == null || ! (obj instanceof ConceptSource)) { throw new IllegalArgumentException(\"The parameter obj should not be null and must be of type \" + ConceptSource.class); } else { ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"name\", \"error.name\"); ValidateUtil.validateFieldLengths(errors, obj.getClass(), \"name\", \"hl7Code\", \"uniqueId\", \"description\", \"retireReason\"); } } ",
        "test_tgt": "@Test public void validate_shouldFailValidationIfDescriptionIsNullOrEmptyOrWhitespace()throws Exception { ConceptSource conceptSource = new ConceptSource(); conceptSource.setName(\"New name\"); conceptSource.setDescription(null); Errors errors = new BindException(conceptSource, \"conceptSource\"); new ConceptSourceValidator().validate(conceptSource, errors); Assert.assertTrue(errors.hasFieldErrors(\"description\")); conceptSource.setDescription(\"\"); errors = new BindException(conceptSource, \"conceptSource\"); new ConceptSourceValidator().validate(conceptSource, errors); Assert.assertTrue(errors.hasFieldErrors(\"description\")); conceptSource.setDescription(\" \"); errors = new BindException(conceptSource, \"conceptSource\"); new ConceptSourceValidator().validate(conceptSource, errors); Assert.assertTrue(errors.hasFieldErrors(\"description\")); } "
    },
    {
        "test_src": "@Test public void horizontal() { Kernel1D_I32 kernel = new Kernel1D_I32(new int[] { 1, 2, 3, 4, 5, 6 }, 4, 6); ImageUInt8 input = new ImageUInt8(15, 16); ImageMiscOps.fillUniform(input, rand, 0, 50); ImageUInt8 output = new ImageUInt8(15, 16); ConvolveNormalizedNaive.horizontal(kernel, input, output); for(int y = 0; y < output.height; y ++ ) { for(int x = 0; x < output.width; x ++ ) { int expected = horizontal(x, y, kernel, input); int found = output.get(x, y); assertEquals(x + \" \" + y, expected, found); } } } ",
        "focal_tgt": "public void horizontal(ImageSingleBand img, ImageSingleBand dest) { Kernel1D ker = FactoryKernelGaussian.gaussian1D(img.getClass(), - 1, kernelRadius); GImageMiscOps.fill(dest, 0); invokeMethod(\"horizontal\", ker, img, dest); double expected = horizontal(1, 1, img, ker, kernelRadius, 2 * kernelRadius + 1); assertEquals(expected, get(dest, 1, 1), 1e-6); assertEquals(0, get(dest, 0, 3), 1e-6); assertEquals(0, get(dest, width - 1, 3), 1e-6); GImageMiscOps.fill(dest, 0); ker.offset = 0; invokeMethod(\"horizontal\", ker, img, dest); expected = horizontal(1, 1, img, ker, 0, 2 * kernelRadius + 1); assertEquals(expected, get(dest, 1, 1), 1e-6); assertTrue(0 != get(dest, 0, 3)); assertEquals(0, get(dest, width - 2, 3), 1e-6); assertEquals(0, get(dest, width - 1, 3), 1e-6); } ",
        "focal_src": "public void horizontal(ImageSingleBand img, ImageSingleBand dest) { Kernel1D ker = FactoryKernelGaussian.gaussian1D(img.getClass(), - 1, kernelRadius); GImageMiscOps.fill(dest, 0); invokeMethod(\"horizontal\", ker, img, dest); double expected = horizontal(1, 1, img, ker, kernelRadius, 2 * kernelRadius + 1); assertEquals(expected, get(dest, 1, 1), 1e-6); assertEquals(0, get(dest, 0, 3), 1e-6); assertEquals(0, get(dest, width - 1, 3), 1e-6); GImageMiscOps.fill(dest, 0); ((Kernel1D)ker).offset = 0; invokeMethod(\"horizontal\", ker, img, dest); expected = horizontal(1, 1, img, ker, 0, 2 * kernelRadius + 1); assertEquals(expected, get(dest, 1, 1), 1e-6); assertTrue(0 != get(dest, 0, 3)); assertEquals(0, get(dest, width - 2, 3), 1e-6); assertEquals(0, get(dest, width - 1, 3), 1e-6); } ",
        "test_tgt": "@Test public void horizontal() { Kernel1D_I32 kernel = new Kernel1D_I32(new int[] { 1, 2, 3, 4, 5, 6 }, 6, 4); ImageUInt8 input = new ImageUInt8(15, 16); ImageMiscOps.fillUniform(input, rand, 0, 50); ImageUInt8 output = new ImageUInt8(15, 16); ConvolveNormalizedNaive.horizontal(kernel, input, output); for(int y = 0; y < output.height; y ++ ) { for(int x = 0; x < output.width; x ++ ) { int expected = horizontal(x, y, kernel, input); int found = output.get(x, y); assertEquals(x + \" \" + y, expected, found); } } } "
    },
    {
        "test_src": "@Test public void canPutKeyValueTest()throws Exception { long size = mWriter.byteCount() + KEY1.length + VALUE1.length + 2 * Constants.BYTES_IN_INTEGER; TachyonConf originalConf = ClientContext.getConf(); TachyonConf conf = new TachyonConf(); conf.set(Constants.KEY_VALUE_PARTITION_SIZE_BYTES_MAX, String.valueOf(size)); ClientContext.reset(conf); mWriter = new BaseKeyValuePartitionWriter(mOutStream); Assert.assertTrue(mWriter.canPutKeyValue(KEY1, VALUE1)); mWriter.put(KEY1, VALUE1); Assert.assertFalse(mWriter.canPutKeyValue(KEY1, VALUE1)); ClientContext.reset(originalConf); } ",
        "focal_tgt": "boolean canPut(byte[]key, byte[]value); ",
        "focal_src": "boolean canPutKeyValue(byte[]key, byte[]value); ",
        "test_tgt": "@Test public void canPutKeyValueTest()throws Exception { long size = mWriter.byteCount() + KEY1.length + VALUE1.length + 2 * Constants.BYTES_IN_INTEGER; TachyonConf originalConf = ClientContext.getConf(); TachyonConf conf = new TachyonConf(); conf.set(Constants.KEY_VALUE_PARTITION_SIZE_BYTES_MAX, String.valueOf(size)); ClientContext.reset(conf); mWriter = new BaseKeyValuePartitionWriter(mOutStream); Assert.assertTrue(mWriter.canPut(KEY1, VALUE1)); mWriter.put(KEY1, VALUE1); Assert.assertFalse(mWriter.canPut(KEY1, VALUE1)); ClientContext.reset(originalConf); } "
    },
    {
        "test_src": "@Test public void testNegativeBinomialCdf() { logger.info(\"NegativeBinomialCdf\"); int n = 10; int r = 4; double p = 0.5; double expResult = 0.12705078125; double result = DiscreteDistributions.NegativeBinomialCdf(n, r, p); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } ",
        "focal_tgt": "public static double negativeBinomialCdf(int n, int r, double p) { if(n < 0 || r < 0 || p < 0) { throw new IllegalArgumentException(\"All the parameters must be positive.\"); } n = Math.max(n, r); double probabilitySum = 0.0; for(int i = 0; i <= r; ++ i) { probabilitySum += negativeBinomial(n, i, p); } return probabilitySum; } ",
        "focal_src": "public static double NegativeBinomialCdf(int n, int r, double p) { if(n < 0 || r < 0 || p < 0) { throw new IllegalArgumentException(\"All the parameters must be positive.\"); } n = Math.max(n, r); double probabilitySum = 0.0; for(int i = 0; i <= r; ++ i) { probabilitySum += NegativeBinomial(n, i, p); } return probabilitySum; } ",
        "test_tgt": "@Test public void testNegativeBinomialCdf() { logger.info(\"NegativeBinomialCdf\"); int n = 10; int r = 4; double p = 0.5; double expResult = 0.12705078125; double result = DiscreteDistributions.negativeBinomialCdf(n, r, p); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); } "
    },
    {
        "test_src": "@Test public void testGetNeighborsND() { defaultSetup(); parameters.setInputDimensions(new int[] { 9, 5 }); initSP(); int[]result = sp.getNeighborsND(new SparseBinaryMatrix(new int[] { 9, 5 }), 2, 3, true); int[]expected = new int[] { 0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44 }; for(int i = 0; i < result.length; i ++ ) { assertEquals(expected[i], result[i]); } defaultSetup(); int[]dimensions = new int[] { 5, 7, 2 }; parameters.setInputDimensions(dimensions); initSP(); SparseBinaryMatrix layout = new SparseBinaryMatrix(dimensions); int radius = 1; int x = 1; int y = 3; int z = 2; int columnIndex = layout.computeIndex(new int[] { z, y, x }); int[]neighbors = sp.getNeighborsND(layout, columnIndex, radius, true); String expect = \"[18, 19, 20, 21, 22, 23, 32, 33, 34, 36, 37, 46, 47, 48, 49, 50, 51]\"; assertEquals(expect, ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 5, 7, 9 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); radius = 3; x = 0; y = 0; z = 3; columnIndex = layout.computeIndex(new int[] { z, y, x }); neighbors = sp.getNeighborsND(layout, columnIndex, radius, true); expect = \"[0, 1, 2, 3, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, \" + \"27, 28, 29, 30, 33, 34, 35, 36, 37, 38, 39, 42, 43, 44, 45, 46, 47, 48, 51, \" + \"52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 69, 70, 71, 72, 73, 74, \" + \"75, 78, 79, 80, 81, 82, 83, 84, 87, 88, 89, 90, 91, 92, 93, 96, 97, 98, 99, \" + \"100, 101, 102, 105, 106, 107, 108, 109, 110, 111, 114, 115, 116, 117, 118, 119, \" + \"120, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 141, \" + \"142, 143, 144, 145, 146, 147, 150, 151, 152, 153, 154, 155, 156, 159, 160, 161, \" + \"162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 177, 178, 179, 180, 181, \" + \"182, 183, 186, 187, 188, 190, 191, 192, 195, 196, 197, 198, 199, 200, 201, 204, \" + \"205, 206, 207, 208, 209, 210, 213, 214, 215, 216, 217, 218, 219, 222, 223, 224, \" + \"225, 226, 227, 228, 231, 232, 233, 234, 235, 236, 237, 240, 241, 242, 243, 244, \" + \"245, 246, 249, 250, 251, 252, 253, 254, 255, 258, 259, 260, 261, 262, 263, 264, \" + \"267, 268, 269, 270, 271, 272, 273, 276, 277, 278, 279, 280, 281, 282, 285, 286, \" + \"287, 288, 289, 290, 291, 294, 295, 296, 297, 298, 299, 300, 303, 304, 305, 306, \" + \"307, 308, 309, 312, 313, 314]\"; assertEquals(expect, ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 5, 10, 7, 6 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); radius = 4; int w = 2; x = 5; y = 6; z = 2; columnIndex = layout.computeIndex(new int[] { z, y, x, w }); neighbors = sp.getNeighborsND(layout, columnIndex, radius, true); TIntHashSet trueNeighbors = new TIntHashSet(); for(int i = - radius; i <= radius; i ++ ) { for(int j = - radius; j <= radius; j ++ ) { for(int k = - radius; k <= radius; k ++ ) { for(int m = - radius; m <= radius; m ++ ) { int zprime = (int)ArrayUtils.positiveRemainder((z + i), dimensions[0]); int yprime = (int)ArrayUtils.positiveRemainder((y + j), dimensions[1]); int xprime = (int)ArrayUtils.positiveRemainder((x + k), dimensions[2]); int wprime = (int)ArrayUtils.positiveRemainder((w + m), dimensions[3]); trueNeighbors.add(layout.computeIndex(new int[] { zprime, yprime, xprime, wprime })); } } } } trueNeighbors.remove(columnIndex); int[]tneighbors = ArrayUtils.unique(trueNeighbors.toArray()); assertEquals(ArrayUtils.print1DArray(tneighbors), ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 2, 4 }, new int[] { 1, 1 }); radius = 1; columnIndex = 3; int[]mask = sp.getNeighborsND(layout, columnIndex, radius, true); TIntArrayList msk = new TIntArrayList(mask); TIntArrayList neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 1, 2, 4, 5 }, new int[] { 1, 1, 1, 1 }); radius = 2; columnIndex = 3; mask = sp.getNeighborsND(layout, columnIndex, radius, true); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 1, 2, 6, 7 }, new int[] { 1, 1, 1, 1 }); radius = 2; columnIndex = 0; mask = sp.getNeighborsND(layout, columnIndex, radius, true); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 0, 1, 2, 3, 4, 5, 7 }, new int[] { 1, 1, 1, 1, 1, 1, 1 }); radius = 20; columnIndex = 6; mask = sp.getNeighborsND(layout, columnIndex, radius, true); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); int[][]input = new int[][] { { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 1, 1, 1, 0 }, { 0, 1, 0, 1, 0 }, { 0, 1, 1, 1, 0 }, { 0, 0, 0, 0, 0 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 1; columnIndex = 3 * 5 + 2; mask = sp.getNeighborsND(layout, columnIndex, radius, true); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); input = new int[][] { { 0, 0, 0, 0, 0 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 0, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 2; columnIndex = 3 * 5 + 2; mask = sp.getNeighborsND(layout, columnIndex, radius, true); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); input = new int[][] { { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 0, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 7; columnIndex = 3 * 5 + 2; mask = sp.getNeighborsND(layout, columnIndex, radius, true); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); input = new int[][] { { 1, 0, 0, 1, 1 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 1, 0, 0, 1, 1 }, { 1, 0, 0, 1, 0 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 1; columnIndex = layout.getMaxIndex(); mask = sp.getNeighborsND(layout, columnIndex, radius, true); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); } ",
        "focal_tgt": "public < M extends SparseMatrix > TIntArrayList getNeighborsND(M poolerMem, int columnIndex, int radius, boolean wrapAround) { int[]columnCoords = poolerMem.computeCoordinates(columnIndex); List < int[] > dimensionCoords = new ArrayList < int[] > (); for(int i = 0; i < inputDimensions.length; i ++ ) { int[]range = ArrayUtils.range(columnCoords[i] - radius, columnCoords[i] + radius + 1); int[]curRange = new int[range.length]; if(wrapAround) { for(int j = 0; j < curRange.length; j ++ ) { curRange[j] = (int)ArrayUtils.positiveRemainder(range[j], inputDimensions[i]); } } else { curRange = range; } dimensionCoords.add(ArrayUtils.unique(curRange)); } List < TIntList > neighborList = ArrayUtils.dimensionsToCoordinateList(dimensionCoords); TIntArrayList neighbors = new TIntArrayList(neighborList.size()); for(int i = 0; i < neighborList.size(); i ++ ) { int flatIndex = poolerMem.computeIndex(neighborList.get(i).toArray()); if(flatIndex == columnIndex)continue; neighbors.add(flatIndex); } return neighbors; } ",
        "focal_src": "public < M extends SparseMatrix > int[]getNeighborsND(M poolerMem, int columnIndex, int radius, boolean wrapAround) { int[]columnCoords = poolerMem.computeCoordinates(columnIndex); List < int[] > dimensionCoords = new ArrayList < int[] > (); for(int i = 0; i < inputDimensions.length; i ++ ) { int[]range = ArrayUtils.range(columnCoords[i] - radius, columnCoords[i] + radius + 1); int[]curRange = new int[range.length]; if(wrapAround) { for(int j = 0; j < curRange.length; j ++ ) { curRange[j] = (int)ArrayUtils.positiveRemainder(range[j], inputDimensions[i]); } } else { curRange = range; } dimensionCoords.add(ArrayUtils.unique(curRange)); } List < TIntList > neighborList = ArrayUtils.dimensionsToCoordinateList(dimensionCoords); TIntList neighbors = new TIntArrayList(neighborList.size()); for(int i = 0; i < neighborList.size(); i ++ ) { int flatIndex = poolerMem.computeIndex(neighborList.get(i).toArray()); if(flatIndex == columnIndex)continue; neighbors.add(flatIndex); } return neighbors.toArray(); } ",
        "test_tgt": "@Test public void testGetNeighborsND() { defaultSetup(); parameters.setInputDimensions(new int[] { 9, 5 }); parameters.setColumnDimensions(new int[] { 5, 5 }); initSP(); int[]result = sp.getNeighborsND(new SparseBinaryMatrix(new int[] { 9, 5 }), 2, 3, true).toArray(); int[]expected = new int[] { 0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44 }; for(int i = 0; i < result.length; i ++ ) { assertEquals(expected[i], result[i]); } defaultSetup(); int[]dimensions = new int[] { 5, 7, 2 }; parameters.setInputDimensions(dimensions); initSP(); SparseBinaryMatrix layout = new SparseBinaryMatrix(dimensions); int radius = 1; int x = 1; int y = 3; int z = 2; int columnIndex = layout.computeIndex(new int[] { z, y, x }); int[]neighbors = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); String expect = \"[18, 19, 20, 21, 22, 23, 32, 33, 34, 36, 37, 46, 47, 48, 49, 50, 51]\"; assertEquals(expect, ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 5, 7, 9 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); radius = 3; x = 0; y = 0; z = 3; columnIndex = layout.computeIndex(new int[] { z, y, x }); neighbors = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); expect = \"[0, 1, 2, 3, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, \" + \"27, 28, 29, 30, 33, 34, 35, 36, 37, 38, 39, 42, 43, 44, 45, 46, 47, 48, 51, \" + \"52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 69, 70, 71, 72, 73, 74, \" + \"75, 78, 79, 80, 81, 82, 83, 84, 87, 88, 89, 90, 91, 92, 93, 96, 97, 98, 99, \" + \"100, 101, 102, 105, 106, 107, 108, 109, 110, 111, 114, 115, 116, 117, 118, 119, \" + \"120, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 141, \" + \"142, 143, 144, 145, 146, 147, 150, 151, 152, 153, 154, 155, 156, 159, 160, 161, \" + \"162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 177, 178, 179, 180, 181, \" + \"182, 183, 186, 187, 188, 190, 191, 192, 195, 196, 197, 198, 199, 200, 201, 204, \" + \"205, 206, 207, 208, 209, 210, 213, 214, 215, 216, 217, 218, 219, 222, 223, 224, \" + \"225, 226, 227, 228, 231, 232, 233, 234, 235, 236, 237, 240, 241, 242, 243, 244, \" + \"245, 246, 249, 250, 251, 252, 253, 254, 255, 258, 259, 260, 261, 262, 263, 264, \" + \"267, 268, 269, 270, 271, 272, 273, 276, 277, 278, 279, 280, 281, 282, 285, 286, \" + \"287, 288, 289, 290, 291, 294, 295, 296, 297, 298, 299, 300, 303, 304, 305, 306, \" + \"307, 308, 309, 312, 313, 314]\"; assertEquals(expect, ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 5, 10, 7, 6 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); radius = 4; int w = 2; x = 5; y = 6; z = 2; columnIndex = layout.computeIndex(new int[] { z, y, x, w }); neighbors = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); TIntHashSet trueNeighbors = new TIntHashSet(); for(int i = - radius; i <= radius; i ++ ) { for(int j = - radius; j <= radius; j ++ ) { for(int k = - radius; k <= radius; k ++ ) { for(int m = - radius; m <= radius; m ++ ) { int zprime = (int)ArrayUtils.positiveRemainder((z + i), dimensions[0]); int yprime = (int)ArrayUtils.positiveRemainder((y + j), dimensions[1]); int xprime = (int)ArrayUtils.positiveRemainder((x + k), dimensions[2]); int wprime = (int)ArrayUtils.positiveRemainder((w + m), dimensions[3]); trueNeighbors.add(layout.computeIndex(new int[] { zprime, yprime, xprime, wprime })); } } } } trueNeighbors.remove(columnIndex); int[]tneighbors = ArrayUtils.unique(trueNeighbors.toArray()); assertEquals(ArrayUtils.print1DArray(tneighbors), ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 2, 4 }, new int[] { 1, 1 }); radius = 1; columnIndex = 3; int[]mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); TIntArrayList msk = new TIntArrayList(mask); TIntArrayList neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 1, 2, 4, 5 }, new int[] { 1, 1, 1, 1 }); radius = 2; columnIndex = 3; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 1, 2, 6, 7 }, new int[] { 1, 1, 1, 1 }); radius = 2; columnIndex = 0; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 0, 1, 2, 3, 4, 5, 7 }, new int[] { 1, 1, 1, 1, 1, 1, 1 }); radius = 20; columnIndex = 6; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); int[][]input = new int[][] { { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 1, 1, 1, 0 }, { 0, 1, 0, 1, 0 }, { 0, 1, 1, 1, 0 }, { 0, 0, 0, 0, 0 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 1; columnIndex = 3 * 5 + 2; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); input = new int[][] { { 0, 0, 0, 0, 0 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 0, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 2; columnIndex = 3 * 5 + 2; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); input = new int[][] { { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 0, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 7; columnIndex = 3 * 5 + 2; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); input = new int[][] { { 1, 0, 0, 1, 1 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 1, 0, 0, 1, 1 }, { 1, 0, 0, 1, 0 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 1; columnIndex = layout.getMaxIndex(); mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); } "
    },
    {
        "test_src": "@Test public void test_presentValue() { ScenarioMarketData md = DsfTradeCalculationFunctionTest.marketData(); RatesProvider provider = RATES_LOOKUP.marketDataView(md.scenario(0)).ratesProvider(); DiscountingDsfTradePricer pricer = DiscountingDsfTradePricer.DEFAULT; CurrencyAmount expectedPv = pricer.presentValue(RTRADE, provider, REF_PRICE); MultiCurrencyAmount expectedCurrencyExposure = pricer.currencyExposure(RTRADE, provider, REF_PRICE); AssertJUnit.assertEquals(DsfTradeCalculations.DEFAULT.presentValue(RTRADE, RATES_LOOKUP, md), CurrencyValuesArray.of(ImmutableList.of(expectedPv))); AssertJUnit.assertEquals(DsfTradeCalculations.DEFAULT.currencyExposure(RTRADE, RATES_LOOKUP, md), MultiCurrencyValuesArray.of(ImmutableList.of(expectedCurrencyExposure))); } ",
        "focal_tgt": "public CurrencyScenarioArray presentValue(ResolvedTermDepositTrade trade, RatesMarketDataLookup lookup, ScenarioMarketData marketData) { return calc.presentValue(trade, lookup.marketDataView(marketData)); } ",
        "focal_src": "public CurrencyValuesArray presentValue(ResolvedTermDepositTrade trade, RatesMarketDataLookup lookup, ScenarioMarketData marketData) { return calc.presentValue(trade, lookup.marketDataView(marketData)); } ",
        "test_tgt": "@Test public void test_presentValue() { ScenarioMarketData md = DsfTradeCalculationFunctionTest.marketData(); RatesProvider provider = RATES_LOOKUP.marketDataView(md.scenario(0)).ratesProvider(); DiscountingDsfTradePricer pricer = DiscountingDsfTradePricer.DEFAULT; CurrencyAmount expectedPv = pricer.presentValue(RTRADE, provider, REF_PRICE); MultiCurrencyAmount expectedCurrencyExposure = pricer.currencyExposure(RTRADE, provider, REF_PRICE); AssertJUnit.assertEquals(DsfTradeCalculations.DEFAULT.presentValue(RTRADE, RATES_LOOKUP, md), CurrencyScenarioArray.of(ImmutableList.of(expectedPv))); AssertJUnit.assertEquals(DsfTradeCalculations.DEFAULT.currencyExposure(RTRADE, RATES_LOOKUP, md), MultiCurrencyScenarioArray.of(ImmutableList.of(expectedCurrencyExposure))); } "
    },
    {
        "test_src": "@Test public void sessionId()throws Exception { assertEquals(\"1\", get(\"?query=\" + request(\"count(S:session-id())\"))); } ",
        "focal_tgt": "@Deterministic@Requires(Permission.NONE)public Str id()throws QueryException { return Str.get(session().getId()); } ",
        "focal_src": "@Deterministic@Requires(Permission.NONE)public String sessionId()throws QueryException { return session().getId(); } ",
        "test_tgt": "@Test public void sessionId()throws Exception { assertEquals(\"1\", get(\"?query=\" + request(\"count(S:id())\"))); } "
    },
    {
        "test_src": "@Test public void testOnCreateOrUpdateJob()throws GeniePreconditionException { Assert.assertNull(this.job.getId()); Assert.assertNull(this.job.getClusterCriteriasString()); Assert.assertNull(this.job.getCommandCriteriaString()); this.job.onCreateAuditable(); this.job.onCreateOrUpdateCommonEntityFields(); this.job.onCreateOrUpdateJob(); Assert.assertNotNull(this.job.getId()); Assert.assertNotNull(this.job.getClusterCriteriasString()); Assert.assertNotNull(this.job.getCommandCriteriaString()); Assert.assertTrue(this.job.getTags().contains(this.job.getId())); Assert.assertTrue(this.job.getTags().contains(NAME)); } ",
        "focal_tgt": "@PrePersist@PreUpdate protected void onCreateOrUpdateJob()throws GeniePreconditionException { this.validate(this.commandCriteria, this.commandArgs, this.clusterCriterias, null); this.clusterCriteriasString = clusterCriteriasToString(this.clusterCriterias); this.commandCriteriaString = commandCriteriaToString(this.commandCriteria); if(this.tags == null) { this.tags = new HashSet < > (); } this.tags.add(this.getId()); } ",
        "focal_src": "@PrePersist@PreUpdate protected void onCreateOrUpdateJob()throws GeniePreconditionException { this.validate(this.commandCriteria, this.commandArgs, this.clusterCriterias, null); this.clusterCriteriasString = clusterCriteriasToString(this.clusterCriterias); this.commandCriteriaString = commandCriteriaToString(this.commandCriteria); if(this.tags == null) { this.tags = new HashSet < > (); } this.tags.add(this.getId()); this.tags.add(this.getName()); } ",
        "test_tgt": "@Test public void testOnCreateOrUpdateJob()throws GeniePreconditionException { Assert.assertNull(this.job.getId()); Assert.assertNull(this.job.getClusterCriteriasString()); Assert.assertNull(this.job.getCommandCriteriaString()); this.job.onCreateAuditable(); this.job.onCreateOrUpdateCommonEntityFields(); this.job.onCreateOrUpdateJob(); Assert.assertNotNull(this.job.getId()); Assert.assertNotNull(this.job.getClusterCriteriasString()); Assert.assertNotNull(this.job.getCommandCriteriaString()); Assert.assertTrue(this.job.getTags().contains(this.job.getId())); } "
    },
    {
        "test_src": "@Test@PrepareForTest(CompressionLoader.class)public void deserializeNextRecordTest()throws IOException { final StringRecord record = new StringRecord(\"abc\"); Decompressor decompressorMock = mock(Decompressor.class); this.uncompressedDataBuffer = mock(Buffer.class); BufferPairResponse bufferPair = new BufferPairResponse(this.uncompressedDataBuffer, this.uncompressedDataBuffer); PowerMockito.mockStatic(CompressionLoader.class); when(CompressionLoader.getDecompressorByCompressionLevel(Matchers.any(CompressionLevel.class))).thenReturn(decompressorMock); @SuppressWarnings(\"unchecked\")final InputGate < StringRecord > inGate = mock(InputGate.class); final ByteBufferedInputChannelBroker inputBroker = mock(ByteBufferedInputChannelBroker.class); when(inputBroker.getReadBufferToConsume()).thenReturn(bufferPair); try { when(this.deserializationBuffer.readData(Matchers.any(ReadableByteChannel.class))).thenReturn(null, record); } catch(IOException e) { } when(this.uncompressedDataBuffer.remaining()).thenReturn(0); final FileInputChannel < StringRecord > fileInputChannel = new FileInputChannel < StringRecord > (inGate, 1, this.deserializer, null, CompressionLevel.NO_COMPRESSION); fileInputChannel.setInputChannelBroker(inputBroker); Whitebox.setInternalState(fileInputChannel, \"deserializationBuffer\", this.deserializationBuffer); try { fileInputChannel.readRecord(); } catch(IOException e) { fail(StringUtils.stringifyException(e)); } try { fileInputChannel.close(); } catch(IOException e) { fail(StringUtils.stringifyException(e)); } catch(InterruptedException e) { fail(StringUtils.stringifyException(e)); } assertEquals(false, fileInputChannel.isClosed()); fileInputChannel.processEvent(new ByteBufferedChannelCloseEvent()); assertEquals(true, fileInputChannel.isClosed()); try { fileInputChannel.readRecord(); fail(); } catch(EOFException e) { } catch(IOException e) { e.printStackTrace(); fail(); } } ",
        "focal_tgt": "private T deserializeNextRecord(final T target)throws IOException { if(this.bufferedRecord != null) { final T record = this.bufferedRecord; this.bufferedRecord = null; return record; } if(this.uncompressedDataBuffer == null) { synchronized(this.synchronisationObject) { if(this.ioException != null) { throw this.ioException; } requestReadBuffersFromBroker(); } if(this.uncompressedDataBuffer == null) { return null; } if(this.decompressor != null) { this.decompressor.decompress(); } } final T nextRecord = this.deserializationBuffer.readData(target, this.uncompressedDataBuffer); if(this.uncompressedDataBuffer.remaining() == 0) { releasedConsumedReadBuffer(); this.bufferedRecord = nextRecord; return null; } return nextRecord; } ",
        "focal_src": "private T deserializeNextRecord()throws IOException { if(this.bufferedRecord != null) { final T record = this.bufferedRecord; this.bufferedRecord = null; return record; } if(this.uncompressedDataBuffer == null) { synchronized(this.synchronisationObject) { if(this.ioException != null) { throw this.ioException; } requestReadBuffersFromBroker(); } if(this.uncompressedDataBuffer == null) { return null; } if(this.decompressor != null) { this.decompressor.decompress(); } } final T nextRecord = this.deserializationBuffer.readData(this.uncompressedDataBuffer); if(this.uncompressedDataBuffer.remaining() == 0) { releasedConsumedReadBuffer(); this.bufferedRecord = nextRecord; return null; } return nextRecord; } ",
        "test_tgt": "@Test@PrepareForTest(CompressionLoader.class)public void deserializeNextRecordTest()throws IOException, InterruptedException { StringRecord record = new StringRecord(\"abc\"); Decompressor decompressorMock = mock(Decompressor.class); this.uncompressedDataBuffer = mock(Buffer.class); BufferPairResponse bufferPair = new BufferPairResponse(this.uncompressedDataBuffer, this.uncompressedDataBuffer); PowerMockito.mockStatic(CompressionLoader.class); when(CompressionLoader.getDecompressorByCompressionLevel(Matchers.any(CompressionLevel.class), Matchers.any(FileInputChannel.class))).thenReturn(decompressorMock); @SuppressWarnings(\"unchecked\")final InputGate < StringRecord > inGate = mock(InputGate.class); final ByteBufferedInputChannelBroker inputBroker = mock(ByteBufferedInputChannelBroker.class); when(inputBroker.getReadBufferToConsume()).thenReturn(bufferPair); try { when(this.deserializationBuffer.readData(Matchers.any(StringRecord.class), Matchers.any(ReadableByteChannel.class))).thenReturn(null, record); } catch(IOException e) { } when(this.uncompressedDataBuffer.remaining()).thenReturn(0); final FileInputChannel < StringRecord > fileInputChannel = new FileInputChannel < StringRecord > (inGate, 1, this.deserializer, null, CompressionLevel.NO_COMPRESSION); fileInputChannel.setInputChannelBroker(inputBroker); Whitebox.setInternalState(fileInputChannel, \"deserializationBuffer\", this.deserializationBuffer); try { fileInputChannel.readRecord(null); } catch(IOException e) { fail(StringUtils.stringifyException(e)); } try { fileInputChannel.close(); } catch(IOException e) { fail(StringUtils.stringifyException(e)); } catch(InterruptedException e) { fail(StringUtils.stringifyException(e)); } assertEquals(false, fileInputChannel.isClosed()); fileInputChannel.processEvent(new ByteBufferedChannelCloseEvent()); assertEquals(true, fileInputChannel.isClosed()); try { fileInputChannel.readRecord(null); fail(); } catch(EOFException e) { } catch(IOException e) { e.printStackTrace(); fail(); } } "
    },
    {
        "test_src": "@Test public void testDescribeVersion()throws TTransportException, TException, UnknownHostException { CassandraCluster cassandraCluster = new CassandraClusterFactory(cassandraClient).create(); assertEquals(\"2.1.0\", cassandraCluster.describeVersion()); } ",
        "focal_tgt": "String describeThriftVersion()throws TTransportException, TException; ",
        "focal_src": "String describeVersion()throws TTransportException, TException; ",
        "test_tgt": "@Test public void testDescribeThriftVersion()throws TTransportException, TException, UnknownHostException { CassandraCluster cassandraCluster = new CassandraClusterFactory(cassandraClient).create(); assertEquals(\"2.1.0\", cassandraCluster.describeThriftVersion()); } "
    },
    {
        "test_src": "@Test(dataProvider = \"calendars\")public void test_date_comparisons(Chronology chrono) { List < ChronoLocalDate > dates = new ArrayList < > (); ChronoLocalDate < ? > date = chrono.date(LocalDate.of(2013, 1, 1)); dates.add(date.minus(1, ChronoUnit.YEARS)); dates.add(date.minus(1, ChronoUnit.MONTHS)); dates.add(date.minus(1, ChronoUnit.WEEKS)); dates.add(date.minus(1, ChronoUnit.DAYS)); dates.add(date); dates.add(date.plus(1, ChronoUnit.DAYS)); dates.add(date.plus(1, ChronoUnit.WEEKS)); dates.add(date.plus(1, ChronoUnit.MONTHS)); dates.add(date.plus(1, ChronoUnit.YEARS)); for(Chronology[]clist : data_of_calendars()) { List < ChronoLocalDate < ? > > otherDates = new ArrayList < > (); Chronology chrono2 = clist[0]; for(ChronoLocalDate < ? > d : dates) { otherDates.add(chrono2.date(d)); } for(int i = 0; i < dates.size(); i ++ ) { ChronoLocalDate < ? > a = dates.get(i); for(int j = 0; j < otherDates.size(); j ++ ) { ChronoLocalDate < ? > b = otherDates.get(j); int cmp = ChronoLocalDate.timeLineOrder().compare(a, b); if(i < j) { assertTrue(cmp < 0, a + \" compare \" + b); assertEquals(a.isBefore(b), true, a + \" isBefore \" + b); assertEquals(a.isAfter(b), false, a + \" isAfter \" + b); assertEquals(a.isEqual(b), false, a + \" isEqual \" + b); } else if(i > j) { assertTrue(cmp > 0, a + \" compare \" + b); assertEquals(a.isBefore(b), false, a + \" isBefore \" + b); assertEquals(a.isAfter(b), true, a + \" isAfter \" + b); assertEquals(a.isEqual(b), false, a + \" isEqual \" + b); } else { assertTrue(cmp == 0, a + \" compare \" + b); assertEquals(a.isBefore(b), false, a + \" isBefore \" + b); assertEquals(a.isAfter(b), false, a + \" isAfter \" + b); assertEquals(a.isEqual(b), true, a + \" isEqual \" + b); } } } } } ",
        "focal_tgt": "public ChronoLocalDate date(Era era, int yearOfEra, int month, int dayOfMonth) { return date(prolepticYear(era, yearOfEra), month, dayOfMonth); } ",
        "focal_src": "public ChronoLocalDate < ? > date(Era era, int yearOfEra, int month, int dayOfMonth) { return date(prolepticYear(era, yearOfEra), month, dayOfMonth); } ",
        "test_tgt": "@Test(dataProvider = \"calendars\")public void test_date_comparisons(Chronology chrono) { List < ChronoLocalDate > dates = new ArrayList < > (); ChronoLocalDate date = chrono.date(LocalDate.of(2013, 1, 1)); dates.add(date.minus(1, ChronoUnit.YEARS)); dates.add(date.minus(1, ChronoUnit.MONTHS)); dates.add(date.minus(1, ChronoUnit.WEEKS)); dates.add(date.minus(1, ChronoUnit.DAYS)); dates.add(date); dates.add(date.plus(1, ChronoUnit.DAYS)); dates.add(date.plus(1, ChronoUnit.WEEKS)); dates.add(date.plus(1, ChronoUnit.MONTHS)); dates.add(date.plus(1, ChronoUnit.YEARS)); for(Chronology[]clist : data_of_calendars()) { List < ChronoLocalDate > otherDates = new ArrayList < > (); Chronology chrono2 = clist[0]; for(ChronoLocalDate d : dates) { otherDates.add(chrono2.date(d)); } for(int i = 0; i < dates.size(); i ++ ) { ChronoLocalDate a = dates.get(i); for(int j = 0; j < otherDates.size(); j ++ ) { ChronoLocalDate b = otherDates.get(j); int cmp = ChronoLocalDate.timeLineOrder().compare(a, b); if(i < j) { assertTrue(cmp < 0, a + \" compare \" + b); assertEquals(a.isBefore(b), true, a + \" isBefore \" + b); assertEquals(a.isAfter(b), false, a + \" isAfter \" + b); assertEquals(a.isEqual(b), false, a + \" isEqual \" + b); } else if(i > j) { assertTrue(cmp > 0, a + \" compare \" + b); assertEquals(a.isBefore(b), false, a + \" isBefore \" + b); assertEquals(a.isAfter(b), true, a + \" isAfter \" + b); assertEquals(a.isEqual(b), false, a + \" isEqual \" + b); } else { assertTrue(cmp == 0, a + \" compare \" + b); assertEquals(a.isBefore(b), false, a + \" isBefore \" + b); assertEquals(a.isAfter(b), false, a + \" isAfter \" + b); assertEquals(a.isEqual(b), true, a + \" isEqual \" + b); } } } } } "
    },
    {
        "test_src": "@Test public void testNext()throws ServiceException, InterruptedException { final AbstractInvokable memOwner = new DummyInvokable(); reader = new CollectionIterator < PactInteger > (objects); SpillingResettableIterator < PactInteger > iterator = new SpillingResettableIterator < PactInteger > (memman, ioman, reader, SpillingResettableIterator.MIN_BUFFER_SIZE * SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS, deserializer, memOwner); try { iterator.open(); } catch(IOException e) { Assert.fail(\"Could not open resettable iterator:\" + e.getMessage()); } PactInteger record; int cnt = 0; while(cnt < NUM_TESTRECORDS) { record = iterator.next(); Assert.assertTrue(\"Record was not read from iterator\", record != null); cnt ++ ; } record = iterator.next(); Assert.assertTrue(\"Too many records were read from iterator\", record == null); iterator.close(); } ",
        "focal_tgt": "@Override public PactRecord next() { if(this.nextElement == null) { if( ! hasNext()) { throw new NoSuchElementException(); } } PactRecord out = this.nextElement; this.nextElement = null; return out; } ",
        "focal_src": "@Override public boolean next(PactRecord target)throws IOException { if(this.next == null) { if(this.bufferCurrentlyRead != null) { if(this.bufferCurrentlyRead.read(target)) { return true; } else { this.consumedBuffers.add(this.bufferCurrentlyRead); if(this.fullBuffers.isEmpty()) { this.bufferCurrentlyRead = null; return false; } else { this.bufferCurrentlyRead = this.fullBuffers.remove(0); if(this.bufferCurrentlyRead.read(target)) { return true; } else { throw new IOException(\"BlockResettableIterator: \" + \"BUG - Could not de-serialize element newly obtaint input block buffer.\"); } } } } else if(this.bufferCurrentlyFilled != null) { if(this.input.next(target)) { if(this.bufferCurrentlyFilled.write(target)) { return true; } else { final int fillPosition = this.bufferCurrentlyFilled.getPosition(); final MemorySegment seg = this.bufferCurrentlyFilled.dispose(); this.bufferCurrentlyFilled = null; final Buffer.Input in = new Buffer.Input(seg); in.reset(fillPosition); this.consumedBuffers.add(in); if(this.emptySegments.isEmpty()) { target.copyTo(this.leftOverRecord); this.leftOver = true; return false; } else { this.bufferCurrentlyFilled = new Buffer.Output(this.emptySegments.remove(this.emptySegments.size() - 1)); if(this.bufferCurrentlyFilled.write(target)) { return true; } else { throw new IOException(\"BlockResettableIterator: \" + \"Could not serialize element into fresh block buffer - element is too large.\"); } } } } else { this.noMoreBlocks = true; return false; } } else { if(this.closed) { throw new IllegalStateException(\"Iterator was closed.\"); } return false; } } else { this.next.copyTo(target); this.next = null; return true; } } ",
        "test_tgt": "@Test public void testNext()throws ServiceException, InterruptedException { final AbstractInvokable memOwner = new DummyInvokable(); reader = objects.iterator(); SpillingResettableIterator < PactInteger > iterator = new SpillingResettableIterator < PactInteger > (memman, ioman, reader, new PactInteger(), SpillingResettableIterator.MIN_BUFFER_SIZE * SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS, memOwner); try { iterator.open(); } catch(IOException e) { Assert.fail(\"Could not open resettable iterator:\" + e.getMessage()); } PactInteger record; int cnt = 0; while(cnt < NUM_TESTRECORDS) { record = iterator.next(); Assert.assertTrue(\"Record was not read from iterator\", record != null); cnt ++ ; } record = iterator.next(); Assert.assertTrue(\"Too many records were read from iterator\", record == null); iterator.close(); } "
    },
    {
        "test_src": "@Test public void listCertificateVersions()throws Exception { String certificateName = \"listCertificateVersions\"; String certificateContent = \"MIIJOwIBAzCCCPcGCSqGSIb3DQEHAaCCCOgEggjkMIII4DCCBgkGCSqGSIb3DQEHAaCCBfoEggX2MIIF8jCCBe4GCyqGSIb3DQEMCgECoIIE/jCCBPowHAYKKoZIhvcNAQwBAzAOBAj15YH9pOE58AICB9AEggTYLrI+SAru2dBZRQRlJY7XQ3LeLkah2FcRR3dATDshZ2h0IA2oBrkQIdsLyAAWZ32qYR1qkWxLHn9AqXgu27AEbOk35+pITZaiy63YYBkkpR+pDdngZt19Z0PWrGwHEq5z6BHS2GLyyN8SSOCbdzCz7blj3+7IZYoMj4WOPgOm/tQ6U44SFWek46QwN2zeA4i97v7ftNNns27ms52jqfhOvTA9c/wyfZKAY4aKJfYYUmycKjnnRl012ldS2lOkASFt+lu4QCa72IY6ePtRudPCvmzRv2pkLYS6z3cI7omT8nHP3DymNOqLbFqr5O2M1ZYaLC63Q3xt3eVvbcPh3N08D1hHkhz/KDTvkRAQpvrW8ISKmgDdmzN55Pe55xHfSWGB7gPw8sZea57IxFzWHTK2yvTslooWoosmGxanYY2IG/no3EbPOWDKjPZ4ilYJe5JJ2immlxPz+2e2EOCKpDI+7fzQcRz3PTd3BK+budZ8aXX8aW/lOgKS8WmxZoKnOJBNWeTNWQFugmktXfdPHAdxMhjUXqeGQd8wTvZ4EzQNNafovwkI7IV/ZYoa++RGofVR3ZbRSiBNF6TDj/qXFt0wN/CQnsGAmQAGNiN+D4mY7i25dtTu/Jc7OxLdhAUFpHyJpyrYWLfvOiS5WYBeEDHkiPUa/8eZSPA3MXWZR1RiuDvuNqMjct1SSwdXADTtF68l/US1ksU657+XSC+6ly1A/upz+X71+C4Ho6W0751j5ZMT6xKjGh5pee7MVuduxIzXjWIy3YSd0fIT3U0A5NLEvJ9rfkx6JiHjRLx6V1tqsrtT6BsGtmCQR1UCJPLqsKVDvAINx3cPA/CGqr5OX2BGZlAihGmN6n7gv8w4O0k0LPTAe5YefgXN3m9pE867N31GtHVZaJ/UVgDNYS2jused4rw76ZWN41akx2QN0JSeMJqHXqVz6AKfz8ICS/dFnEGyBNpXiMRxrY/QPKi/wONwqsbDxRW7vZRVKs78pBkE0ksaShlZk5GkeayDWC/7Hi/NqUFtIloK9XB3paLxo1DGu5qqaF34jZdktzkXp0uZqpp+FfKZaiovMjt8F7yHCPk+LYpRsU2Cyc9DVoDA6rIgf+uEP4jppgehsxyT0lJHax2t869R2jYdsXwYUXjgwHIV0voj7bJYPGFlFjXOp6ZW86scsHM5xfsGQoK2Fp838VT34SHE1ZXU/puM7rviREHYW72pfpgGZUILQMohuTPnd8tFtAkbrmjLDo+k9xx7HUvgoFTiNNWuq/cRjr70FKNguMMTIrid+HwfmbRoaxENWdLcOTNeascER2a+37UQolKD5ksrPJG6RdNA7O2pzp3micDYRs/+s28cCIxO//J/d4nsgHp6RTuCu4+Jm9k0YTw2Xg75b2cWKrxGnDUgyIlvNPaZTB5QbMid4x44/lE0LLi9kcPQhRgrK07OnnrMgZvVGjt1CLGhKUv7KFc3xV1r1rwKkosxnoG99oCoTQtregcX5rIMjHgkc1IdflGJkZzaWMkYVFOJ4Weynz008i4ddkske5vabZs37Lb8iggUYNBYZyGzalruBgnQyK4fz38Fae4nWYjyildVfgyo/fCePR2ovOfphx9OQJi+M9BoFmPrAg+8ARDZ+R+5yzYuEc9ZoVX7nkp7LTGB3DANBgkrBgEEAYI3EQIxADATBgkqhkiG9w0BCRUxBgQEAQAAADBXBgkqhkiG9w0BCRQxSh5IAGEAOAAwAGQAZgBmADgANgAtAGUAOQA2AGUALQA0ADIAMgA0AC0AYQBhADEAMQAtAGIAZAAxADkANABkADUAYQA2AGIANwA3MF0GCSsGAQQBgjcRATFQHk4ATQBpAGMAcgBvAHMAbwBmAHQAIABTAHQAcgBvAG4AZwAgAEMAcgB5AHAAdABvAGcAcgBhAHAAaABpAGMAIABQAHIAbwB2AGkAZABlAHIwggLPBgkqhkiG9w0BBwagggLAMIICvAIBADCCArUGCSqGSIb3DQEHATAcBgoqhkiG9w0BDAEGMA4ECNX+VL2MxzzWAgIH0ICCAojmRBO+CPfVNUO0s+BVuwhOzikAGNBmQHNChmJ/pyzPbMUbx7tO63eIVSc67iERda2WCEmVwPigaVQkPaumsfp8+L6iV/BMf5RKlyRXcwh0vUdu2Qa7qadD+gFQ2kngf4Dk6vYo2/2HxayuIf6jpwe8vql4ca3ZtWXfuRix2fwgltM0bMz1g59d7x/glTfNqxNlsty0A/rWrPJjNbOPRU2XykLuc3AtlTtYsQ32Zsmu67A7UNBw6tVtkEXlFDqhavEhUEO3dvYqMY+QLxzpZhA0q44ZZ9/ex0X6QAFNK5wuWxCbupHWsgxRwKftrxyszMHsAvNoNcTlqcctee+ecNwTJQa1/MDbnhO6/qHA7cfG1qYDq8Th635vGNMW1w3sVS7l0uEvdayAsBHWTcOC2tlMa5bfHrhY8OEIqj5bN5H9RdFy8G/W239tjDu1OYjBDydiBqzBn8HG1DSj1Pjc0kd/82d4ZU0308KFTC3yGcRad0GnEH0Oi3iEJ9HbriUbfVMbXNHOF+MktWiDVqzndGMKmuJSdfTBKvGFvejAWVO5E4mgLvoaMmbchc3BO7sLeraHnJN5hvMBaLcQI38N86mUfTR8AP6AJ9c2k514KaDLclm4z6J8dMz60nUeo5D3YD09G6BavFHxSvJ8MF0Lu5zOFzEePDRFm9mH8W0N/sFlIaYfD/GWU/w44mQucjaBk95YtqOGRIj58tGDWr8iUdHwaYKGqU24zGeRae9DhFXPzZshV1ZGsBQFRaoYkyLAwdJWIXTi+c37YaC8FRSEnnNmS79Dou1Kc3BvK4EYKAD2KxjtUebrV174gD0Q+9YuJ0GXOTspBvCFd5VT2Rw5zDNrA/J3F5fMCk4wOzAfMAcGBSsOAwIaBBSxgh2xyF+88V4vAffBmZXv8Txt4AQU4O/NX4MjxSodbE7ApNAMIvrtREwCAgfQ\"; String certificatePassword = \"123\"; SecretProperties secretProperties = new SecretProperties(); secretProperties.withContentType(MIME_PKCS12); CertificatePolicy certificatePolicy = new CertificatePolicy(); certificatePolicy.withSecretProperties(secretProperties); HashSet < String > certificates = new HashSet < String > (); for(int i = 0; i < MAX_CERTS; ++ i) { int failureCount = 0; for(; ; ) { try { CertificateBundle certificateBundle = keyVaultClient.importCertificate(new ImportCertificateRequest.Builder(getVaultUri(), certificateName, certificateContent).withPassword(certificatePassword).withPolicy(certificatePolicy).build()); CertificateIdentifier id = certificateBundle.certificateIdentifier(); certificates.add(id.identifier()); break; } catch(KeyVaultErrorException e) { ++ failureCount; if(e.getBody().error().code().equals(\"Throttled\")) { System.out.println(\"Waiting to avoid throttling\"); Thread.sleep(failureCount * 1500); continue; } throw e; } } } PagedList < CertificateItem > listResult = keyVaultClient.listCertificateVersions(getVaultUri(), certificateName, PAGELIST_MAX_CERTS); Assert.assertTrue(PAGELIST_MAX_CERTS >= listResult.currentPage().getItems().size()); listResult = keyVaultClient.listCertificateVersions(getVaultUri(), certificateName); for(CertificateItem item : listResult) { if(item != null) { certificates.remove(item.id()); } } Assert.assertEquals(0, certificates.size()); keyVaultClient.deleteCertificate(getVaultUri(), certificateName); } ",
        "focal_tgt": "public PagedList < CertificateItem > listCertificateVersions(final String vaultBaseUrl, final String certificateName) { return innerKeyVaultClient.getCertificateVersions(vaultBaseUrl, certificateName); } ",
        "focal_src": "public PagedList < CertificateItem > listCertificateVersions(final String vaultBaseUrl, final String certificateName)throws KeyVaultErrorException, IOException, IllegalArgumentException { return innerKeyVaultClient.getCertificateVersions(vaultBaseUrl, certificateName); } ",
        "test_tgt": "@Test public void listCertificateVersions()throws Exception { String certificateName = \"listCertificateVersions\"; String certificateContent = \"MIIJOwIBAzCCCPcGCSqGSIb3DQEHAaCCCOgEggjkMIII4DCCBgkGCSqGSIb3DQEHAaCCBfoEggX2MIIF8jCCBe4GCyqGSIb3DQEMCgECoIIE/jCCBPowHAYKKoZIhvcNAQwBAzAOBAj15YH9pOE58AICB9AEggTYLrI+SAru2dBZRQRlJY7XQ3LeLkah2FcRR3dATDshZ2h0IA2oBrkQIdsLyAAWZ32qYR1qkWxLHn9AqXgu27AEbOk35+pITZaiy63YYBkkpR+pDdngZt19Z0PWrGwHEq5z6BHS2GLyyN8SSOCbdzCz7blj3+7IZYoMj4WOPgOm/tQ6U44SFWek46QwN2zeA4i97v7ftNNns27ms52jqfhOvTA9c/wyfZKAY4aKJfYYUmycKjnnRl012ldS2lOkASFt+lu4QCa72IY6ePtRudPCvmzRv2pkLYS6z3cI7omT8nHP3DymNOqLbFqr5O2M1ZYaLC63Q3xt3eVvbcPh3N08D1hHkhz/KDTvkRAQpvrW8ISKmgDdmzN55Pe55xHfSWGB7gPw8sZea57IxFzWHTK2yvTslooWoosmGxanYY2IG/no3EbPOWDKjPZ4ilYJe5JJ2immlxPz+2e2EOCKpDI+7fzQcRz3PTd3BK+budZ8aXX8aW/lOgKS8WmxZoKnOJBNWeTNWQFugmktXfdPHAdxMhjUXqeGQd8wTvZ4EzQNNafovwkI7IV/ZYoa++RGofVR3ZbRSiBNF6TDj/qXFt0wN/CQnsGAmQAGNiN+D4mY7i25dtTu/Jc7OxLdhAUFpHyJpyrYWLfvOiS5WYBeEDHkiPUa/8eZSPA3MXWZR1RiuDvuNqMjct1SSwdXADTtF68l/US1ksU657+XSC+6ly1A/upz+X71+C4Ho6W0751j5ZMT6xKjGh5pee7MVuduxIzXjWIy3YSd0fIT3U0A5NLEvJ9rfkx6JiHjRLx6V1tqsrtT6BsGtmCQR1UCJPLqsKVDvAINx3cPA/CGqr5OX2BGZlAihGmN6n7gv8w4O0k0LPTAe5YefgXN3m9pE867N31GtHVZaJ/UVgDNYS2jused4rw76ZWN41akx2QN0JSeMJqHXqVz6AKfz8ICS/dFnEGyBNpXiMRxrY/QPKi/wONwqsbDxRW7vZRVKs78pBkE0ksaShlZk5GkeayDWC/7Hi/NqUFtIloK9XB3paLxo1DGu5qqaF34jZdktzkXp0uZqpp+FfKZaiovMjt8F7yHCPk+LYpRsU2Cyc9DVoDA6rIgf+uEP4jppgehsxyT0lJHax2t869R2jYdsXwYUXjgwHIV0voj7bJYPGFlFjXOp6ZW86scsHM5xfsGQoK2Fp838VT34SHE1ZXU/puM7rviREHYW72pfpgGZUILQMohuTPnd8tFtAkbrmjLDo+k9xx7HUvgoFTiNNWuq/cRjr70FKNguMMTIrid+HwfmbRoaxENWdLcOTNeascER2a+37UQolKD5ksrPJG6RdNA7O2pzp3micDYRs/+s28cCIxO//J/d4nsgHp6RTuCu4+Jm9k0YTw2Xg75b2cWKrxGnDUgyIlvNPaZTB5QbMid4x44/lE0LLi9kcPQhRgrK07OnnrMgZvVGjt1CLGhKUv7KFc3xV1r1rwKkosxnoG99oCoTQtregcX5rIMjHgkc1IdflGJkZzaWMkYVFOJ4Weynz008i4ddkske5vabZs37Lb8iggUYNBYZyGzalruBgnQyK4fz38Fae4nWYjyildVfgyo/fCePR2ovOfphx9OQJi+M9BoFmPrAg+8ARDZ+R+5yzYuEc9ZoVX7nkp7LTGB3DANBgkrBgEEAYI3EQIxADATBgkqhkiG9w0BCRUxBgQEAQAAADBXBgkqhkiG9w0BCRQxSh5IAGEAOAAwAGQAZgBmADgANgAtAGUAOQA2AGUALQA0ADIAMgA0AC0AYQBhADEAMQAtAGIAZAAxADkANABkADUAYQA2AGIANwA3MF0GCSsGAQQBgjcRATFQHk4ATQBpAGMAcgBvAHMAbwBmAHQAIABTAHQAcgBvAG4AZwAgAEMAcgB5AHAAdABvAGcAcgBhAHAAaABpAGMAIABQAHIAbwB2AGkAZABlAHIwggLPBgkqhkiG9w0BBwagggLAMIICvAIBADCCArUGCSqGSIb3DQEHATAcBgoqhkiG9w0BDAEGMA4ECNX+VL2MxzzWAgIH0ICCAojmRBO+CPfVNUO0s+BVuwhOzikAGNBmQHNChmJ/pyzPbMUbx7tO63eIVSc67iERda2WCEmVwPigaVQkPaumsfp8+L6iV/BMf5RKlyRXcwh0vUdu2Qa7qadD+gFQ2kngf4Dk6vYo2/2HxayuIf6jpwe8vql4ca3ZtWXfuRix2fwgltM0bMz1g59d7x/glTfNqxNlsty0A/rWrPJjNbOPRU2XykLuc3AtlTtYsQ32Zsmu67A7UNBw6tVtkEXlFDqhavEhUEO3dvYqMY+QLxzpZhA0q44ZZ9/ex0X6QAFNK5wuWxCbupHWsgxRwKftrxyszMHsAvNoNcTlqcctee+ecNwTJQa1/MDbnhO6/qHA7cfG1qYDq8Th635vGNMW1w3sVS7l0uEvdayAsBHWTcOC2tlMa5bfHrhY8OEIqj5bN5H9RdFy8G/W239tjDu1OYjBDydiBqzBn8HG1DSj1Pjc0kd/82d4ZU0308KFTC3yGcRad0GnEH0Oi3iEJ9HbriUbfVMbXNHOF+MktWiDVqzndGMKmuJSdfTBKvGFvejAWVO5E4mgLvoaMmbchc3BO7sLeraHnJN5hvMBaLcQI38N86mUfTR8AP6AJ9c2k514KaDLclm4z6J8dMz60nUeo5D3YD09G6BavFHxSvJ8MF0Lu5zOFzEePDRFm9mH8W0N/sFlIaYfD/GWU/w44mQucjaBk95YtqOGRIj58tGDWr8iUdHwaYKGqU24zGeRae9DhFXPzZshV1ZGsBQFRaoYkyLAwdJWIXTi+c37YaC8FRSEnnNmS79Dou1Kc3BvK4EYKAD2KxjtUebrV174gD0Q+9YuJ0GXOTspBvCFd5VT2Rw5zDNrA/J3F5fMCk4wOzAfMAcGBSsOAwIaBBSxgh2xyF+88V4vAffBmZXv8Txt4AQU4O/NX4MjxSodbE7ApNAMIvrtREwCAgfQ\"; String certificatePassword = \"123\"; SecretProperties secretProperties = new SecretProperties(); secretProperties.withContentType(MIME_PKCS12); CertificatePolicy certificatePolicy = new CertificatePolicy(); certificatePolicy.withSecretProperties(secretProperties); HashSet < String > certificates = new HashSet < String > (); for(int i = 0; i < MAX_CERTS; ++ i) { int failureCount = 0; for(; ; ) { try { CertificateBundle certificateBundle = keyVaultClient.importCertificate(new ImportCertificateRequest.Builder(getVaultUri(), certificateName, certificateContent).withPassword(certificatePassword).withPolicy(certificatePolicy).build()); CertificateIdentifier id = certificateBundle.certificateIdentifier(); certificates.add(id.identifier()); break; } catch(KeyVaultErrorException e) { ++ failureCount; if(e.body().error().code().equals(\"Throttled\")) { System.out.println(\"Waiting to avoid throttling\"); Thread.sleep(failureCount * 1500); continue; } throw e; } } } PagedList < CertificateItem > listResult = keyVaultClient.listCertificateVersions(getVaultUri(), certificateName, PAGELIST_MAX_CERTS); Assert.assertTrue(PAGELIST_MAX_CERTS >= listResult.currentPage().items().size()); listResult = keyVaultClient.listCertificateVersions(getVaultUri(), certificateName); for(CertificateItem item : listResult) { if(item != null) { certificates.remove(item.id()); } } Assert.assertEquals(0, certificates.size()); keyVaultClient.deleteCertificate(getVaultUri(), certificateName); } "
    },
    {
        "test_src": "@Test public void query()throws BaseXException { final Query query = session.query(\"1\"); check(\"1\", query.execute()); check(\"\", query.close()); } ",
        "focal_tgt": "public abstract Query query(final String query)throws IOException; ",
        "focal_src": "public abstract Query query(final String query)throws BaseXException; ",
        "test_tgt": "@Test public void query()throws IOException { final Query query = session.query(\"1\"); check(\"1\", query.execute()); check(\"\", query.close()); } "
    },
    {
        "test_src": "@Test public void getAsyncRequestResponseHandlerTest()throws InstantiationException { Properties properties = new Properties(); VerifiableProperties verifiableProperties = new VerifiableProperties(properties); Router router = new InMemoryRouter(verifiableProperties); BlobStorageService blobStorageService = new MockBlobStorageService(verifiableProperties, router); AsyncRequestResponseHandlerFactory responseHandlerFactory = new AsyncRequestResponseHandlerFactory(1, restServerMetrics); RestResponseHandler restResponseHandler = responseHandlerFactory.getRestResponseHandler(); assertNotNull(\"No RestResponseHandler returned\", restResponseHandler); assertEquals(\"Did not receive an AsyncRequestResponseHandler instance\", AsyncRequestResponseHandler.class.getCanonicalName(), restResponseHandler.getClass().getCanonicalName()); AsyncRequestResponseHandlerFactory requestHandlerFactory = new AsyncRequestResponseHandlerFactory(1, restServerMetrics, blobStorageService); RestRequestHandler restRequestHandler = requestHandlerFactory.getRestRequestHandler(); assertNotNull(\"No RestRequestHandler returned\", restRequestHandler); assertEquals(\"Did not receive an AsyncRequestResponseHandler instance\", AsyncRequestResponseHandler.class.getCanonicalName(), restRequestHandler.getClass().getCanonicalName()); assertEquals(\"Instances of AsyncRequestResponseHandler are not the same\", restResponseHandler, restRequestHandler); restRequestHandler.start(); restRequestHandler.shutdown(); } ",
        "focal_tgt": "private static AsyncRequestResponseHandler getAsyncRequestResponseHandler(int requestWorkers, int responseWorkers)throws IOException { RestServerMetrics serverMetrics = new RestServerMetrics(new MetricRegistry()); AsyncRequestResponseHandler handler = new AsyncRequestResponseHandler(serverMetrics); if(blobStorageService == null) { blobStorageService = new MockBlobStorageService(verifiableProperties, handler, router); } handler.setRequestWorkersCount(requestWorkers); handler.setResponseWorkersCount(responseWorkers); handler.setBlobStorageService(blobStorageService); return handler; } ",
        "focal_src": "private static AsyncRequestResponseHandler getAsyncRequestResponseHandler(BlobStorageService blobStorageService, int requestWorkers, int responseWorkers)throws IOException { RestServerMetrics serverMetrics = new RestServerMetrics(new MetricRegistry()); AsyncRequestResponseHandler handler = new AsyncRequestResponseHandler(serverMetrics); handler.setRequestWorkersCount(requestWorkers); handler.setResponseWorkersCount(responseWorkers); if(blobStorageService != null) { handler.setBlobStorageService(blobStorageService); } return handler; } ",
        "test_tgt": "@Test public void getAsyncRequestResponseHandlerTest()throws InstantiationException { Properties properties = new Properties(); VerifiableProperties verifiableProperties = new VerifiableProperties(properties); Router router = new InMemoryRouter(verifiableProperties); AsyncRequestResponseHandlerFactory responseHandlerFactory = new AsyncRequestResponseHandlerFactory(1, restServerMetrics); RestResponseHandler restResponseHandler = responseHandlerFactory.getRestResponseHandler(); assertNotNull(\"No RestResponseHandler returned\", restResponseHandler); assertEquals(\"Did not receive an AsyncRequestResponseHandler instance\", AsyncRequestResponseHandler.class.getCanonicalName(), restResponseHandler.getClass().getCanonicalName()); BlobStorageService blobStorageService = new MockBlobStorageService(verifiableProperties, restResponseHandler, router); AsyncRequestResponseHandlerFactory requestHandlerFactory = new AsyncRequestResponseHandlerFactory(1, restServerMetrics, blobStorageService); RestRequestHandler restRequestHandler = requestHandlerFactory.getRestRequestHandler(); assertNotNull(\"No RestRequestHandler returned\", restRequestHandler); assertEquals(\"Did not receive an AsyncRequestResponseHandler instance\", AsyncRequestResponseHandler.class.getCanonicalName(), restRequestHandler.getClass().getCanonicalName()); assertEquals(\"Instances of AsyncRequestResponseHandler are not the same\", restResponseHandler, restRequestHandler); restRequestHandler.start(); restRequestHandler.shutdown(); } "
    },
    {
        "test_src": "@Test public void testTrainC_ClassificationDataSet_ExecutorService() { System.out.println(\"trainC\"); ClassificationDataSet trainSet = FixedProblems.getInnerOuterCircle(150, new Random(2)); ClassificationDataSet testSet = FixedProblems.getInnerOuterCircle(50, new Random(3)); for(SupportVectorLearner.CacheMode cacheMode : SupportVectorLearner.CacheMode.values()) { LSSVM classifier = new LSSVM(new RBFKernel(0.5), cacheMode); classifier.setCacheMode(cacheMode); classifier.setC(1); classifier.train(trainSet, true); for(int i = 0; i < testSet.getSampleSize(); i ++ )assertEquals(testSet.getDataPointCategory(i), classifier.classify(testSet.getDataPoint(i)).mostLikely()); } } ",
        "focal_tgt": "public void trainC(ClassificationDataSet dataSet, Set < Integer > categoriesToUse) { if(categoriesToUse.size() > dataSet.getNumFeatures() + 1)throw new FailedToFitException(\"CPT can not train on a number of features greater then the dataset's feature count. \" + \"Specified \" + categoriesToUse.size() + \" but data set has only \" + dataSet.getNumFeatures()); CategoricalData[]tmp = dataSet.getCategories(); predicting = dataSet.getPredicting(); predictingIndex = dataSet.getNumCategoricalVars(); valid = new HashMap < Integer, CategoricalData > (); realIndexToCatIndex = new int[categoriesToUse.size()]; catIndexToRealIndex = new int[dataSet.getNumCategoricalVars() + 1]; Arrays.fill(catIndexToRealIndex, - 1); dimSize = new int[realIndexToCatIndex.length]; int flatSize = 1; int k = 0; for(int i : categoriesToUse) { if(i == predictingIndex)continue; CategoricalData dataInfo = tmp[i]; flatSize *= dataInfo.getNumOfCategories(); valid.put(i, dataInfo); realIndexToCatIndex[k] = i; catIndexToRealIndex[i] = k; dimSize[k ++ ] = dataInfo.getNumOfCategories(); } if(categoriesToUse.contains(predictingIndex)) { flatSize *= predicting.getNumOfCategories(); realIndexToCatIndex[k] = predictingIndex; catIndexToRealIndex[predictingIndex] = k; dimSize[k] = predicting.getNumOfCategories(); valid.put(predictingIndex, predicting); } countArray = new double[flatSize]; Arrays.fill(countArray, 1); int[]cordinate = new int[dimSize.length]; for(int i = 0; i < dataSet.size(); i ++ ) { DataPoint dp = dataSet.getDataPoint(i); for(int j = 0; j < realIndexToCatIndex.length; j ++ )if(realIndexToCatIndex[j] != predictingIndex)cordinate[j] = dp.getCategoricalValue(realIndexToCatIndex[j]); else cordinate[j] = dataSet.getDataPointCategory(i); countArray[cordToIndex(cordinate)] += dp.getWeight(); } } ",
        "focal_src": "public void trainC(ClassificationDataSet dataSet, Set < Integer > categoriesToUse) { if(categoriesToUse.size() > dataSet.getNumFeatures() + 1)throw new FailedToFitException(\"CPT can not train on a number of features greater then the dataset's feature count. \" + \"Specified \" + categoriesToUse.size() + \" but data set has only \" + dataSet.getNumFeatures()); CategoricalData[]tmp = dataSet.getCategories(); predicting = dataSet.getPredicting(); predictingIndex = dataSet.getNumCategoricalVars(); valid = new HashMap < Integer, CategoricalData > (); realIndexToCatIndex = new int[categoriesToUse.size()]; catIndexToRealIndex = new int[dataSet.getNumCategoricalVars() + 1]; Arrays.fill(catIndexToRealIndex, - 1); dimSize = new int[realIndexToCatIndex.length]; int flatSize = 1; int k = 0; for(int i : categoriesToUse) { if(i == predictingIndex)continue; CategoricalData dataInfo = tmp[i]; flatSize *= dataInfo.getNumOfCategories(); valid.put(i, dataInfo); realIndexToCatIndex[k] = i; catIndexToRealIndex[i] = k; dimSize[k ++ ] = dataInfo.getNumOfCategories(); } if(categoriesToUse.contains(predictingIndex)) { flatSize *= predicting.getNumOfCategories(); realIndexToCatIndex[k] = predictingIndex; catIndexToRealIndex[predictingIndex] = k; dimSize[k] = predicting.getNumOfCategories(); valid.put(predictingIndex, predicting); } countArray = new double[flatSize]; Arrays.fill(countArray, 1); int[]cordinate = new int[dimSize.length]; for(int i = 0; i < dataSet.getSampleSize(); i ++ ) { DataPoint dp = dataSet.getDataPoint(i); for(int j = 0; j < realIndexToCatIndex.length; j ++ )if(realIndexToCatIndex[j] != predictingIndex)cordinate[j] = dp.getCategoricalValue(realIndexToCatIndex[j]); else cordinate[j] = dataSet.getDataPointCategory(i); countArray[cordToIndex(cordinate)] += dp.getWeight(); } } ",
        "test_tgt": "@Test public void testTrainC_ClassificationDataSet_ExecutorService() { System.out.println(\"trainC\"); ClassificationDataSet trainSet = FixedProblems.getInnerOuterCircle(150, new Random(2)); ClassificationDataSet testSet = FixedProblems.getInnerOuterCircle(50, new Random(3)); for(SupportVectorLearner.CacheMode cacheMode : SupportVectorLearner.CacheMode.values()) { LSSVM classifier = new LSSVM(new RBFKernel(0.5), cacheMode); classifier.setCacheMode(cacheMode); classifier.setC(1); classifier.train(trainSet, true); for(int i = 0; i < testSet.size(); i ++ )assertEquals(testSet.getDataPointCategory(i), classifier.classify(testSet.getDataPoint(i)).mostLikely()); } } "
    },
    {
        "test_src": "@Test public void testClearRecursively() { FinishedTriggersProperties.verifyClearRecursively(FinishedTriggersSet.fromSet(new HashSet < ExecutableTrigger < ? > > ())); } ",
        "focal_tgt": "public void clearRecursively(ExecutableTrigger trigger); ",
        "focal_src": "public void clearRecursively(ExecutableTrigger < ? > trigger); ",
        "test_tgt": "@Test public void testClearRecursively() { FinishedTriggersProperties.verifyClearRecursively(FinishedTriggersSet.fromSet(new HashSet < ExecutableTrigger > ())); } "
    },
    {
        "test_src": "@Test public void testInitialize() { BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); init.start(); checkInitialize(init); } ",
        "focal_tgt": "@Override protected MultiBackgroundInitializerResults initialize()throws Exception { Map < String, BackgroundInitializer < ? > > inits; synchronized(this) { inits = new HashMap < String, BackgroundInitializer < ? > > (childInitializers); } final ExecutorService exec = getActiveExecutor(); for(final BackgroundInitializer < ? > bi : inits.values()) { if(bi.getExternalExecutor() == null) { bi.setExternalExecutor(exec); } bi.start(); } final Map < String, Object > results = new HashMap < String, Object > (); final Map < String, ConcurrentException > excepts = new HashMap < String, ConcurrentException > (); for(final Map.Entry < String, BackgroundInitializer < ? > > e : inits.entrySet()) { try { results.put(e.getKey(), e.getValue().get()); } catch(final ConcurrentException cex) { excepts.put(e.getKey(), cex); } } return new MultiBackgroundInitializerResults(inits, results, excepts); } ",
        "focal_src": "@Override protected MultiBackgroundInitializerResults initialize()throws Exception { Map < String, BackgroundInitializer < ? > > inits; synchronized(this) { inits = new HashMap < String, BackgroundInitializer < ? > > (childInitializers); } ExecutorService exec = getActiveExecutor(); for(BackgroundInitializer < ? > bi : inits.values()) { if(bi.getExternalExecutor() == null) { bi.setExternalExecutor(exec); } bi.start(); } Map < String, Object > results = new HashMap < String, Object > (); Map < String, ConcurrentException > excepts = new HashMap < String, ConcurrentException > (); for(Map.Entry < String, BackgroundInitializer < ? > > e : inits.entrySet()) { try { results.put(e.getKey(), e.getValue().get()); } catch(ConcurrentException cex) { excepts.put(e.getKey(), cex); } } return new MultiBackgroundInitializerResults(inits, results, excepts); } ",
        "test_tgt": "@Test public void testInitialize() { final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl(); init.start(); checkInitialize(init); } "
    },
    {
        "test_src": "@Test public final void singletonCollectionToGetInstance() { final Predicate < T > predicate = createMockPredicate(null); final Predicate < T > allPredicate = getPredicateInstance(Collections. < Predicate < ? super T > > singleton(predicate)); assertSame(\"expected singleton collection member to be returned by getInstance()\", predicate, allPredicate); } ",
        "focal_tgt": "public void singletonCollectionToGetInstance() { final Predicate < T > predicate = createMockPredicate(null); final Predicate < T > allPredicate = getPredicateInstance(Collections. < Predicate < T > > singleton(predicate)); Assert.assertSame(\"expected argument to be returned by getInstance()\", predicate, allPredicate); } ",
        "focal_src": "public void singletonCollectionToGetInstance() { final Predicate < T > predicate = createMockPredicate(null); final Predicate < T > allPredicate = getPredicateInstance(Collections. < Predicate < ? super T > > singleton(predicate)); Assert.assertSame(\"expected argument to be returned by getInstance()\", predicate, allPredicate); } ",
        "test_tgt": "@Test public final void singletonCollectionToGetInstance() { final Predicate < T > predicate = createMockPredicate(null); final Predicate < T > allPredicate = getPredicateInstance(Collections. < Predicate < T > > singleton(predicate)); assertSame(\"expected singleton collection member to be returned by getInstance()\", predicate, allPredicate); } "
    },
    {
        "test_src": "@Test public void testAnalyze()throws Exception { File file = new File(this.getClass().getClassLoader().getResource(\"commons-fileupload-1.2.1.jar\").getPath()); File suppression = new File(this.getClass().getClassLoader().getResource(\"commons-fileupload-1.2.1.suppression.xml\").getPath()); Settings.setBoolean(Settings.KEYS.AUTO_UPDATE, false); Settings.setBoolean(Settings.KEYS.ANALYZER_NEXUS_ENABLED, false); Engine engine = new Engine(); engine.scan(file); engine.analyzeDependencies(); Dependency dependency = getDependency(engine, file); assertTrue(dependency.getVulnerabilities().size() > 0); assertTrue(dependency.getIdentifiers().size() > 0); Settings.setString(Settings.KEYS.SUPPRESSION_FILE, suppression.getAbsolutePath()); VulnerabilitySuppressionAnalyzer instance = new VulnerabilitySuppressionAnalyzer(); instance.initialize(); instance.analyze(dependency, engine); assertTrue(dependency.getVulnerabilities().size() == 0); assertTrue(dependency.getIdentifiers().isEmpty()); engine.cleanup(); } ",
        "focal_tgt": "@Override public void analyze(Dependency dependency, Engine engine)throws AnalysisException { removeJreEntries(dependency); removeBadMatches(dependency); removeWrongVersionMatches(dependency); removeSpuriousCPE(dependency); removeDuplicativePOMEntries(dependency, engine); addFalseNegativeCPEs(dependency); } ",
        "focal_src": "@Override public void analyze(Dependency dependency, Engine engine)throws AnalysisException { removeJreEntries(dependency); removeBadMatches(dependency); removeWrongVersionMatches(dependency); removeSpuriousCPE(dependency); addFalseNegativeCPEs(dependency); } ",
        "test_tgt": "@Test public void testAnalyze()throws Exception { File file = new File(this.getClass().getClassLoader().getResource(\"commons-fileupload-1.2.1.jar\").getPath()); File suppression = new File(this.getClass().getClassLoader().getResource(\"commons-fileupload-1.2.1.suppression.xml\").getPath()); Settings.setBoolean(Settings.KEYS.AUTO_UPDATE, false); Settings.setBoolean(Settings.KEYS.ANALYZER_NEXUS_ENABLED, false); Engine engine = new Engine(); engine.scan(file); engine.analyzeDependencies(); Dependency dependency = getDependency(engine, file); int cveSize = dependency.getVulnerabilities().size(); int cpeSize = dependency.getIdentifiers().size(); assertTrue(cveSize > 0); assertTrue(cpeSize > 0); Settings.setString(Settings.KEYS.SUPPRESSION_FILE, suppression.getAbsolutePath()); VulnerabilitySuppressionAnalyzer instance = new VulnerabilitySuppressionAnalyzer(); instance.initialize(); instance.analyze(dependency, engine); cveSize = cveSize > 1 ? cveSize - 2 : 0; cpeSize = cpeSize > 0 ? cpeSize - 1 : 0; assertTrue(dependency.getVulnerabilities().size() == cveSize); assertTrue(dependency.getIdentifiers().size() == cpeSize); engine.cleanup(); } "
    },
    {
        "test_src": "@Test void testEnsureCapacity() { GroupByResultHolder resultHolder = new DoubleGroupByResultHolder(INITIAL_CAPACITY, MAX_CAPACITY, DEFAULT_VALUE); for(int i = 0; i < INITIAL_CAPACITY; i ++ ) { resultHolder.setValueForKey(i, _expected[i]); } resultHolder.ensureCapacity(MAX_CAPACITY); for(int i = INITIAL_CAPACITY; i < MAX_CAPACITY; i ++ ) { double actual = resultHolder.getDoubleResult(i); Assert.assertEquals(actual, DEFAULT_VALUE, \"Default Value mis-match: Actual: \" + actual + \" Expected: \" + DEFAULT_VALUE + \" Random seed: \" + RANDOM_SEED); resultHolder.setValueForKey(i, _expected[i]); } testValues(resultHolder, _expected, 0, MAX_CAPACITY); } ",
        "focal_tgt": "@Override public void ensureCapacity(int capacity) { Preconditions.checkArgument(capacity <= _maxCapacity); if(_storageMode == StorageMode.MAP_STORAGE) { return; } if(capacity > _trimSize) { switchToMapMode(capacity); return; } if(capacity > _resultHolderCapacity) { int copyLength = _resultHolderCapacity; _resultHolderCapacity = Math.max(_resultHolderCapacity * 2, capacity); _resultHolderCapacity = Math.min(_resultHolderCapacity, _maxCapacity); double[]current = _resultArray; _resultArray = new double[_resultHolderCapacity]; System.arraycopy(current, 0, _resultArray, 0, copyLength); if(_defaultValue != 0.0) { Arrays.fill(_resultArray, copyLength, _resultHolderCapacity, _defaultValue); } } } ",
        "focal_src": "@Override public void ensureCapacity(int capacity) { if(_storageMode == StorageMode.MAP_STORAGE) { return; } if(capacity > _maxCapacity) { switchToMapMode(capacity); return; } Preconditions.checkArgument(capacity <= _maxCapacity); if(capacity > _resultHolderCapacity) { int copyLength = _resultHolderCapacity; _resultHolderCapacity = Math.max(_resultHolderCapacity * 2, capacity); _resultHolderCapacity = Math.min(_resultHolderCapacity, _maxCapacity); double[]current = _resultArray; _resultArray = new double[_resultHolderCapacity]; System.arraycopy(current, 0, _resultArray, 0, copyLength); if(_defaultValue != 0.0) { Arrays.fill(_resultArray, copyLength, _resultHolderCapacity, _defaultValue); } } } ",
        "test_tgt": "@Test void testEnsureCapacity() { GroupByResultHolder resultHolder = new DoubleGroupByResultHolder(INITIAL_CAPACITY, MAX_CAPACITY, MAX_CAPACITY, DEFAULT_VALUE); for(int i = 0; i < INITIAL_CAPACITY; i ++ ) { resultHolder.setValueForKey(i, _expected[i]); } resultHolder.ensureCapacity(MAX_CAPACITY); for(int i = INITIAL_CAPACITY; i < MAX_CAPACITY; i ++ ) { double actual = resultHolder.getDoubleResult(i); Assert.assertEquals(actual, DEFAULT_VALUE, \"Default Value mis-match: Actual: \" + actual + \" Expected: \" + DEFAULT_VALUE + \" Random seed: \" + RANDOM_SEED); resultHolder.setValueForKey(i, _expected[i]); } testValues(resultHolder, _expected, 0, MAX_CAPACITY); } "
    },
    {
        "test_src": "@Test(expected = IllegalArgumentException.class)public void getProvidersByPerson_shouldFailIfPersonIsNull()throws Exception { service.getProvidersByPerson(null); Assert.fail(); } ",
        "focal_tgt": "@Override public Collection < Provider > getProvidersByPerson(Person person, boolean includeRetired) { Criteria criteria = getSession().createCriteria(Provider.class); if( ! includeRetired) { criteria.add(Restrictions.eq(\"retired\", false)); } else { criteria.addOrder(Order.asc(\"retired\")); } criteria.add(Restrictions.eq(\"person\", person)); criteria.addOrder(Order.asc(\"providerId\")); return criteria.list(); } ",
        "focal_src": "@Override public Collection < Provider > getProvidersByPerson(Person person, boolean includeRetired) { Criteria criteria = getSession().createCriteria(Provider.class); if( ! includeRetired) { criteria.add(Expression.eq(\"retired\", false)); } else { criteria.addOrder(Order.asc(\"retired\")); } criteria.add(Restrictions.eq(\"person\", person)); criteria.addOrder(Order.asc(\"providerId\")); return criteria.list(); } ",
        "test_tgt": "@Test(expected = IllegalArgumentException.class)public void getProvidersByPerson_shouldFailIfPersonIsNull()throws Exception { service.getProvidersByPerson(null); Assert.fail(); } "
    },
    {
        "test_src": "@Test public void parseSpaceSize() { long max = 10240; for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"b\")); Assert.assertEquals(k / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"B\")); Assert.assertEquals(k / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"\")); } for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"kb\")); Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Kb\")); Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"KB\")); Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"kB\")); } for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"mb\")); Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Mb\")); Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"MB\")); Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"mB\")); } for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"gb\")); Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Gb\")); Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"GB\")); Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"gB\")); } for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"tb\")); Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Tb\")); Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"TB\")); Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"tB\")); } for(long k = 0; k < 8192; k ++ ) { Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"pb\")); Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Pb\")); Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"PB\")); Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"pB\")); } } ",
        "focal_tgt": "public static long parseSpaceSize(String spaceSize) { double alpha = 0.0001; String ori = spaceSize; String end = \"\"; int index = spaceSize.length() - 1; while(index >= 0) { if(spaceSize.charAt(index) > '9' || spaceSize.charAt(index) < '0') { end = spaceSize.charAt(index) + end; } else { break; } index -- ; } spaceSize = spaceSize.substring(0, index + 1); double ret = Double.parseDouble(spaceSize); end = end.toLowerCase(); if(end.isEmpty() || end.equals(\"b\")) { return(long)(ret + alpha); } else if(end.equals(\"kb\") || end.equals(\"k\")) { return(long)(ret * Constants.KB + alpha); } else if(end.equals(\"mb\") || end.equals(\"m\")) { return(long)(ret * Constants.MB + alpha); } else if(end.equals(\"gb\") || end.equals(\"g\")) { return(long)(ret * Constants.GB + alpha); } else if(end.equals(\"tb\") || end.equals(\"t\")) { return(long)(ret * Constants.TB + alpha); } else if(end.equals(\"pb\") || end.equals(\"p\")) { BigDecimal pBDecimal = new BigDecimal(Constants.PB); return pBDecimal.multiply(BigDecimal.valueOf(ret)).longValue(); } else { throw new IllegalArgumentException(\"Fail to parse \" + ori + \" to bytes\"); } } ",
        "focal_src": "public static long parseSpaceSize(String spaceSize) { double alpha = 0.0001; String ori = spaceSize; String end = \"\"; int index = spaceSize.length() - 1; while(index >= 0) { if(spaceSize.charAt(index) > '9' || spaceSize.charAt(index) < '0') { end = spaceSize.charAt(index) + end; } else { break; } index -- ; } spaceSize = spaceSize.substring(0, index + 1); double ret = Double.parseDouble(spaceSize); end = end.toLowerCase(); if(end.isEmpty() || end.equals(\"b\")) { return(long)(ret + alpha); } else if(end.equals(\"kb\")) { return(long)(ret * Constants.KB + alpha); } else if(end.equals(\"mb\")) { return(long)(ret * Constants.MB + alpha); } else if(end.equals(\"gb\")) { return(long)(ret * Constants.GB + alpha); } else if(end.equals(\"tb\")) { return(long)(ret * Constants.TB + alpha); } else if(end.equals(\"pb\")) { BigDecimal pBDecimal = new BigDecimal(Constants.PB); return pBDecimal.multiply(BigDecimal.valueOf(ret)).longValue(); } else { throw new IllegalArgumentException(\"Fail to parse \" + ori + \" to bytes\"); } } ",
        "test_tgt": "@Test public void parseSpaceSize() { long max = 10240; for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"b\")); Assert.assertEquals(k / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"B\")); Assert.assertEquals(k / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"\")); } for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"kb\")); Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Kb\")); Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"KB\")); Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"kB\")); Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"k\")); Assert.assertEquals(k * Constants.KB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"K\")); } for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"mb\")); Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Mb\")); Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"MB\")); Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"mB\")); Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"m\")); Assert.assertEquals(k * Constants.MB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"M\")); } for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"gb\")); Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Gb\")); Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"GB\")); Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"gB\")); Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"g\")); Assert.assertEquals(k * Constants.GB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"G\")); } for(long k = 0; k < max; k ++ ) { Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"tb\")); Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Tb\")); Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"TB\")); Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"tB\")); Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"t\")); Assert.assertEquals(k * Constants.TB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"T\")); } for(long k = 0; k < 8192; k ++ ) { Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"pb\")); Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"Pb\")); Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"PB\")); Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"pB\")); Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"p\")); Assert.assertEquals(k * Constants.PB / 10, FormatUtils.parseSpaceSize(k / 10.0 + \"P\")); } } "
    },
    {
        "test_src": "@Ignore@Test public void testGetRepeatMode()throws InterruptedException { final int testRepeatMode = MediaPlaylistAgent.REPEAT_MODE_GROUP; final MediaPlaylistAgent agent = new MediaPlaylistAgent() { @Override public int getRepeatMode() { return testRepeatMode; } }; final CountDownLatch latch = new CountDownLatch(1); final SessionCallback sessionCallback = new SessionCallback() { @Override public void onRepeatModeChanged(MediaSession2 session, MediaPlaylistAgent playlistAgent, int repeatMode) { assertEquals(agent, playlistAgent); assertEquals(testRepeatMode, repeatMode); latch.countDown(); } }; try(MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setPlaylistAgent(agent).setId(\"testGetRepeatMode\").setSessionCallback(sHandlerExecutor, sessionCallback).build()) { agent.notifyRepeatModeChanged(); assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)); } } ",
        "focal_tgt": "public abstract@RepeatMode int getRepeatMode(); ",
        "focal_src": "public@RepeatMode int getRepeatMode() { return REPEAT_MODE_NONE; } ",
        "test_tgt": "@Ignore@Test public void testGetRepeatMode()throws InterruptedException { final int testRepeatMode = MediaPlaylistAgent.REPEAT_MODE_GROUP; mMockAgent.setRepeatMode(testRepeatMode); final CountDownLatch latch = new CountDownLatch(1); final SessionCallback sessionCallback = new SessionCallback() { @Override public void onRepeatModeChanged(MediaSession2 session, MediaPlaylistAgent playlistAgent, int repeatMode) { assertEquals(mMockAgent, playlistAgent); assertEquals(testRepeatMode, repeatMode); latch.countDown(); } }; try(MediaSession2 session = new MediaSession2.Builder(mContext).setPlayer(mPlayer).setPlaylistAgent(mMockAgent).setId(\"testGetRepeatMode\").setSessionCallback(sHandlerExecutor, sessionCallback).build()) { mMockAgent.notifyRepeatModeChanged(); assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)); } } "
    },
    {
        "test_src": "@Test public void testInitialize() { @Cleanup TestContext context = new TestContext(DEFAULT_CONFIG); context.transactionAggregators[0].initialize(TIMEOUT).join(); Assert.assertTrue(\"isDeleted() flag not set on metadata for deleted segment.\", context.transactionAggregators[0].getMetadata().isDeleted()); val handle1 = context.storage.create(context.transactionAggregators[1].getMetadata().getName(), TIMEOUT).join(); context.storage.seal(handle1, TIMEOUT).join(); AssertExtensions.assertThrows(\"initialize() succeeded on a Segment is sealed in Storage but not in the metadata.\", () -> context.transactionAggregators[1].initialize(TIMEOUT), ex -> ex instanceof DataCorruptionException); val handle2 = context.storage.create(context.transactionAggregators[2].getMetadata().getName(), TIMEOUT).join(); context.storage.seal(handle2, TIMEOUT).join(); ((UpdateableSegmentMetadata)context.transactionAggregators[2].getMetadata()).markSealed(); context.transactionAggregators[2].initialize(TIMEOUT).join(); Assert.assertTrue(\"isSealedInStorage() flag not set on metadata for storage-sealed segment.\", context.transactionAggregators[2].getMetadata().isSealedInStorage()); final int writeLength = 10; val handle3 = context.storage.create(context.segmentAggregator.getMetadata().getName(), TIMEOUT).join(); context.storage.write(handle3, 0, new ByteArrayInputStream(new byte[writeLength]), writeLength, TIMEOUT).join(); context.segmentAggregator.initialize(TIMEOUT).join(); Assert.assertEquals(\"SegmentMetadata.StorageLength was not updated after call to initialize().\", writeLength, context.segmentAggregator.getMetadata().getStorageLength()); } ",
        "focal_tgt": "public void initialize()throws IOException { this.storage.initialize(); } ",
        "focal_src": "public void initialize()throws IOException { } ",
        "test_tgt": "@Test public void testInitialize() { @Cleanup TestContext context = new TestContext(DEFAULT_CONFIG); context.transactionAggregators[0].initialize(TIMEOUT).join(); Assert.assertTrue(\"isDeleted() flag not set on metadata for deleted segment.\", context.transactionAggregators[0].getMetadata().isDeleted()); context.storage.create(context.transactionAggregators[1].getMetadata().getName(), TIMEOUT).join(); context.storage.seal(context.transactionAggregators[1].getMetadata().getName(), TIMEOUT).join(); AssertExtensions.assertThrows(\"initialize() succeeded on a Segment is sealed in Storage but not in the metadata.\", () -> context.transactionAggregators[1].initialize(TIMEOUT), ex -> ex instanceof DataCorruptionException); context.storage.create(context.transactionAggregators[2].getMetadata().getName(), TIMEOUT).join(); context.storage.seal(context.transactionAggregators[2].getMetadata().getName(), TIMEOUT).join(); ((UpdateableSegmentMetadata)context.transactionAggregators[2].getMetadata()).markSealed(); context.transactionAggregators[2].initialize(TIMEOUT).join(); Assert.assertTrue(\"isSealedInStorage() flag not set on metadata for storage-sealed segment.\", context.transactionAggregators[2].getMetadata().isSealedInStorage()); final int writeLength = 10; context.storage.create(context.segmentAggregator.getMetadata().getName(), TIMEOUT).join(); context.storage.write(context.segmentAggregator.getMetadata().getName(), 0, new ByteArrayInputStream(new byte[writeLength]), writeLength, TIMEOUT).join(); context.segmentAggregator.initialize(TIMEOUT).join(); Assert.assertEquals(\"SegmentMetadata.StorageLength was not updated after call to initialize().\", writeLength, context.segmentAggregator.getMetadata().getStorageLength()); } "
    },
    {
        "test_src": "@Test public void testAddCommand_String_int()throws Exception { System.out.println(\"addCommand\"); GcodeParser instance = new GcodeParser(); List < PointSegment > results = instance.addCommand(\"G20 G0X1F150\", 123); testCommand(results, 1, 150, 1., 0., 0., true, false, false, false, false, 123); } ",
        "focal_tgt": "public List < PointSegment > addCommand(String command)throws GcodeParserException; ",
        "focal_src": "public PointSegment addCommand(String command)throws GcodeParserException; ",
        "test_tgt": "@Test public void testAddCommand_String_int()throws Exception { System.out.println(\"addCommand\"); GcodeParser instance = new GcodeParser(); List < PointSegment > results = instance.addCommand(\"G20 G0X1F150\", 123); testCommand(results, 1, 150, 1., 0., 0., true, false, false, false, false, 123); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should update an existing cohort\", method = \"saveCohort(Cohort)\")public void saveCohort_shouldUpdateAnExistingCohort()throws Exception { executeDataSet(COHORT_XML); String modifiedCohortDescription = \"This description has been modified in a test\"; Cohort cohortToModify = service.getCohort(2); cohortToModify.setDescription(modifiedCohortDescription); service.saveCohort(cohortToModify); assertTrue(service.getCohort(2).getDescription().equals(modifiedCohortDescription)); } ",
        "focal_tgt": "@Override public Cohort saveCohort(Cohort cohort)throws APIException { if(cohort.getCohortId() == null) { Context.requirePrivilege(PrivilegeConstants.ADD_COHORTS); } else { Context.requirePrivilege(PrivilegeConstants.EDIT_COHORTS); } if(cohort.getName() == null) { throw new APIException(\"Cohort.save.nameRequired\", (Object[])null); } if(cohort.getDescription() == null) { throw new APIException(\"Cohort.save.descriptionRequired\", (Object[])null); } if(log.isInfoEnabled()) { log.info(\"Saving cohort \" + cohort); } return dao.saveCohort(cohort); } ",
        "focal_src": "public Cohort saveCohort(Cohort cohort)throws APIException { if(cohort.getCohortId() == null) { Context.requirePrivilege(PrivilegeConstants.ADD_COHORTS); } else { Context.requirePrivilege(PrivilegeConstants.EDIT_COHORTS); } if(cohort.getName() == null) { throw new APIException(\"Cohort.save.nameRequired\", (Object[])null); } if(cohort.getDescription() == null) { throw new APIException(\"Cohort.save.descriptionRequired\", (Object[])null); } if(log.isInfoEnabled()) { log.info(\"Saving cohort \" + cohort); } return dao.saveCohort(cohort); } ",
        "test_tgt": "@Test public void saveCohort_shouldUpdateAnExistingCohort()throws Exception { executeDataSet(COHORT_XML); String modifiedCohortDescription = \"This description has been modified in a test\"; Cohort cohortToModify = service.getCohort(2); cohortToModify.setDescription(modifiedCohortDescription); service.saveCohort(cohortToModify); assertTrue(service.getCohort(2).getDescription().equals(modifiedCohortDescription)); } "
    },
    {
        "test_src": "@Test public void error()throws Exception { get(\"declare %R:path('') function m:a() { error() };\" + \"declare %R:error('*') function m:b() { 'F' };\", \"\", \"F\"); get(\"declare %R:path('') function m:a() { error(xs:QName('x')) };\" + \"declare %R:error('x') function m:b() { 'F' };\", \"\", \"F\"); getE(\"declare %R:path('') function m:a() { error(xs:QName('x')) };\" + \"declare %R:error('y') function m:b() { 'F' };\", \"\"); getE(\"declare %R:path('') function m:a() { () };\" + \"declare %R:error('*') function m:b() { 'F' };\" + \"declare %R:error('*') function m:b() { 'F' };\", \"\"); getE(\"declare %R:path('') function m:a() { () };\" + \"declare %R:error('*') %R:error('*') function m:b() { 'F' };\", \"\"); } ",
        "focal_tgt": "private RestXqError error(final Value value, final QNm name)throws QueryException { if(value.size() != 1)throw error(function.info, ANN_EXACTLY, \"%\", name.string(), 1); final String err = toString(value.itemAt(0), name); final NameTest test; QNm qnm = null; if(err.equals(\"*\")) { test = new NameTest(false); } else if(err.startsWith(\"*:\")) { final byte[]local = token(err.substring(2)); if( ! XMLToken.isNCName(local))throw error(INV_CODE, err); test = new NameTest(new QNm(local), NameTest.Kind.NAME, false, null); } else if(err.endsWith(\":*\")) { final byte[]prefix = token(err.substring(0, err.length() - 2)); if( ! XMLToken.isNCName(prefix))throw error(INV_CODE, err); qnm = new QNm(concat(prefix, COLON), function.sc); test = new NameTest(qnm, NameTest.Kind.URI, false, null); } else { final byte[]nm = token(err); if( ! XMLToken.isQName(nm))throw error(INV_CODE, err); qnm = new QNm(nm, function.sc); test = new NameTest(qnm, NameTest.Kind.URI_NAME, false, null); } if(qnm != null && qnm.hasPrefix() && ! qnm.hasURI())throw error(INV_NONS, qnm); return new RestXqError(test); } ",
        "focal_src": "private RestXqError error(final Value value, final QNm name)throws QueryException { if(value.size() != 1)throw error(function.info, ANN_EXACTLY, \"%\", name.string(), 1); final String err = toString(value.itemAt(0), name); QNm code = null; if( ! \"*\".equals(err)) { final byte[]c = token(err); if( ! XMLToken.isQName(c))throw error(INV_CODE, c); code = new QNm(c, function.sc); if( ! code.hasURI() && code.hasPrefix())throw error(INV_NONS, code); } return new RestXqError(code); } ",
        "test_tgt": "@Test public void error()throws Exception { get(\"declare %R:path('') function m:a() { error() };\" + \"declare %R:error('*') function m:b() { 'F' };\", \"\", \"F\"); get(\"declare %R:path('') function m:a() { error(xs:QName('x')) };\" + \"declare %R:error('x') function m:b() { 'F' };\", \"\", \"F\"); get(\"declare %R:path('') function m:a() { 1 + <a/> };\" + \"declare %R:error('*:FORG0001') function m:b() { 'F' };\", \"\", \"F\"); get(\"declare %R:path('') function m:a() { 1 + <a/> };\" + \"declare %R:error('err:*') function m:b() { 'F' };\", \"\", \"F\"); get(\"declare %R:path('') function m:a() { 1 + <a/> };\" + \"declare %R:error('err:FORG0001') function m:b() { 'F' };\", \"\", \"F\"); getE(\"declare %R:path('') function m:a() { error(xs:QName('x')) };\" + \"declare %R:error('y') function m:b() { 'F' };\", \"\"); getE(\"declare %R:path('') function m:a() { () };\" + \"declare %R:error('unknown:*') function m:b() { 'F' };\", \"\"); getE(\"declare %R:path('') function m:a() { () };\" + \"declare %R:error('*:In Valid') function m:b() { 'F' };\", \"\"); getE(\"declare %R:path('') function m:a() { () };\" + \"declare %R:error('In Valid') function m:b() { 'F' };\", \"\"); getE(\"declare %R:path('') function m:a() { () };\" + \"declare %R:error('*') function m:b() { 'F' };\" + \"declare %R:error('*') function m:b() { 'F' };\", \"\"); getE(\"declare %R:path('') function m:a() { () };\" + \"declare %R:error('*') %R:error('*') function m:b() { 'F' };\", \"\"); } "
    },
    {
        "test_src": "@Test public void testCreateLanguageModel()throws InterruptedException, FileNotFoundException { LanguageModel model = loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model))); CreateLanguageModel newModel = new CreateLanguageModel.Builder().name(model.getName()).baseModelName(\"en-GB_BroadbandModel\").description(model.getDescription()).build(); CreateLanguageModelOptions createOptions = new CreateLanguageModelOptions.Builder().createLanguageModel(newModel).build(); LanguageModel result = service.createLanguageModel(createOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_CUSTOMIZATIONS, request.getPath()); assertEquals(result.toString(), model.toString()); } ",
        "focal_tgt": "public ServiceCall < LanguageModel > createLanguageModel(CreateLanguageModelOptions createLanguageModelOptions) { Validator.notNull(createLanguageModelOptions, \"createLanguageModelOptions cannot be null\"); RequestBuilder builder = RequestBuilder.post(\"/v1/customizations\"); final JsonObject contentJson = new JsonObject(); contentJson.addProperty(\"name\", createLanguageModelOptions.name()); contentJson.addProperty(\"base_model_name\", createLanguageModelOptions.baseModelName()); if(createLanguageModelOptions.dialect() != null) { contentJson.addProperty(\"dialect\", createLanguageModelOptions.dialect()); } if(createLanguageModelOptions.description() != null) { contentJson.addProperty(\"description\", createLanguageModelOptions.description()); } builder.bodyJson(contentJson); return createServiceCall(builder.build(), ResponseConverterUtils.getObject(LanguageModel.class)); } ",
        "focal_src": "public ServiceCall < LanguageModel > createLanguageModel(CreateLanguageModelOptions createLanguageModelOptions) { Validator.notNull(createLanguageModelOptions, \"createLanguageModelOptions cannot be null\"); RequestBuilder builder = RequestBuilder.post(\"/v1/customizations\"); builder.header(\"Content-Type\", createLanguageModelOptions.contentType()); if(createLanguageModelOptions.contentType().equalsIgnoreCase(CreateLanguageModelOptions.ContentType.APPLICATION_JSON)) { builder.bodyJson(GsonSingleton.getGson().toJsonTree(createLanguageModelOptions.createLanguageModel()).getAsJsonObject()); } return createServiceCall(builder.build(), ResponseConverterUtils.getObject(LanguageModel.class)); } ",
        "test_tgt": "@Test public void testCreateLanguageModel()throws InterruptedException, FileNotFoundException { LanguageModel model = loadFixture(\"src/test/resources/speech_to_text/customization.json\", LanguageModel.class); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(GSON.toJson(model))); CreateLanguageModelOptions createOptions = new CreateLanguageModelOptions.Builder().name(model.getName()).baseModelName(\"en-GB_BroadbandModel\").description(model.getDescription()).build(); LanguageModel result = service.createLanguageModel(createOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"POST\", request.getMethod()); assertEquals(PATH_CUSTOMIZATIONS, request.getPath()); assertEquals(result.toString(), model.toString()); } "
    },
    {
        "test_src": "@Test public void testGetLongitudeFromX01() { final int iterations = 10; for(int i = 0; i <= iterations; i ++ ) { final double longitude = TileSystem.MinLongitude + i * (TileSystem.MaxLongitude - TileSystem.MinLongitude) / iterations; checkLongitude(longitude, TileSystem.getLongitudeFromX01(((double)i) / iterations, true)); } checkLongitude(TileSystem.MinLongitude, TileSystem.getLongitudeFromX01(0, true)); checkLongitude(0, TileSystem.getLongitudeFromX01(0.5, true)); checkLongitude(TileSystem.MaxLongitude, TileSystem.getLongitudeFromX01(1, true)); } ",
        "focal_tgt": "public double getLongitudeFromX01(final double pX01, boolean wrapEnabled) { final double longitude = getLongitudeFromX01(wrapEnabled ? Clip(pX01, 0, 1) : pX01); return wrapEnabled ? Clip(longitude, getMinLongitude(), getMaxLongitude()) : longitude; } ",
        "focal_src": "public static double getLongitudeFromX01(final double pX01, boolean wrapEnabled) { return MinLongitude + (MaxLongitude - MinLongitude) * (wrapEnabled ? Clip(pX01, 0, 1) : pX01); } ",
        "test_tgt": "@Test public void testGetLongitudeFromX01() { final int iterations = 10; for(int i = 0; i <= iterations; i ++ ) { final double longitude = tileSystem.getMinLongitude() + i * (tileSystem.getMaxLongitude() - tileSystem.getMinLongitude()) / iterations; checkLongitude(longitude, tileSystem.getLongitudeFromX01(((double)i) / iterations, true)); } checkLongitude(tileSystem.getMinLongitude(), tileSystem.getLongitudeFromX01(0, true)); checkLongitude(0, tileSystem.getLongitudeFromX01(0.5, true)); checkLongitude(tileSystem.getMaxLongitude(), tileSystem.getLongitudeFromX01(1, true)); } "
    },
    {
        "test_src": "@Test public void testClear()throws MetaDataException { testOneAddGet(false, \"a\", \"p\", \"a\", \"x\", \"a\", \"1\", null, null); testOneAddGet(false, \"a\", \"q\", \"b\", \"y\", \"a\", \"2\", null, null); testOneAddGet(false, \"a\", null, \"c\", \"z\", \"a\", \"1\", null, null); testOneAddGet(false, \"b\", \"q\", \"c\", \"z\", \"a\", \"1\", null, null); mds.clear(\"a\", \"p\"); Assert.assertNull(mds.get(\"a\", \"p\", \"a\", \"x\")); Assert.assertNotNull(mds.get(\"a\", \"q\", \"b\", \"y\")); Assert.assertNotNull(mds.get(\"a\", null, \"c\", \"z\")); mds.clear(\"a\", null); Assert.assertNull(mds.get(\"a\", \"q\", \"b\", \"y\")); Assert.assertNull(mds.get(\"a\", null, \"c\", \"z\")); Assert.assertNotNull(mds.get(\"b\", \"q\", \"c\", \"z\")); } ",
        "focal_tgt": "public void clear(OperationContext conetxt, String account, String application)throws MetaDataException; ",
        "focal_src": "public void clear(String account, String application)throws MetaDataException; ",
        "test_tgt": "@Test public void testClear()throws MetaDataException { testOneAddGet(false, \"a\", \"p\", \"a\", \"x\", \"a\", \"1\", null, null); testOneAddGet(false, \"a\", \"q\", \"b\", \"y\", \"a\", \"2\", null, null); testOneAddGet(false, \"a\", null, \"c\", \"z\", \"a\", \"1\", null, null); testOneAddGet(false, \"b\", \"q\", \"c\", \"z\", \"a\", \"1\", null, null); mds.clear(context, \"a\", \"p\"); Assert.assertNull(mds.get(context, \"a\", \"p\", \"a\", \"x\")); Assert.assertNotNull(mds.get(context, \"a\", \"q\", \"b\", \"y\")); Assert.assertNotNull(mds.get(context, \"a\", null, \"c\", \"z\")); mds.clear(context, \"a\", null); Assert.assertNull(mds.get(context, \"a\", \"q\", \"b\", \"y\")); Assert.assertNull(mds.get(context, \"a\", null, \"c\", \"z\")); Assert.assertNotNull(mds.get(context, \"b\", \"q\", \"c\", \"z\")); } "
    },
    {
        "test_src": "@Test public void derivX_I8() { ImageInt8 img = new ImageInt8(width, height); BasicDrawing_I8.randomize(img, rand); ImageInt16 derivX = new ImageInt16(width, height, true); GecvTesting.checkSubImage(this, \"derivX_I8\", true, img, derivX); } ",
        "focal_tgt": "public static void derivX_I8(ImageUInt8 orig, ImageSInt16 derivX) { InputSanityCheck.checkSameShape(orig, derivX); GradientThree_Standard.derivX_I8(orig, derivX); } ",
        "focal_src": "public static void derivX_I8(ImageInt8 orig, ImageInt16 derivX) { InputSanityCheck.checkSameShape(orig, false, derivX, true); GradientThree_Standard.derivX_I8(orig, derivX); } ",
        "test_tgt": "@Test public void derivX_I8() { ImageUInt8 img = new ImageUInt8(width, height); BasicDrawing_I8.randomize(img, rand); ImageSInt16 derivX = new ImageSInt16(width, height); GecvTesting.checkSubImage(this, \"derivX_I8\", true, img, derivX); } "
    },
    {
        "test_src": "@Test public void testSetApplicationsForCommand()throws GenieException { final Command command2 = this.service.getCommand(COMMAND_2_ID); Assert.assertTrue(command2.getApplications().isEmpty()); final Application app = this.appService.getApplication(APP_1_ID); final Set < Application > apps = new HashSet < > (); apps.add(app); final List < Command > preCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(1, preCommands.size()); Assert.assertEquals(1, preCommands.stream().filter(command -> COMMAND_1_ID.equals(command.getId())).count()); this.service.setApplicationsForCommand(COMMAND_2_ID, apps); final List < Command > savedCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(2, savedCommands.size()); Assert.assertEquals(1, this.service.getApplicationsForCommand(COMMAND_2_ID).stream().filter(application -> APP_1_ID.equals(application.getId())).count()); } ",
        "focal_tgt": "Set < Application > setApplicationsForCommand(@NotBlank(message = \"No command id entered. Unable to add applications.\")final String id, @NotNull(message = \"No application ids entered. Unable to set applications.\")final Set < String > applicationIds)throws GenieException; ",
        "focal_src": "Set < Application > setApplicationsForCommand(@NotBlank(message = \"No command id entered. Unable to add applications.\")final String id, @NotNull(message = \"No applications entered. Unable to set applications.\")final Set < Application > applications)throws GenieException; ",
        "test_tgt": "@Test public void testSetApplicationsForCommand()throws GenieException { final Command command2 = this.service.getCommand(COMMAND_2_ID); Assert.assertTrue(command2.getApplications().isEmpty()); final Set < String > appIds = new HashSet < > (); appIds.add(APP_1_ID); final List < Command > preCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(1, preCommands.size()); Assert.assertEquals(1, preCommands.stream().filter(command -> COMMAND_1_ID.equals(command.getId())).count()); this.service.setApplicationsForCommand(COMMAND_2_ID, appIds); final List < Command > savedCommands = this.appService.getCommandsForApplication(APP_1_ID, null); Assert.assertEquals(2, savedCommands.size()); Assert.assertEquals(1, this.service.getApplicationsForCommand(COMMAND_2_ID).stream().filter(application -> APP_1_ID.equals(application.getId())).count()); } "
    },
    {
        "test_src": "@Test public void applyUMaskTest() { FileSystemPermission umaskPermission = new FileSystemPermission((short)0022); PermissionStatus permissionStatus = new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault()); permissionStatus = permissionStatus.applyUMask(umaskPermission); Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction()); Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getGroupAction()); Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getOtherAction()); Assert.assertEquals(0755, permissionStatus.getPermission().toShort()); } ",
        "focal_tgt": "public PermissionStatus applyUMask(FileSystemPermission umask, Configuration configuration) { if( ! SecurityUtils.isSecurityEnabled(configuration)) { return new PermissionStatus(mUserName, mGroupName, mPermission); } FileSystemPermission newFileSystemPermission = mPermission.applyUMask(umask); return new PermissionStatus(mUserName, mGroupName, newFileSystemPermission); } ",
        "focal_src": "public PermissionStatus applyUMask(FileSystemPermission umask) { FileSystemPermission newFileSystemPermission = mPermission.applyUMask(umask); return new PermissionStatus(mUserName, mGroupName, newFileSystemPermission); } ",
        "test_tgt": "@Test public void applyUMaskTest() { FileSystemPermission umaskPermission = new FileSystemPermission((short)0022); PermissionStatus permissionStatus = new PermissionStatus(\"user1\", \"group1\", FileSystemPermission.getDefault()); Configuration conf = new Configuration(); conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, AuthType.SIMPLE.getAuthName()); conf.set(Constants.SECURITY_AUTHORIZATION_PERMISSION_ENABLED, \"true\"); permissionStatus = permissionStatus.applyUMask(umaskPermission, conf); Assert.assertEquals(FileSystemAction.ALL, permissionStatus.getPermission().getUserAction()); Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getGroupAction()); Assert.assertEquals(FileSystemAction.READ_EXECUTE, permissionStatus.getPermission().getOtherAction()); Assert.assertEquals(0755, permissionStatus.getPermission().toShort()); } "
    },
    {
        "test_src": "@Test public void testDeleteFileOrDirectory2() { FileUtil.deleteFileOrDirectory(\"E:/test\"); } ",
        "focal_tgt": "public static boolean deleteFileOrDirectory(String fileName) { File file = new File(fileName); return deleteFileOrDirectory(file); } ",
        "focal_src": "public static void deleteFileOrDirectory(String fileName) { File file = new File(fileName); if(file.exists()) { deleteFileOrDirectory(file); } throw new IllegalArgumentException(\"file:[\" + fileName + \"] not exists,please check it!\"); } ",
        "test_tgt": "@Test public void testDeleteFileOrDirectory2() { FileUtil.deleteFileOrDirectory(\"E:\\\\test\"); } "
    },
    {
        "test_src": "@Test public void testListStreams()throws ExecutionException, InterruptedException { final String resourceURI = \"v1/scopes/scope1/streams\"; final StreamConfiguration streamConfiguration1 = StreamConfiguration.builder().scope(scope1).streamName(stream1).scalingPolicy(ScalingPolicy.byEventRate(100, 2, 2)).retentionPolicy(RetentionPolicy.byTime(Duration.ofMillis(123L))).build(); final StreamConfiguration streamConfiguration2 = StreamConfiguration.builder().scope(scope1).streamName(stream2).scalingPolicy(ScalingPolicy.byEventRate(100, 2, 2)).retentionPolicy(RetentionPolicy.byTime(Duration.ofMillis(123L))).build(); List < StreamConfiguration > streamsList = Arrays.asList(streamConfiguration1, streamConfiguration2); when(mockControllerService.listStreamsInScope(\"scope1\")).thenReturn(CompletableFuture.completedFuture(streamsList)); response = target(resourceURI).request().async().get(); final StreamsList streamsList1 = response.get().readEntity(StreamsList.class); assertEquals(\"List Streams response code\", 200, response.get().getStatus()); assertEquals(\"List count\", streamsList1.getStreams().size(), 2); assertEquals(\"List element\", streamsList1.getStreams().get(0).getStreamName(), \"stream1\"); assertEquals(\"List element\", streamsList1.getStreams().get(1).getStreamName(), \"stream2\"); final CompletableFuture < List < StreamConfiguration > > completableFuture1 = new CompletableFuture < > (); completableFuture1.completeExceptionally(new DataNotFoundException(\"\")); when(mockControllerService.listStreamsInScope(\"scope1\")).thenReturn(completableFuture1); response = target(resourceURI).request().async().get(); assertEquals(\"List Streams response code\", 404, response.get().getStatus()); final CompletableFuture < List < StreamConfiguration > > completableFuture = new CompletableFuture < > (); completableFuture.completeExceptionally(new Exception()); when(mockControllerService.listStreamsInScope(\"scope1\")).thenReturn(completableFuture); response = target(resourceURI).request().async().get(); assertEquals(\"List Streams response code\", 500, response.get().getStatus()); } ",
        "focal_tgt": "@Override public void listStreams(final String scopeName, final String showInternalStreams, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"listStreams\"); boolean showOnlyInternalStreams = showInternalStreams != null && showInternalStreams.equals(\"true\"); controllerService.listStreamsInScope(scopeName).thenApply(streamsList -> { StreamsList streams = new StreamsList(); streamsList.forEach(stream -> { if(( ! showOnlyInternalStreams ^ stream.getStreamName().startsWith(INTERNAL_NAME_PREFIX)) && streams.getStreams().size() < 200) { streams.addStreamsItem(ModelHelper.encodeStreamResponse(stream)); } }); log.info(\"Successfully fetched streams for scope: {}\", scopeName); return Response.status(Status.OK).entity(streams).build(); }).exceptionally(exception -> { if(exception.getCause()instanceof DataNotFoundException || exception instanceof DataNotFoundException || exception.getCause()instanceof StoreException.NodeNotFoundException || exception instanceof StoreException.NodeNotFoundException) { log.warn(\"Scope name: {} not found\", scopeName); return Response.status(Status.NOT_FOUND).build(); } else { log.warn(\"listStreams for {} failed with exception: {}\", scopeName, exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).thenApply(asyncResponse :: resume).thenAccept(x -> LoggerHelpers.traceLeave(log, \"listStreams\", traceId)); } ",
        "focal_src": "@Override public void listStreams(final String scopeName, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"listStreams\"); controllerService.listStreamsInScope(scopeName).thenApply(streamsList -> { StreamsList streams = new StreamsList(); streamsList.forEach(stream -> streams.addStreamsItem(ModelHelper.encodeStreamResponse(stream))); log.info(\"Successfully fetched streams for scope: {}\", scopeName); return Response.status(Status.OK).entity(streams).build(); }).exceptionally(exception -> { if(exception.getCause()instanceof DataNotFoundException || exception instanceof DataNotFoundException || exception.getCause()instanceof StoreException.NodeNotFoundException || exception instanceof StoreException.NodeNotFoundException) { log.warn(\"Scope name: {} not found\", scopeName); return Response.status(Status.NOT_FOUND).build(); } else { log.warn(\"listStreams for {} failed with exception: {}\", scopeName, exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).thenApply(asyncResponse :: resume).thenAccept(x -> LoggerHelpers.traceLeave(log, \"listStreams\", traceId)); } ",
        "test_tgt": "@Test public void testListStreams()throws ExecutionException, InterruptedException { final String resourceURI = \"v1/scopes/scope1/streams\"; final StreamConfiguration streamConfiguration1 = StreamConfiguration.builder().scope(scope1).streamName(stream1).scalingPolicy(ScalingPolicy.byEventRate(100, 2, 2)).retentionPolicy(RetentionPolicy.byTime(Duration.ofMillis(123L))).build(); final StreamConfiguration streamConfiguration2 = StreamConfiguration.builder().scope(scope1).streamName(stream2).scalingPolicy(ScalingPolicy.byEventRate(100, 2, 2)).retentionPolicy(RetentionPolicy.byTime(Duration.ofMillis(123L))).build(); List < StreamConfiguration > streamsList = Arrays.asList(streamConfiguration1, streamConfiguration2); when(mockControllerService.listStreamsInScope(\"scope1\")).thenReturn(CompletableFuture.completedFuture(streamsList)); response = target(resourceURI).request().async().get(); final StreamsList streamsList1 = response.get().readEntity(StreamsList.class); assertEquals(\"List Streams response code\", 200, response.get().getStatus()); assertEquals(\"List count\", streamsList1.getStreams().size(), 2); assertEquals(\"List element\", streamsList1.getStreams().get(0).getStreamName(), \"stream1\"); assertEquals(\"List element\", streamsList1.getStreams().get(1).getStreamName(), \"stream2\"); final CompletableFuture < List < StreamConfiguration > > completableFuture1 = new CompletableFuture < > (); completableFuture1.completeExceptionally(new DataNotFoundException(\"\")); when(mockControllerService.listStreamsInScope(\"scope1\")).thenReturn(completableFuture1); response = target(resourceURI).request().async().get(); assertEquals(\"List Streams response code\", 404, response.get().getStatus()); final CompletableFuture < List < StreamConfiguration > > completableFuture = new CompletableFuture < > (); completableFuture.completeExceptionally(new Exception()); when(mockControllerService.listStreamsInScope(\"scope1\")).thenReturn(completableFuture); response = target(resourceURI).request().async().get(); assertEquals(\"List Streams response code\", 500, response.get().getStatus()); final StreamConfiguration streamConfiguration3 = StreamConfiguration.builder().scope(scope1).streamName(NameUtils.getInternalNameForStream(\"stream3\")).scalingPolicy(ScalingPolicy.fixed(1)).retentionPolicy(RetentionPolicy.INFINITE).build(); List < StreamConfiguration > allStreamsList = Arrays.asList(streamConfiguration1, streamConfiguration2, streamConfiguration3); when(mockControllerService.listStreamsInScope(\"scope1\")).thenReturn(CompletableFuture.completedFuture(allStreamsList)); response = target(resourceURI).request().async().get(); StreamsList streamsListResp = response.get().readEntity(StreamsList.class); assertEquals(\"List Streams response code\", 200, response.get().getStatus()); assertEquals(\"List count\", 2, streamsListResp.getStreams().size()); assertEquals(\"List element\", \"stream1\", streamsListResp.getStreams().get(0).getStreamName()); assertEquals(\"List element\", \"stream2\", streamsListResp.getStreams().get(1).getStreamName()); response = target(resourceURI).queryParam(\"showInternalStreams\", \"true\").request().async().get(); streamsListResp = response.get().readEntity(StreamsList.class); assertEquals(\"List Streams response code\", 200, response.get().getStatus()); assertEquals(\"List count\", 1, streamsListResp.getStreams().size()); assertEquals(\"List element\", NameUtils.getInternalNameForStream(\"stream3\"), streamsListResp.getStreams().get(0).getStreamName()); streamsList = Collections.nCopies(1000, streamConfiguration1); when(mockControllerService.listStreamsInScope(\"scope1\")).thenReturn(CompletableFuture.completedFuture(streamsList)); response = target(resourceURI).request().async().get(); final StreamsList streamsList2 = response.get().readEntity(StreamsList.class); assertEquals(\"List Streams response code\", 200, response.get().getStatus()); assertEquals(\"List count\", 200, streamsList2.getStreams().size()); } "
    },
    {
        "test_src": "@Test public void testChangeState() { StateVertix state2 = new StateVertix(\"state2\", \"<table><div>state2</div></table>\"); assertFalse(sm.changeState(state2)); assertNotSame(sm.getCurrentState(), state2); Eventable c = new Eventable(new Identification(How.xpath, \"/bla\"), EventType.click); assertTrue(sm.update(c, state2, dummyBrowser, new CrawlSession(dummyBrowser))); assertEquals(\"State name changed correctly\", \"state1\", state2.getName()); assertEquals(sm.getCurrentState(), state2); assertTrue(sm.changeState(index)); assertEquals(sm.getCurrentState(), index); } ",
        "focal_tgt": "public boolean changeState(StateVertix nextState) { if(nextState == null) { LOGGER.info(\"nextState given is null\"); return false; } LOGGER.debug(\"AFTER: sm.current: \" + currentState.getName() + \" hold.current: \" + nextState.getName()); if(stateFlowGraph.canGoTo(currentState, nextState)) { LOGGER.debug(\"Changed To state: \" + nextState.getName() + \" From: \" + currentState.getName()); this.previousState = this.currentState; currentState = nextState; LOGGER.info(\"StateMachine's Pointer changed to: \" + currentState); return true; } else { LOGGER.info(\"Cannot change To state: \" + nextState.getName() + \" From: \" + currentState.getName()); return false; } } ",
        "focal_src": "public boolean changeState(StateVertix nextState) { if(nextState == null) { return false; } LOGGER.debug(\"AFTER: sm.current: \" + currentState.getName() + \" hold.current: \" + nextState.getName()); if(stateFlowGraph.canGoTo(currentState, nextState)) { LOGGER.debug(\"Changed To state: \" + nextState.getName() + \" From: \" + currentState.getName()); this.previousState = this.currentState; currentState = nextState; LOGGER.info(\"StateMachine's Pointer changed to: \" + currentState); return true; } else { LOGGER.info(\"Cannot change To state: \" + nextState.getName() + \" From: \" + currentState.getName()); return false; } } ",
        "test_tgt": "@Test public void testChangeState() { StateVertix state2 = new StateVertix(\"state2\", \"<table><div>state2</div></table>\"); assertFalse(sm.changeState(state2)); assertNotSame(sm.getCurrentState(), state2); Eventable c = new Eventable(new Identification(How.xpath, \"/bla\"), EventType.click); assertTrue(sm.update(c, state2, dummyBrowser, new CrawlSession(dummyFactory))); assertEquals(\"State name changed correctly\", \"state1\", state2.getName()); assertEquals(sm.getCurrentState(), state2); assertTrue(sm.changeState(index)); assertEquals(sm.getCurrentState(), index); } "
    },
    {
        "test_src": "@Test public void testTrainAndValidate() { logger.info(\"testTrainAndValidate\"); Configuration conf = Configuration.getConfiguration(); Dataframe[]data = Datasets.carsNumeric(conf); Dataframe trainingData = data[0]; Dataframe validationData = data[1]; String dbName = this.getClass().getSimpleName(); Modeler.TrainingParameters trainingParameters = new Modeler.TrainingParameters(); MultinomialNaiveBayes.TrainingParameters modelTrainingParameters = new MultinomialNaiveBayes.TrainingParameters(); modelTrainingParameters.setMultiProbabilityWeighted(true); trainingParameters.setModelerTrainingParameters(modelTrainingParameters); DummyXMinMaxNormalizer.TrainingParameters dtParams = new DummyXMinMaxNormalizer.TrainingParameters(); trainingParameters.setDataTransformerTrainingParameters(dtParams); trainingParameters.setFeatureSelectorTrainingParameters(null); Modeler instance = MLBuilder.create(trainingParameters, conf); instance.fit(trainingData); instance.save(dbName); instance.close(); instance = MLBuilder.load(Modeler.class, dbName, conf); instance.predict(trainingData); ClassificationMetrics vm = new ClassificationMetrics(trainingData); double expResult2 = 0.8; assertEquals(expResult2, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); trainingData.delete(); instance.close(); instance = MLBuilder.load(Modeler.class, dbName, conf); instance.predict(validationData); Map < Integer, Object > expResult = new HashMap < > (); Map < Integer, Object > result = new HashMap < > (); for(Map.Entry < Integer, Record > e : validationData.entries()) { Integer rId = e.getKey(); Record r = e.getValue(); expResult.put(rId, r.getY()); result.put(rId, r.getYPredicted()); } assertEquals(expResult, result); instance.delete(); validationData.delete(); } ",
        "focal_tgt": "private < ML extends AbstractClassifier, FS extends AbstractFeatureSelector > void trainAndValidate(ML.AbstractTrainingParameters modelerTrainingParameters, FS.AbstractTrainingParameters featureSelectorTrainingParameters, double expectedF1score) { Configuration conf = Configuration.getConfiguration(); String dbName = this.getClass().getSimpleName(); Map < Object, URI > dataset = new HashMap < > (); try { dataset.put(\"negative\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.neg.txt\").toURI()); dataset.put(\"positive\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.pos.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } TextClassifier.TrainingParameters trainingParameters = new TextClassifier.TrainingParameters(); trainingParameters.setModelerTrainingParameters(modelerTrainingParameters); trainingParameters.setDataTransformerTrainingParameters(null); trainingParameters.setFeatureSelectorTrainingParameters(featureSelectorTrainingParameters); NgramsExtractor.Parameters exParams = new NgramsExtractor.Parameters(); exParams.setMaxDistanceBetweenKwds(2); exParams.setExaminationWindowLength(6); trainingParameters.setTextExtractorParameters(exParams); TextClassifier instance = MLBuilder.create(trainingParameters, conf); instance.fit(dataset); instance.save(dbName); ClassificationMetrics vm = instance.validate(dataset); assertEquals(expectedF1score, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); instance.close(); instance = MLBuilder.load(TextClassifier.class, dbName, conf); Dataframe validationData; try { validationData = instance.predict(this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.unlabelled.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } List < Object > expResult = Arrays.asList(\"negative\", \"positive\"); int i = 0; for(Record r : validationData.values()) { assertEquals(expResult.get(i), r.getYPredicted()); ++ i; } instance.delete(); validationData.close(); } ",
        "focal_src": "private < ML extends AbstractClassifier, FS extends AbstractFeatureSelector > void trainAndValidate(ML.AbstractTrainingParameters modelerTrainingParameters, FS.AbstractTrainingParameters featureSelectorTrainingParameters, double expectedF1score) { Configuration conf = Configuration.getConfiguration(); String dbName = this.getClass().getSimpleName(); Map < Object, URI > dataset = new HashMap < > (); try { dataset.put(\"negative\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.neg.txt\").toURI()); dataset.put(\"positive\", this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.pos.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } TextClassifier.TrainingParameters trainingParameters = new TextClassifier.TrainingParameters(); trainingParameters.setModelerTrainingParameters(modelerTrainingParameters); trainingParameters.setDataTransformerTrainingParameters(null); trainingParameters.setFeatureSelectorTrainingParameters(featureSelectorTrainingParameters); NgramsExtractor.Parameters exParams = new NgramsExtractor.Parameters(); exParams.setMaxDistanceBetweenKwds(2); exParams.setExaminationWindowLength(6); trainingParameters.setTextExtractorParameters(exParams); TextClassifier instance = MLBuilder.create(trainingParameters, conf); instance.fit(dataset); instance.save(dbName); ClassificationMetrics vm = instance.validate(dataset); assertEquals(expectedF1score, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); instance.close(); instance = MLBuilder.load(TextClassifier.class, dbName, conf); Dataframe validationData; try { validationData = instance.predict(this.getClass().getClassLoader().getResource(\"datasets/sentimentAnalysis.unlabelled.txt\").toURI()); } catch(UncheckedIOException | URISyntaxException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } List < Object > expResult = Arrays.asList(\"negative\", \"positive\"); int i = 0; for(Record r : validationData.values()) { assertEquals(expResult.get(i), r.getYPredicted()); ++ i; } instance.delete(); validationData.delete(); } ",
        "test_tgt": "@Test public void testTrainAndValidate() { logger.info(\"testTrainAndValidate\"); Configuration conf = Configuration.getConfiguration(); Dataframe[]data = Datasets.carsNumeric(conf); Dataframe trainingData = data[0]; Dataframe validationData = data[1]; String dbName = this.getClass().getSimpleName(); Modeler.TrainingParameters trainingParameters = new Modeler.TrainingParameters(); MultinomialNaiveBayes.TrainingParameters modelTrainingParameters = new MultinomialNaiveBayes.TrainingParameters(); modelTrainingParameters.setMultiProbabilityWeighted(true); trainingParameters.setModelerTrainingParameters(modelTrainingParameters); DummyXMinMaxNormalizer.TrainingParameters dtParams = new DummyXMinMaxNormalizer.TrainingParameters(); trainingParameters.setDataTransformerTrainingParameters(dtParams); trainingParameters.setFeatureSelectorTrainingParameters(null); Modeler instance = MLBuilder.create(trainingParameters, conf); instance.fit(trainingData); instance.save(dbName); instance.close(); instance = MLBuilder.load(Modeler.class, dbName, conf); instance.predict(trainingData); ClassificationMetrics vm = new ClassificationMetrics(trainingData); double expResult2 = 0.8; assertEquals(expResult2, vm.getMacroF1(), Constants.DOUBLE_ACCURACY_HIGH); trainingData.close(); instance.close(); instance = MLBuilder.load(Modeler.class, dbName, conf); instance.predict(validationData); Map < Integer, Object > expResult = new HashMap < > (); Map < Integer, Object > result = new HashMap < > (); for(Map.Entry < Integer, Record > e : validationData.entries()) { Integer rId = e.getKey(); Record r = e.getValue(); expResult.put(rId, r.getY()); result.put(rId, r.getYPredicted()); } assertEquals(expResult, result); instance.delete(); validationData.close(); } "
    },
    {
        "test_src": "@TestInfo(status = TestStatus.LGTM, notes = \"The test verifies the start() method.\", targets = { @TestTarget(methodName = \"start\", methodArgs = { }) })public void test_start() { String testPattern = \"(abb)\"; String testString = \"cccabbabbabbabbabb\"; Pattern pat = Pattern.compile(testPattern); Matcher mat = pat.matcher(testString); int start = 3; int end = 6; int j; for(j = 0; j < 3; j ++ ) { while(mat.find()) { assertEquals(\"Start is wrong\", start, mat.start()); start = end; end += 3; } } } ",
        "focal_tgt": "int start(); ",
        "focal_src": "public int start(); ",
        "test_tgt": "@TestInfo(level = TestLevel.PARTIAL_OK, purpose = \"Verifies the start() method.\", targets = { @TestTarget(methodName = \"start\", methodArgs = { }) })public void test_start() { String testPattern = \"(abb)\"; String testString = \"cccabbabbabbabbabb\"; Pattern pat = Pattern.compile(testPattern); Matcher mat = pat.matcher(testString); int start = 3; int end = 6; int j; for(j = 0; j < 3; j ++ ) { while(mat.find()) { assertEquals(\"Start is wrong\", start, mat.start()); start = end; end += 3; } } } "
    },
    {
        "test_src": "@Test(expected = UnsupportedOperationException.class)public void testCalculateMac() { record.calculateMac(data); } ",
        "focal_tgt": "@Override public byte[]calculateMac(byte[]data) { writeMac.update(data); LOGGER.debug(\"The MAC was calculated over the following data: {}\", ArrayConverter.bytesToHexString(data)); byte[]result = writeMac.doFinal(); LOGGER.debug(\"MAC result: {}\", ArrayConverter.bytesToHexString(result)); return result; } ",
        "focal_src": "@Override public byte[]calculateMac(byte[]data) { writeMac.update(data); LOGGER.debug(\"The MAC was caluculated over the following data: {}\", ArrayConverter.bytesToHexString(data)); byte[]result = writeMac.doFinal(); LOGGER.debug(\"MAC result: {}\", ArrayConverter.bytesToHexString(result)); return result; } ",
        "test_tgt": "@Test public void testCalculateMac() { assertArrayEquals(record.calculateMac(data), new byte[0]); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should fail validation if complex is null\", method = \"validate(Object,Errors)\")public void validate_shouldFailValidationIfComplexIsNull()throws Exception { DrugOrder order = new DrugOrder(); order.setComplex(null); order.setDrug(Context.getConceptService().getDrug(3)); Errors errors = new BindException(order, \"order\"); new DrugOrderValidator().validate(order, errors); Assert.assertTrue(errors.hasFieldErrors(\"complex\")); } ",
        "focal_tgt": "public void validate(Object obj, Errors errors) { super.validate(obj, errors); DrugOrder order = (DrugOrder)obj; if(order == null) { errors.rejectValue(\"order\", \"error.general\"); } else { ValidationUtils.rejectIfEmpty(errors, \"asNeeded\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"dosingType\", \"error.null\"); if(order.getDrug() != null)ValidationUtils.rejectIfEmpty(errors, \"drug.concept\", \"error.null\"); if( ! (order.getConcept() == null)) { if( ! (order.getDrug() == null) && ! (order.getDrug().getConcept().equals(order.getConcept()))) { errors.rejectValue(\"drug\", \"error.general\"); errors.rejectValue(\"concept\", \"error.concept\"); } } } } ",
        "focal_src": "public void validate(Object obj, Errors errors) { super.validate(obj, errors); DrugOrder order = (DrugOrder)obj; if(order == null) { errors.rejectValue(\"order\", \"error.general\"); } else { ValidationUtils.rejectIfEmpty(errors, \"prn\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"complex\", \"error.null\"); if(order.getDrug() != null)ValidationUtils.rejectIfEmpty(errors, \"drug.concept\", \"error.null\"); if( ! (order.getConcept() == null)) { if( ! (order.getDrug() == null) && ! (order.getDrug().getConcept().equals(order.getConcept()))) { errors.rejectValue(\"drug\", \"error.general\"); errors.rejectValue(\"concept\", \"error.concept\"); } } } } ",
        "test_tgt": "@Test@Verifies(value = \"should fail validation if dosingType is null\", method = \"validate(Object,Errors)\")public void validate_shouldFailValidationIfDosingTypeIsNull()throws Exception { DrugOrder order = new DrugOrder(); order.setDosingType(null); order.setDrug(Context.getConceptService().getDrug(3)); Errors errors = new BindException(order, \"order\"); new DrugOrderValidator().validate(order, errors); Assert.assertTrue(errors.hasFieldErrors(\"dosingType\")); } "
    },
    {
        "test_src": "@Test(groups = { \"tck\" })public void test_plus_Adjuster_positiveHours() { PlusAdjuster period = MockSimplePeriod.of(7, ChronoUnit.HOURS); LocalTime t = TEST_12_30_40_987654321.plus(period); assertEquals(t, LocalTime.of(19, 30, 40, 987654321)); } ",
        "focal_tgt": "@Override public Instant plus(TemporalAdder adjuster) { return(Instant)adjuster.doPlusAdjustment(this); } ",
        "focal_src": "@Override public Instant plus(PlusAdjuster adjuster) { return(Instant)adjuster.doPlusAdjustment(this); } ",
        "test_tgt": "@Test(groups = { \"tck\" })public void test_plus_Adjuster_positiveHours() { TemporalAdder period = MockSimplePeriod.of(7, ChronoUnit.HOURS); LocalTime t = TEST_12_30_40_987654321.plus(period); assertEquals(t, LocalTime.of(19, 30, 40, 987654321)); } "
    },
    {
        "test_src": "@Test public void calculateNetworkBufNew()throws Exception { Configuration config = new Configuration(); final Float defaultFrac = TaskManagerOptions.NETWORK_BUFFERS_MEMORY_FRACTION.defaultValue(); final Long defaultMin = MemorySize.parse(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MIN.defaultValue()).getBytes(); final Long defaultMax = MemorySize.parse(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX.defaultValue()).getBytes(); assertEquals(enforceBounds((long)(defaultFrac * (10L << 20)), defaultMin, defaultMax), TaskManagerServices.calculateNetworkBufferMemory((64L << 20 + 1), config)); assertEquals(enforceBounds((long)(defaultFrac * (10L << 30)), defaultMin, defaultMax), TaskManagerServices.calculateNetworkBufferMemory((10L << 30), config)); calculateNetworkBufNew(config); } ",
        "focal_tgt": "private static void calculateNetworkBufNew(final Configuration config) { config.setLong(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MIN, 1L << 20); config.setLong(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX, 1L << 20); assertEquals(1 << 20, TaskManagerServices.calculateNetworkBufferMemory(10L << 20, config)); assertEquals(1 << 20, TaskManagerServices.calculateNetworkBufferMemory(64L << 20, config)); assertEquals(1 << 20, TaskManagerServices.calculateNetworkBufferMemory(1L << 30, config)); Random ran = new Random(); for(int i = 0; i < 1_000; ++ i) { float frac = Math.max(ran.nextFloat(), Float.MIN_VALUE); config.setFloat(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_FRACTION, frac); long min = Math.max(TaskManagerOptions.MEMORY_SEGMENT_SIZE.defaultValue(), ran.nextLong()); config.setLong(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MIN, min); long max = Math.max(min, ran.nextLong()); config.setLong(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX, max); long javaMem = Math.max(max + 1, ran.nextLong()); final long networkBufMem = TaskManagerServices.calculateNetworkBufferMemory(javaMem, config); if(networkBufMem < min) { fail(\"Lower bound not met with configuration: \" + config.toString()); } if(networkBufMem > max) { fail(\"Upper bound not met with configuration: \" + config.toString()); } if(networkBufMem > min && networkBufMem < max) { if((javaMem * frac) != networkBufMem) { fail(\"Wrong network buffer memory size with configuration: \" + config.toString() + \". Expected value: \" + (javaMem * frac) + \" actual value: \" + networkBufMem + '.'); } } } } ",
        "focal_src": "private static void calculateNetworkBufNew(final Configuration config) { config.setString(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MIN, String.valueOf(1L << 20)); config.setString(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX, String.valueOf(1L << 20)); assertEquals(1 << 20, TaskManagerServices.calculateNetworkBufferMemory(10L << 20, config)); assertEquals(1 << 20, TaskManagerServices.calculateNetworkBufferMemory(64L << 20, config)); assertEquals(1 << 20, TaskManagerServices.calculateNetworkBufferMemory(1L << 30, config)); Random ran = new Random(); for(int i = 0; i < 1_000; ++ i) { float frac = Math.max(ran.nextFloat(), Float.MIN_VALUE); config.setFloat(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_FRACTION, frac); long min = Math.max(MemorySize.parse(TaskManagerOptions.MEMORY_SEGMENT_SIZE.defaultValue()).getBytes(), ran.nextLong()); config.setString(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MIN, String.valueOf(min)); long max = Math.max(min, ran.nextLong()); config.setString(TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX, String.valueOf(max)); long javaMem = Math.max(max + 1, ran.nextLong()); final long networkBufMem = TaskManagerServices.calculateNetworkBufferMemory(javaMem, config); if(networkBufMem < min) { fail(\"Lower bound not met with configuration: \" + config.toString()); } if(networkBufMem > max) { fail(\"Upper bound not met with configuration: \" + config.toString()); } if(networkBufMem > min && networkBufMem < max) { if((javaMem * frac) != networkBufMem) { fail(\"Wrong network buffer memory size with configuration: \" + config.toString() + \". Expected value: \" + (javaMem * frac) + \" actual value: \" + networkBufMem + '.'); } } } } ",
        "test_tgt": "@Test public void calculateNetworkBufNew()throws Exception { Configuration config = new Configuration(); final Float defaultFrac = TaskManagerOptions.NETWORK_BUFFERS_MEMORY_FRACTION.defaultValue(); final Long defaultMin = TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MIN.defaultValue(); final Long defaultMax = TaskManagerOptions.NETWORK_BUFFERS_MEMORY_MAX.defaultValue(); assertEquals(enforceBounds((long)(defaultFrac * (10L << 20)), defaultMin, defaultMax), TaskManagerServices.calculateNetworkBufferMemory((64L << 20 + 1), config)); assertEquals(enforceBounds((long)(defaultFrac * (10L << 30)), defaultMin, defaultMax), TaskManagerServices.calculateNetworkBufferMemory((10L << 30), config)); calculateNetworkBufNew(config); } "
    },
    {
        "test_src": "@Test public final void testFireEvent()throws CrawljaxException, MalformedURLException { browser.goToUrl(new URL(SERVER.getSiteUrl() + \"simple.html\")); browser.fireEvent(new Eventable(new Identification(How.xpath, \"//H1\"), EventType.click)); } ",
        "focal_tgt": "@Override public synchronized boolean fireEventAndWait(Eventable eventable)throws ElementNotVisibleException, NoSuchElementException, InterruptedException { try { boolean handleChanged = false; boolean result = false; if(eventable.getRelatedFrame() != null && ! eventable.getRelatedFrame().equals(\"\")) { LOGGER.debug(\"switching to frame: \" + eventable.getRelatedFrame()); try { switchToFrame(eventable.getRelatedFrame()); } catch(NoSuchFrameException e) { LOGGER.debug(\"Frame not found, possibily while back-tracking..\", e); } handleChanged = true; } WebElement webElement = browser.findElement(eventable.getIdentification().getWebDriverBy()); if(webElement != null) { result = fireEventWait(webElement, eventable); } if(handleChanged) { browser.switchTo().defaultContent(); } return result; } catch(ElementNotVisibleException | NoSuchElementException e) { throw e; } catch(WebDriverException e) { throwIfConnectionException(e); return false; } } ",
        "focal_src": "@Override public synchronized boolean fireEvent(Eventable eventable)throws ElementNotVisibleException, NoSuchElementException { try { boolean handleChanged = false; boolean result = false; if(eventable.getRelatedFrame() != null && ! eventable.getRelatedFrame().equals(\"\")) { LOGGER.debug(\"switching to frame: \" + eventable.getRelatedFrame()); try { switchToFrame(eventable.getRelatedFrame()); } catch(NoSuchFrameException e) { LOGGER.debug(\"Frame not found, possibily while back-tracking..\", e); } handleChanged = true; } WebElement webElement = browser.findElement(eventable.getIdentification().getWebDriverBy()); if(webElement != null) { result = fireEventWait(webElement, eventable); } if(handleChanged) { browser.switchTo().defaultContent(); } return result; } catch(ElementNotVisibleException | NoSuchElementException e) { throw e; } catch(WebDriverException e) { throwIfConnectionException(e); return false; } } ",
        "test_tgt": "@Test public final void testFireEvent()throws Exception { browser.goToUrl(new URL(SERVER.getSiteUrl() + \"simple.html\")); browser.fireEventAndWait(new Eventable(new Identification(How.xpath, \"//H1\"), EventType.click)); } "
    },
    {
        "test_src": "@Test public void testSum() { assertThat(emptyVector().sum(), closeTo(0)); assertThat(singleton().sum(), closeTo(Math.PI)); assertThat(simpleVector().sum(), closeTo(7)); } ",
        "focal_tgt": "public double sum() { double result = 0; DoubleIterator iter = values().iterator(); while(iter.hasNext()) { result += iter.nextDouble(); } return result; } ",
        "focal_src": "public double sum() { if(sum == null) { double s = 0; DoubleIterator iter = values().iterator(); while(iter.hasNext()) { s += iter.nextDouble(); } sum = s; } return sum; } ",
        "test_tgt": "@Test public void testSum() { assertThat(emptyVector().sum(), closeTo(0)); assertThat(singleton().sum(), closeTo(Math.PI)); SparseVector sv = simpleVector(); assertThat(sv.sum(), closeTo(7)); assertThat(sv.sum(), closeTo(7)); } "
    },
    {
        "test_src": "@Test public void testLocalPeek()throws Exception { if(cacheMode() == LOCAL) { checkAffinityLocalCache(); checkStorage(0); } else { checkAffinityPeek(0); checkAffinityPeek(1); checkStorage(0); checkStorage(1); } } ",
        "focal_tgt": "@Override public final V localPeek(K key, CachePeekMode[]peekModes)throws IgniteCheckedException { A.notNull(key, \"key\"); if(keyCheck)validateCacheKey(key); ctx.checkSecurity(SecurityPermission.CACHE_READ); PeekModes modes = parsePeekModes(peekModes, false); KeyCacheObject cacheKey = ctx.toCacheKeyObject(key); CacheObject cacheVal = null; AffinityTopologyVersion topVer = ctx.affinity().affinityTopologyVersion(); int part = ctx.affinity().partition(cacheKey); boolean nearKey; if( ! (modes.near && modes.primary && modes.backup)) { boolean keyPrimary = ctx.affinity().primaryByPartition(ctx.localNode(), part, topVer); if(keyPrimary) { if( ! modes.primary)return null; nearKey = false; } else { boolean keyBackup = ctx.affinity().partitionBelongs(ctx.localNode(), part, topVer); if(keyBackup) { if( ! modes.backup)return null; nearKey = false; } else { if( ! modes.near)return null; nearKey = true; modes.offheap = false; } } } else { nearKey = ! ctx.affinity().partitionBelongs(ctx.localNode(), part, topVer); if(nearKey) { modes.offheap = false; } } if(nearKey && ! ctx.isNear())return null; GridCacheEntryEx e; GridCacheContext ctx0; while(true) { if(nearKey)e = peekEx(key); else { ctx0 = ctx.isNear() ? ctx.near().dht().context() : ctx; e = modes.offheap ? ctx0.cache().entryEx(key) : ctx0.cache().peekEx(key); } if(e != null) { ctx.shared().database().checkpointReadLock(); try { cacheVal = ctx.mvccEnabled() ? e.mvccPeek(modes.heap && ! modes.offheap) : e.peek(modes.heap, modes.offheap, topVer, null); } catch(GridCacheEntryRemovedException ignore) { if(log.isDebugEnabled())log.debug(\"Got removed entry during 'peek': \" + key); continue; } finally { e.touch(); ctx.shared().database().checkpointReadUnlock(); } } break; } Object val = ctx.unwrapBinaryIfNeeded(cacheVal, ctx.keepBinary(), false); return(V)val; } ",
        "focal_src": "@Override public final V localPeek(K key, CachePeekMode[]peekModes)throws IgniteCheckedException { A.notNull(key, \"key\"); if(keyCheck)validateCacheKey(key); ctx.checkSecurity(SecurityPermission.CACHE_READ); PeekModes modes = parsePeekModes(peekModes, false); KeyCacheObject cacheKey = ctx.toCacheKeyObject(key); CacheObject cacheVal = null; if( ! ctx.isLocal()) { AffinityTopologyVersion topVer = ctx.affinity().affinityTopologyVersion(); int part = ctx.affinity().partition(cacheKey); boolean nearKey; if( ! (modes.near && modes.primary && modes.backup)) { boolean keyPrimary = ctx.affinity().primaryByPartition(ctx.localNode(), part, topVer); if(keyPrimary) { if( ! modes.primary)return null; nearKey = false; } else { boolean keyBackup = ctx.affinity().partitionBelongs(ctx.localNode(), part, topVer); if(keyBackup) { if( ! modes.backup)return null; nearKey = false; } else { if( ! modes.near)return null; nearKey = true; modes.offheap = false; } } } else { nearKey = ! ctx.affinity().partitionBelongs(ctx.localNode(), part, topVer); if(nearKey) { modes.offheap = false; } } if(nearKey && ! ctx.isNear())return null; GridCacheEntryEx e; GridCacheContext ctx0; while(true) { if(nearKey)e = peekEx(key); else { ctx0 = ctx.isNear() ? ctx.near().dht().context() : ctx; e = modes.offheap ? ctx0.cache().entryEx(key) : ctx0.cache().peekEx(key); } if(e != null) { ctx.shared().database().checkpointReadLock(); try { cacheVal = ctx.mvccEnabled() ? e.mvccPeek(modes.heap && ! modes.offheap) : e.peek(modes.heap, modes.offheap, topVer, null); } catch(GridCacheEntryRemovedException ignore) { if(log.isDebugEnabled())log.debug(\"Got removed entry during 'peek': \" + key); continue; } finally { e.touch(); ctx.shared().database().checkpointReadUnlock(); } } break; } } else { while(true) { try { cacheVal = localCachePeek0(cacheKey, modes.heap, modes.offheap); break; } catch(GridCacheEntryRemovedException ignore) { if(log.isDebugEnabled())log.debug(\"Got removed entry during 'peek': \" + key); } } } Object val = ctx.unwrapBinaryIfNeeded(cacheVal, ctx.keepBinary(), false); return(V)val; } ",
        "test_tgt": "@Test public void testLocalPeek()throws Exception { checkAffinityPeek(0); checkAffinityPeek(1); } "
    },
    {
        "test_src": "@Test public void testEquals() { Assert.assertEquals(byClass(SimpleTypedNameDeclaration.class), byClass(SimpleTypedNameDeclaration.class)); Assert.assertEquals(byClass(List.class), byClass(ArrayList.class)); Assert.assertEquals(byClass(ArrayList.class), byClass(List.class)); Assert.assertEquals(byName(\"String\"), byName(\"String\")); Assert.assertEquals(byClass(String.class), byName(\"String\")); Assert.assertEquals(byClass(JComponent.class), byClass(JTextField.class)); Assert.assertFalse(byClass(Map.class).equals(byClass(List.class))); Assert.assertFalse(byName(\"A\").equals(byName(\"B\"))); Assert.assertFalse(byClass(String.class).equals(byName(\"A\"))); Assert.assertEquals(by(Double.TYPE, \"double\"), by(null, \"double\")); Assert.assertEquals(by(Double.class, \"Double\"), by(null, \"double\")); Assert.assertEquals(by(Character.class, \"Character\"), by(null, \"char\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(null, \"float\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(null, \"int\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(Integer.class, \"Integer\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(null, \"long\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(Long.TYPE, \"long\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(Long.class, \"Long\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(null, \"int\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(Integer.TYPE, \"int\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(Integer.class, \"Integer\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(null, \"long\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(Long.TYPE, \"long\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(Long.class, \"Long\")); Assert.assertEquals(by(Integer.TYPE, \"int\"), by(null, \"char\")); Assert.assertEquals(by(Integer.TYPE, \"int\"), by(Character.TYPE, \"char\")); Assert.assertEquals(by(Integer.TYPE, \"int\"), by(Character.class, \"Character\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(null, \"int\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(Integer.TYPE, \"int\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(Integer.class, \"Integer\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(null, \"char\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(Character.TYPE, \"char\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(Character.class, \"Character\")); } ",
        "focal_tgt": "@Override public boolean equals(Object obj) { if(this == obj)return true; if(obj == null)return false; if(getClass() != obj.getClass())return false; SimpleTypedNameDeclaration other = (SimpleTypedNameDeclaration)obj; if(type == null) { if(other.type == Object.class)return true; if(other.type != null)return false; } if(type != null && (type.equals(other.type) || type == Object.class))return true; if(type != null && other.type != null && (type.isAssignableFrom(other.type) || other.type.isAssignableFrom(type)))return true; if(typeImage == null) { if(other.typeImage != null)return false; } else if( ! typeImage.equals(other.typeImage)) { if(other.typeImage != null) { String lcType = typeImage.toLowerCase(); String otherLcType = other.typeImage.toLowerCase(); if(primitiveTypes.contains(lcType) && primitiveTypes.contains(otherLcType)) { if(lcType.equals(otherLcType)) { return true; } else if((lcType.equals(\"char\") || lcType.equals(\"character\")) && (otherLcType.equals(\"char\") || otherLcType.equals(\"character\"))) { return true; } else if((lcType.equals(\"int\") || lcType.equals(\"integer\")) && (otherLcType.equals(\"int\") || otherLcType.equals(\"integer\") || otherLcType.equals(\"short\") || otherLcType.equals(\"char\") || otherLcType.equals(\"character\") || otherLcType.equals(\"byte\"))) { return true; } else if(lcType.equals(\"double\") && (otherLcType.equals(\"float\") || otherLcType.equals(\"int\") || otherLcType.equals(\"integer\") || otherLcType.equals(\"long\"))) { return true; } else if(lcType.equals(\"float\") && (otherLcType.equals(\"int\") || otherLcType.equals(\"integer\") || otherLcType.equals(\"long\"))) { return true; } else if(lcType.equals(\"long\") && (otherLcType.equals(\"int\") || otherLcType.equals(\"integer\") || otherLcType.equals(\"char\") || otherLcType.equals(\"character\"))) { return true; } } } return false; } return true; } ",
        "focal_src": "@Override public boolean equals(Object obj) { if(this == obj)return true; if(obj == null)return false; if(getClass() != obj.getClass())return false; SimpleTypedNameDeclaration other = (SimpleTypedNameDeclaration)obj; if(type == null) { if(other.type != null)return false; } if(type != null && type.equals(other.type))return true; if(type != null && other.type != null && (type.isAssignableFrom(other.type) || other.type.isAssignableFrom(type)))return true; if(typeImage == null) { if(other.typeImage != null)return false; } else if( ! typeImage.equals(other.typeImage)) { if(other.typeImage != null) { String lcType = typeImage.toLowerCase(); String otherLcType = other.typeImage.toLowerCase(); if(primitiveTypes.contains(lcType) && primitiveTypes.contains(otherLcType)) { if(lcType.equals(otherLcType)) { return true; } else if((lcType.equals(\"char\") || lcType.equals(\"character\")) && (otherLcType.equals(\"char\") || otherLcType.equals(\"character\"))) { return true; } else if((lcType.equals(\"int\") || lcType.equals(\"integer\")) && (otherLcType.equals(\"int\") || otherLcType.equals(\"integer\") || otherLcType.equals(\"short\") || otherLcType.equals(\"char\") || otherLcType.equals(\"character\") || otherLcType.equals(\"byte\"))) { return true; } else if(lcType.equals(\"double\") && (otherLcType.equals(\"float\") || otherLcType.equals(\"int\") || otherLcType.equals(\"integer\") || otherLcType.equals(\"long\"))) { return true; } else if(lcType.equals(\"float\") && (otherLcType.equals(\"int\") || otherLcType.equals(\"integer\") || otherLcType.equals(\"long\"))) { return true; } else if(lcType.equals(\"long\") && (otherLcType.equals(\"int\") || otherLcType.equals(\"integer\") || otherLcType.equals(\"char\") || otherLcType.equals(\"character\"))) { return true; } } } return false; } return true; } ",
        "test_tgt": "@Test public void testEquals() { Assert.assertEquals(byClass(SimpleTypedNameDeclaration.class), byClass(SimpleTypedNameDeclaration.class)); Assert.assertEquals(byClass(List.class), byClass(ArrayList.class)); Assert.assertEquals(byClass(ArrayList.class), byClass(List.class)); Assert.assertEquals(byName(\"String\"), byName(\"String\")); Assert.assertEquals(byClass(String.class), byName(\"String\")); Assert.assertEquals(byClass(JComponent.class), byClass(JTextField.class)); Assert.assertFalse(byClass(Map.class).equals(byClass(List.class))); Assert.assertFalse(byName(\"A\").equals(byName(\"B\"))); Assert.assertFalse(byClass(String.class).equals(byName(\"A\"))); Assert.assertEquals(by(Double.TYPE, \"double\"), by(null, \"double\")); Assert.assertEquals(by(Double.class, \"Double\"), by(null, \"double\")); Assert.assertEquals(by(Character.class, \"Character\"), by(null, \"char\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(null, \"float\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(null, \"int\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(Integer.class, \"Integer\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(null, \"long\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(Long.TYPE, \"long\")); Assert.assertEquals(by(Double.TYPE, \"double\"), by(Long.class, \"Long\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(null, \"int\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(Integer.TYPE, \"int\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(Integer.class, \"Integer\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(null, \"long\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(Long.TYPE, \"long\")); Assert.assertEquals(by(Float.TYPE, \"float\"), by(Long.class, \"Long\")); Assert.assertEquals(by(Integer.TYPE, \"int\"), by(null, \"char\")); Assert.assertEquals(by(Integer.TYPE, \"int\"), by(Character.TYPE, \"char\")); Assert.assertEquals(by(Integer.TYPE, \"int\"), by(Character.class, \"Character\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(null, \"int\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(Integer.TYPE, \"int\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(Integer.class, \"Integer\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(null, \"char\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(Character.TYPE, \"char\")); Assert.assertEquals(by(Long.TYPE, \"long\"), by(Character.class, \"Character\")); Assert.assertEquals(by(Object.class, \"Object\"), by(null, \"Something\")); } "
    },
    {
        "test_src": "@Test public void testPutConnectionBackInPartition()throws InterruptedException { expect(mockPartition.getFreeConnections()).andReturn(mockConnectionHandles).anyTimes(); AtomicInteger ai = new AtomicInteger(1); expect(mockPartition.getAvailableConnections()).andReturn(ai).anyTimes(); expect(mockConnection.getOriginatingPartition()).andReturn(mockPartition).anyTimes(); expect(mockConnectionHandles.tryTransfer(mockConnection)).andReturn(false).anyTimes(); mockConnectionHandles.put(mockConnection); expectLastCall().once(); replay(mockPartition, mockConnectionHandles, mockConnection); testClass.putConnectionBackInPartition(mockConnection); assertEquals(2, ai.get()); verify(mockPartition, mockConnectionHandles); } ",
        "focal_tgt": "protected void putConnectionBackInPartition(ConnectionHandle connectionHandle)throws SQLException { BoundedLinkedTransferQueue < ConnectionHandle > queue = connectionHandle.getOriginatingPartition().getFreeConnections(); if( ! queue.tryTransfer(connectionHandle)) { if( ! queue.tryPut(connectionHandle)) { connectionHandle.internalClose(); } } } ",
        "focal_src": "protected void putConnectionBackInPartition(ConnectionHandle connectionHandle) { LinkedTransferQueue < ConnectionHandle > queue = connectionHandle.getOriginatingPartition().getFreeConnections(); if( ! queue.tryTransfer(connectionHandle)) { queue.put(connectionHandle); } connectionHandle.getOriginatingPartition().getAvailableConnections().incrementAndGet(); } ",
        "test_tgt": "@Test public void testPutConnectionBackInPartition()throws InterruptedException, SQLException { expect(mockPartition.getFreeConnections()).andReturn(mockConnectionHandles).anyTimes(); expect(mockPartition.getAvailableConnections()).andReturn(1).anyTimes(); expect(mockConnection.getOriginatingPartition()).andReturn(mockPartition).anyTimes(); expect(mockConnectionHandles.tryTransfer(mockConnection)).andReturn(false).anyTimes(); expect(mockConnectionHandles.tryPut(mockConnection)).andReturn(true).once(); replay(mockPartition, mockConnectionHandles, mockConnection); testClass.putConnectionBackInPartition(mockConnection); verify(mockPartition, mockConnectionHandles); } "
    },
    {
        "test_src": "@Test public void testSubmitTopology()throws Exception { HttpURLConnection httpURLConnection = Mockito.mock(HttpURLConnection.class); final String appConf = \"{app: conf}\"; PowerMockito.spy(NetworkUtils.class); PowerMockito.doReturn(null).when(NetworkUtils.class, \"getHttpConnection\", Mockito.anyString()); Assert.assertFalse(controller.submitTopology(Mockito.anyString())); PowerMockito.verifyStatic(); NetworkUtils.getHttpConnection(Mockito.anyString()); PowerMockito.spy(NetworkUtils.class); PowerMockito.doReturn(httpURLConnection).when(NetworkUtils.class, \"getHttpConnection\", Mockito.anyString()); PowerMockito.doReturn(false).when(NetworkUtils.class, \"sendHttpPostRequest\", Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); Assert.assertFalse(controller.submitTopology(appConf)); PowerMockito.verifyStatic(); NetworkUtils.getHttpConnection(Mockito.anyString()); NetworkUtils.sendHttpPostRequest(Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); PowerMockito.spy(NetworkUtils.class); PowerMockito.doReturn(httpURLConnection).when(NetworkUtils.class, \"getHttpConnection\", Mockito.anyString()); PowerMockito.doReturn(true).when(NetworkUtils.class, \"sendHttpPostRequest\", Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); PowerMockito.doReturn(false).when(NetworkUtils.class, \"checkHttpResponseCode\", Mockito.any(HttpURLConnection.class), Mockito.anyInt()); Assert.assertFalse(controller.submitTopology(appConf)); PowerMockito.verifyStatic(); NetworkUtils.getHttpConnection(Mockito.anyString()); NetworkUtils.sendHttpPostRequest(Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); NetworkUtils.checkHttpResponseCode(Mockito.any(HttpURLConnection.class), Mockito.anyInt()); PowerMockito.spy(NetworkUtils.class); PowerMockito.doReturn(httpURLConnection).when(NetworkUtils.class, \"getHttpConnection\", Mockito.anyString()); PowerMockito.doReturn(true).when(NetworkUtils.class, \"sendHttpPostRequest\", Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); PowerMockito.doReturn(true).when(NetworkUtils.class, \"checkHttpResponseCode\", Mockito.any(HttpURLConnection.class), Mockito.anyInt()); Assert.assertTrue(controller.submitTopology(appConf)); PowerMockito.verifyStatic(); NetworkUtils.getHttpConnection(Mockito.anyString()); NetworkUtils.sendHttpPostRequest(Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); NetworkUtils.checkHttpResponseCode(Mockito.any(HttpURLConnection.class), Mockito.anyInt()); } ",
        "focal_tgt": "public boolean submitTopology(String appConf) { if(this.isVerbose) { LOG.log(Level.INFO, \"Topology conf is: \" + appConf); } if( ! this.topologyName.equals(this.topologyName.toLowerCase())) { LOG.log(Level.SEVERE, \"Marathon scheduler does not allow upper case topologies\"); return false; } String schedulerURI = String.format(\"%s/v2/groups\", this.marathonURI); HttpURLConnection conn = NetworkUtils.getHttpConnection(schedulerURI); if(this.marathonAuthToken != null) { conn.setRequestProperty(\"Authorization\", String.format(\"token=%s\", this.marathonAuthToken)); } if(conn == null) { LOG.log(Level.SEVERE, \"Failed to find marathon scheduler\"); return false; } try { if( ! NetworkUtils.sendHttpPostRequest(conn, NetworkUtils.JSON_TYPE, appConf.getBytes())) { LOG.log(Level.SEVERE, \"Failed to send post request\"); return false; } boolean success = NetworkUtils.checkHttpResponseCode(conn, HttpURLConnection.HTTP_CREATED); if(success) { LOG.log(Level.INFO, \"Topology submitted successfully\"); return true; } else if(NetworkUtils.checkHttpResponseCode(conn, HttpURLConnection.HTTP_UNAUTHORIZED)) { LOG.log(Level.SEVERE, \"Marathon requires authentication\"); return false; } else { LOG.log(Level.SEVERE, \"Failed to submit topology\"); return false; } } finally { conn.disconnect(); } } ",
        "focal_src": "public boolean submitTopology(String appConf) { if(this.isVerbose) { LOG.log(Level.INFO, \"Topology conf is: \" + appConf); } if( ! this.topologyName.equals(this.topologyName.toLowerCase())) { LOG.log(Level.SEVERE, \"Marathon scheduler does not allow upper case topologies\"); return false; } String schedulerURI = String.format(\"%s/v2/groups\", this.marathonURI); HttpURLConnection conn = NetworkUtils.getHttpConnection(schedulerURI); if(conn == null) { LOG.log(Level.SEVERE, \"Failed to find marathon scheduler\"); return false; } try { if( ! NetworkUtils.sendHttpPostRequest(conn, NetworkUtils.JSON_TYPE, appConf.getBytes())) { LOG.log(Level.SEVERE, \"Failed to send post request\"); return false; } boolean success = NetworkUtils.checkHttpResponseCode(conn, HttpURLConnection.HTTP_CREATED); if(success) { LOG.log(Level.INFO, \"Topology submitted successfully\"); return true; } else { LOG.log(Level.SEVERE, \"Failed to submit topology\"); return false; } } finally { conn.disconnect(); } } ",
        "test_tgt": "@Test public void testSubmitTopology()throws Exception { HttpURLConnection httpURLConnection = Mockito.mock(HttpURLConnection.class); final String appConf = \"{app: conf}\"; PowerMockito.spy(NetworkUtils.class); PowerMockito.doReturn(httpURLConnection).when(NetworkUtils.class, \"getHttpConnection\", Mockito.anyString()); Assert.assertFalse(controller.submitTopology(Mockito.anyString())); PowerMockito.verifyStatic(); NetworkUtils.getHttpConnection(Mockito.anyString()); PowerMockito.spy(NetworkUtils.class); PowerMockito.doReturn(httpURLConnection).when(NetworkUtils.class, \"getHttpConnection\", Mockito.anyString()); PowerMockito.doReturn(false).when(NetworkUtils.class, \"sendHttpPostRequest\", Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); Assert.assertFalse(controller.submitTopology(appConf)); PowerMockito.verifyStatic(); NetworkUtils.getHttpConnection(Mockito.anyString()); NetworkUtils.sendHttpPostRequest(Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); PowerMockito.spy(NetworkUtils.class); PowerMockito.doReturn(httpURLConnection).when(NetworkUtils.class, \"getHttpConnection\", Mockito.anyString()); PowerMockito.doReturn(true).when(NetworkUtils.class, \"sendHttpPostRequest\", Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); PowerMockito.doReturn(false).when(NetworkUtils.class, \"checkHttpResponseCode\", Mockito.any(HttpURLConnection.class), Mockito.anyInt()); Assert.assertFalse(controller.submitTopology(appConf)); PowerMockito.verifyStatic(); NetworkUtils.getHttpConnection(Mockito.anyString()); NetworkUtils.sendHttpPostRequest(Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); NetworkUtils.checkHttpResponseCode(Mockito.any(HttpURLConnection.class), Mockito.anyInt()); PowerMockito.spy(NetworkUtils.class); PowerMockito.doReturn(httpURLConnection).when(NetworkUtils.class, \"getHttpConnection\", Mockito.anyString()); PowerMockito.doReturn(true).when(NetworkUtils.class, \"sendHttpPostRequest\", Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); PowerMockito.doReturn(false).when(NetworkUtils.class, \"checkHttpResponseCode\", Mockito.any(HttpURLConnection.class), Mockito.anyInt()); PowerMockito.doReturn(true).when(NetworkUtils.class, \"checkHttpResponseCode\", httpURLConnection, HttpURLConnection.HTTP_UNAUTHORIZED); Assert.assertFalse(controller.submitTopology(appConf)); PowerMockito.verifyStatic(); NetworkUtils.getHttpConnection(Mockito.anyString()); NetworkUtils.sendHttpPostRequest(Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); NetworkUtils.checkHttpResponseCode(Mockito.any(HttpURLConnection.class), Mockito.anyInt()); NetworkUtils.checkHttpResponseCode(httpURLConnection, HttpURLConnection.HTTP_UNAUTHORIZED); PowerMockito.spy(NetworkUtils.class); PowerMockito.doReturn(httpURLConnection).when(NetworkUtils.class, \"getHttpConnection\", Mockito.anyString()); PowerMockito.doReturn(true).when(NetworkUtils.class, \"sendHttpPostRequest\", Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); PowerMockito.doReturn(true).when(NetworkUtils.class, \"checkHttpResponseCode\", Mockito.any(HttpURLConnection.class), Mockito.anyInt()); Assert.assertTrue(controller.submitTopology(appConf)); PowerMockito.verifyStatic(); NetworkUtils.getHttpConnection(Mockito.anyString()); NetworkUtils.sendHttpPostRequest(Mockito.any(HttpURLConnection.class), Mockito.anyString(), Mockito.any(byte[].class)); NetworkUtils.checkHttpResponseCode(Mockito.any(HttpURLConnection.class), Mockito.anyInt()); } "
    },
    {
        "test_src": "@Test public void testInclude() { System.out.println(\"include\"); RunTable instance = createHorizontalInstance(); ByteProcessor buffer = instance.getBuffer(); buffer.invert(); GlobalFilter filter = new GlobalFilter(buffer, 127); RunTableFactory factory = new RunTableFactory(HORIZONTAL); RunTable that = factory.createTable(\"inverted\", filter.filteredImage()); that.dumpSequences(); System.out.println(\"inverted\" + that.dumpOf()); instance.include(that); instance.dumpSequences(); System.out.println(\"full\" + instance.dumpOf()); assertEquals(5, instance.getTotalRunCount()); } ",
        "focal_tgt": "public void include(RunTable that) { if(that == null) { throw new IllegalArgumentException(\"Cannot include a null RunTable\"); } if(that.orientation != orientation) { throw new IllegalArgumentException(\"Cannot include a RunTable of different orientation\"); } if(that.width != width) { throw new IllegalArgumentException(\"Cannot include a RunTable of different width\"); } if(that.height != height) { throw new IllegalArgumentException(\"Cannot include a RunTable of different height\"); } for(int row = 0, size = getSize(); row < size; row ++ ) { for(Itr it = that.new Itr(row); it.hasNext(); ) { Run thatRun = it.next(); addRun(row, thatRun); } } } ",
        "focal_src": "public void include(RunTable that) { if(that == null) { throw new IllegalArgumentException(\"Cannot include a null runsTable\"); } if(that.orientation != orientation) { throw new IllegalArgumentException(\"Cannot include a runsTable of different orientation\"); } if(that.width != width) { throw new IllegalArgumentException(\"Cannot include a runsTable of different width\"); } if(that.height != height) { throw new IllegalArgumentException(\"Cannot include a runsTable of different height\"); } for(int row = 0; row < getSize(); row ++ ) { RunSequence thisSeq = this.getSequence(row); RunSequence thatSeq = that.getSequence(row); for(Run thatRun : thatSeq) { thisSeq.add(thatRun); } } } ",
        "test_tgt": "@Test public void testInclude() { System.out.println(\"\\n+++ include\"); RunTable instance = createHorizontalInstance(); ByteProcessor buffer = instance.getBuffer(); buffer.invert(); GlobalFilter filter = new GlobalFilter(buffer, 127); RunTableFactory factory = new RunTableFactory(HORIZONTAL); RunTable that = factory.createTable(\"inverted\", filter.filteredImage()); System.out.println(\"inverted\" + that.dumpOf()); that.dumpSequences(); instance.include(that); System.out.println(\"full\" + instance.dumpOf()); instance.dumpSequences(); assertEquals(5, instance.getTotalRunCount()); } "
    },
    {
        "test_src": "@Test public void testRemove() { map.put(key1, value1); assertEquals2(value1, map.remove(key1)); assertEquals2(Intrinsics.defaultVTypeValue(), map.remove(key1)); assertEquals(0, map.size()); assertEquals(1, map.deleted); assertEquals(0, map.assigned); } ",
        "focal_tgt": "@Override public VType remove(KType key) { final int mask = states.length - 1; int slot = keyHashFunction.hash(key) & mask; while(states[slot] == ASSIGNED) { if(keyComparator.compare(keys[slot], key) == 0) { assigned -- ; VType v = values[slot]; shiftConflictingKeys(slot); return v; } slot = (slot + 1) & mask; } return Intrinsics. < VType > defaultVTypeValue(); } ",
        "focal_src": "@Override public VType remove(KType key) { final int slot = slotFor(key); final VType value = values[slot]; final byte state = states[slot]; if(state == ASSIGNED) { deleted ++ ; assigned -- ; keys[slot] = Intrinsics. < KType > defaultKTypeValue(); values[slot] = Intrinsics. < VType > defaultVTypeValue(); states[slot] = DELETED; } else { assert(Intrinsics.defaultVTypeValue() == value) : \"Default value expected.\"; } return value; } ",
        "test_tgt": "@Test public void testRemove() { map.put(key1, value1); assertEquals2(value1, map.remove(key1)); assertEquals2(Intrinsics.defaultVTypeValue(), map.remove(key1)); assertEquals(0, map.size()); assertEquals(0, map.assigned); } "
    },
    {
        "test_src": "@Test public void testDelete()throws MetaDataException { MetaDataEntry meta = new MetaDataEntry(\"u\", \"q\", \"tbd\", \"whatever\"); meta.addField(\"text\", \"some text\"); meta.addField(\"binary\", new byte[] { 'b', 'i', 'n' }); mds.add(context, meta); Assert.assertEquals(meta, mds.get(context, \"u\", \"q\", \"tbd\", \"whatever\")); mds.delete(context, \"u\", \"q\", \"tbd\", \"whatever\"); Assert.assertNull(mds.get(context, \"u\", \"q\", \"tbd\", \"whatever\")); Assert.assertFalse(mds.list(context, \"u\", null, \"tbd\", null).contains(meta)); MetaDataEntry meta1 = new MetaDataEntry(\"u\", \"q\", \"tbd\", \"whatever\"); meta1.addField(\"other\", \"other text\"); try { mds.update(context, meta1); Assert.fail(\"update should fail\"); } catch(MetaDataException e) { } mds.add(context, meta1); Assert.assertEquals(meta1, mds.get(context, \"u\", \"q\", \"tbd\", \"whatever\")); } ",
        "focal_tgt": "public void delete(OperationContext context, String account, String application, String type, String name)throws OperationException; ",
        "focal_src": "public void delete(OperationContext context, String account, String application, String type, String name)throws MetaDataException; ",
        "test_tgt": "@Test public void testDelete()throws OperationException { MetaDataEntry meta = new MetaDataEntry(\"u\", \"q\", \"tbd\", \"whatever\"); meta.addField(\"text\", \"some text\"); meta.addField(\"binary\", new byte[] { 'b', 'i', 'n' }); mds.add(context, meta); Assert.assertEquals(meta, mds.get(context, \"u\", \"q\", \"tbd\", \"whatever\")); mds.delete(context, \"u\", \"q\", \"tbd\", \"whatever\"); Assert.assertNull(mds.get(context, \"u\", \"q\", \"tbd\", \"whatever\")); Assert.assertFalse(mds.list(context, \"u\", null, \"tbd\", null).contains(meta)); MetaDataEntry meta1 = new MetaDataEntry(\"u\", \"q\", \"tbd\", \"whatever\"); meta1.addField(\"other\", \"other text\"); try { mds.update(context, meta1); Assert.fail(\"update should fail\"); } catch(OperationException e) { } mds.add(context, meta1); Assert.assertEquals(meta1, mds.get(context, \"u\", \"q\", \"tbd\", \"whatever\")); } "
    },
    {
        "test_src": "@Test public void testSetDatasetOverlays() { OverlayTranslator ot = new OverlayTranslator(); Random r = new Random(1234); Dataset ds = makeDataset(makeRandomByteArray(r, 11, 15), \"Foo\"); ImagePlus imagePlus = makeImagePlus(\"Bar\", makeRandomByteArray(r, 11, 15)); imagePlus.setRoi(makePolygonROI(new int[] { 0, 5, 5, 0, 0 }, new int[] { 0, 0, 5, 5, 0 })); ot.setDatasetOverlays(ds, imagePlus); } ",
        "focal_tgt": "public void setDisplayOverlays(final Display display, final ImagePlus imp) { final OverlayManager overlayManager = ImageJ.get(OverlayManager.class); ShapeRoi oldROI = createROI(overlayManager.getOverlays(display)); if(oldROI != null) { float[]oldPath = oldROI.getShapeAsArray(); Roi newROI = imp.getRoi(); if(newROI instanceof ShapeRoi) { float[]newPath = ((ShapeRoi)newROI).getShapeAsArray(); if(oldPath.length == newPath.length) { boolean same = true; for(int i = 0; i < oldPath.length; i ++ ) { if(oldPath[i] != newPath[i]) { same = false; break; } } if(same)return; } } } final List < Overlay > overlaysToRemove = overlayManager.getOverlays(display); for(Overlay overlay : overlaysToRemove) { overlayManager.removeOverlay(display, overlay); } final List < Overlay > overlays = getOverlays(imp); overlayManager.addOverlays(display, overlays); } ",
        "focal_src": "public void setDatasetOverlays(final Dataset ds, final ImagePlus imp) { final OverlayManager overlayManager = ImageJ.get(OverlayManager.class); ShapeRoi oldROI = createROI(overlayManager.getOverlays(ds)); if(oldROI != null) { float[]oldPath = oldROI.getShapeAsArray(); Roi newROI = imp.getRoi(); if(newROI instanceof ShapeRoi) { float[]newPath = ((ShapeRoi)newROI).getShapeAsArray(); if(oldPath.length == newPath.length) { boolean same = true; for(int i = 0; i < oldPath.length; i ++ ) { if(oldPath[i] != newPath[i]) { same = false; break; } } if(same)return; } } } final List < Overlay > overlaysToRemove = overlayManager.getOverlays(ds); for(Overlay overlay : overlaysToRemove) { overlayManager.removeOverlay(ds, overlay); } final List < Overlay > overlays = getOverlays(imp); overlayManager.setOverlays(ds, overlays); } ",
        "test_tgt": "@Test public void testSetDatasetOverlays() { } "
    },
    {
        "test_src": "@Test public void testAlwaysAddChannel() { MutableSparseVector simple = simpleVector(); simple.addChannel(fooSymbol); simple.channel(fooSymbol).set(3, 4.5); simple.alwaysAddChannel(fooSymbol); simple.alwaysAddChannel(barSymbol); assert(simple.channel(barSymbol).isEmpty()); simple.channel(barSymbol).set(3, 33); assertThat(simple.channel(fooSymbol).get(3), closeTo(4.5)); assertThat(simple.channel(barSymbol).get(3, - 1.0), closeTo(33)); simple.channel(fooSymbol).unset(8); assertThat(simple.channel(fooSymbol).get(8, 45.0), closeTo(45.0)); } ",
        "focal_tgt": "public MutableSparseVector getOrAddChannel(Symbol channelSymbol) { MutableSparseVector chan = channelMap.get(channelSymbol); if(chan == null) { chan = addChannel(channelSymbol); } return chan; } ",
        "focal_src": "public MutableSparseVector alwaysAddChannel(Symbol channelSymbol) { MutableSparseVector chan = channelMap.get(channelSymbol); if(chan == null) { chan = addChannel(channelSymbol); } return chan; } ",
        "test_tgt": "@Test public void testAlwaysAddChannel() { MutableSparseVector simple = simpleVector(); simple.addChannel(fooSymbol); simple.channel(fooSymbol).set(3, 4.5); simple.getOrAddChannel(fooSymbol); simple.getOrAddChannel(barSymbol); assert(simple.channel(barSymbol).isEmpty()); simple.channel(barSymbol).set(3, 33); assertThat(simple.channel(fooSymbol).get(3), closeTo(4.5)); assertThat(simple.channel(barSymbol).get(3, - 1.0), closeTo(33)); simple.channel(fooSymbol).unset(8); assertThat(simple.channel(fooSymbol).get(8, 45.0), closeTo(45.0)); } "
    },
    {
        "test_src": "@Test public void getPatientIdentifiers_shouldNotGetVoidedPatientIdentifiers() { List < PatientIdentifier > patientIdentifiers = dao.getPatientIdentifiers(null, new ArrayList < PatientIdentifierType > (), new ArrayList < Location > (), new ArrayList < Patient > (), null); Assert.assertEquals(8, patientIdentifiers.size()); for(PatientIdentifier patientIdentifier : patientIdentifiers) { Assert.assertFalse(patientIdentifier.getVoided()); } } ",
        "focal_tgt": "public List < PatientIdentifier > getPatientIdentifiers(PatientIdentifierType pit) { List < PatientIdentifier > ids = new ArrayList < > (); for(PatientIdentifier pi : getIdentifiers()) { if( ! pi.getVoided() && pit.equals(pi.getIdentifierType())) { ids.add(pi); } } return ids; } ",
        "focal_src": "public List < PatientIdentifier > getPatientIdentifiers(PatientIdentifierType pit) { List < PatientIdentifier > ids = new ArrayList < PatientIdentifier > (); for(PatientIdentifier pi : getIdentifiers()) { if( ! pi.getVoided() && pit.equals(pi.getIdentifierType())) { ids.add(pi); } } return ids; } ",
        "test_tgt": "@Test public void getPatientIdentifiers_shouldNotGetVoidedPatientIdentifiers() { List < PatientIdentifier > patientIdentifiers = dao.getPatientIdentifiers(null, new ArrayList < > (), new ArrayList < > (), new ArrayList < > (), null); Assert.assertEquals(8, patientIdentifiers.size()); for(PatientIdentifier patientIdentifier : patientIdentifiers) { Assert.assertFalse(patientIdentifier.getVoided()); } } "
    },
    {
        "test_src": "@Test public void testForClose()throws IOException { } ",
        "focal_tgt": "@Override public void close()throws IOException { flushCacheAttrToTempFile(); String className = getYangName(); className = JavaIdentifierSyntax.getCaptialCase(className); String path = getRelativeFilePath(); int fileType = getGeneratedFileTypes(); List < String > imports = new ArrayList < > (); String importString; for(ImportInfo importInfo : new ArrayList < ImportInfo > (getImportSet())) { importString = UtilConstants.IMPORT; if(importInfo.getPkgInfo() != null) { importString = importString + importInfo.getPkgInfo() + \".\"; } importString = importString + importInfo.getClassInfo() + UtilConstants.SEMI_COLAN + UtilConstants.NEW_LINE; imports.add(importString); } java.util.Collections.sort(imports); if((fileType & GeneratedFileType.INTERFACE_MASK) != 0 || fileType == GeneratedFileType.GENERATE_INTERFACE_WITH_BUILDER) { String interfaceFileName = className; File interfaceFile = JavaFileGenerator.getFileObject(path, interfaceFileName, JAVA_FILE_EXTENSION, this); interfaceFile = JavaFileGenerator.generateInterfaceFile(interfaceFile, className, imports, getCachedAttributeList(), path.replace('/', '.'), this); String builderInterfaceFileName = className + UtilConstants.BUILDER + UtilConstants.INTERFACE; File builderInterfaceFile = JavaFileGenerator.getFileObject(path, builderInterfaceFileName, TEMP_FILE_EXTENSION, this); builderInterfaceFile = JavaFileGenerator.generateBuilderInterfaceFile(builderInterfaceFile, className, path.replace('/', '.'), getCachedAttributeList(), this); JavaFileGenerator.appendFileContents(builderInterfaceFile, interfaceFile); JavaFileGenerator.insert(interfaceFile, JavaFileGenerator.closeFile(GeneratedFileType.INTERFACE_MASK, interfaceFileName)); JavaFileGenerator.closeFileHandles(builderInterfaceFile); JavaFileGenerator.closeFileHandles(interfaceFile); JavaFileGenerator.clean(builderInterfaceFile); } imports.add(UtilConstants.MORE_OBJECT_IMPORT); imports.add(UtilConstants.JAVA_UTIL_OBJECTS_IMPORT); java.util.Collections.sort(imports); if((fileType & GeneratedFileType.BUILDER_CLASS_MASK) != 0 || fileType == GeneratedFileType.GENERATE_INTERFACE_WITH_BUILDER) { String builderFileName = className + UtilConstants.BUILDER; File builderFile = JavaFileGenerator.getFileObject(path, builderFileName, JAVA_FILE_EXTENSION, this); builderFile = JavaFileGenerator.generateBuilderClassFile(builderFile, className, imports, path.replace('/', '.'), getCachedAttributeList(), this); String implFileName = className + UtilConstants.IMPL; File implTempFile = JavaFileGenerator.getFileObject(path, implFileName, TEMP_FILE_EXTENSION, this); implTempFile = JavaFileGenerator.generateImplClassFile(implTempFile, className, path.replace('/', '.'), getCachedAttributeList(), this); JavaFileGenerator.appendFileContents(implTempFile, builderFile); JavaFileGenerator.insert(builderFile, JavaFileGenerator.closeFile(GeneratedFileType.BUILDER_CLASS_MASK, builderFileName)); JavaFileGenerator.closeFileHandles(implTempFile); JavaFileGenerator.closeFileHandles(builderFile); JavaFileGenerator.clean(implTempFile); } if((fileType & GeneratedFileType.GENERATE_TYPEDEF_CLASS) != 0) { String typeDefFileName = className; File typeDefFile = JavaFileGenerator.getFileObject(path, typeDefFileName, JAVA_FILE_EXTENSION, this); typeDefFile = JavaFileGenerator.generateTypeDefClassFile(typeDefFile, className, imports, path.replace('/', '.'), getCachedAttributeList(), this); JavaFileGenerator.insert(typeDefFile, JavaFileGenerator.closeFile(GeneratedFileType.GENERATE_TYPEDEF_CLASS, typeDefFileName)); JavaFileGenerator.closeFileHandles(typeDefFile); } closeTempDataFileHandles(className, getCodeGenFilePath() + getRelativeFilePath()); JavaFileGenerator.cleanTempFiles(new File(getCodeGenFilePath() + getRelativeFilePath() + File.separator + className + TEMP_FOLDER_NAME_SUFIX)); } ",
        "focal_src": "@Override public void close()throws IOException { flushCacheAttrToTempFile(); String className = getYangName(); className = JavaIdentifierSyntax.getCaptialCase(className); String path = getRelativeFilePath(); int fileType = getGeneratedFileTypes(); List < String > imports = new LinkedList < > (); String importString; for(ImportInfo importInfo : getImportSet()) { importString = \"\"; if(importInfo.getPkgInfo() != null) { importString = importString + importInfo.getPkgInfo() + \".\"; } importString = importString + importInfo.getClassInfo(); imports.add(importString); } if((fileType & GeneratedFileType.INTERFACE_MASK) != 0 || fileType == GeneratedFileType.GENERATE_INTERFACE_WITH_BUILDER) { String interfaceFileName = className; File interfaceFile = JavaFileGenerator.getFileObject(path, interfaceFileName, JAVA_FILE_EXTENSION); interfaceFile = JavaFileGenerator.generateInterfaceFile(interfaceFile, className, imports, getCachedAttributeList(), path.replace('/', '.')); String builderInterfaceFileName = className + UtilConstants.BUILDER + UtilConstants.INTERFACE; File builderInterfaceFile = JavaFileGenerator.getFileObject(path, builderInterfaceFileName, TEMP_FILE_EXTENSION); builderInterfaceFile = JavaFileGenerator.generateBuilderInterfaceFile(builderInterfaceFile, className, path.replace('/', '.'), getCachedAttributeList()); JavaFileGenerator.appendFileContents(builderInterfaceFile, interfaceFile); JavaFileGenerator.insert(interfaceFile, JavaFileGenerator.closeFile(GeneratedFileType.INTERFACE_MASK, interfaceFileName)); JavaFileGenerator.clean(builderInterfaceFile); } if((fileType & GeneratedFileType.BUILDER_CLASS_MASK) != 0 || fileType == GeneratedFileType.GENERATE_INTERFACE_WITH_BUILDER) { String builderFileName = className + UtilConstants.BUILDER; File builderFile = JavaFileGenerator.getFileObject(path, builderFileName, JAVA_FILE_EXTENSION); builderFile = JavaFileGenerator.generateBuilderClassFile(builderFile, className, imports, path.replace('/', '.'), getCachedAttributeList()); String implFileName = className + UtilConstants.IMPL; File implTempFile = JavaFileGenerator.getFileObject(path, implFileName, TEMP_FILE_EXTENSION); implTempFile = JavaFileGenerator.generateImplClassFile(implTempFile, className, path.replace('/', '.'), getCachedAttributeList()); JavaFileGenerator.appendFileContents(implTempFile, builderFile); JavaFileGenerator.insert(builderFile, JavaFileGenerator.closeFile(GeneratedFileType.BUILDER_CLASS_MASK, builderFileName)); JavaFileGenerator.clean(implTempFile); } } ",
        "test_tgt": "@Test public void testForClose()throws IOException { CopyrightHeader.parseCopyrightHeader(); AttributeInfo attr = getAttr(); attr.setListAttr(false); CachedFileHandle handle = getFileHandle(); handle.addAttributeInfo(attr.getAttributeType(), attr.getAttributeName(), attr.isListAttr()); handle.close(); assertThat(true, is(getStubDir().exists())); assertThat(true, is(getStubPkgInfo().exists())); assertThat(true, is(getStubInterfaceFile().exists())); assertThat(true, is(getStubBuilderFile().exists())); } "
    },
    {
        "test_src": "@Test public void testContainsAlertAfterModifiedMessage() { WorkflowConfigurationFactory factory = WorkflowConfigurationFactory.createInstance(new ClientCommandConfig()); TlsContext context = factory.createFullTlsContext(); context.setMyConnectionEnd(ConnectionEnd.CLIENT); ApplicationMessage am = (ApplicationMessage)context.getWorkflowTrace().getFirstProtocolMessage(ProtocolMessageType.APPLICATION_DATA); ModifiableByteArray data = new ModifiableByteArray(); data.setOriginalValue(new byte[0]); data.setModification(ByteArrayModificationFactory.explicitValue(new byte[] { 1 })); am.setData(data); assertEquals(\"There is no alert after modification.\", TlsContextAnalyzer.AnalyzerResponse.NO_ALERT, TlsContextAnalyzer.containsAlertAfterModifiedMessage(context)); context.getWorkflowTrace().getProtocolMessages().add(new AlertMessage(ConnectionEnd.SERVER)); assertEquals(\"There is an alert after modification.\", TlsContextAnalyzer.AnalyzerResponse.ALERT, TlsContextAnalyzer.containsAlertAfterModifiedMessage(context)); } ",
        "focal_tgt": "public static AnalyzerResponse containsAlertAfterModifiedMessage(TlsContext tlsContext) { int position = getModifiedMessagePosition(tlsContext); if(position == - 1) { return AnalyzerResponse.NO_MODIFICATION; } else { ProtocolMessage pm = getNextReceiveProtocolMessage(tlsContext, position); if(pm != null && pm.getProtocolMessageType() == ProtocolMessageType.ALERT) { return AnalyzerResponse.ALERT; } else { return AnalyzerResponse.NO_ALERT; } } } ",
        "focal_src": "public static AnalyzerResponse containsAlertAfterModifiedMessage(TlsContext tlsContext) { int position = getModifiedMessagePosition(tlsContext); if(position == - 1) { return AnalyzerResponse.NO_MODIFICATION; } else { ProtocolMessage pm = getNextProtocolMessageFromPeer(tlsContext, position); if(pm != null && pm.getProtocolMessageType() == ProtocolMessageType.ALERT) { return AnalyzerResponse.ALERT; } else { return AnalyzerResponse.NO_ALERT; } } } ",
        "test_tgt": "@Test public void testContainsAlertAfterModifiedMessage() { WorkflowConfigurationFactory factory = WorkflowConfigurationFactory.createInstance(new ClientCommandConfig()); TlsContext context = factory.createFullServerResponseTlsContext(ConnectionEnd.CLIENT); context.setMyConnectionEnd(ConnectionEnd.CLIENT); ApplicationMessage am = (ApplicationMessage)context.getWorkflowTrace().getFirstProtocolMessage(ProtocolMessageType.APPLICATION_DATA); ModifiableByteArray data = new ModifiableByteArray(); data.setOriginalValue(new byte[0]); data.setModification(ByteArrayModificationFactory.explicitValue(new byte[] { 1 })); am.setData(data); assertEquals(\"There is no alert after modification.\", TlsContextAnalyzer.AnalyzerResponse.NO_ALERT, TlsContextAnalyzer.containsAlertAfterModifiedMessage(context)); ReceiveAction action = context.getWorkflowTrace().getReceiveActions().get(2); List < ProtocolMessage > messages = new LinkedList < > (); messages.add(new AlertMessage()); action.setConfiguredMessages(messages); context.getWorkflowTrace().add(new ReceiveAction(new AlertMessage())); } "
    },
    {
        "test_src": "@Test public void findSegment() { System.out.println(\"findSegment\"); System.out.println(\"before: \" + instance.getSequenceString()); Point point = new Point(11, 3); instance.setStickyDistance(2); assertEquals(p1, instance.findSegment(point)); instance.setStickyDistance(0); assertEquals(null, instance.findSegment(point)); instance = new BrokenLine(); instance.setStickyDistance(2); assertEquals(null, instance.findSegment(point)); instance.addPoint(p1); assertEquals(null, instance.findSegment(point)); instance.addPoint(p2); assertEquals(p1, instance.findSegment(point)); } ",
        "focal_tgt": "public Point findSegment(Point point) { final int sqrStickyDistance = getStickyDistance() * getStickyDistance(); Point bestPoint = null; double bestDistSq = java.lang.Double.MAX_VALUE; if(points.size() < 2) { return null; } Point prevPt = points.get(0); for(Point pt : points) { if(pt == prevPt) { continue; } Line2D.Double line = new Line2D.Double(prevPt, pt); double distSq = line.ptSegDistSq(point); if(distSq < bestDistSq) { bestPoint = prevPt; bestDistSq = distSq; } prevPt = pt; } if(bestDistSq <= sqrStickyDistance) { return bestPoint; } else { return null; } } ",
        "focal_src": "public Point findSegment(Point point) { Point bestPoint = null; double bestDistSq = java.lang.Double.MAX_VALUE; if(points.size() < 2) { return null; } Point prevPt = points.get(0); for(Point pt : points) { if(pt == prevPt) { continue; } Line2D.Double line = new Line2D.Double(prevPt, pt); double distSq = line.ptSegDistSq(point); if(distSq < bestDistSq) { bestPoint = prevPt; bestDistSq = distSq; } prevPt = pt; } if(bestDistSq <= (stickyDistance * stickyDistance)) { return bestPoint; } else { return null; } } ",
        "test_tgt": "@Test public void findSegment() { System.out.println(\"findSegment\"); System.out.println(\"before: \" + instance.getSequenceString()); Point point = new Point(11, 3); assertEquals(p1, instance.findSegment(point)); instance = new BrokenLine(); assertEquals(null, instance.findSegment(point)); instance.addPoint(p1); assertEquals(null, instance.findSegment(point)); instance.addPoint(p2); assertEquals(p1, instance.findSegment(point)); } "
    },
    {
        "test_src": "@Test public void testUpdateCommand()throws GenieException { final Command command = this.service.getCommand(COMMAND_1_ID); Assert.assertEquals(COMMAND_1_USER, command.getUser()); Assert.assertEquals(CommandStatus.ACTIVE, command.getStatus()); Assert.assertEquals(5, command.getTags().size()); final Set < String > tags = new HashSet < > (command.getTags()); tags.add(\"yarn\"); tags.add(\"hadoop\"); final Command updateCommand = new Command.Builder(command.getName(), COMMAND_2_USER, command.getVersion(), CommandStatus.INACTIVE, command.getExecutable()).withId(command.getId()).withCreated(command.getCreated()).withUpdated(command.getUpdated()).withDescription(command.getDescription()).withTags(tags).withConfigs(command.getConfigs()).withSetupFile(command.getSetupFile()).withJobType(command.getJobType()).build(); this.service.updateCommand(COMMAND_1_ID, updateCommand); final Command updated = this.service.getCommand(COMMAND_1_ID); Assert.assertEquals(COMMAND_2_USER, updated.getUser()); Assert.assertEquals(CommandStatus.INACTIVE, updated.getStatus()); Assert.assertEquals(7, updated.getTags().size()); } ",
        "focal_tgt": "@Override public void updateCommand(@NotBlank(message = \"No id entered. Unable to update.\")final String id, @NotNull(message = \"No command information entered. Unable to update.\")@Valid final Command updateCommand)throws GenieException { if( ! this.commandRepo.exists(id)) { throw new GenieNotFoundException(\"No command exists with the given id. Unable to update.\"); } if( ! id.equals(updateCommand.getId())) { throw new GenieBadRequestException(\"Command id inconsistent with id passed in.\"); } if(LOG.isDebugEnabled()) { LOG.debug(\"Called to update command with id \" + id + \" \" + updateCommand.toString()); } final CommandEntity commandEntity = this.findCommand(id); commandEntity.setName(updateCommand.getName()); commandEntity.setUser(updateCommand.getUser()); commandEntity.setVersion(updateCommand.getVersion()); commandEntity.setStatus(updateCommand.getStatus()); commandEntity.setDescription(updateCommand.getDescription()); commandEntity.setExecutable(updateCommand.getExecutable()); commandEntity.setSetupFile(updateCommand.getSetupFile()); commandEntity.setConfigs(updateCommand.getConfigs()); commandEntity.setCommandTags(updateCommand.getTags()); this.commandRepo.save(commandEntity); } ",
        "focal_src": "@Override public void updateCommand(@NotBlank(message = \"No id entered. Unable to update.\")final String id, @NotNull(message = \"No command information entered. Unable to update.\")@Valid final Command updateCommand)throws GenieException { if( ! this.commandRepo.exists(id)) { throw new GenieNotFoundException(\"No command exists with the given id. Unable to update.\"); } if( ! id.equals(updateCommand.getId())) { throw new GenieBadRequestException(\"Command id inconsistent with id passed in.\"); } if(LOG.isDebugEnabled()) { LOG.debug(\"Called to update command with id \" + id + \" \" + updateCommand.toString()); } final CommandEntity commandEntity = this.findCommand(id); commandEntity.setName(updateCommand.getName()); commandEntity.setUser(updateCommand.getUser()); commandEntity.setVersion(updateCommand.getVersion()); commandEntity.setStatus(updateCommand.getStatus()); commandEntity.setDescription(updateCommand.getDescription()); commandEntity.setExecutable(updateCommand.getExecutable()); commandEntity.setSetupFile(updateCommand.getSetupFile()); commandEntity.setJobType(updateCommand.getJobType()); commandEntity.setConfigs(updateCommand.getConfigs()); commandEntity.setCommandTags(updateCommand.getTags()); this.commandRepo.save(commandEntity); } ",
        "test_tgt": "@Test public void testUpdateCommand()throws GenieException { final Command command = this.service.getCommand(COMMAND_1_ID); Assert.assertEquals(COMMAND_1_USER, command.getUser()); Assert.assertEquals(CommandStatus.ACTIVE, command.getStatus()); Assert.assertEquals(5, command.getTags().size()); final Set < String > tags = new HashSet < > (command.getTags()); tags.add(\"yarn\"); tags.add(\"hadoop\"); final Command updateCommand = new Command.Builder(command.getName(), COMMAND_2_USER, command.getVersion(), CommandStatus.INACTIVE, command.getExecutable()).withId(command.getId()).withCreated(command.getCreated()).withUpdated(command.getUpdated()).withDescription(command.getDescription()).withTags(tags).withConfigs(command.getConfigs()).withSetupFile(command.getSetupFile()).build(); this.service.updateCommand(COMMAND_1_ID, updateCommand); final Command updated = this.service.getCommand(COMMAND_1_ID); Assert.assertEquals(COMMAND_2_USER, updated.getUser()); Assert.assertEquals(CommandStatus.INACTIVE, updated.getStatus()); Assert.assertEquals(7, updated.getTags().size()); } "
    },
    {
        "test_src": "@Test public void RenameTest()throws Exception { for(int i = 0; i < 10; i ++ ) { mTfs.mkdir(new TachyonURI(\"/i\" + i)); for(int j = 0; j < 10; j ++ ) { mTfs.createFile(new TachyonURI(\"/i\" + i + \"/j\" + j), (i + j + 1) * 64); mTfs.rename(new TachyonURI(\"/i\" + i + \"/j\" + j), new TachyonURI(\"/i\" + i + \"/jj\" + j)); } mTfs.rename(new TachyonURI(\"/i\" + i), new TachyonURI(\"/ii\" + i)); } mLocalTachyonCluster.stopTFS(); RenameTestUtil(); String editLogPath = mLocalTachyonCluster.getEditLogPath(); UnderFileSystem.get(editLogPath).delete(editLogPath, true); RenameTestUtil(); } ",
        "focal_tgt": "public static void rename(String src, String dst, MasterInfo info)throws IOException { UnderFileSystem ufs = UnderFileSystem.get(src, info.getTachyonConf()); ufs.rename(src, dst); LOG.info(\"Renamed \" + src + \" to \" + dst); } ",
        "focal_src": "public static void rename(String src, String dst)throws IOException { UnderFileSystem ufs = UnderFileSystem.get(src); ufs.rename(src, dst); LOG.info(\"Renamed \" + src + \" to \" + dst); } ",
        "test_tgt": "@Test public void RenameTest()throws Exception { for(int i = 0; i < 10; i ++ ) { mTfs.mkdir(new TachyonURI(\"/i\" + i)); for(int j = 0; j < 10; j ++ ) { mTfs.createFile(new TachyonURI(\"/i\" + i + \"/j\" + j), (i + j + 1) * 64); mTfs.rename(new TachyonURI(\"/i\" + i + \"/j\" + j), new TachyonURI(\"/i\" + i + \"/jj\" + j)); } mTfs.rename(new TachyonURI(\"/i\" + i), new TachyonURI(\"/ii\" + i)); } mLocalTachyonCluster.stopTFS(); RenameTestUtil(); String editLogPath = mLocalTachyonCluster.getEditLogPath(); UnderFileSystem.get(editLogPath, mMasterTachyonConf).delete(editLogPath, true); RenameTestUtil(); } "
    },
    {
        "test_src": "@Test public void testGetLatitudeFromY01() { checkLatitude(TileSystem.MaxLatitude, TileSystem.getLatitudeFromY01(0, true)); checkLatitude(0, TileSystem.getLatitudeFromY01(0.5, true)); checkLatitude(TileSystem.MinLatitude, TileSystem.getLatitudeFromY01(1, true)); } ",
        "focal_tgt": "public double getLatitudeFromY01(final double pY01, boolean wrapEnabled) { final double latitude = getLatitudeFromY01(wrapEnabled ? Clip(pY01, 0, 1) : pY01); return wrapEnabled ? Clip(latitude, getMinLatitude(), getMaxLatitude()) : latitude; } ",
        "focal_src": "public static double getLatitudeFromY01(final double pY01, boolean wrapEnabled) { double latitude = 90 - 360 * Math.atan(Math.exp((pY01 - 0.5) * 2 * Math.PI)) / Math.PI; return wrapEnabled ? Clip(latitude, MinLatitude, MaxLatitude) : latitude; } ",
        "test_tgt": "@Test public void testGetLatitudeFromY01() { checkLatitude(tileSystem.getMaxLatitude(), tileSystem.getLatitudeFromY01(0, true)); checkLatitude(0, tileSystem.getLatitudeFromY01(0.5, true)); checkLatitude(tileSystem.getMinLatitude(), tileSystem.getLatitudeFromY01(1, true)); } "
    },
    {
        "test_src": "@Test public void listStatusTest()throws Exception { TachyonURI file = new TachyonURI(\"/file\"); List < URIStatus > infos = Lists.newArrayList(new URIStatus(new FileInfo())); Mockito.when(mFileSystemMasterClient.listStatus(file)).thenReturn(infos); ListStatusOptions listStatusOptions = ListStatusOptions.defaults(); Assert.assertSame(infos, mFileSystem.listStatus(file, listStatusOptions)); Mockito.verify(mFileSystemMasterClient).listStatus(file); } ",
        "focal_tgt": "public synchronized List < URIStatus > listStatus(final AlluxioURI path)throws IOException, AlluxioException { return retryRPC(new RpcCallableThrowsTachyonTException < List < URIStatus > > () { @Override public List < URIStatus > call()throws AlluxioTException, TException { List < URIStatus > result = new ArrayList < URIStatus > (); for(alluxio.thrift.FileInfo fileInfo : mClient.listStatus(path.getPath())) { result.add(new URIStatus(ThriftUtils.fromThrift(fileInfo))); } return result; } }); } ",
        "focal_src": "public synchronized List < URIStatus > listStatus(final TachyonURI path)throws IOException, TachyonException { return retryRPC(new RpcCallableThrowsTachyonTException < List < URIStatus > > () { @Override public List < URIStatus > call()throws TachyonTException, TException { List < URIStatus > result = new ArrayList < URIStatus > (); for(alluxio.thrift.FileInfo fileInfo : mClient.listStatus(path.getPath())) { result.add(new URIStatus(ThriftUtils.fromThrift(fileInfo))); } return result; } }); } ",
        "test_tgt": "@Test public void listStatusTest()throws Exception { AlluxioURI file = new AlluxioURI(\"/file\"); List < URIStatus > infos = Lists.newArrayList(new URIStatus(new FileInfo())); Mockito.when(mFileSystemMasterClient.listStatus(file)).thenReturn(infos); ListStatusOptions listStatusOptions = ListStatusOptions.defaults(); Assert.assertSame(infos, mFileSystem.listStatus(file, listStatusOptions)); Mockito.verify(mFileSystemMasterClient).listStatus(file); } "
    },
    {
        "test_src": "@Test public void testEncrypt() { context.setSelectedProtocolVersion(ProtocolVersion.TLS13); context.setSelectedCipherSuite(CipherSuite.TLS_AES_128_GCM_SHA256); context.setEncryptActive(true); context.setClientHandshakeTrafficSecret(ArrayConverter.hexStringToByteArray(\"4B63051EABCD514D7CB6D1899F472B9F56856B01BDBC5B733FBB47269E7EBDC2\")); context.setServerHandshakeTrafficSecret(ArrayConverter.hexStringToByteArray(\"ACC9DB33EE0968FAE7E06DAA34D642B146092CE7F9C9CF47670C66A0A6CE1C8C\")); context.setConnectionEnd(new ServerConnectionEnd()); record.setCleanProtocolMessageBytes(ArrayConverter.hexStringToByteArray(\"080000020000\")); record.setContentMessageType(ProtocolMessageType.HANDSHAKE); record.setPaddingLength(0); recordCipher = new RecordAEADCipher(context); encryptor = new RecordEncryptor(recordCipher, context); encryptor.encrypt(record); assertTrue(record.getProtocolMessageBytes().getValue().length == 23); assertArrayEquals(record.getProtocolMessageBytes().getValue(), ArrayConverter.hexStringToByteArray(\"1BB3293A919E0D66F145AE830488E8D89BE5EC16688229\")); } ",
        "focal_tgt": "@Override public EncryptionResult encrypt(EncryptionRequest request)throws CryptoException { try { byte[]ciphertext; if(useExplicitIv) { encryptIv = new IvParameterSpec(request.getInitialisationVector()); encryptCipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(getKeySet().getKey(context.getTalkingConnectionEndType()), bulkCipherAlg.getJavaName()), encryptIv); ciphertext = encryptCipher.doFinal(request.getPlainText()); return new EncryptionResult(encryptIv.getIV(), ciphertext, useExplicitIv); } else { byte[]iv = encryptCipher.getIV(); ciphertext = encryptCipher.update(request.getPlainText()); return new EncryptionResult(ciphertext, iv, false); } } catch(InvalidKeyException | InvalidAlgorithmParameterException | BadPaddingException | IllegalBlockSizeException ex) { throw new CryptoException(ex); } } ",
        "focal_src": "@Override public byte[]encrypt(byte[]data)throws CryptoException { try { byte[]ciphertext; if(useExplicitIv) { ciphertext = ArrayConverter.concatenate(encryptIv.getIV(), encryptCipher.doFinal(data)); } else { ciphertext = encryptCipher.update(data); } return ciphertext; } catch(BadPaddingException | IllegalBlockSizeException ex) { throw new CryptoException(ex); } } ",
        "test_tgt": "@Test public void testEncryptTLS13()throws NoSuchAlgorithmException { context.setSelectedProtocolVersion(ProtocolVersion.TLS13); context.setSelectedCipherSuite(CipherSuite.TLS_AES_128_GCM_SHA256); context.setEncryptActive(true); context.setClientHandshakeTrafficSecret(ArrayConverter.hexStringToByteArray(\"4B63051EABCD514D7CB6D1899F472B9F56856B01BDBC5B733FBB47269E7EBDC2\")); context.setServerHandshakeTrafficSecret(ArrayConverter.hexStringToByteArray(\"ACC9DB33EE0968FAE7E06DAA34D642B146092CE7F9C9CF47670C66A0A6CE1C8C\")); context.setConnectionEnd(new ServerConnectionEnd()); record.setCleanProtocolMessageBytes(ArrayConverter.hexStringToByteArray(\"080000020000\")); record.setContentMessageType(ProtocolMessageType.HANDSHAKE); record.setPaddingLength(0); recordCipher = new RecordAEADCipher(context, KeySetGenerator.generateKeySet(context)); encryptor = new RecordEncryptor(recordCipher, context); encryptor.encrypt(record); assertTrue(record.getProtocolMessageBytes().getValue().length == 23); assertArrayEquals(record.getProtocolMessageBytes().getValue(), ArrayConverter.hexStringToByteArray(\"1BB3293A919E0D66F145AE830488E8D89BE5EC16688229\")); } "
    },
    {
        "test_src": "@Test public void testProcess()throws Exception { int segmentCount = 10; int operationCountPerType = 5; MemoryOperationLog opLog = new MemoryOperationLog(); ArrayList < TestReadIndex.MethodInvocation > methodInvocations = new ArrayList < > (); TestReadIndex readIndex = new TestReadIndex(methodInvocations :: add); @Cleanup InMemoryCache cache = new InMemoryCache(\"0\"); MemoryStateUpdater updater = new MemoryStateUpdater(opLog, new CacheUpdater(cache, readIndex)); ArrayList < Operation > operations = populate(updater, segmentCount, operationCountPerType); Assert.assertEquals(\"Unexpected size for MemoryOperationLog.\", operations.size(), opLog.size()); Assert.assertEquals(\"Unexpected number of items added to ReadIndex.\", operations.size() - segmentCount * operationCountPerType, methodInvocations.size()); Iterator < Operation > logIterator = opLog.read(op -> true, opLog.size()); int currentIndex = - 1; int currentReadIndex = - 1; while(logIterator.hasNext()) { currentIndex ++ ; Operation expected = operations.get(currentIndex); Operation actual = logIterator.next(); if(expected instanceof StorageOperation) { currentReadIndex ++ ; TestReadIndex.MethodInvocation invokedMethod = methodInvocations.get(currentReadIndex); if(expected instanceof StreamSegmentAppendOperation) { Assert.assertTrue(\"StreamSegmentAppendOperation was not added as a CachedStreamSegmentAppendOperation to the Memory Log.\", actual instanceof CachedStreamSegmentAppendOperation); StreamSegmentAppendOperation appendOp = (StreamSegmentAppendOperation)expected; Assert.assertEquals(\"Append with SeqNo \" + expected.getSequenceNumber() + \" was not added to the ReadIndex.\", TestReadIndex.APPEND, invokedMethod.methodName); Assert.assertEquals(\"Append with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", appendOp.getStreamSegmentId(), invokedMethod.args.get(\"streamSegmentId\")); Assert.assertEquals(\"Append with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", appendOp.getStreamSegmentOffset(), invokedMethod.args.get(\"offset\")); Assert.assertEquals(\"Append with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", appendOp.getData(), invokedMethod.args.get(\"data\")); } else if(expected instanceof MergeTransactionOperation) { MergeTransactionOperation mergeOp = (MergeTransactionOperation)expected; Assert.assertEquals(\"Merge with SeqNo \" + expected.getSequenceNumber() + \" was not added to the ReadIndex.\", TestReadIndex.BEGIN_MERGE, invokedMethod.methodName); Assert.assertEquals(\"Merge with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", mergeOp.getStreamSegmentId(), invokedMethod.args.get(\"targetStreamSegmentId\")); Assert.assertEquals(\"Merge with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", mergeOp.getStreamSegmentOffset(), invokedMethod.args.get(\"offset\")); Assert.assertEquals(\"Merge with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", mergeOp.getTransactionSegmentId(), invokedMethod.args.get(\"sourceStreamSegmentId\")); } } } AssertExtensions.assertThrows(\"MemoryStateUpdater accepted an operation that was out of order.\", () -> updater.process(new MergeTransactionOperation(1, 2)), ex -> ex instanceof DataCorruptionException); } ",
        "focal_tgt": "void process(Operation operation)throws DataCorruptionException { if(operation instanceof StorageOperation) { this.cacheUpdater.addToReadIndex((StorageOperation)operation); if(operation instanceof StreamSegmentAppendOperation) { try { operation = new CachedStreamSegmentAppendOperation((StreamSegmentAppendOperation)operation); } catch(Throwable ex) { if(ExceptionHelpers.mustRethrow(ex)) { throw ex; } else { throw new DataCorruptionException(String.format(\"Unable to create a CachedStreamSegmentAppendOperation from operation '%s'.\", operation), ex); } } } } boolean added = this.inMemoryOperationLog.add(operation); if( ! added) { throw new DataCorruptionException(\"About to have added a Log Operation to InMemoryOperationLog that was out of order.\"); } } ",
        "focal_src": "void process(Operation operation)throws DataCorruptionException { if(operation instanceof StorageOperation) { this.cacheUpdater.addToReadIndex((StorageOperation)operation); if(operation instanceof StreamSegmentAppendOperation) { try { operation = new CachedStreamSegmentAppendOperation((StreamSegmentAppendOperation)operation); } catch(Throwable ex) { if(ExceptionHelpers.mustRethrow(ex)) { throw ex; } else { throw new DataCorruptionException(String.format(\"Unable to create a CachedStreamSegmentAppendOperation from operation '%s'.\", operation), ex); } } } } long seqNo = operation.getSequenceNumber(); boolean added = this.inMemoryOperationLog.addIf(operation, previous -> previous.getSequenceNumber() < seqNo); if( ! added) { throw new DataCorruptionException(\"About to have added a Log Operation to InMemoryOperationLog that was out of order.\"); } } ",
        "test_tgt": "@Test public void testProcess()throws Exception { int segmentCount = 10; int operationCountPerType = 5; SequencedItemList < Operation > opLog = new SequencedItemList < > (); ArrayList < TestReadIndex.MethodInvocation > methodInvocations = new ArrayList < > (); TestReadIndex readIndex = new TestReadIndex(methodInvocations :: add); @Cleanup InMemoryCache cache = new InMemoryCache(\"0\"); MemoryStateUpdater updater = new MemoryStateUpdater(opLog, new CacheUpdater(cache, readIndex)); ArrayList < Operation > operations = populate(updater, segmentCount, operationCountPerType); Assert.assertEquals(\"Unexpected number of items added to ReadIndex.\", operations.size() - segmentCount * operationCountPerType, methodInvocations.size()); Iterator < Operation > logIterator = opLog.read( - 1, operations.size()); int currentIndex = - 1; int currentReadIndex = - 1; while(logIterator.hasNext()) { currentIndex ++ ; Operation expected = operations.get(currentIndex); Operation actual = logIterator.next(); if(expected instanceof StorageOperation) { currentReadIndex ++ ; TestReadIndex.MethodInvocation invokedMethod = methodInvocations.get(currentReadIndex); if(expected instanceof StreamSegmentAppendOperation) { Assert.assertTrue(\"StreamSegmentAppendOperation was not added as a CachedStreamSegmentAppendOperation to the Memory Log.\", actual instanceof CachedStreamSegmentAppendOperation); StreamSegmentAppendOperation appendOp = (StreamSegmentAppendOperation)expected; Assert.assertEquals(\"Append with SeqNo \" + expected.getSequenceNumber() + \" was not added to the ReadIndex.\", TestReadIndex.APPEND, invokedMethod.methodName); Assert.assertEquals(\"Append with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", appendOp.getStreamSegmentId(), invokedMethod.args.get(\"streamSegmentId\")); Assert.assertEquals(\"Append with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", appendOp.getStreamSegmentOffset(), invokedMethod.args.get(\"offset\")); Assert.assertEquals(\"Append with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", appendOp.getData(), invokedMethod.args.get(\"data\")); } else if(expected instanceof MergeTransactionOperation) { MergeTransactionOperation mergeOp = (MergeTransactionOperation)expected; Assert.assertEquals(\"Merge with SeqNo \" + expected.getSequenceNumber() + \" was not added to the ReadIndex.\", TestReadIndex.BEGIN_MERGE, invokedMethod.methodName); Assert.assertEquals(\"Merge with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", mergeOp.getStreamSegmentId(), invokedMethod.args.get(\"targetStreamSegmentId\")); Assert.assertEquals(\"Merge with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", mergeOp.getStreamSegmentOffset(), invokedMethod.args.get(\"offset\")); Assert.assertEquals(\"Merge with SeqNo \" + expected.getSequenceNumber() + \" was added to the ReadIndex with wrong arguments.\", mergeOp.getTransactionSegmentId(), invokedMethod.args.get(\"sourceStreamSegmentId\")); } } } AssertExtensions.assertThrows(\"MemoryStateUpdater accepted an operation that was out of order.\", () -> updater.process(new MergeTransactionOperation(1, 2)), ex -> ex instanceof DataCorruptionException); } "
    },
    {
        "test_src": "@Test public void testDelete()throws QueryException { final String fun = check(FunDef.DELETE); query(\"file:create-directory('\" + PATH3 + \"')\"); error(fun + \"('\" + PATH1 + \"')\", Err.DIRNOTEMPTY); query(fun + \"('\" + PATH3 + \"')\"); query(\"file:create-directory('\" + PATH3 + \"')\"); query(\"file:write('\" + PATH4 + \"', ())\"); query(fun + \"('\" + PATH1 + \"', true())\"); } ",
        "focal_tgt": "private Str baseName(final File path, final QueryContext ctx)throws QueryException { final String suf = expr.length < 2 ? null : string(checkStr(expr[1], ctx)); String pth = path.getName(); if(suf != null && pth.endsWith(suf))pth = pth.substring(0, pth.length() - suf.length()); return Str.get(pth); } ",
        "focal_src": "private Item delete(final File path, final QueryContext ctx)throws QueryException { final boolean rec = optionalBool(1, ctx); if(path.exists()) { if(rec)recDelete(path); else delete(path); } return null; } ",
        "test_tgt": "@Test public void testDelete()throws QueryException { final String fun = check(FunDef.DELETE); query(\"file:create-directory('\" + PATH3 + \"')\"); query(fun + \"('\" + PATH3 + \"')\"); query(\"file:create-directory('\" + PATH3 + \"')\"); query(\"file:write('\" + PATH4 + \"', ())\"); query(fun + \"('\" + PATH1 + \"')\"); error(fun + \"('\" + PATH1 + \"')\", Err.PATHNOTEXISTS); } "
    },
    {
        "test_src": "@Test public void getBuildTest() { String method = getBuild(CLASS_NAME); assertThat(true, is(method.equals(FOUR_SPACE_INDENTATION + PUBLIC + SPACE + CLASS_NAME + SPACE + BUILD + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + NEW + SPACE + \"Default\" + CLASS_NAME + OPEN_PARENTHESIS + THIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET))); } ",
        "focal_tgt": "static String getBuild(String yangName, boolean isRootNode) { String type = getCapitalCase(DEFAULT) + yangName; if(isRootNode) { type = yangName + OP_PARAM; } return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + yangName + SPACE + BUILD + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + NEW + SPACE + type + OPEN_PARENTHESIS + THIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET; } ",
        "focal_src": "public static String getBuild(String yangName) { return FOUR_SPACE_INDENTATION + PUBLIC + SPACE + yangName + SPACE + BUILD + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + NEW + SPACE + getCapitalCase(DEFAULT) + yangName + OPEN_PARENTHESIS + THIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET; } ",
        "test_tgt": "@Test public void getBuildTest() { String method = getBuild(CLASS_NAME, false); assertThat(true, is(method.equals(FOUR_SPACE_INDENTATION + PUBLIC + SPACE + CLASS_NAME + SPACE + BUILD + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + NEW + SPACE + \"Default\" + CLASS_NAME + OPEN_PARENTHESIS + THIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET))); } "
    },
    {
        "test_src": "@Test public void testReplaceFirst_char_char() { StrBuilder sb = new StrBuilder(\"abcbccba\"); sb.replaceFirst('x', 'y'); assertEquals(\"abcbccba\", sb.toString()); sb.replaceFirst('a', 'd'); assertEquals(\"dbcbccba\", sb.toString()); sb.replaceFirst('b', 'e'); assertEquals(\"decbccba\", sb.toString()); sb.replaceFirst('c', 'f'); assertEquals(\"defbccba\", sb.toString()); sb.replaceFirst('d', 'd'); assertEquals(\"defbccba\", sb.toString()); } ",
        "focal_tgt": "public StrBuilder replaceFirst(final String searchStr, final String replaceStr) { final int searchLen = (searchStr == null ? 0 : searchStr.length()); if(searchLen > 0) { final int index = indexOf(searchStr, 0); if(index >= 0) { final int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); } } return this; } ",
        "focal_src": "public StrBuilder replaceFirst(final String searchStr, final String replaceStr) { int searchLen = (searchStr == null ? 0 : searchStr.length()); if(searchLen > 0) { int index = indexOf(searchStr, 0); if(index >= 0) { int replaceLen = (replaceStr == null ? 0 : replaceStr.length()); replaceImpl(index, index + searchLen, searchLen, replaceStr, replaceLen); } } return this; } ",
        "test_tgt": "@Test public void testReplaceFirst_char_char() { final StrBuilder sb = new StrBuilder(\"abcbccba\"); sb.replaceFirst('x', 'y'); assertEquals(\"abcbccba\", sb.toString()); sb.replaceFirst('a', 'd'); assertEquals(\"dbcbccba\", sb.toString()); sb.replaceFirst('b', 'e'); assertEquals(\"decbccba\", sb.toString()); sb.replaceFirst('c', 'f'); assertEquals(\"defbccba\", sb.toString()); sb.replaceFirst('d', 'd'); assertEquals(\"defbccba\", sb.toString()); } "
    },
    {
        "test_src": "@Test(expected = GenieNotFoundException.class)public void testGetDependenciesForCommand()throws GenieException { final String id = UUID.randomUUID().toString(); Mockito.when(this.jpaCommandRepository.findOne(id)).thenReturn(null); this.service.getDependenciesForCommand(id); } ",
        "focal_tgt": "@Override@Transactional(readOnly = true)public Set < String > getDependenciesForCommand(@NotBlank(message = \"No command id entered. Unable to get dependencies.\")final String id)throws GenieException { return this.findCommand(id).getDependencies().stream().map(FileEntity :: getFile).collect(Collectors.toSet()); } ",
        "focal_src": "@Override@Transactional(readOnly = true)public Set < String > getDependenciesForCommand(@NotBlank(message = \"No command id entered. Unable to get dependencies.\")final String id)throws GenieException { return this.findCommand(id).getDependencies(); } ",
        "test_tgt": "@Test(expected = GenieNotFoundException.class)public void testGetDependenciesForCommand()throws GenieException { final String id = UUID.randomUUID().toString(); Mockito.when(this.jpaCommandRepository.findByUniqueId(id)).thenReturn(Optional.empty()); this.service.getDependenciesForCommand(id); } "
    },
    {
        "test_src": "@Test public void testCreateUser_NoDuplicates()throws Exception { initForCreateUser(null); Users users = injector.getInstance(Users.class); users.createUser(SERVICEOP_USER_NAME, \"qwert\"); } ",
        "focal_tgt": "@POST@Produces(\"text/plain\")@ApiOperation(value = \"Creates one or more users in a single request\")@ApiImplicitParams( { @ApiImplicitParam(dataType = CREATE_USERS_REQUEST_TYPE, paramType = PARAM_TYPE_BODY, allowMultiple = true) })@ApiResponses( { @ApiResponse(code = HttpStatus.SC_CREATED, message = MSG_SUCCESSFUL_OPERATION), @ApiResponse(code = HttpStatus.SC_ACCEPTED, message = MSG_REQUEST_ACCEPTED), @ApiResponse(code = HttpStatus.SC_BAD_REQUEST, message = MSG_INVALID_ARGUMENTS), @ApiResponse(code = HttpStatus.SC_NOT_FOUND, message = MSG_RESOURCE_NOT_FOUND), @ApiResponse(code = HttpStatus.SC_CONFLICT, message = MSG_RESOURCE_ALREADY_EXISTS), @ApiResponse(code = HttpStatus.SC_UNAUTHORIZED, message = MSG_NOT_AUTHENTICATED), @ApiResponse(code = HttpStatus.SC_FORBIDDEN, message = MSG_PERMISSION_DENIED), @ApiResponse(code = HttpStatus.SC_INTERNAL_SERVER_ERROR, message = MSG_SERVER_ERROR), })public Response createUsers(String body, @Context HttpHeaders headers, @Context UriInfo ui) { return handleRequest(headers, body, ui, Request.Type.POST, createUserResource(null)); } ",
        "focal_src": "@POST@ApiIgnore@Produces(\"text/plain\")public Response createUser(String body, @Context HttpHeaders headers, @Context UriInfo ui) { return handleRequest(headers, body, ui, Request.Type.POST, createUserResource(null)); } ",
        "test_tgt": "@Test public void testCreateUser_NoDuplicates()throws Exception { initForCreateUser(null); Users users = injector.getInstance(Users.class); users.createUser(SERVICEOP_USER_NAME, SERVICEOP_USER_NAME, SERVICEOP_USER_NAME); } "
    },
    {
        "test_src": "@Test public void testCompressStringifiedRules()throws Exception { String compressed = \"eJzztEpMSrYytDKyMtQz0jPWM9E31THTM9ez0LPUN9Dxc40IUXAlrAQAPdoP3Q==\"; String a = securityGroupRulesCmd.compressStringifiedRules(); assertTrue(compressed.equals(a)); } ",
        "focal_tgt": "public String compressStringifiedRules() { final String stringified = stringifyRules(); final ByteArrayOutputStream out = new ByteArrayOutputStream(); String encodedResult = null; try { final DeflaterOutputStream dzip = new DeflaterOutputStream(out); dzip.write(stringified.getBytes()); dzip.close(); encodedResult = Base64.encodeBase64String(out.toByteArray()); } catch(final IOException e) { LOGGER.warn(\"Exception while compressing security group rules\"); } return encodedResult; } ",
        "focal_src": "public String compressStringifiedRules() { final String stringified = stringifyRules(); final ByteArrayOutputStream out = new ByteArrayOutputStream(); String encodedResult = null; try { final DeflaterOutputStream dzip = new DeflaterOutputStream(out); dzip.write(stringified.getBytes()); dzip.close(); encodedResult = Base64.encodeBase64String(out.toByteArray()); } catch(IOException e) { LOGGER.warn(\"Exception while compressing security group rules\"); } return encodedResult; } ",
        "test_tgt": "@Test public void testCompressStringifiedRules()throws Exception { final String compressed = \"eJzztEpMSrYytDKyMtQz0jPWM9E31THTM9ez0LPUN9Dxc40IUXAlrAQAPdoP3Q==\"; final String a = securityGroupRulesCmd.compressStringifiedRules(); assertTrue(compressed.equals(a)); } "
    },
    {
        "test_src": "@Test public void testGeProp() { assertTrue(instance.geProp(\"id\", \"name\").getQueryCriterions().contains(new GePropCriterion(\"id\", \"name\"))); } ",
        "focal_tgt": "public CriteriaQuery geProp(String propName, String otherProp) { criterion = criterion.and(criterionBuilder.geProp(propName, otherProp)); return this; } ",
        "focal_src": "public CriteriaQuery geProp(String propName, String otherProp) { addCriterion(criterionBuilder.geProp(propName, otherProp)); return this; } ",
        "test_tgt": "@Test public void testGeProp() { assertEquals(new GePropCriterion(\"id\", \"name\"), instance.geProp(\"id\", \"name\").getQueryCriterion()); } "
    },
    {
        "test_src": "@Test public void testThrowIfIllegalArrayRange() { int minBound = 10; int maxBound = 20; int length = 5; for(int i = minBound - length - 1; i <= maxBound + 1; i ++ ) { boolean valid = i >= minBound && i + length <= maxBound; if(valid) { Exceptions.throwIfIllegalArrayRange(i, length, minBound, maxBound, \"start\", \"length\"); } else { final int index = i; AssertExtensions.assertThrows(String.format(\"Unexpected behavior for throwIfIllegalArrayRange(index = %d, length = %d, minbound = %d, maxbound = %d).\", index, length, minBound, maxBound), () -> Exceptions.throwIfIllegalArrayRange(index, length, minBound, maxBound, \"start\", \"length\"), ex -> ex instanceof ArrayIndexOutOfBoundsException); } } AssertExtensions.assertThrows(\"Unexpected behavior for throwIfIllegalArrayRange() with negative length.\", () -> Exceptions.throwIfIllegalArrayRange(10, - 1, 8, 20, \"start\", \"length\"), ex -> ex instanceof IllegalArgumentException); } ",
        "focal_tgt": "public static void throwIfIllegalArrayRange(long startIndex, int length, long lowBoundInclusive, long upBoundExclusive, String startIndexArgName, String lengthArgName)throws ArrayIndexOutOfBoundsException, IllegalArgumentException { if(length < 0) { throw new IllegalArgumentException(String.format(\"%s must be a non-negative integer.\", lengthArgName)); } if(startIndex < lowBoundInclusive || startIndex >= upBoundExclusive) { if( ! (startIndex == 0 && length == 0 && lowBoundInclusive == 0 && upBoundExclusive == 0)) { throw new ArrayIndexOutOfBoundsException(String.format(\"%s: value must be in interval [%d, %d), given %d.\", startIndexArgName, lowBoundInclusive, upBoundExclusive, startIndex)); } } if(startIndex + length > upBoundExclusive) { throw new ArrayIndexOutOfBoundsException(String.format(\"%s + %s: value must be in interval [%d, %d], actual %d.\", startIndexArgName, lengthArgName, lowBoundInclusive, upBoundExclusive, startIndex + length)); } } ",
        "focal_src": "public static void throwIfIllegalArrayRange(long startIndex, int length, long lowBoundInclusive, long upBoundExclusive, String startIndexArgName, String lengthArgName)throws ArrayIndexOutOfBoundsException, IllegalArgumentException { if(length < 0) { throw new IllegalArgumentException(String.format(\"%s must be a non-negative integer.\", lengthArgName)); } if(startIndex < lowBoundInclusive || startIndex >= upBoundExclusive) { throw new ArrayIndexOutOfBoundsException(String.format(\"%s: value must be in interval [%d, %d), given %d.\", startIndexArgName, lowBoundInclusive, upBoundExclusive, startIndex)); } if(startIndex + length > upBoundExclusive) { throw new ArrayIndexOutOfBoundsException(String.format(\"%s + %s: value must be in interval [%d, %d], actual %d.\", startIndexArgName, lengthArgName, lowBoundInclusive, upBoundExclusive, startIndex + length)); } } ",
        "test_tgt": "@Test public void testThrowIfIllegalArrayRange() { int minBound = 10; int maxBound = 20; int length = 5; for(int i = minBound - length - 1; i <= maxBound + 1; i ++ ) { boolean valid = i >= minBound && i + length <= maxBound; if(valid) { Exceptions.throwIfIllegalArrayRange(i, length, minBound, maxBound, \"start\", \"length\"); } else { final int index = i; AssertExtensions.assertThrows(String.format(\"Unexpected behavior for throwIfIllegalArrayRange(index = %d, length = %d, minbound = %d, maxbound = %d).\", index, length, minBound, maxBound), () -> Exceptions.throwIfIllegalArrayRange(index, length, minBound, maxBound, \"start\", \"length\"), ex -> ex instanceof ArrayIndexOutOfBoundsException); } } AssertExtensions.assertThrows(\"Unexpected behavior for throwIfIllegalArrayRange() with negative length.\", () -> Exceptions.throwIfIllegalArrayRange(10, - 1, 8, 20, \"start\", \"length\"), ex -> ex instanceof IllegalArgumentException); Exceptions.throwIfIllegalArrayRange(0, 0, 0, 0, \"start\", \"length\"); AssertExtensions.assertThrows(\"Unexpected behavior for throwIfIllegalArrayRange() with non-empty range in an empty array.\", () -> Exceptions.throwIfIllegalArrayRange(0, 1, 0, 0, \"start\", \"length\"), ex -> ex instanceof ArrayIndexOutOfBoundsException); } "
    },
    {
        "test_src": "@Test public void getMacros()throws Exception { final Set < Macro > macros = provider.getMacros(devMachine); assertEquals(macros.size(), 2); final Iterator < Macro > iterator = macros.iterator(); final Macro provider1 = iterator.next(); assertTrue(provider1 instanceof BaseMacro); assertEquals(provider1.getName(), ServerHostNameMacro.KEY.replace(\"%\", WS_AGENT_PORT)); provider1.expand().then(new Operation < String > () { @Override public void apply(String address)throws OperationException { assertEquals(address, PROTOCOL); } }); final Macro provider2 = iterator.next(); assertTrue(provider2 instanceof BaseMacro); assertEquals(provider2.getName(), ServerHostNameMacro.KEY.replace(\"%\", WS_AGENT_PORT.substring(0, WS_AGENT_PORT.length() - 4))); provider2.expand().then(new Operation < String > () { @Override public void apply(String address)throws OperationException { assertEquals(address, PROTOCOL); } }); } ",
        "focal_tgt": "@Override public Set < Macro > getMacros(MachineImpl machine) { final Set < Macro > macros = Sets.newHashSet(); for(Map.Entry < String, ServerImpl > entry : machine.getServers().entrySet()) { if( ! entry.getValue().getUrl().contains(\":\")) { continue; } final String externalPort = entry.getValue().getUrl().split(\":\")[1]; Macro macro = new BaseMacro(KEY.replace(\"%\", entry.getKey()), externalPort, \"Returns port of a server registered by name\"); macros.add(macro); if(entry.getKey().endsWith(\"/tcp\")) { final String port = entry.getKey().substring(0, entry.getKey().length() - 4); Macro shortMacro = new BaseMacro(KEY.replace(\"%\", port), externalPort, \"Returns port of a server registered by name\"); macros.add(shortMacro); } } return macros; } ",
        "focal_src": "@Override public Set < Macro > getMacros(MachineImpl devMachine) { final Set < Macro > macros = Sets.newHashSet(); for(Map.Entry < String, ServerImpl > entry : devMachine.getServers().entrySet()) { if( ! entry.getValue().getUrl().contains(\":\")) { continue; } final String externalPort = entry.getValue().getUrl().split(\":\")[1]; Macro macro = new BaseMacro(KEY.replace(\"%\", entry.getKey()), externalPort, \"Returns port of a server registered by name\"); macros.add(macro); if(entry.getKey().endsWith(\"/tcp\")) { final String port = entry.getKey().substring(0, entry.getKey().length() - 4); Macro shortMacro = new BaseMacro(KEY.replace(\"%\", port), externalPort, \"Returns port of a server registered by name\"); macros.add(shortMacro); } } return macros; } ",
        "test_tgt": "@Ignore@Test public void getMacros()throws Exception { final Set < Macro > macros = provider.getMacros(machine); assertEquals(macros.size(), 2); final Iterator < Macro > iterator = macros.iterator(); final Macro provider1 = iterator.next(); assertTrue(provider1 instanceof BaseMacro); assertEquals(provider1.getName(), ServerHostNameMacro.KEY.replace(\"%\", WS_AGENT_PORT)); provider1.expand().then(new Operation < String > () { @Override public void apply(String address)throws OperationException { assertEquals(address, PROTOCOL); } }); final Macro provider2 = iterator.next(); assertTrue(provider2 instanceof BaseMacro); assertEquals(provider2.getName(), ServerHostNameMacro.KEY.replace(\"%\", WS_AGENT_PORT.substring(0, WS_AGENT_PORT.length() - 4))); provider2.expand().then(new Operation < String > () { @Override public void apply(String address)throws OperationException { assertEquals(address, PROTOCOL); } }); } "
    },
    {
        "test_src": "@Test public void testGetTables()throws Exception { try(Connection conn = DriverManager.getConnection(URL)) { DatabaseMetaData meta = conn.getMetaData(); ResultSet rs = meta.getTables(null, \"pers\", \"%\", new String[] { \"TABLE\" }); assertNotNull(rs); assertTrue(rs.next()); assertEquals(\"TABLE\", rs.getString(\"TABLE_TYPE\")); assertEquals(JdbcThinDatabaseMetadata.CATALOG_NAME, rs.getString(\"TABLE_CAT\")); assertEquals(\"PERSON\", rs.getString(\"TABLE_NAME\")); assertFalse(rs.next()); rs = meta.getTables(null, \"org\", \"%\", new String[] { \"TABLE\" }); assertNotNull(rs); assertTrue(rs.next()); assertEquals(\"TABLE\", rs.getString(\"TABLE_TYPE\")); assertEquals(JdbcThinDatabaseMetadata.CATALOG_NAME, rs.getString(\"TABLE_CAT\")); assertEquals(\"ORGANIZATION\", rs.getString(\"TABLE_NAME\")); assertFalse(rs.next()); rs = meta.getTables(null, \"pers\", \"%\", null); assertNotNull(rs); assertTrue(rs.next()); assertEquals(\"TABLE\", rs.getString(\"TABLE_TYPE\")); assertEquals(JdbcThinDatabaseMetadata.CATALOG_NAME, rs.getString(\"TABLE_CAT\")); assertEquals(\"PERSON\", rs.getString(\"TABLE_NAME\")); assertFalse(rs.next()); rs = meta.getTables(null, \"org\", \"%\", null); assertNotNull(rs); assertTrue(rs.next()); assertEquals(\"TABLE\", rs.getString(\"TABLE_TYPE\")); assertEquals(JdbcThinDatabaseMetadata.CATALOG_NAME, rs.getString(\"TABLE_CAT\")); assertEquals(\"ORGANIZATION\", rs.getString(\"TABLE_NAME\")); assertFalse(rs.next()); rs = meta.getTables(null, \"PUBLIC\", \"\", new String[] { \"WRONG\" }); assertFalse(rs.next()); } } ",
        "focal_tgt": "@Override public ResultSet getTables(String catalog, String schemaPtrn, String tblNamePtrn, String[]tblTypes)throws SQLException { conn.ensureNotClosed(); List < List < ? > > rows = Collections.emptyList(); boolean areTypesValid = tblTypes == null || Arrays.asList(tblTypes).contains(\"TABLE\"); if(isValidCatalog(catalog) && areTypesValid) { List < JdbcTableMeta > tabMetas = meta.getTablesMeta(schemaPtrn, tblNamePtrn); rows = new ArrayList < > (tabMetas.size()); for(JdbcTableMeta m : tabMetas)rows.add(tableRow(m)); } return new JdbcResultSet(true, null, conn.createStatement0(), Collections. < String > emptyList(), Arrays.asList(\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"TABLE_TYPE\", \"REMARKS\", \"TYPE_CAT\", \"TYPE_SCHEM\", \"TYPE_NAME\", \"SELF_REFERENCING_COL_NAME\", \"REF_GENERATION\"), Arrays.asList(String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName()), rows, true); } ",
        "focal_src": "@Override public ResultSet getTables(String catalog, String schemaPtrn, String tblNamePtrn, String[]tblTypes)throws SQLException { updateMetaData(); List < List < ? > > rows = new LinkedList < > (); if(isValidCatalog(catalog) && (tblTypes == null || Arrays.asList(tblTypes).contains(\"TABLE\"))) { for(Map.Entry < String, Map < String, Map < String, ColumnInfo > > > schema : meta.entrySet()) { if(matches(schema.getKey(), schemaPtrn)) { for(String tbl : schema.getValue().keySet()) { if(matches(tbl, tblNamePtrn))rows.add(tableRow(schema.getKey(), tbl)); } } } } return new JdbcResultSet(true, null, conn.createStatement0(), Collections. < String > emptyList(), Arrays.asList(\"TABLE_CAT\", \"TABLE_SCHEM\", \"TABLE_NAME\", \"TABLE_TYPE\", \"REMARKS\", \"TYPE_CAT\", \"TYPE_SCHEM\", \"TYPE_NAME\", \"SELF_REFERENCING_COL_NAME\", \"REF_GENERATION\"), Arrays.asList(String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName(), String.class.getName()), rows, true); } ",
        "test_tgt": "@Test public void testGetTables()throws Exception { try(Connection conn = DriverManager.getConnection(URL)) { DatabaseMetaData meta = conn.getMetaData(); ResultSet rs = meta.getTables(null, \"pers\", \"%\", new String[] { \"TABLE\" }); assertNotNull(rs); assertTrue(rs.next()); assertEquals(\"TABLE\", rs.getString(\"TABLE_TYPE\")); assertEquals(JdbcUtils.CATALOG_NAME, rs.getString(\"TABLE_CAT\")); assertEquals(\"PERSON\", rs.getString(\"TABLE_NAME\")); assertFalse(rs.next()); rs = meta.getTables(null, \"org\", \"%\", new String[] { \"TABLE\" }); assertNotNull(rs); assertTrue(rs.next()); assertEquals(\"TABLE\", rs.getString(\"TABLE_TYPE\")); assertEquals(JdbcUtils.CATALOG_NAME, rs.getString(\"TABLE_CAT\")); assertEquals(\"ORGANIZATION\", rs.getString(\"TABLE_NAME\")); assertFalse(rs.next()); rs = meta.getTables(null, \"pers\", \"%\", null); assertNotNull(rs); assertTrue(rs.next()); assertEquals(\"TABLE\", rs.getString(\"TABLE_TYPE\")); assertEquals(JdbcUtils.CATALOG_NAME, rs.getString(\"TABLE_CAT\")); assertEquals(\"PERSON\", rs.getString(\"TABLE_NAME\")); assertFalse(rs.next()); rs = meta.getTables(null, \"org\", \"%\", null); assertNotNull(rs); assertTrue(rs.next()); assertEquals(\"TABLE\", rs.getString(\"TABLE_TYPE\")); assertEquals(JdbcUtils.CATALOG_NAME, rs.getString(\"TABLE_CAT\")); assertEquals(\"ORGANIZATION\", rs.getString(\"TABLE_NAME\")); assertFalse(rs.next()); rs = meta.getTables(null, \"PUBLIC\", \"\", new String[] { \"WRONG\" }); assertFalse(rs.next()); } } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should add membership to cohort\", method = \"addMembershipToCohort(Cohort, CohortMembership)\")public void addMembershipToCohort_shouldAddMembershipToCohort()throws Exception { executeDataSet(COHORT_XML); Patient p = new Patient(4); CohortMembership memberToAdd = new CohortMembership(p); service.addMembershipToCohort(service.getCohort(1), memberToAdd); assertTrue(service.getCohort(1).contains(p)); } ",
        "focal_tgt": "@Override public Cohort addMembershipToCohort(Cohort cohort, CohortMembership cohortMembership)throws APIException { cohort.addMembership(cohortMembership); return Context.getCohortService().saveCohort(cohort); } ",
        "focal_src": "public Cohort addMembershipToCohort(Cohort cohort, CohortMembership cohortMembership)throws APIException { cohort.addMembership(cohortMembership); Context.getCohortService().saveCohort(cohort); return cohort; } ",
        "test_tgt": "@Test public void addMembershipToCohort_shouldAddMembershipToCohort()throws Exception { executeDataSet(COHORT_XML); Patient p = new Patient(4); CohortMembership memberToAdd = new CohortMembership(p.getPatientId()); Cohort cohort = service.getCohort(1); if( ! cohort.contains(p)) { service.addMembershipToCohort(cohort, memberToAdd); } assertTrue(cohort.contains(p)); } "
    },
    {
        "test_src": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"read\", args = { })public void test_read()throws IOException { int result = 0; int buffer[] = new int[500]; byte orgBuffer[] = { 1, 3, 4, 7, 8 }; InputStream infile = Support_Resources.getStream(\"hyts_constru_OD.txt\"); Inflater inflate = new Inflater(); InflaterInputStream inflatIP = new InflaterInputStream(infile, inflate); int i = 0; while((result = inflatIP.read()) != - 1) { buffer[i] = result; i ++ ; } inflatIP.close(); for(int j = 0; j < orgBuffer.length; j ++ ) { assertTrue(\"original compressed data did not equal decompressed data\", buffer[j] == orgBuffer[j]); } inflatIP.close(); try { inflatIP.read(); fail(\"IOException expected\"); } catch(IOException ee) { } } ",
        "focal_tgt": "@Override public int read(byte[]buffer, int off, int nbytes)throws IOException { if(closed) { throw new IOException(Messages.getString(\"archive.1E\")); } if(eos) { return - 1; } if(off > buffer.length || nbytes < 0 || off < 0 || buffer.length - off < nbytes) { throw new ArrayIndexOutOfBoundsException(); } int bytesRead; try { bytesRead = super.read(buffer, off, nbytes); } finally { eos = eof; } if(bytesRead != - 1) { crc.update(buffer, off, bytesRead); } if(eos) { verifyCrc(); } return bytesRead; } ",
        "focal_src": "@Override public int read(byte[]buffer, int off, int nbytes)throws IOException { if(closed) { throw new IOException(Messages.getString(\"archive.1E\")); } if(eof) { return - 1; } if(off <= buffer.length && nbytes >= 0 && off >= 0 && buffer.length - off >= nbytes) { int val = super.read(buffer, off, nbytes); if(val != - 1) { crc.update(buffer, off, val); } else if( ! eos) { eos = true; int size = inf.getRemaining(); final int trailerSize = 8; byte[]b = new byte[trailerSize]; int copySize = (size > trailerSize) ? trailerSize : size; System.arraycopy(buf, len - size, b, 0, copySize); readFully(b, copySize, trailerSize - copySize); if(getLong(b, 0) != crc.getValue()) { throw new IOException(Messages.getString(\"archive.20\")); } if((int)getLong(b, 4) != inf.getTotalOut()) { throw new IOException(Messages.getString(\"archive.21\")); } } return val; } throw new ArrayIndexOutOfBoundsException(); } ",
        "test_tgt": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"\", method = \"read\", args = { })public void test_read()throws IOException { int result = 0; int buffer[] = new int[500]; byte orgBuffer[] = { 1, 3, 4, 7, 8 }; InputStream infile = Support_Resources.getStream(\"hyts_constru_OD.txt\"); Inflater inflate = new Inflater(); InflaterInputStream inflatIP = new InflaterInputStream(infile, inflate); int i = 0; while((result = inflatIP.read()) != - 1) { buffer[i] = result; i ++ ; } inflatIP.close(); for(int j = 0; j < orgBuffer.length; j ++ ) { assertTrue(\"original compressed data did not equal decompressed data\", buffer[j] == orgBuffer[j]); } inflatIP.close(); try { inflatIP.read(); fail(\"IOException expected\"); } catch(IOException ee) { } } "
    },
    {
        "test_src": "@Test public void createDB()throws BaseXException { new CreateDB(DBNAME).execute(CONTEXT); assertEquals(dbName(), DBNAME); } ",
        "focal_tgt": "private void createDB(final String input)throws BaseXException { new CreateDB(DB, input == null ? DOC : input).execute(CONTEXT); } ",
        "focal_src": "private void createDB(final String input)throws BaseXException { new CreateDB(DBNAME, input == null ? DOC : input).execute(CONTEXT); } ",
        "test_tgt": "@Test public void createDB()throws BaseXException { new CreateDB(DB).execute(CONTEXT); assertEquals(db(), DB); } "
    },
    {
        "test_src": "@Test public void test_putFilename() { DBObject properties = new BasicDBObject(); String expectedFilename = \"myFilename\"; BodyInjectorHandler.putFilename(expectedFilename, \"defaultFilename\", properties); assertEquals(expectedFilename, properties.get(BodyInjectorHandler.FILENAME)); } ",
        "focal_tgt": "protected static void putFilename(final String formDataFilename, final String defaultFilename, final BsonDocument target) { String filename = target.containsKey(FILENAME) && target.get(FILENAME).isString() ? target.get(FILENAME).asString().getValue() : formDataFilename; if(filename == null || filename.isEmpty()) { LOGGER.debug(\"No filename in neither multipart content disposition \" + \"header nor in properties! Using default value\"); filename = defaultFilename; } target.append(FILENAME, new BsonString(filename)); } ",
        "focal_src": "protected static void putFilename(final String formDataFilename, final String defaultFilename, final DBObject target) { String filename = target.containsField(FILENAME) && target.get(FILENAME)instanceof String ? (String)target.get(FILENAME) : formDataFilename; if(filename == null || filename.isEmpty()) { LOGGER.debug(\"No filename in neither multipart content disposition header nor in properties! Using default value\"); filename = defaultFilename; } target.put(FILENAME, filename); } ",
        "test_tgt": "@Test public void test_putFilename() { BsonDocument properties = new BsonDocument(); BsonString expectedFilename = new BsonString(\"myFilename\"); BodyInjectorHandler.putFilename(expectedFilename.getValue(), \"defaultFilename\", properties); assertEquals(expectedFilename, properties.get(BodyInjectorHandler.FILENAME)); } "
    },
    {
        "test_src": "@Test public void testSolve() { System.out.println(\"solve a vector\"); DenseMatrix a = new JMatrix(A); LU result = a.lu(); result.solve(b); for(int i = 0; i < x.length; i ++ ) { assertEquals(x[i], b[i], 1E-7); } } ",
        "focal_tgt": "public void solve(double[]b) { DenseMatrix B = Matrix.newInstance(b); solve(B); } ",
        "focal_src": "public void solve(double[]b) { int m = lu.nrows(); int n = lu.ncols(); if(m != n) { throw new UnsupportedOperationException(\"The matrix is not square.\"); } if(b.length != m) { throw new IllegalArgumentException(String.format(\"Row dimensions do not agree: A is %d x %d, but b is %d x 1\", lu.nrows(), lu.ncols(), b.length)); } if(isSingular()) { throw new RuntimeException(\"Matrix is singular.\"); } double[]x = new double[b.length]; for(int i = 0; i < m; i ++ ) { x[i] = b[piv[i]]; } for(int k = 0; k < n; k ++ ) { for(int i = k + 1; i < n; i ++ ) { x[i] -= x[k] * lu.get(i, k); } } for(int k = n - 1; k >= 0; k -- ) { x[k] /= lu.get(k, k); for(int i = 0; i < k; i ++ ) { x[i] -= x[k] * lu.get(i, k); } } for(int i = 0; i < m; i ++ ) { b[i] = x[i]; } } ",
        "test_tgt": "@Test public void testSolve() { System.out.println(\"solve a vector\"); JMatrix a = new JMatrix(A); LU result = a.lu(); result.solve(b); for(int i = 0; i < x.length; i ++ ) { assertEquals(x[i], b[i], 1E-7); } } "
    },
    {
        "test_src": "@Test public void testGetNeighborsND() { defaultSetup(); parameters.setInputDimensions(new int[] { 9, 5 }); parameters.setColumnDimensions(new int[] { 5, 5 }); initSP(); int[]result = sp.getNeighborsND(new SparseBinaryMatrix(new int[] { 9, 5 }), 2, 3, true).toArray(); int[]expected = new int[] { 0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44 }; for(int i = 0; i < result.length; i ++ ) { assertEquals(expected[i], result[i]); } defaultSetup(); int[]dimensions = new int[] { 5, 7, 2 }; parameters.setInputDimensions(dimensions); initSP(); SparseBinaryMatrix layout = new SparseBinaryMatrix(dimensions); int radius = 1; int x = 1; int y = 3; int z = 2; int columnIndex = layout.computeIndex(new int[] { z, y, x }); int[]neighbors = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); String expect = \"[18, 19, 20, 21, 22, 23, 32, 33, 34, 36, 37, 46, 47, 48, 49, 50, 51]\"; assertEquals(expect, ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 5, 7, 9 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); radius = 3; x = 0; y = 0; z = 3; columnIndex = layout.computeIndex(new int[] { z, y, x }); neighbors = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); expect = \"[0, 1, 2, 3, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, \" + \"27, 28, 29, 30, 33, 34, 35, 36, 37, 38, 39, 42, 43, 44, 45, 46, 47, 48, 51, \" + \"52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 69, 70, 71, 72, 73, 74, \" + \"75, 78, 79, 80, 81, 82, 83, 84, 87, 88, 89, 90, 91, 92, 93, 96, 97, 98, 99, \" + \"100, 101, 102, 105, 106, 107, 108, 109, 110, 111, 114, 115, 116, 117, 118, 119, \" + \"120, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 141, \" + \"142, 143, 144, 145, 146, 147, 150, 151, 152, 153, 154, 155, 156, 159, 160, 161, \" + \"162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 177, 178, 179, 180, 181, \" + \"182, 183, 186, 187, 188, 190, 191, 192, 195, 196, 197, 198, 199, 200, 201, 204, \" + \"205, 206, 207, 208, 209, 210, 213, 214, 215, 216, 217, 218, 219, 222, 223, 224, \" + \"225, 226, 227, 228, 231, 232, 233, 234, 235, 236, 237, 240, 241, 242, 243, 244, \" + \"245, 246, 249, 250, 251, 252, 253, 254, 255, 258, 259, 260, 261, 262, 263, 264, \" + \"267, 268, 269, 270, 271, 272, 273, 276, 277, 278, 279, 280, 281, 282, 285, 286, \" + \"287, 288, 289, 290, 291, 294, 295, 296, 297, 298, 299, 300, 303, 304, 305, 306, \" + \"307, 308, 309, 312, 313, 314]\"; assertEquals(expect, ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 5, 10, 7, 6 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); radius = 4; int w = 2; x = 5; y = 6; z = 2; columnIndex = layout.computeIndex(new int[] { z, y, x, w }); neighbors = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); TIntHashSet trueNeighbors = new TIntHashSet(); for(int i = - radius; i <= radius; i ++ ) { for(int j = - radius; j <= radius; j ++ ) { for(int k = - radius; k <= radius; k ++ ) { for(int m = - radius; m <= radius; m ++ ) { int zprime = (int)ArrayUtils.positiveRemainder((z + i), dimensions[0]); int yprime = (int)ArrayUtils.positiveRemainder((y + j), dimensions[1]); int xprime = (int)ArrayUtils.positiveRemainder((x + k), dimensions[2]); int wprime = (int)ArrayUtils.positiveRemainder((w + m), dimensions[3]); trueNeighbors.add(layout.computeIndex(new int[] { zprime, yprime, xprime, wprime })); } } } } trueNeighbors.remove(columnIndex); int[]tneighbors = ArrayUtils.unique(trueNeighbors.toArray()); assertEquals(ArrayUtils.print1DArray(tneighbors), ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 2, 4 }, new int[] { 1, 1 }); radius = 1; columnIndex = 3; int[]mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); TIntArrayList msk = new TIntArrayList(mask); TIntArrayList neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 1, 2, 4, 5 }, new int[] { 1, 1, 1, 1 }); radius = 2; columnIndex = 3; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 1, 2, 6, 7 }, new int[] { 1, 1, 1, 1 }); radius = 2; columnIndex = 0; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); layout.set(new int[] { 0, 1, 2, 3, 4, 5, 7 }, new int[] { 1, 1, 1, 1, 1, 1, 1 }); radius = 20; columnIndex = 6; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); int[][]input = new int[][] { { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 1, 1, 1, 0 }, { 0, 1, 0, 1, 0 }, { 0, 1, 1, 1, 0 }, { 0, 0, 0, 0, 0 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 1; columnIndex = 3 * 5 + 2; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); input = new int[][] { { 0, 0, 0, 0, 0 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 0, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 2; columnIndex = 3 * 5 + 2; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); input = new int[][] { { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 0, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 7; columnIndex = 3 * 5 + 2; mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); initSP(); layout = new SparseBinaryMatrix(dimensions); input = new int[][] { { 1, 0, 0, 1, 1 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 1, 0, 0, 1, 1 }, { 1, 0, 0, 1, 0 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)layout.set(layout.computeIndex(new int[] { i, j }), 1); } } radius = 1; columnIndex = layout.getMaxIndex(); mask = sp.getNeighborsND(layout, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(layout.all(mask)); assertFalse(layout.any(neg)); } ",
        "focal_tgt": "public static TIntArrayList getNeighborsND(SpatialLattice l, int columnIndex, int radius, boolean wrapAround) { int[]columnCoords = l.getInputMatrix().computeCoordinates(columnIndex); List < int[] > dimensionCoords = new ArrayList < int[] > (); for(int i = 0; i < l.getInputDimensions().length; i ++ ) { int[]range = ArrayUtils.range(columnCoords[i] - radius, columnCoords[i] + radius + 1); int[]curRange = new int[range.length]; if(wrapAround) { for(int j = 0; j < curRange.length; j ++ ) { curRange[j] = (int)ArrayUtils.positiveRemainder(range[j], l.getInputDimensions()[i]); } } else { curRange = range; } dimensionCoords.add(ArrayUtils.unique(curRange)); } List < TIntList > neighborList = ArrayUtils.dimensionsToCoordinateList(dimensionCoords); TIntArrayList neighbors = new TIntArrayList(neighborList.size()); for(int i = 0; i < neighborList.size(); i ++ ) { int flatIndex = l.getInputMatrix().computeIndex(neighborList.get(i).toArray()); if(flatIndex == columnIndex)continue; neighbors.add(flatIndex); } return neighbors; } ",
        "focal_src": "public < M extends SparseMatrix > TIntArrayList getNeighborsND(M poolerMem, int columnIndex, int radius, boolean wrapAround) { int[]columnCoords = poolerMem.computeCoordinates(columnIndex); List < int[] > dimensionCoords = new ArrayList < int[] > (); for(int i = 0; i < inputDimensions.length; i ++ ) { int[]range = ArrayUtils.range(columnCoords[i] - radius, columnCoords[i] + radius + 1); int[]curRange = new int[range.length]; if(wrapAround) { for(int j = 0; j < curRange.length; j ++ ) { curRange[j] = (int)ArrayUtils.positiveRemainder(range[j], inputDimensions[i]); } } else { curRange = range; } dimensionCoords.add(ArrayUtils.unique(curRange)); } List < TIntList > neighborList = ArrayUtils.dimensionsToCoordinateList(dimensionCoords); TIntArrayList neighbors = new TIntArrayList(neighborList.size()); for(int i = 0; i < neighborList.size(); i ++ ) { int flatIndex = poolerMem.computeIndex(neighborList.get(i).toArray()); if(flatIndex == columnIndex)continue; neighbors.add(flatIndex); } return neighbors; } ",
        "test_tgt": "@Test public void testGetNeighborsND() { defaultSetup(); parameters.setInputDimensions(new int[] { 9, 5 }); parameters.setColumnDimensions(new int[] { 5, 5 }); initSP(); int[]result = SpatialPooler.getNeighborsND(mem, 2, 3, true).toArray(); int[]expected = new int[] { 0, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44 }; for(int i = 0; i < result.length; i ++ ) { assertEquals(expected[i], result[i]); } defaultSetup(); int[]dimensions = new int[] { 5, 7, 2 }; parameters.setInputDimensions(dimensions); parameters.setColumnDimensions(dimensions); initSP(); int radius = 1; int x = 1; int y = 3; int z = 2; int columnIndex = mem.getInputMatrix().computeIndex(new int[] { z, y, x }); int[]neighbors = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); String expect = \"[18, 19, 20, 21, 22, 23, 32, 33, 34, 36, 37, 46, 47, 48, 49, 50, 51]\"; assertEquals(expect, ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 5, 7, 9 }; parameters.setInputDimensions(dimensions); parameters.setColumnDimensions(dimensions); initSP(); radius = 3; x = 0; y = 0; z = 3; columnIndex = mem.getInputMatrix().computeIndex(new int[] { z, y, x }); neighbors = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); expect = \"[0, 1, 2, 3, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, \" + \"27, 28, 29, 30, 33, 34, 35, 36, 37, 38, 39, 42, 43, 44, 45, 46, 47, 48, 51, \" + \"52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 65, 66, 69, 70, 71, 72, 73, 74, \" + \"75, 78, 79, 80, 81, 82, 83, 84, 87, 88, 89, 90, 91, 92, 93, 96, 97, 98, 99, \" + \"100, 101, 102, 105, 106, 107, 108, 109, 110, 111, 114, 115, 116, 117, 118, 119, \" + \"120, 123, 124, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 137, 138, 141, \" + \"142, 143, 144, 145, 146, 147, 150, 151, 152, 153, 154, 155, 156, 159, 160, 161, \" + \"162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 177, 178, 179, 180, 181, \" + \"182, 183, 186, 187, 188, 190, 191, 192, 195, 196, 197, 198, 199, 200, 201, 204, \" + \"205, 206, 207, 208, 209, 210, 213, 214, 215, 216, 217, 218, 219, 222, 223, 224, \" + \"225, 226, 227, 228, 231, 232, 233, 234, 235, 236, 237, 240, 241, 242, 243, 244, \" + \"245, 246, 249, 250, 251, 252, 253, 254, 255, 258, 259, 260, 261, 262, 263, 264, \" + \"267, 268, 269, 270, 271, 272, 273, 276, 277, 278, 279, 280, 281, 282, 285, 286, \" + \"287, 288, 289, 290, 291, 294, 295, 296, 297, 298, 299, 300, 303, 304, 305, 306, \" + \"307, 308, 309, 312, 313, 314]\"; assertEquals(expect, ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 5, 10, 7, 6 }; parameters.setInputDimensions(dimensions); parameters.setColumnDimensions(dimensions); initSP(); radius = 4; int w = 2; x = 5; y = 6; z = 2; columnIndex = mem.getInputMatrix().computeIndex(new int[] { z, y, x, w }); neighbors = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); TIntHashSet trueNeighbors = new TIntHashSet(); for(int i = - radius; i <= radius; i ++ ) { for(int j = - radius; j <= radius; j ++ ) { for(int k = - radius; k <= radius; k ++ ) { for(int m = - radius; m <= radius; m ++ ) { int zprime = (int)ArrayUtils.positiveRemainder((z + i), dimensions[0]); int yprime = (int)ArrayUtils.positiveRemainder((y + j), dimensions[1]); int xprime = (int)ArrayUtils.positiveRemainder((x + k), dimensions[2]); int wprime = (int)ArrayUtils.positiveRemainder((w + m), dimensions[3]); trueNeighbors.add(mem.getInputMatrix().computeIndex(new int[] { zprime, yprime, xprime, wprime })); } } } } trueNeighbors.remove(columnIndex); int[]tneighbors = ArrayUtils.unique(trueNeighbors.toArray()); assertEquals(ArrayUtils.print1DArray(tneighbors), ArrayUtils.print1DArray(neighbors)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); SparseBinaryMatrix sbm = (SparseBinaryMatrix)mem.getInputMatrix(); sbm.set(new int[] { 2, 4 }, new int[] { 1, 1 }); radius = 1; columnIndex = 3; int[]mask = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); TIntArrayList msk = new TIntArrayList(mask); TIntArrayList neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(sbm.all(mask)); assertFalse(sbm.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); sbm = (SparseBinaryMatrix)mem.getInputMatrix(); sbm.set(new int[] { 1, 2, 4, 5 }, new int[] { 1, 1, 1, 1 }); radius = 2; columnIndex = 3; mask = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(sbm.all(mask)); assertFalse(sbm.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); sbm = (SparseBinaryMatrix)mem.getInputMatrix(); sbm.set(new int[] { 1, 2, 6, 7 }, new int[] { 1, 1, 1, 1 }); radius = 2; columnIndex = 0; mask = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(sbm.all(mask)); assertFalse(sbm.any(neg)); defaultSetup(); dimensions = new int[] { 8 }; parameters.setInputDimensions(dimensions); initSP(); sbm = (SparseBinaryMatrix)mem.getInputMatrix(); sbm.set(new int[] { 0, 1, 2, 3, 4, 5, 7 }, new int[] { 1, 1, 1, 1, 1, 1, 1 }); radius = 20; columnIndex = 6; mask = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(sbm.all(mask)); assertFalse(sbm.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); parameters.setColumnDimensions(dimensions); initSP(); sbm = (SparseBinaryMatrix)mem.getInputMatrix(); int[][]input = new int[][] { { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 1, 1, 1, 0 }, { 0, 1, 0, 1, 0 }, { 0, 1, 1, 1, 0 }, { 0, 0, 0, 0, 0 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)sbm.set(sbm.computeIndex(new int[] { i, j }), 1); } } radius = 1; columnIndex = 3 * 5 + 2; mask = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(sbm.all(mask)); assertFalse(sbm.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); parameters.setColumnDimensions(dimensions); initSP(); sbm = (SparseBinaryMatrix)mem.getInputMatrix(); input = new int[][] { { 0, 0, 0, 0, 0 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 0, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)sbm.set(sbm.computeIndex(new int[] { i, j }), 1); } } radius = 2; columnIndex = 3 * 5 + 2; mask = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(sbm.all(mask)); assertFalse(sbm.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); parameters.setColumnDimensions(dimensions); initSP(); sbm = (SparseBinaryMatrix)mem.getInputMatrix(); input = new int[][] { { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 0, 1, 1 }, { 1, 1, 1, 1, 1 }, { 1, 1, 1, 1, 1 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)sbm.set(sbm.computeIndex(new int[] { i, j }), 1); } } radius = 7; columnIndex = 3 * 5 + 2; mask = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(sbm.all(mask)); assertFalse(sbm.any(neg)); defaultSetup(); dimensions = new int[] { 6, 5 }; parameters.setInputDimensions(dimensions); parameters.setColumnDimensions(dimensions); initSP(); sbm = (SparseBinaryMatrix)mem.getInputMatrix(); input = new int[][] { { 1, 0, 0, 1, 1 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0 }, { 1, 0, 0, 1, 1 }, { 1, 0, 0, 1, 0 } }; for(int i = 0; i < input.length; i ++ ) { for(int j = 0; j < input[i].length; j ++ ) { if(input[i][j] == 1)sbm.set(sbm.computeIndex(new int[] { i, j }), 1); } } radius = 1; columnIndex = sbm.getMaxIndex(); mask = SpatialPooler.getNeighborsND(mem, columnIndex, radius, true).toArray(); msk = new TIntArrayList(mask); neg = new TIntArrayList(ArrayUtils.range(0, dimensions[0])); neg.removeAll(msk); assertTrue(sbm.all(mask)); assertFalse(sbm.any(neg)); } "
    },
    {
        "test_src": "@Test public void standard_F32() { for(int i = 4; i <= 4; i += 2) { WaveletDesc_F32 desc = FactoryWaveletDaub.standard_F32(i); double sumScaling = UtilWavelet.sumCoefficients(desc.scaling); double sumWavelet = UtilWavelet.sumCoefficients(desc.wavelet); assertEquals(Math.sqrt(2), sumScaling, 1e-4); assertEquals(0, sumWavelet, 1e-4); double energyScaling = UtilWavelet.computeEnergy(desc.scaling); double energyWavelet = UtilWavelet.computeEnergy(desc.wavelet); assertEquals(1, energyScaling, 1e-4); assertEquals(1, energyWavelet, 1e-4); int polyOrder = i / 2 - 1; checkPolySumToZero(desc.wavelet, polyOrder, 0); for(int offset = 0; offset <= 4; offset += 2) { checkBiorthogonal(offset, desc.scaling, desc.offsetScaling, desc.scaling, desc.offsetScaling); checkBiorthogonal(offset, desc.wavelet, desc.offsetWavelet, desc.wavelet, desc.offsetWavelet); } } } ",
        "focal_tgt": "public static WaveletCoefficient_F32 standard_F32(int J) { if(J != 4) { throw new IllegalArgumentException(\"Only 4 is currently supported\"); } WaveletCoefficient_F32 ret = new WaveletCoefficient_F32(); ret.border = new BorderIndex1D_Wrap(); ret.offsetScaling = 0; ret.offsetWavelet = 0; ret.scaling = new float[4]; ret.wavelet = new float[4]; double sqrt3 = Math.sqrt(3); double div = 4.0 * Math.sqrt(2); ret.scaling[0] = (float)((1 + sqrt3) / div); ret.scaling[1] = (float)((3 + sqrt3) / div); ret.scaling[2] = (float)((3 - sqrt3) / div); ret.scaling[3] = (float)((1 - sqrt3) / div); ret.wavelet[0] = ret.scaling[3]; ret.wavelet[1] = - ret.scaling[2]; ret.wavelet[2] = ret.scaling[1]; ret.wavelet[3] = - ret.scaling[0]; return ret; } ",
        "focal_src": "public static WaveletDesc_F32 standard_F32(int J) { if(J != 4) { throw new IllegalArgumentException(\"Only 4 is currently supported\"); } WaveletDesc_F32 ret = new WaveletDesc_F32(); ret.border = new BorderIndex1D_Wrap(); ret.offsetScaling = 0; ret.offsetWavelet = 0; ret.scaling = new float[4]; ret.wavelet = new float[4]; double sqrt3 = Math.sqrt(3); double div = 4.0 * Math.sqrt(2); ret.scaling[0] = (float)((1 + sqrt3) / div); ret.scaling[1] = (float)((3 + sqrt3) / div); ret.scaling[2] = (float)((3 - sqrt3) / div); ret.scaling[3] = (float)((1 - sqrt3) / div); ret.wavelet[0] = ret.scaling[3]; ret.wavelet[1] = - ret.scaling[2]; ret.wavelet[2] = ret.scaling[1]; ret.wavelet[3] = - ret.scaling[0]; return ret; } ",
        "test_tgt": "@Test public void standard_F32() { for(int i = 4; i <= 4; i += 2) { WaveletCoefficient_F32 desc = FactoryWaveletDaub.standard_F32(i); double sumScaling = UtilWavelet.sumCoefficients(desc.scaling); double sumWavelet = UtilWavelet.sumCoefficients(desc.wavelet); assertEquals(Math.sqrt(2), sumScaling, 1e-4); assertEquals(0, sumWavelet, 1e-4); double energyScaling = UtilWavelet.computeEnergy(desc.scaling); double energyWavelet = UtilWavelet.computeEnergy(desc.wavelet); assertEquals(1, energyScaling, 1e-4); assertEquals(1, energyWavelet, 1e-4); int polyOrder = i / 2 - 1; checkPolySumToZero(desc.wavelet, polyOrder, 0); for(int offset = 0; offset <= 4; offset += 2) { checkBiorthogonal(offset, desc.scaling, desc.offsetScaling, desc.scaling, desc.offsetScaling); checkBiorthogonal(offset, desc.wavelet, desc.offsetWavelet, desc.wavelet, desc.offsetWavelet); } } } "
    },
    {
        "test_src": "@Test public final void run()throws IOException { IOFile io = new IOFile(\"test.xq\"); no(new Run(io.path())); io.write(token(\"// li\")); no(new Run(io.path())); ok(new CreateDB(NAME, FILE)); ok(new Run(io.path())); io.delete(); io = new IOFile(\"test.bxs\"); io.write(token(\"<info/>\")); ok(new Run(io.path())); io = new IOFile(\"test.bxs\"); io.write(token(\"</>\")); no(new Run(io.path())); io.delete(); } ",
        "focal_tgt": "private void run()throws Exception { ctx.soptions.set(StaticOptions.DBPATH, sandbox().path() + \"/data\"); parseArgs(); init(); final Performance perf = new Performance(); ctx.options.set(MainOptions.CHOP, false); final SerializerOptions sopts = new SerializerOptions(); sopts.set(SerializerOptions.METHOD, SerialMethod.XML); sopts.set(SerializerOptions.INDENT, YesNo.NO); sopts.set(SerializerOptions.OMIT_XML_DECLARATION, YesNo.NO); ctx.options.set(MainOptions.SERIALIZER, sopts); final XdmValue doc = new XQuery(\"doc('\" + file(false, CATALOG) + \"')\", ctx).value(); final String version = asString(\"*:catalog/@version\", doc); Util.outln(NL + \"QT3 Test Suite \" + version); Util.outln(\"Test directory: \" + file(false, \".\")); Util.out(\"Parsing queries\"); for(final XdmItem ienv : new XQuery(\"*:catalog/*:environment\", ctx).context(doc))genvs.add(new QT3Env(ctx, ienv)); for(final XdmItem item : new XQuery(\"for $f in //*:test-set/@file return string($f)\", ctx).context(doc))testSet(item.getString()); final StringBuilder result = new StringBuilder(); result.append(\" Rate : \").append(pc(correct, tested)).append(NL); result.append(\" Total : \").append(total).append(NL); result.append(\" Tested : \").append(tested).append(NL); result.append(\" Wrong : \").append(tested - correct).append(NL); result.append(\" Ignored : \").append(ignored).append(NL); Util.outln(NL + \"Writing log file '\" + TESTID + \".log'...\"); try(PrintOutput po = new PrintOutput(new IOFile(TESTID + \".log\"))) { po.println(\"QT3TS RESULTS __________________________\" + NL); po.println(result.toString()); po.println(\"WRONG __________________________________\" + NL); po.print(wrong.finish()); if(all || ! single.isEmpty()) { po.println(\"CORRECT ________________________________\" + NL); po.print(right.finish()); } if(ignoring) { po.println(\"IGNORED ________________________________\" + NL); po.print(ignore.finish()); } } if(report != null) { sopts.set(SerializerOptions.OMIT_XML_DECLARATION, YesNo.YES); final String file = \"ReportingResults/results_\" + NAME + '_' + VERSION + IO.XMLSUFFIX; new IOFile(file).write(report.create(ctx)); Util.outln(\"Creating report '\" + file + \"'...\"); } Util.out(NL + result); Util.outln(\" Time : \" + perf); if(slow != null && ! slow.isEmpty()) { Util.outln(NL + \"Slow queries:\"); for(final Entry < Long, String > l : slow.entrySet()) { Util.outln(\"- \" + - (l.getKey() / 1000000) + \" ms: \" + l.getValue()); } } ctx.close(); sandbox().delete(); } ",
        "focal_src": "private void run()throws Exception { ctx.soptions.set(StaticOptions.DBPATH, sandbox().path() + \"/data\"); parseArgs(); init(); final Performance perf = new Performance(); ctx.options.set(MainOptions.CHOP, false); final SerializerOptions sopts = new SerializerOptions(); sopts.set(SerializerOptions.METHOD, SerialMethod.XML); sopts.set(SerializerOptions.INDENT, YesNo.NO); sopts.set(SerializerOptions.OMIT_XML_DECLARATION, YesNo.NO); ctx.options.set(MainOptions.SERIALIZER, sopts); final XdmValue doc = new XQuery(\"doc('\" + file(false, CATALOG) + \"')\", ctx).value(); final String version = asString(\"*:catalog/@version\", doc); Util.outln(NL + \"QT3 Test Suite \" + version); Util.outln(\"Test directory: \" + file(false, \".\")); Util.out(\"Parsing queries\"); for(final XdmItem ienv : new XQuery(\"*:catalog/*:environment\", ctx).context(doc))genvs.add(new QT3Env(ctx, ienv)); for(final XdmItem item : new XQuery(\"for $f in //*:test-set/@file return string($f)\", ctx).context(doc))testSet(item.getString()); final StringBuilder result = new StringBuilder(); result.append(\" Rate : \").append(pc(correct, tested)).append(NL); result.append(\" Total : \").append(total).append(NL); result.append(\" Tested : \").append(tested).append(NL); result.append(\" Wrong : \").append(tested - correct).append(NL); result.append(\" Ignored : \").append(ignored).append(NL); Util.outln(NL + \"Writing log file '\" + TESTID + \".log'...\"); try(PrintOutput po = new PrintOutput(TESTID + \".log\")) { po.println(\"QT3TS RESULTS __________________________\" + NL); po.println(result.toString()); po.println(\"WRONG __________________________________\" + NL); po.print(wrong.finish()); if(all || ! single.isEmpty()) { po.println(\"CORRECT ________________________________\" + NL); po.print(right.finish()); } if(ignoring) { po.println(\"IGNORED ________________________________\" + NL); po.print(ignore.finish()); } } if(report != null) { sopts.set(SerializerOptions.OMIT_XML_DECLARATION, YesNo.YES); final String file = \"ReportingResults/results_\" + NAME + '_' + VERSION + IO.XMLSUFFIX; new IOFile(file).write(report.create(ctx)); Util.outln(\"Creating report '\" + file + \"'...\"); } Util.out(NL + result); Util.outln(\" Time : \" + perf); if(slow != null && ! slow.isEmpty()) { Util.outln(NL + \"Slow queries:\"); for(final Entry < Long, String > l : slow.entrySet()) { Util.outln(\"- \" + - (l.getKey() / 1000000) + \" ms: \" + l.getValue()); } } ctx.close(); sandbox().delete(); } ",
        "test_tgt": "@Test public final void run()throws IOException { IOFile io = new IOFile(\"test.xq\"); no(new Run(io.path())); io.write(\"// li\"); no(new Run(io.path())); ok(new CreateDB(NAME, FILE)); ok(new Run(io.path())); io.delete(); io = new IOFile(\"test.bxs\"); io.write(\"<info/>\"); ok(new Run(io.path())); io = new IOFile(\"test.bxs\"); io.write(\"</>\"); no(new Run(io.path())); io.delete(); } "
    },
    {
        "test_src": "@Test public void updateStateSync_singleComponentD() { measureAndLayoutComponent(createSimpleTree()); LayoutState current = mComponentTree.getMainThreadLayoutState(); DefaultInternalNode layout = (DefaultInternalNode)current.getLayoutRoot(); mComponentTree.updateStateSync(\"root,B,D\", createStateUpdate(), \"test\"); Set < String > set = new HashSet < > (); set.add(\"root\"); set.add(\"root,A\"); set.add(\"root,B\"); set.add(\"root,B,C\"); assertCloneCalledForOnly(layout, set); } ",
        "focal_tgt": "public void updateStateSync(StateUpdate stateUpdate, String attribution) { checkIfNoStateUpdatesMethod(); if(mComponentTree == null) { return; } mComponentTree.updateStateSync(mComponentScope.getGlobalKey(), stateUpdate, attribution, isCreateLayoutInProgress()); } ",
        "focal_src": "public void updateStateSync(StateUpdate stateUpdate, String attribution) { checkIfNoStateUpdatesMethod(); if(mComponentTree == null) { return; } mComponentTree.updateStateSync(mComponentScope.getGlobalKey(), stateUpdate, attribution); } ",
        "test_tgt": "@Test public void updateStateSync_singleComponentD() { measureAndLayoutComponent(createSimpleTree()); LayoutState current = mComponentTree.getMainThreadLayoutState(); DefaultInternalNode layout = (DefaultInternalNode)current.getLayoutRoot(); mComponentTree.updateStateSync(\"root,B,D\", createStateUpdate(), \"test\", false); Set < String > set = new HashSet < > (); set.add(\"root\"); set.add(\"root,A\"); set.add(\"root,B\"); set.add(\"root,B,C\"); assertCloneCalledForOnly(layout, set); } "
    },
    {
        "test_src": "@Test public void testGetEventClassFamiliesByApplicationToken()throws Exception { ApplicationDto application = createApplication(tenantAdminDto); EventClassFamilyDto eventClassFamily = createEventClassFamily(application.getTenantId()); createApplicationEventFamilyMap(application.getId(), eventClassFamily.getId(), 1); loginTenantDeveloper(tenantDeveloperUser); List < AefMapInfoDto > applicationEcfs = client.getEventClassFamiliesByApplicationToken(application.getApplicationToken()); Assert.assertNotNull(applicationEcfs); Assert.assertEquals(1, applicationEcfs.size()); Assert.assertNotNull(applicationEcfs.get(0)); Assert.assertEquals(eventClassFamily.getId(), applicationEcfs.get(0).getEcfId()); Assert.assertEquals(eventClassFamily.getName(), applicationEcfs.get(0).getEcfName()); Assert.assertEquals(1, applicationEcfs.get(0).getVersion()); } ",
        "focal_tgt": "@RequestMapping(value = \"eventClassFamilies/{applicationToken}\", method = RequestMethod.GET)@ResponseBody public List < AefMapInfoDto > getEventClassFamiliesByApplicationToken(@PathVariable String applicationToken)throws KaaAdminServiceException { return kaaAdminService.getEventClassFamiliesByApplicationToken(applicationToken); } ",
        "focal_src": "@RequestMapping(value = \"eventClassFamiliesByAppToken/{applicationToken}\", method = RequestMethod.GET)@ResponseBody public List < AefMapInfoDto > getEventClassFamiliesByApplicationToken(@PathVariable String applicationToken)throws KaaAdminServiceException { return kaaAdminService.getEventClassFamiliesByApplicationToken(applicationToken); } ",
        "test_tgt": "@Test public void testGetEventClassFamiliesByApplicationToken()throws Exception { ApplicationDto application = createApplication(tenantAdminDto); EventClassFamilyDto eventClassFamily = createEventClassFamily(application.getTenantId()); createApplicationEventFamilyMap(application.getApplicationToken(), eventClassFamily.getId(), 1); loginTenantDeveloper(tenantDeveloperUser); List < AefMapInfoDto > applicationEcfs = client.getEventClassFamiliesByApplicationToken(application.getApplicationToken()); Assert.assertNotNull(applicationEcfs); Assert.assertEquals(1, applicationEcfs.size()); Assert.assertNotNull(applicationEcfs.get(0)); Assert.assertEquals(eventClassFamily.getId(), applicationEcfs.get(0).getEcfId()); Assert.assertEquals(eventClassFamily.getName(), applicationEcfs.get(0).getEcfName()); Assert.assertEquals(1, applicationEcfs.get(0).getVersion()); } "
    },
    {
        "test_src": "@Test public void testSelect() { List < User > list = toList(new User(\"\u5f20\u98de\", 23), new User(\"\u5173\u7fbd\", 24), new User(\"\u5218\u5907\", 25)); LOGGER.debug(JsonUtil.format(CollectionsUtil.select(list, \"name\", toList(\"\u5f20\u98de\", \"\u5218\u5907\")))); } ",
        "focal_tgt": "@SafeVarargs public static < O, V > List < O > select(Collection < O > objectCollection, String propertyName, V ... propertyValues) { return isNullOrEmpty(objectCollection) ? Collections. < O > emptyList() : select(objectCollection, BeanPredicateUtil. < O, V > containsPredicate(propertyName, propertyValues)); } ",
        "focal_src": "@SafeVarargs public static < O, V > List < O > select(Collection < O > objectCollection, String propertyName, V ... propertyValues) { return Validator.isNullOrEmpty(objectCollection) ? Collections. < O > emptyList() : select(objectCollection, new ArrayContainsPredicate < O > (propertyName, propertyValues)); } ",
        "test_tgt": "@Test public void testSelect() { User zhangfei = new User(\"\u5f20\u98de\", 23); User guanyu = new User(\"\u5173\u7fbd\", 24); User liubei = new User(\"\u5218\u5907\", 25); List < User > list = toList(zhangfei, guanyu, liubei); assertThat(CollectionsUtil.select(list, \"name\", toList(\"\u5f20\u98de\", \"\u5218\u5907\")), allOf(hasItem(zhangfei), hasItem(liubei), not(hasItem(guanyu)))); } "
    },
    {
        "test_src": "@Test public void testCreateEvaluation() { EvaluationData e = new EvaluationData(); e.course = \"Winzor101\"; e.name = \"Basic Herping Derping\"; e.startTime = new Date(); e.endTime = new Date(); try { evaluationsDb.createEvaluation(e); } catch(EntityAlreadyExistsException ex) { fail(); } try { evaluationsDb.createEvaluation(e); fail(); } catch(EntityAlreadyExistsException ex) { } e.startTime = null; try { evaluationsDb.createEvaluation(e); fail(); } catch(AssertionError a) { } catch(EntityAlreadyExistsException ex) { fail(); } } ",
        "focal_tgt": "public void createEvaluation(EvaluationData evaluation)throws EntityAlreadyExistsException, InvalidParametersException { Assumption.assertNotNull(ERROR_NULL_PARAMETER, evaluation); verifyCourseOwnerOrAbove(evaluation.course); if( ! evaluation.isValid()) { throw new InvalidParametersException(evaluation.getInvalidStateInfo()); } EvaluationsStorage.inst().createEvaluation(evaluation); } ",
        "focal_src": "public void createEvaluation(EvaluationData evaluation)throws EntityAlreadyExistsException, InvalidParametersException { verifyCourseOwnerOrAbove(evaluation.course); if( ! evaluation.isValid()) { throw new InvalidParametersException(evaluation.getInvalidStateInfo()); } EvaluationsStorage.inst().createEvaluation(evaluation); } ",
        "test_tgt": "@Test public void testCreateEvaluation()throws EntityAlreadyExistsException { EvaluationData e = new EvaluationData(); e.course = \"Computing101\"; e.name = \"Basic Computing Evaluation1\"; e.startTime = new Date(); e.endTime = new Date(); evaluationsDb.createEvaluation(e); try { evaluationsDb.createEvaluation(e); fail(); } catch(EntityAlreadyExistsException ex) { assertContains(EvaluationsDb.ERROR_CREATE_EVALUATION_ALREADY_EXISTS, ex.getMessage()); } e.startTime = null; try { evaluationsDb.createEvaluation(e); fail(); } catch(AssertionError a) { assertEquals(a.getMessage(), EvaluationData.ERROR_FIELD_STARTTIME); } catch(EntityAlreadyExistsException ex) { fail(); } try { evaluationsDb.createEvaluation(null); fail(); } catch(AssertionError a) { assertEquals(Common.ERROR_DBLEVEL_NULL_INPUT, a.getMessage()); } } "
    },
    {
        "test_src": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"Class is abstract. Functionality tested in subclasses for example in java.util.HashMap.\", method = \"clone\", args = { })public void test_clone() { class MyMap extends AbstractMap implements Cloneable { private Map map = new HashMap(); public Set entrySet() { return map.entrySet(); } public Object put(Object key, Object value) { return map.put(key, value); } public Map getMap() { return map; } public Object clone() { try { return super.clone(); } catch(CloneNotSupportedException e) { return null; } } }; MyMap map = new MyMap(); map.put(\"one\", \"1\"); Map.Entry entry = (Map.Entry)map.entrySet().iterator().next(); assertTrue(\"entry not added\", entry.getKey() == \"one\" && entry.getValue() == \"1\"); MyMap mapClone = (MyMap)map.clone(); assertTrue(\"clone not shallow\", map.getMap() == mapClone.getMap()); } ",
        "focal_tgt": "@Override public Object clone() { try { BitSet clone = (BitSet)super.clone(); clone.bits = bits.clone(); return clone; } catch(CloneNotSupportedException e) { throw new AssertionError(e); } } ",
        "focal_src": "@Override public Object clone() { try { BitSet clone = (BitSet)super.clone(); clone.bits = bits.clone(); return clone; } catch(CloneNotSupportedException e) { return null; } } ",
        "test_tgt": "@TestTargetNew(level = TestLevel.COMPLETE, notes = \"Class is abstract. Functionality tested in subclasses for example in java.util.HashMap.\", method = \"clone\", args = { })public void test_clone() { class MyMap extends AbstractMap implements Cloneable { private Map map = new HashMap(); public Set entrySet() { return map.entrySet(); } public Object put(Object key, Object value) { return map.put(key, value); } public Map getMap() { return map; } public Object clone() { try { return super.clone(); } catch(CloneNotSupportedException e) { throw new AssertionError(e); } } }; MyMap map = new MyMap(); map.put(\"one\", \"1\"); Map.Entry entry = (Map.Entry)map.entrySet().iterator().next(); assertTrue(\"entry not added\", entry.getKey() == \"one\" && entry.getValue() == \"1\"); MyMap mapClone = (MyMap)map.clone(); assertTrue(\"clone not shallow\", map.getMap() == mapClone.getMap()); } "
    },
    {
        "test_src": "@Test public void getTraces_lookback() { store(span1, span3); assertThat(store().getTraces(new QueryRequest.Builder(\"service\").endTs(today + 1L).lookback(1L).build())).containsExactly(asList(span1)); assertThat(store().getTraces(new QueryRequest.Builder(\"service\").endTs(today + 2L).lookback(1L).build())).containsExactly(asList(span3), asList(span1)); assertThat(store().getTraces(new QueryRequest.Builder(\"service\").endTs(today + 3L).lookback(1L).build())).containsExactly(asList(span3)); assertThat(store().getTraces(new QueryRequest.Builder(\"service\").endTs(today + 3L).lookback(2L).build())).containsExactly(asList(span3), asList(span1)); } ",
        "focal_tgt": "public List < List < Span > > getTraces() { List < Long > traceIds = storage.spanStore().traceIds(); List < List < Span > > result = new ArrayList < > (traceIds.size()); for(long traceId : traceIds) { result.add(storage.spanStore().getTrace(traceId)); } return result; } ",
        "focal_src": "public List < List < Span > > getTraces() { List < Long > traceIds = store.traceIds(); List < List < Span > > result = new ArrayList < > (traceIds.size()); for(long traceId : traceIds) { result.add(store.getTrace(traceId)); } return result; } ",
        "test_tgt": "@Test public void getTraces_lookback() { accept(span1, span3); assertThat(store().getTraces(new QueryRequest.Builder(\"service\").endTs(today + 1L).lookback(1L).build())).containsExactly(asList(span1)); assertThat(store().getTraces(new QueryRequest.Builder(\"service\").endTs(today + 2L).lookback(1L).build())).containsExactly(asList(span3), asList(span1)); assertThat(store().getTraces(new QueryRequest.Builder(\"service\").endTs(today + 3L).lookback(1L).build())).containsExactly(asList(span3)); assertThat(store().getTraces(new QueryRequest.Builder(\"service\").endTs(today + 3L).lookback(2L).build())).containsExactly(asList(span3), asList(span1)); } "
    },
    {
        "test_src": "@Test public void testGetChangeLog2()throws ConnectionException { LOG.info(\"getChangeLog2\"); CollectionScope context = new CollectionScopeImpl(new SimpleId(\"organization\"), new SimpleId(\"test\"), \"test\"); EntityCollectionManager manager = factory.createCollectionManager(context); Entity e1 = new Entity(new SimpleId(\"test\")); e1.setField(new StringField(\"name\", \"name1\")); e1.setField(new IntegerField(\"count\", 1)); Observable < Entity > o1 = manager.write(e1); e1 = o1.toBlockingObservable().lastOrDefault(null); Entity e2 = manager.load(e1.getId()).toBlockingObservable().lastOrDefault(null); e2.setField(new StringField(\"name\", \"name2\")); e2.setField(new IntegerField(\"count\", 2)); e2.setField(new StringField(\"nickname\", \"buddy\")); Observable < Entity > o2 = manager.write(e2); e2 = o2.toBlockingObservable().lastOrDefault(null); Entity e3 = manager.load(e1.getId()).toBlockingObservable().lastOrDefault(null); e3.setField(new StringField(\"name\", \"name3\")); e3.setField(new IntegerField(\"count\", 2)); e3.getFields().remove(new StringField(\"nickname\", \"buddy\")); Observable < Entity > o3 = manager.write(e3); e3 = o3.toBlockingObservable().lastOrDefault(null); { List < MvccEntity > versions = mvccEntitySerializationStrategy.load(context, e1.getId(), e3.getVersion(), 10); ChangeLogGeneratorImpl instance = new ChangeLogGeneratorImpl(); List < ChangeLogEntry > result = instance.getChangeLog(versions, e3.getVersion()); for(ChangeLogEntry cle : result) { LOG.info(cle.toString()); } assertEquals(7, result.size()); } LOG.info(\"===================\"); { List < MvccEntity > versions = mvccEntitySerializationStrategy.load(context, e1.getId(), e3.getVersion(), 10); ChangeLogGeneratorImpl instance = new ChangeLogGeneratorImpl(); List < ChangeLogEntry > result = instance.getChangeLog(versions, e2.getVersion()); for(ChangeLogEntry cle : result) { LOG.info(cle.toString()); } assertEquals(6, result.size()); } } ",
        "focal_tgt": "@Override public List < ChangeLogEntry > getChangeLog(List < MvccEntity > mvccEntities, UUID minVersion) { Map < String, ChangeLogEntry > writeMap = new HashMap < String, ChangeLogEntry > (); List < ChangeLogEntry > changeLog = new ArrayList < ChangeLogEntry > (); Entity keeper = null; for(MvccEntity mvccEntity : mvccEntities) { Entity entity = mvccEntity.getEntity().get(); int compare = mvccEntity.getVersion().compareTo(minVersion); if(compare == 0) { keeper = entity; } } for(MvccEntity mvccEntity : mvccEntities) { Entity entity = mvccEntity.getEntity().get(); int compare = mvccEntity.getVersion().compareTo(minVersion); if(compare == - 1) { for(Field field : entity.getFields()) { Field keeperField = keeper.getField(field.getName()); if(keeperField == null || keeperField.getValue() == null || ! keeperField.getValue().equals(field.getValue())) { ChangeLogEntry cle = new ChangeLogEntry(entity.getId(), null, ChangeLogEntry.ChangeType.PROPERTY_DELETE, field); changeLog.add(cle); } } } else { for(Field field : entity.getFields()) { String key = field.getName() + field.getValue(); ChangeLogEntry cle = writeMap.get(key); if(cle == null) { cle = new ChangeLogEntry(entity.getId(), mvccEntity.getVersion(), ChangeLogEntry.ChangeType.PROPERTY_WRITE, field); writeMap.put(key, cle); changeLog.add(cle); } else { cle.addVersion(mvccEntity.getVersion()); } } } } return changeLog; } ",
        "focal_src": "@Override public List < ChangeLogEntry > getChangeLog(List < MvccEntity > mvccEntities, UUID minVersion) { Map < String, ChangeLogEntry > writeMap = new HashMap < String, ChangeLogEntry > (); List < ChangeLogEntry > changeLog = new ArrayList < ChangeLogEntry > (); for(MvccEntity mvccEntity : mvccEntities) { Entity entity = mvccEntity.getEntity().get(); int compare = mvccEntity.getVersion().compareTo(minVersion); if(compare == - 1) { for(Field field : entity.getFields()) { String key = field.getName(); ChangeLogEntry cle = new ChangeLogEntry(entity.getId(), null, ChangeLogEntry.ChangeType.PROPERTY_DELETE, field); changeLog.add(0, cle); } } else { for(Field field : entity.getFields()) { String key = field.getName() + field.getValue(); ChangeLogEntry cle = writeMap.get(key); if(cle == null) { cle = new ChangeLogEntry(entity.getId(), mvccEntity.getVersion(), ChangeLogEntry.ChangeType.PROPERTY_WRITE, field); writeMap.put(key, cle); changeLog.add(0, cle); } else { cle.addVersion(mvccEntity.getVersion()); } } } } return changeLog; } ",
        "test_tgt": "@Test public void testBasicOperation()throws ConnectionException { LOG.info(\"getChangeLog1\"); CollectionScope context = new CollectionScopeImpl(new SimpleId(\"organization\"), new SimpleId(\"test\"), \"test\"); EntityCollectionManager manager = factory.createCollectionManager(context); Entity e1 = new Entity(new SimpleId(\"test\")); e1.setField(new StringField(\"name\", \"name1\")); e1.setField(new IntegerField(\"count\", 1)); Observable < Entity > o1 = manager.write(e1); e1 = o1.toBlockingObservable().lastOrDefault(null); Entity e2 = manager.load(e1.getId()).toBlockingObservable().lastOrDefault(null); e2.setField(new StringField(\"name\", \"name2\")); e2.setField(new IntegerField(\"count\", 2)); e2.setField(new StringField(\"nickname\", \"buddy\")); Observable < Entity > o2 = manager.write(e2); e2 = o2.toBlockingObservable().lastOrDefault(null); Entity e3 = manager.load(e1.getId()).toBlockingObservable().lastOrDefault(null); e3.setField(new StringField(\"name\", \"name3\")); e3.setField(new IntegerField(\"count\", 2)); e3.getFields().remove(new StringField(\"nickname\", \"buddy\")); Observable < Entity > o3 = manager.write(e3); e3 = o3.toBlockingObservable().lastOrDefault(null); { List < MvccEntity > versions = mvccEntitySerializationStrategy.load(context, e1.getId(), e3.getVersion(), 10); ChangeLogGeneratorImpl instance = new ChangeLogGeneratorImpl(); List < ChangeLogEntry > result = instance.getChangeLog(versions, e3.getVersion()); for(ChangeLogEntry cle : result) { LOG.info(cle.toString()); } assertEquals(6, result.size()); } LOG.info(\"===================\"); { List < MvccEntity > versions = mvccEntitySerializationStrategy.load(context, e1.getId(), e3.getVersion(), 10); ChangeLogGeneratorImpl instance = new ChangeLogGeneratorImpl(); List < ChangeLogEntry > result = instance.getChangeLog(versions, e2.getVersion()); for(ChangeLogEntry cle : result) { LOG.info(cle.toString()); } assertEquals(6, result.size()); } } "
    },
    {
        "test_src": "@Test public void setOriginToCurrent() { HelperMotion motion = new HelperMotion(); HelperDistort distort = new HelperDistort(); StitchingTransform trans = FactoryStitchingTransform.createAffine_F64(); StitchingFromMotion2D < ImageFloat32, Affine2D_F64 > alg = new StitchingFromMotion2D < ImageFloat32, Affine2D_F64 > (motion, distort, trans, 0.3); alg.configure(200, 300, null); assertTrue(alg.process(image)); Affine2D_F64 found = alg.getWorldToCurr(); assertEquals(1, found.tx, 1e-5); assertEquals( - 2, found.ty, 1e-5); alg.setOriginToCurrent(); found = alg.getWorldToCurr(); assertEquals(0, found.tx, 1e-5); assertEquals(0, found.ty, 1e-5); assertEquals(2, distort.numSetModel); assertEquals(2, distort.numApply); } ",
        "focal_tgt": "public void setOriginToCurrent() { IT currToWorld = (IT)worldToCurr.invert(null); IT oldWorldToNewWorld = (IT)worldToInit.concat(currToWorld, null); PixelTransform_F32 newToOld = converter.convertPixel(oldWorldToNewWorld, null); GImageMiscOps.fill(workImage, 0); distorter.setModel(newToOld); distorter.apply(stitchedImage, workImage); I s = workImage; workImage = stitchedImage; stitchedImage = s; motion.setToFirst(); first = true; computeCurrToInit_PixelTran(); } ",
        "focal_src": "public void setOriginToCurrent() { IT currToWorld = (IT)worldToCurr.invert(null); IT oldWorldToNewWorld = (IT)worldToInit.concat(currToWorld, null); PixelTransform_F32 newToOld = converter.convertPixel(oldWorldToNewWorld, null); GImageMiscOps.fill(workImage, 0); distorter.setModel(newToOld); distorter.apply(stitchedImage, workImage); I s = workImage; workImage = stitchedImage; stitchedImage = s; motion.setToFirst(); worldToCurr.reset(); first = true; } ",
        "test_tgt": "@Test public void setOriginToCurrent() { HelperMotion motion = new HelperMotion(); HelperDistort distort = new HelperDistort(); StitchingTransform trans = FactoryStitchingTransform.createAffine_F64(); StitchingFromMotion2D < ImageFloat32, Affine2D_F64 > alg = new StitchingFromMotion2D < ImageFloat32, Affine2D_F64 > (motion, distort, trans, 0.3); alg.configure(200, 300, null); assertTrue(alg.process(image)); alg.setOriginToCurrent(); assertEquals(2, distort.numSetModel); assertEquals(2, distort.numApply); } "
    },
    {
        "test_src": "@Test public void testCreateSSLServerContext()throws Exception { Configuration serverConfig = new Configuration(); serverConfig.setBoolean(SecurityOptions.SSL_ENABLED, true); serverConfig.setString(SecurityOptions.SSL_KEYSTORE, \"src/test/resources/local127.keystore\"); serverConfig.setString(SecurityOptions.SSL_KEYSTORE_PASSWORD, \"password\"); serverConfig.setString(SecurityOptions.SSL_KEY_PASSWORD, \"password\"); SSLContext serverContext = SSLUtils.createSSLServerContext(serverConfig); Assert.assertNotNull(serverContext); } ",
        "focal_tgt": "@Nullable public static SSLContext createSSLServerContext(Configuration sslConfig)throws Exception { Preconditions.checkNotNull(sslConfig); if( ! getSSLEnabled(sslConfig)) { return null; } LOG.debug(\"Creating server SSL context from configuration\"); String keystoreFilePath = sslConfig.getString(SecurityOptions.SSL_KEYSTORE); String keystorePassword = sslConfig.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD); String certPassword = sslConfig.getString(SecurityOptions.SSL_KEY_PASSWORD); String sslProtocolVersion = sslConfig.getString(SecurityOptions.SSL_PROTOCOL); int sessionCacheSize = sslConfig.getInteger(SecurityOptions.SSL_SESSION_CACHE_SIZE); int sessionTimeoutMs = sslConfig.getInteger(SecurityOptions.SSL_SESSION_TIMEOUT); int handshakeTimeoutMs = sslConfig.getInteger(SecurityOptions.SSL_HANDSHAKE_TIMEOUT); int closeNotifyFlushTimeoutMs = sslConfig.getInteger(SecurityOptions.SSL_CLOSE_NOTIFY_FLUSH_TIMEOUT); Preconditions.checkNotNull(keystoreFilePath, SecurityOptions.SSL_KEYSTORE.key() + \" was not configured.\"); Preconditions.checkNotNull(keystorePassword, SecurityOptions.SSL_KEYSTORE_PASSWORD.key() + \" was not configured.\"); Preconditions.checkNotNull(certPassword, SecurityOptions.SSL_KEY_PASSWORD.key() + \" was not configured.\"); KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); try(FileInputStream keyStoreFile = new FileInputStream(new File(keystoreFilePath))) { ks.load(keyStoreFile, keystorePassword.toCharArray()); } KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); kmf.init(ks, certPassword.toCharArray()); javax.net.ssl.SSLContext serverSSLContext = javax.net.ssl.SSLContext.getInstance(sslProtocolVersion); serverSSLContext.init(kmf.getKeyManagers(), null, null); if(sessionCacheSize >= 0) { serverSSLContext.getServerSessionContext().setSessionCacheSize(sessionCacheSize); } if(sessionTimeoutMs >= 0) { serverSSLContext.getServerSessionContext().setSessionTimeout(sessionTimeoutMs / 1000); } return new SSLContext(serverSSLContext, handshakeTimeoutMs, closeNotifyFlushTimeoutMs); } ",
        "focal_src": "@Nullable public static SSLContext createSSLServerContext(Configuration sslConfig)throws Exception { Preconditions.checkNotNull(sslConfig); SSLContext serverSSLContext = null; if(getSSLEnabled(sslConfig)) { LOG.debug(\"Creating server SSL context from configuration\"); String keystoreFilePath = sslConfig.getString(SecurityOptions.SSL_KEYSTORE); String keystorePassword = sslConfig.getString(SecurityOptions.SSL_KEYSTORE_PASSWORD); String certPassword = sslConfig.getString(SecurityOptions.SSL_KEY_PASSWORD); String sslProtocolVersion = sslConfig.getString(SecurityOptions.SSL_PROTOCOL); Preconditions.checkNotNull(keystoreFilePath, SecurityOptions.SSL_KEYSTORE.key() + \" was not configured.\"); Preconditions.checkNotNull(keystorePassword, SecurityOptions.SSL_KEYSTORE_PASSWORD.key() + \" was not configured.\"); Preconditions.checkNotNull(certPassword, SecurityOptions.SSL_KEY_PASSWORD.key() + \" was not configured.\"); KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType()); try(FileInputStream keyStoreFile = new FileInputStream(new File(keystoreFilePath))) { ks.load(keyStoreFile, keystorePassword.toCharArray()); } KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); kmf.init(ks, certPassword.toCharArray()); serverSSLContext = SSLContext.getInstance(sslProtocolVersion); serverSSLContext.init(kmf.getKeyManagers(), null, null); } return serverSSLContext; } ",
        "test_tgt": "@Test public void testCreateSSLServerContext()throws Exception { Configuration serverConfig = new Configuration(); serverConfig.setBoolean(SecurityOptions.SSL_ENABLED, true); serverConfig.setString(SecurityOptions.SSL_KEYSTORE, \"src/test/resources/local127.keystore\"); serverConfig.setString(SecurityOptions.SSL_KEYSTORE_PASSWORD, \"password\"); serverConfig.setString(SecurityOptions.SSL_KEY_PASSWORD, \"password\"); SSLUtils.SSLContext serverContext = SSLUtils.createSSLServerContext(serverConfig); Assert.assertNotNull(serverContext); } "
    },
    {
        "test_src": "@Test public void considerConnect_nominal() { List < Polygon2D_F64 > squares = new ArrayList < > (); squares.add(new Polygon2D_F64( - 1, 1, 1, 1, 1, - 1, - 1, - 1)); squares.add(new Polygon2D_F64(2, 1, 4, 1, 4, - 1, 2, - 1)); SquaresIntoRegularClusters alg = new SquaresIntoRegularClusters(2, 6, 1.35); alg.computeNodeInfo(squares); SquareNode a = alg.nodes.get(0); SquareNode b = alg.nodes.get(1); alg.considerConnect(a, b); assertConnected(a, 1, b, 3, 3); } ",
        "focal_tgt": "void considerConnect(SquareNode node0, SquareNode node1) { lineA.a = node0.center; lineA.b = node1.center; int intersection0 = graph.findSideIntersect(node0, lineA, intersection, lineB); connectLine.a.set(intersection); int intersection1 = graph.findSideIntersect(node1, lineA, intersection, lineB); connectLine.b.set(intersection); if(intersection1 < 0 || intersection0 < 0) { return; } double side0 = node0.sideLengths[intersection0]; double side1 = node1.sideLengths[intersection1]; double sideLoc0 = connectLine.a.distance(node0.square.get(intersection0)) / side0; double sideLoc1 = connectLine.b.distance(node1.square.get(intersection1)) / side1; if(Math.abs(sideLoc0 - 0.5) > 0.35 || Math.abs(sideLoc1 - 0.5) > 0.35)return; double spaceDistance = connectLine.getLength(); if(Math.abs(side0 - side1) / Math.max(side0, side1) > 0.25) { return; } if( ! graph.almostParallel(node0, intersection0, node1, intersection1)) { return; } double ratio = Math.max(node0.smallestSide / node1.largestSide, node1.smallestSide / node0.largestSide); if(ratio > 1.3)return; graph.checkConnect(node0, intersection0, node1, intersection1, spaceDistance); } ",
        "focal_src": "void considerConnect(SquareNode node0, SquareNode node1) { lineA.a = node0.center; lineA.b = node1.center; int intersection0 = graph.findSideIntersect(node0, lineA, intersection, lineB); connectLine.a.set(intersection); int intersection1 = graph.findSideIntersect(node1, lineA, intersection, lineB); connectLine.b.set(intersection); if(intersection1 < 0 || intersection0 < 0) { return; } double side0 = node0.sideLengths[intersection0]; double side1 = node1.sideLengths[intersection1]; double sideLoc0 = connectLine.a.distance(node0.square.get(intersection0)) / side0; double sideLoc1 = connectLine.b.distance(node1.square.get(intersection1)) / side1; if(Math.abs(sideLoc0 - 0.5) > 0.35 || Math.abs(sideLoc1 - 0.5) > 0.35)return; double distanceApart = connectLine.getLength() * spaceToSquareRatio; if(Math.abs(side0 - side1) / Math.max(side0, side1) > 0.25) { return; } if( ! graph.almostParallel(node0, intersection0, node1, intersection1)) { return; } double ratio = Math.max(node0.smallestSide / node1.largestSide, node1.smallestSide / node0.largestSide); if(ratio > 1.3)return; graph.checkConnect(node0, intersection0, node1, intersection1, distanceApart); } ",
        "test_tgt": "@Test public void considerConnect_nominal() { List < Polygon2D_F64 > squares = new ArrayList < > (); squares.add(new Polygon2D_F64( - 1, 1, 1, 1, 1, - 1, - 1, - 1)); squares.add(new Polygon2D_F64(2, 1, 4, 1, 4, - 1, 2, - 1)); SquaresIntoRegularClusters alg = new SquaresIntoRegularClusters(2, 6, 1.35); alg.computeNodeInfo(squares); SquareNode a = alg.nodes.get(0); SquareNode b = alg.nodes.get(1); alg.considerConnect(a, b); assertConnected(a, 1, b, 3, 1); } "
    },
    {
        "test_src": "@Test public final void add() { no(new Add(FILE)); ok(new CreateDB(NAME)); ok(new Add(FILE, FN)); ok(new Add(FILE, FN, \"target\")); ok(new Add(FLDR, \"xml\")); no(new Add(FILE, \"\\\\\")); no(new Add(FILE, \"/\")); } ",
        "focal_tgt": "private static String add(final Parser parser, final Context ctx, final String target, final String name, final Add cmd)throws BaseXException { final Performance p = new Performance(); final String input = name == null ? parser.src.path() : name; final String path = target + (target.isEmpty() ? \"/\" : \"\") + (name == null ? parser.src.name() : name); final long fl = parser.src.length(); boolean large = false; final Runtime rt = Runtime.getRuntime(); if(fl > rt.freeMemory() / 3) { Performance.gc(2); large = fl > rt.freeMemory() / 3; } final Data data = ctx.data; final String dbname = large ? ctx.mprop.random(data.meta.name) : path; final Builder build = large ? new DiskBuilder(dbname, parser, ctx) : new MemBuilder(dbname, parser, ctx.prop); if(cmd != null)cmd.build = build; Data tmp = null; try { tmp = build.build(); if(tmp.meta.size > 1) { data.insert(data.meta.size, - 1, tmp); ctx.update(); data.flush(); } return Util.info(parser.info() + PATHADDED, input, p); } catch(final IOException ex) { Util.debug(ex); throw new BaseXException(ex); } finally { if(tmp != null)try { tmp.close(); } catch(final IOException e) { } if(large)DropDB.drop(dbname, ctx.mprop); } } ",
        "focal_src": "private static String add(final Parser parser, final Context ctx, final String target, final String name, final Add cmd)throws BaseXException { final Performance p = new Performance(); final String path = target + (target.isEmpty() ? \"/\" : \"\") + (name == null ? parser.src.name() : name); final long fl = parser.src.length(); boolean large = false; final Runtime rt = Runtime.getRuntime(); if(fl > rt.freeMemory() / 3) { Performance.gc(2); large = fl > rt.freeMemory() / 3; } final Data data = ctx.data; final String dbname = large ? ctx.mprop.random(data.meta.name) : path; final Builder build = large ? new DiskBuilder(dbname, parser, ctx) : new MemBuilder(dbname, parser, ctx.prop); if(cmd != null)cmd.build = build; Data tmp = null; try { tmp = build.build(); if(tmp.meta.size > 1) { data.insert(data.meta.size, - 1, tmp); ctx.update(); data.flush(); } return Util.info(PATHADDED, path, p); } catch(final IOException ex) { Util.debug(ex); throw new BaseXException(ex); } finally { if(tmp != null)try { tmp.close(); } catch(final IOException e) { } if(large)DropDB.drop(dbname, ctx.mprop); } } ",
        "test_tgt": "@Test public final void add() { no(new Add(FILE)); ok(new CreateDB(NAME)); ok(new Add(FILE, FN)); ok(new Add(FILE, FN, \"target\")); no(new Add(FILE, \"\\\\\")); no(new Add(FILE, \"/\")); } "
    },
    {
        "test_src": "@Test public void testKFoldCrossValidation() { logger.info(\"kFoldCrossValidation\"); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); int k = 5; Dataframe[]data = Datasets.multinomialClusters(dbConf); Dataframe trainingData = data[0]; data[1].delete(); String dbName = this.getClass().getSimpleName(); MultinomialDPMM instance = new MultinomialDPMM(dbName, dbConf); MultinomialDPMM.TrainingParameters param = new MultinomialDPMM.TrainingParameters(); param.setAlpha(0.01); param.setMaxIterations(100); param.setInitializationMethod(BaseDPMM.TrainingParameters.Initialization.ONE_CLUSTER_PER_RECORD); param.setAlphaWords(1); MultinomialDPMM.ValidationMetrics vm = instance.kFoldCrossValidation(trainingData, param, k); double expResult = 1.0; double result = vm.getPurity(); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); instance.delete(); trainingData.delete(); } ",
        "focal_tgt": "@Override public AbstractRegressor.ValidationMetrics kFoldCrossValidation(Dataframe trainingData, TrainingParameters trainingParameters, int k) { if(mlregressor == null) { throw new RuntimeException(\"You need to train a Regressor before running k-fold cross validation.\"); } else { return(ValidationMetrics)mlregressor.kFoldCrossValidation(trainingData, trainingParameters, k); } } ",
        "focal_src": "@Override public BaseMLregressor.ValidationMetrics kFoldCrossValidation(Dataframe trainingData, TrainingParameters trainingParameters, int k) { throw new UnsupportedOperationException(\"K-fold Cross Validation is not supported. Run it directly to the wrapped regressor.\"); } ",
        "test_tgt": "@Test public void testKFoldCrossValidation() { logger.info(\"kFoldCrossValidation\"); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); int k = 5; Dataframe[]data = Datasets.multinomialClusters(dbConf); Dataframe trainingData = data[0]; data[1].delete(); String dbName = this.getClass().getSimpleName(); MultinomialDPMM instance = new MultinomialDPMM(dbName, dbConf); MultinomialDPMM.TrainingParameters param = new MultinomialDPMM.TrainingParameters(); param.setAlpha(0.01); param.setMaxIterations(100); param.setInitializationMethod(AbstractDPMM.TrainingParameters.Initialization.ONE_CLUSTER_PER_RECORD); param.setAlphaWords(1); MultinomialDPMM.ValidationMetrics vm = instance.kFoldCrossValidation(trainingData, param, k); double expResult = 1.0; double result = vm.getPurity(); assertEquals(expResult, result, TestConfiguration.DOUBLE_ACCURACY_HIGH); instance.delete(); trainingData.delete(); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should update encounter successfully\", method = \"saveEncounter(Encounter)\")public void saveEncounter_shouldUpdateEncounterSuccessfully()throws Exception { EncounterService es = Context.getEncounterService(); Encounter encounter = es.getEncounter(1); Patient origPatient = encounter.getPatient(); Location origLocation = encounter.getLocation(); Date origDate = encounter.getEncounterDatetime(); EncounterType origEncType = encounter.getEncounterType(); Location loc2 = new Location(2); EncounterType encType2 = new EncounterType(2); Date d2 = new Date(); Patient pat2 = new Patient(2); encounter.setLocation(loc2); encounter.setEncounterType(encType2); encounter.setEncounterDatetime(d2); encounter.setPatient(pat2); es.saveEncounter(encounter); Encounter newestEnc = es.getEncounter(encounter.getEncounterId()); assertFalse(\"The location should be different\", origLocation.equals(loc2)); assertTrue(\"The location should be different\", newestEnc.getLocation().equals(loc2)); assertFalse(\"The enc should have changed\", origEncType.equals(encType2)); assertTrue(\"The enc type needs to have been set\", newestEnc.getEncounterType().equals(encType2)); assertFalse(\"Make sure the dates changed slightly\", origDate.equals(d2)); assertTrue(\"The date needs to have been set\", newestEnc.getEncounterDatetime().equals(d2)); assertFalse(\"The patient should be different\", origPatient.equals(pat2)); assertTrue(\"The patient should have been set\", newestEnc.getPatient().equals(pat2)); } ",
        "focal_tgt": "public Encounter saveEncounter(Encounter encounter)throws APIException { if(encounter.getEncounterId() == null) { EncounterVisitHandler encounterVisitHandler = Context.getEncounterService().getActiveEncounterVisitHandler(); if(encounterVisitHandler != null) { encounterVisitHandler.beforeCreateEncounter(encounter); if(encounter.getVisit() != null && encounter.getVisit().getVisitId() == null) { Context.getVisitService().saveVisit(encounter.getVisit()); } } } Errors errors = new BindException(encounter, \"encounter\"); boolean isNewEncounter = false; Date newDate = encounter.getEncounterDatetime(); Date originalDate = null; Location newLocation = encounter.getLocation(); Location originalLocation = null; if(encounter.getEncounterId() == null) { isNewEncounter = true; Context.requirePrivilege(PrivilegeConstants.ADD_ENCOUNTERS); } else { Context.requirePrivilege(PrivilegeConstants.EDIT_ENCOUNTERS); } Patient p = encounter.getPatient(); if( ! isNewEncounter) { originalDate = dao.getSavedEncounterDatetime(encounter); if(encounter.getLocation() != null)originalLocation = dao.getSavedEncounterLocation(encounter); for(Obs obs : encounter.getAllObs(true)) { if(OpenmrsUtil.compare(originalDate, newDate) != 0) { if(OpenmrsUtil.compare(obs.getObsDatetime(), originalDate) == 0) { obs.setObsDatetime(newDate); } } if( ! OpenmrsUtil.nullSafeEquals(newLocation, originalLocation)) { if(obs.getLocation().equals(originalLocation)) { obs.setLocation(newLocation); } } if( ! obs.getPerson().getPersonId().equals(p.getPatientId())) { obs.setPerson(p); } } } for(Order o : encounter.getOrders()) { if( ! p.equals(o.getPatient())) { o.setPatient(p); } } dao.saveEncounter(encounter); for(Order o : encounter.getOrders()) { if(o.getOrderId() == null) { Context.getOrderService().saveOrder(o, null); } } return encounter; } ",
        "focal_src": "public Encounter saveEncounter(Encounter encounter)throws APIException { if(encounter.getEncounterId() == null) { EncounterVisitHandler encounterVisitHandler = Context.getEncounterService().getActiveEncounterVisitHandler(); if(encounterVisitHandler != null) { encounterVisitHandler.beforeCreateEncounter(encounter); if(encounter.getVisit() != null && encounter.getVisit().getVisitId() == null) { Context.getVisitService().saveVisit(encounter.getVisit()); } } } Errors errors = new BindException(encounter, \"encounter\"); boolean isNewEncounter = false; Date newDate = encounter.getEncounterDatetime(); Date originalDate = null; Location newLocation = encounter.getLocation(); Location originalLocation = null; if(encounter.getEncounterId() == null) { isNewEncounter = true; Context.requirePrivilege(PrivilegeConstants.ADD_ENCOUNTERS); } else { Context.requirePrivilege(PrivilegeConstants.EDIT_ENCOUNTERS); } if( ! isNewEncounter) { originalDate = dao.getSavedEncounterDatetime(encounter); if(encounter.getLocation() != null)originalLocation = dao.getSavedEncounterLocation(encounter); Patient p = encounter.getPatient(); for(Obs obs : encounter.getAllObs(true)) { if(OpenmrsUtil.compare(originalDate, newDate) != 0) { if(OpenmrsUtil.compare(obs.getObsDatetime(), originalDate) == 0) { obs.setObsDatetime(newDate); } } if( ! OpenmrsUtil.nullSafeEquals(newLocation, originalLocation)) { if(obs.getLocation().equals(originalLocation)) { obs.setLocation(newLocation); } } if( ! obs.getPerson().getPersonId().equals(p.getPatientId())) { obs.setPerson(p); } } for(Order o : encounter.getOrders()) { if( ! p.equals(o.getPatient())) { o.setPatient(p); } } } dao.saveEncounter(encounter); return encounter; } ",
        "test_tgt": "@Test@Verifies(value = \"should update encounter successfully\", method = \"saveEncounter(Encounter)\")public void saveEncounter_shouldUpdateEncounterSuccessfully()throws Exception { EncounterService es = Context.getEncounterService(); Encounter encounter = es.getEncounter(1); Patient origPatient = encounter.getPatient(); Location origLocation = encounter.getLocation(); Date origDate = encounter.getEncounterDatetime(); EncounterType origEncType = encounter.getEncounterType(); Location loc2 = new Location(2); EncounterType encType2 = new EncounterType(2); Date d2 = new Date(); Patient pat2 = new Patient(2); encounter.setLocation(loc2); encounter.setEncounterType(encType2); encounter.setEncounterDatetime(d2); encounter.setPatient(pat2); es.saveEncounter(encounter); Encounter newestEnc = es.getEncounter(encounter.getEncounterId()); assertFalse(\"The location should be different\", origLocation.equals(loc2)); assertTrue(\"The location should be different\", newestEnc.getLocation().equals(loc2)); assertFalse(\"The enc should have changed\", origEncType.equals(encType2)); assertTrue(\"The enc type needs to have been set\", newestEnc.getEncounterType().equals(encType2)); assertFalse(\"Make sure the dates changed slightly\", origDate.equals(d2)); assertTrue(\"The date needs to have been set\", newestEnc.getEncounterDatetime().equals(d2)); assertFalse(\"The patient should be different\", origPatient.equals(pat2)); assertTrue(\"The patient should have been set\", newestEnc.getPatient().equals(pat2)); } "
    },
    {
        "test_src": "@Test public void testUpdateClassifier()throws IOException, InterruptedException { Classifier mockResponse = loadFixture(FIXTURE_CLASSIFIER, Classifier.class); server.enqueue(new MockResponse().setBody(mockResponse.toString())); File images = new File(IMAGE_FILE); String class1 = \"class1\"; String classifierId = \"foo123\"; UpdateClassifierOptions options = new UpdateClassifierOptions.Builder(classifierId).addClass(class1, images).build(); Classifier serviceResponse = service.updateClassifier(options).execute(); String path = String.format(PATH_CLASSIFIER, classifierId); RecordedRequest request = server.takeRequest(); path += \"?\" + VERSION_DATE + \"=\" + VisualRecognition.VERSION_DATE_2016_05_20 + \"&api_key=\" + API_KEY; assertEquals(path, request.getPath()); assertEquals(\"POST\", request.getMethod()); String body = request.getBody().readUtf8(); String contentDisposition = \"Content-Disposition: form-data; name=\\\"class1_positive_examples\\\"; filename=\\\"test.zip\\\"\"; assertTrue(body.contains(contentDisposition)); assertTrue( ! body.contains(\"Content-Disposition: form-data; name=\\\"name\\\"\")); assertEquals(serviceResponse, mockResponse); } ",
        "focal_tgt": "public ServiceCall < Classifier > updateClassifier(UpdateClassifierOptions updateClassifierOptions) { Validator.notNull(updateClassifierOptions, \"updateClassifierOptions cannot be null\"); Validator.isTrue((updateClassifierOptions.classNames().size() > 0) || (updateClassifierOptions.negativeExamples() != null), \"At least one of classnamePositiveExamples or negativeExamples must be supplied.\"); RequestBuilder builder = RequestBuilder.post(String.format(\"/v3/classifiers/%s\", updateClassifierOptions.classifierId())); builder.query(VERSION, versionDate); MultipartBody.Builder multipartBuilder = new MultipartBody.Builder(); multipartBuilder.setType(MultipartBody.FORM); for(String className : updateClassifierOptions.classNames()) { String dataName = className + \"_positive_examples\"; File positiveExamples = updateClassifierOptions.positiveExamplesByClassName(className); RequestBody body = RequestUtils.fileBody(positiveExamples, \"application/octet-stream\"); multipartBuilder.addFormDataPart(dataName, positiveExamples.getName(), body); } if(updateClassifierOptions.negativeExamples() != null) { RequestBody negativeExamplesBody = RequestUtils.inputStreamBody(updateClassifierOptions.negativeExamples(), \"application/octet-stream\"); multipartBuilder.addFormDataPart(\"negative_examples\", updateClassifierOptions.negativeExamplesFilename(), negativeExamplesBody); } builder.body(multipartBuilder.build()); return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class)); } ",
        "focal_src": "public ServiceCall < Classifier > updateClassifier(UpdateClassifierOptions updateClassifierOptions) { Validator.notNull(updateClassifierOptions, \"updateClassifierOptions cannot be null\"); Validator.isTrue((updateClassifierOptions.classNames() != null) || (updateClassifierOptions.negativeExamples() != null), \"At least one of classnamePositiveExamples or negativeExamples must be supplied.\"); RequestBuilder builder = RequestBuilder.post(String.format(\"/v3/classifiers/%s\", updateClassifierOptions.classifierId())); builder.query(VERSION, versionDate); MultipartBody.Builder multipartBuilder = new MultipartBody.Builder(); multipartBuilder.setType(MultipartBody.FORM); if(updateClassifierOptions.classNames() != null) { for(String className : updateClassifierOptions.classNames()) { String dataName = className + \"_positive_examples\"; File positiveExamples = updateClassifierOptions.positiveExamplesByClassName(className); RequestBody body = RequestUtils.fileBody(positiveExamples, \"application/octet-stream\"); multipartBuilder.addFormDataPart(dataName, positiveExamples.getName(), body); } } if(updateClassifierOptions.negativeExamples() != null) { RequestBody negativeExamplesBody = RequestUtils.inputStreamBody(updateClassifierOptions.negativeExamples(), \"application/octet-stream\"); multipartBuilder.addFormDataPart(\"negative_examples\", updateClassifierOptions.negativeExamplesFilename(), negativeExamplesBody); } builder.body(multipartBuilder.build()); return createServiceCall(builder.build(), ResponseConverterUtils.getObject(Classifier.class)); } ",
        "test_tgt": "@Test public void testUpdateClassifier()throws IOException, InterruptedException { Classifier mockResponse = loadFixture(FIXTURE_CLASSIFIER, Classifier.class); server.enqueue(new MockResponse().setBody(mockResponse.toString())); File images = new File(IMAGE_FILE); String class1 = \"class1\"; String classifierId = \"foo123\"; UpdateClassifierOptions options = new UpdateClassifierOptions.Builder(classifierId).addClass(class1, images).build(); Classifier serviceResponse = service.updateClassifier(options).execute(); String path = String.format(PATH_CLASSIFIER, classifierId); RecordedRequest request = server.takeRequest(); path += \"?\" + VERSION_DATE + \"=2016-05-20&api_key=\" + API_KEY; assertEquals(path, request.getPath()); assertEquals(\"POST\", request.getMethod()); String body = request.getBody().readUtf8(); String contentDisposition = \"Content-Disposition: form-data; name=\\\"class1_positive_examples\\\"; filename=\\\"test.zip\\\"\"; assertTrue(body.contains(contentDisposition)); assertTrue( ! body.contains(\"Content-Disposition: form-data; name=\\\"name\\\"\")); assertEquals(serviceResponse, mockResponse); } "
    },
    {
        "test_src": "@Test public void create() { query(_USER_CREATE.args(NAME, \"\")); query(_USER_CREATE.args(NAME, NAME, Perm.ADMIN)); error(_USER_CREATE.args(NAME, NAME, \"\"), USER_PERMISSION_X); error(_USER_CREATE.args(UserText.ADMIN, \"\"), USER_ADMIN); error(_USER_CREATE.args(\"\", \"\"), USER_NAME_X); error(_USER_CREATE.args(\"\", \"\", Perm.ADMIN), USER_NAME_X); error(_USER_CREATE.args(NAME, \"\") + ',' + _USER_CREATE.args(NAME, \"\"), USER_UPDATE_X_X); } ",
        "focal_tgt": "public synchronized void add(final User user) { users.put(user.name(), user); } ",
        "focal_src": "public synchronized void create(final String name, final String password, final Perm perm) { users.put(name, new User(name, password, perm == null ? Perm.NONE : perm)); } ",
        "test_tgt": "@Test public void create() { query(_USER_CREATE.args(NAME, \"\")); query(_USER_CREATE.args(NAME, NAME, Perm.ADMIN)); query(_USER_CREATE.args(NAME, NAME, \"('admin','none')\", \"('','x')\")); error(_USER_CREATE.args(NAME, NAME, \"\"), USER_PERMISSION_X); error(_USER_CREATE.args(UserText.ADMIN, \"\"), USER_ADMIN); error(_USER_CREATE.args(\"\", \"\"), USER_NAME_X); error(_USER_CREATE.args(\"\", \"\", Perm.ADMIN), USER_NAME_X); error(_USER_CREATE.args(NAME, \"\") + ',' + _USER_CREATE.args(NAME, \"\"), USER_UPDATE_X_X); error(_USER_CREATE.args(NAME, \"\", \"('admin','admin')\", \"('','')\"), USER_SAMEPERM_X_X); error(_USER_CREATE.args(NAME, \"\", \"('admin','admin')\", \"('x','x')\"), USER_SAMEPAT_X); } "
    },
    {
        "test_src": "@Test public void testFindLocations()throws Exception { File test1 = new File(Constants.TEST_TMP_ROOT, \"test1\"); try { bc = new TestBootstrapConfig(); bc.findLocations(null, null, null, null, null); bc.printLocations(false); assertTrue(\"Bootstrap lib dir should be a directory (not a jar)\", bc.bootstrapLib.isDirectory()); checkDirs(\"A\", bc); assertEquals(\"A: Default server name\", BootstrapConstants.DEFAULT_SERVER_NAME, bc.getProcessName()); assertEquals(\"A: installRoot should be parent of bootstrap lib\", bc.installRoot, bc.bootstrapLib.getParentFile()); assertEquals(\"A: userRoot should be child of installRoot\", bc.installRoot, bc.userRoot.getParentFile()); assertEquals(\"A: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"A: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertSame(\"A: outputRoot should be same as processesRoot\", bc.processesRoot, bc.outputRoot); assertSame(\"A: outputDir should be same as configDir\", bc.configDir, bc.outputDir); bc = new TestBootstrapConfig(); bc.findLocations(testName.getMethodName(), test1.getAbsolutePath(), null, null, null); checkDirs(\"B\", bc); assertEquals(\"B: userRoot should match userDir parameter\", test1.getCanonicalFile(), bc.userRoot.getCanonicalFile()); assertEquals(\"B: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"B: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertEquals(\"B: getServerFile(null) should return configDir\", bc.configDir, bc.getConfigFile(null)); assertSame(\"B: outputRoot should be same as processesRoot\", bc.processesRoot, bc.outputRoot); assertSame(\"B: outputDir should be same as configDir\", bc.configDir, bc.outputDir); assertEquals(\"B: getServerOutputFile(null) should return outputDir\", bc.outputDir, bc.getOutputFile(null)); bc = new TestBootstrapConfig(); bc.findLocations(testName.getMethodName(), null, test1.getAbsolutePath(), null, null); checkDirs(\"C\", bc); assertEquals(\"C: userRoot should be child of installRoot\", bc.installRoot, bc.userRoot.getParentFile()); assertEquals(\"C: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"C: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertEquals(\"C: getServerFile(null) should return configDir\", bc.configDir, bc.getConfigFile(null)); assertEquals(\"C: outputRoot should match outputDir parameter\", test1.getCanonicalFile(), bc.outputRoot.getCanonicalFile()); assertEquals(\"C: outputDir should be a child of the outputRoot\", bc.outputRoot, bc.outputDir.getParentFile()); assertEquals(\"C: getServerOutputFile(null) should return outputDir\", bc.outputDir, bc.getOutputFile(null)); assertEquals(\"C: getLogDiretory() should be a child of outputDir\", bc.getOutputFile(\"logs\"), bc.getLogDirectory()); bc = new TestBootstrapConfig(); bc.findLocations(testName.getMethodName(), null, null, test1.getAbsolutePath(), null); checkDirs(\"D\", bc); assertEquals(\"D: userRoot should be child of installRoot\", bc.installRoot, bc.userRoot.getParentFile()); assertEquals(\"D: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"D: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertEquals(\"D: getServerFile(null) should return configDir\", bc.configDir, bc.getConfigFile(null)); assertSame(\"D: outputRoot should be same as processesRoot\", bc.processesRoot, bc.outputRoot); assertSame(\"D: outputDir should be same as configDir\", bc.configDir, bc.outputDir); assertEquals(\"D: getServerOutputFile(null) should return outputDir\", bc.outputDir, bc.getOutputFile(null)); assertEquals(\"D: getLogDiretory() should match logDir parameter\", test1.getCanonicalFile(), bc.getLogDirectory().getCanonicalFile()); initProps.clear(); System.setProperty(BootstrapConstants.LOC_PROPERTY_INSTANCE_DIR, test1.getAbsolutePath()); bc = new TestBootstrapConfig(); bc.findLocations(testName.getMethodName(), null, null, null, null); checkDirs(\"E\", bc); assertEquals(\"E: userRoot should be child of installRoot\", bc.installRoot, bc.userRoot.getParentFile()); assertEquals(\"E: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"E: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertSame(\"E: outputRoot should be same as processesRoot\", bc.processesRoot, bc.outputRoot); assertSame(\"E: outputDir should be same as configDir\", bc.configDir, bc.outputDir); } finally { TestUtils.cleanTempFiles(test1); System.clearProperty(BootstrapConstants.LOC_PROPERTY_INSTANCE_DIR); System.clearProperty(BootstrapConstants.LOC_PROPERTY_INSTALL_DIR); } } ",
        "focal_tgt": "protected void findLocations(String newServerName, String instanceDirStr, String outputDirStr, String logDirStr, String consoleLogFileStr)throws LocationException { findLocations(newServerName, instanceDirStr, outputDirStr, logDirStr, consoleLogFileStr, null); } ",
        "focal_src": "protected void findLocations(String newServerName, String instanceDirStr, String outputDirStr, String logDirStr, String consoleLogFileStr)throws LocationException { setProcessName(newServerName); installRoot = bootstrapLib.getParentFile(); if(instanceDirStr == null)userRoot = new File(installRoot, BootstrapConstants.LOC_AREA_NAME_USR); else userRoot = assertDirectory(FileUtils.normalize(instanceDirStr), BootstrapConstants.ENV_WLP_USER_DIR); processesRoot = new File(userRoot, getProcessesSubdirectory()); configDir = new File(processesRoot, processName); String canonicalServerName = processName; try { File parentDir = configDir.getParentFile(); if( ! isSymbolicLink(configDir, parentDir)) { canonicalServerName = configDir.getCanonicalFile().getName(); if( ! processName.equals(canonicalServerName)) { processName = canonicalServerName; configDir = new File(processesRoot, processName); } } else { File candidate = null; File[]siblings = parentDir.listFiles(); File canonicalConfigDir = configDir.getCanonicalFile(); for(int i = 0; i < siblings.length; ++ i) { File sibling = siblings[i]; if( ! sibling.isDirectory())continue; String sibname = sibling.getCanonicalFile().getName(); if(sibname.equals(processName)) { candidate = sibling; break; } else if(sibname.equalsIgnoreCase(processName)) { if(sibling.getCanonicalFile().equals(canonicalConfigDir))candidate = sibling; } } if(candidate != null) { processName = candidate.getName(); configDir = new File(processesRoot, processName); } } } catch(IOException e) { } if(outputDirStr == null) { outputRoot = processesRoot; outputDir = configDir; } else { outputRoot = assertDirectory(FileUtils.normalize(outputDirStr), getOutputDirectoryEnvName()); outputDir = new File(outputRoot, processName); } if(logDirStr == null)logDir = new File(outputDir, BootstrapConstants.LOC_AREA_NAME_LOGS); else logDir = assertDirectory(FileUtils.normalize(logDirStr), BootstrapConstants.ENV_LOG_DIR); consoleLogFile = new File(logDir, consoleLogFileStr != null ? consoleLogFileStr : BootstrapConstants.CONSOLE_LOG); workarea = new File(outputDir, BootstrapConstants.LOC_AREA_NAME_WORKING); } ",
        "test_tgt": "@Test public void testFindLocations()throws Exception { File test1 = new File(Constants.TEST_TMP_ROOT, \"test1\"); try { bc = new TestBootstrapConfig(); bc.findLocations(null, null, null, null, null); bc.printLocations(false); assertTrue(\"Bootstrap lib dir should be a directory (not a jar)\", bc.bootstrapLib.isDirectory()); checkDirs(\"A\", bc); assertEquals(\"A: Default server name\", BootstrapConstants.DEFAULT_SERVER_NAME, bc.getProcessName()); assertEquals(\"A: installRoot should be parent of bootstrap lib\", bc.installRoot, bc.bootstrapLib.getParentFile()); assertEquals(\"A: userRoot should be child of installRoot\", bc.installRoot, bc.userRoot.getParentFile()); assertEquals(\"A: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"A: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertSame(\"A: outputRoot should be same as processesRoot\", bc.processesRoot, bc.outputRoot); assertSame(\"A: outputDir should be same as configDir\", bc.configDir, bc.outputDir); bc = new TestBootstrapConfig(); bc.findLocations(testName.getMethodName(), test1.getAbsolutePath(), null, null, null); checkDirs(\"B\", bc); assertEquals(\"B: userRoot should match userDir parameter\", test1.getCanonicalFile(), bc.userRoot.getCanonicalFile()); assertEquals(\"B: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"B: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertEquals(\"B: getServerFile(null) should return configDir\", bc.configDir, bc.getConfigFile(null)); assertSame(\"B: outputRoot should be same as processesRoot\", bc.processesRoot, bc.outputRoot); assertSame(\"B: outputDir should be same as configDir\", bc.configDir, bc.outputDir); assertEquals(\"B: getServerOutputFile(null) should return outputDir\", bc.outputDir, bc.getOutputFile(null)); bc = new TestBootstrapConfig(); bc.findLocations(testName.getMethodName(), null, test1.getAbsolutePath(), null, null); checkDirs(\"C\", bc); assertEquals(\"C: userRoot should be child of installRoot\", bc.installRoot, bc.userRoot.getParentFile()); assertEquals(\"C: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"C: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertEquals(\"C: getServerFile(null) should return configDir\", bc.configDir, bc.getConfigFile(null)); assertEquals(\"C: outputRoot should match outputDir parameter\", test1.getCanonicalFile(), bc.outputRoot.getCanonicalFile()); assertEquals(\"C: outputDir should be a child of the outputRoot\", bc.outputRoot, bc.outputDir.getParentFile()); assertEquals(\"C: getServerOutputFile(null) should return outputDir\", bc.outputDir, bc.getOutputFile(null)); assertEquals(\"C: getLogDiretory() should be a child of outputDir\", bc.getOutputFile(\"logs\"), bc.getLogDirectory()); bc = new TestBootstrapConfig(); bc.findLocations(testName.getMethodName(), null, null, test1.getAbsolutePath(), null); checkDirs(\"D\", bc); assertEquals(\"D: userRoot should be child of installRoot\", bc.installRoot, bc.userRoot.getParentFile()); assertEquals(\"D: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"D: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertEquals(\"D: getServerFile(null) should return configDir\", bc.configDir, bc.getConfigFile(null)); assertSame(\"D: outputRoot should be same as processesRoot\", bc.processesRoot, bc.outputRoot); assertSame(\"D: outputDir should be same as configDir\", bc.configDir, bc.outputDir); assertEquals(\"D: getServerOutputFile(null) should return outputDir\", bc.outputDir, bc.getOutputFile(null)); assertEquals(\"D: getLogDiretory() should match logDir parameter\", test1.getCanonicalFile(), bc.getLogDirectory().getCanonicalFile()); initProps.clear(); System.setProperty(BootstrapConstants.LOC_PROPERTY_INSTANCE_DIR, test1.getAbsolutePath()); bc = new TestBootstrapConfig(); bc.findLocations(testName.getMethodName(), null, null, null, null); checkDirs(\"E\", bc); assertEquals(\"E: userRoot should be child of installRoot\", bc.installRoot, bc.userRoot.getParentFile()); assertEquals(\"E: processesRoot should be a child of the userRoot\", bc.userRoot, bc.processesRoot.getParentFile()); assertEquals(\"E: configDir should be a child of the processesRoot\", bc.processesRoot, bc.configDir.getParentFile()); assertSame(\"E: outputRoot should be same as processesRoot\", bc.processesRoot, bc.outputRoot); assertSame(\"E: outputDir should be same as configDir\", bc.configDir, bc.outputDir); bc = new TestBootstrapConfig(); bc.findLocations(testName.getMethodName(), null, null, null, null, BootstrapConstants.LOC_AREA_NAME_WORKING_UTILS); assertTrue(\"F: workarea should be child of outputDir/workarea: \", new File(bc.outputDir, \"workarea\").equals(bc.workarea.getParentFile())); } finally { TestUtils.cleanTempFiles(test1); System.clearProperty(BootstrapConstants.LOC_PROPERTY_INSTANCE_DIR); System.clearProperty(BootstrapConstants.LOC_PROPERTY_INSTALL_DIR); } } "
    },
    {
        "test_src": "@Test public void testDownloadFileFromServer()throws Exception { final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance(); FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList < String > ()); try { String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName); Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString); } catch(Exception e) { e.printStackTrace(); Assert.assertTrue(false); } } ",
        "focal_tgt": "public String downloadFileFromServer(String url, String fileName, String targetFileDir)throws Exception { String localDir = getLocalDownloadDirPath(); RemoteUrl remoteUrl = new RemoteUrl(url, hostList); return restfulMgr.downloadFromServer(remoteUrl, fileName, localDir, targetFileDir, retryTime, retrySleepSeconds); } ",
        "focal_src": "public String downloadFileFromServer(String url, String fileName)throws Exception { String localDir = getLocalDownloadDirPath(); RemoteUrl remoteUrl = new RemoteUrl(url, hostList); return restfulMgr.downloadFromServer(remoteUrl, fileName, localDir, this.enableLocalDownloadDirInClassPath, retryTime, retrySleepSeconds); } ",
        "test_tgt": "@Test public void testDownloadFileFromServer()throws Exception { final RestfulMgr restfulMgr = new RestfulMgrMock().getMockInstance(); FetcherMgr fetcherMgr = new FetcherMgrImpl(restfulMgr, 3, 5, true, \"\", new ArrayList < String > ()); try { String valueString = fetcherMgr.downloadFileFromServer(requestUrl, RestfulMgrMock.defaultFileName, \"./disconf\"); Assert.assertEquals(RestfulMgrMock.defaultFileName, valueString); } catch(Exception e) { e.printStackTrace(); Assert.assertTrue(false); } } "
    },
    {
        "test_src": "@Test public void saveOrder_shouldFailIfTheExistingDrugOrderMatchesTheConceptAndNotDrugOfTheDCOrder()throws Exception { final DrugOrder orderToDiscontinue = (DrugOrder)orderService.getOrder(5); assertTrue(OrderUtilTest.isActiveOrder(orderToDiscontinue, null)); Drug discontinuationOrderDrug = new Drug(); discontinuationOrderDrug.setConcept(orderToDiscontinue.getConcept()); discontinuationOrderDrug = conceptService.saveDrug(discontinuationOrderDrug); assertNotEquals(discontinuationOrderDrug, orderToDiscontinue.getDrug()); assertNotNull(orderToDiscontinue.getDrug()); DrugOrder order = orderToDiscontinue.cloneForRevision(); order.setDateActivated(new Date()); order.setOrderer(providerService.getProvider(1)); order.setEncounter(encounterService.getEncounter(6)); order.setDrug(discontinuationOrderDrug); order.setOrderReasonNonCoded(\"Discontinue this\"); expectedException.expect(APIException.class); expectedException.expectMessage(\"The orderable of the previous order and the new one order don't match\"); orderService.saveOrder(order, null); } ",
        "focal_tgt": "public synchronized Order saveOrder(Order order, OrderContext orderContext)throws APIException { if(order.getOrderId() != null) { throw new APIException(\"Cannot edit an existing order, you need to revise it instead\"); } if(order.getDateActivated() == null) { order.setDateActivated(new Date()); } boolean isDrugOrder = DrugOrder.class.isAssignableFrom(getActualType(order)); Concept concept = order.getConcept(); if(concept == null && isDrugOrder) { DrugOrder drugOrder = (DrugOrder)order; if(drugOrder.getDrug() != null) { concept = drugOrder.getDrug().getConcept(); drugOrder.setConcept(concept); } } if(isDrugOrder) { ((DrugOrder)order).setAutoExpireDateBasedOnDuration(); } if(concept == null) { throw new APIException(\"concept is required for an order\"); } Order previousOrder = order.getPreviousOrder(); if(order.getOrderType() == null) { OrderType orderType = null; if(orderContext != null) { orderType = orderContext.getOrderType(); } if(orderType == null) { orderType = getOrderTypeByConcept(concept); } if(orderType == null && order instanceof DrugOrder) { orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.DRUG_ORDER_TYPE_UUID); } if(orderType == null && order instanceof TestOrder) { orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.TEST_ORDER_TYPE_UUID); } if(orderType == null || (previousOrder != null && ! orderType.equals(previousOrder.getOrderType()))) { throw new APIException(\"Cannot determine the order type of the order, make sure the concept's class is mapped to an order type\"); } order.setOrderType(orderType); } if(order.getCareSetting() == null) { CareSetting careSetting = null; if(orderContext != null) { careSetting = orderContext.getCareSetting(); } if(careSetting == null || (previousOrder != null && ! careSetting.equals(previousOrder.getCareSetting()))) { throw new APIException(\"Cannot determine the care setting of the order\"); } order.setCareSetting(careSetting); } if( ! order.getOrderType().getJavaClass().isAssignableFrom(order.getClass())) { throw new APIException(\"Order type class \" + order.getOrderType().getJavaClass() + \" does not match the order class \" + order.getClass().getName()); } if(REVISE == order.getAction()) { if(previousOrder == null) { throw new APIException(\"Previous Order is required for a revised order\"); } stopOrder(previousOrder, aMomentBefore(order.getDateActivated())); } else if(DISCONTINUE == order.getAction()) { discontinueExistingOrdersIfNecessary(order); } if(previousOrder != null) { boolean isPreviousDrugOrder = DrugOrder.class.isAssignableFrom(previousOrder.getClass()); List < List < Object > > rows = dao.getOrderFromDatabase(previousOrder, isPreviousDrugOrder); List < Object > rowData = rows.get(0); if( ! rowData.get(0).equals(previousOrder.getPatient().getPatientId())) { throw new APIException(\"Cannot change the patient of an order\"); } else if( ! rowData.get(1).equals(previousOrder.getCareSetting().getCareSettingId())) { throw new APIException(\"Cannot change the careSetting of an order\"); } else if( ! rowData.get(2).equals(previousOrder.getConcept().getConceptId())) { throw new APIException(\"Cannot change the concept of an order\"); } else if(isPreviousDrugOrder) { Drug previousDrug = ((DrugOrder)previousOrder).getDrug(); if(previousDrug == null && rowData.get(3) != null) { throw new APIException(\"Cannot change the drug of a drug order\"); } else if(previousDrug != null && ! OpenmrsUtil.nullSafeEquals(rowData.get(3), previousDrug.getDrugId())) { throw new APIException(\"Cannot change the drug of a drug order\"); } } boolean isDrugOrderAndHasADrug = isDrugOrder && ((DrugOrder)order).getDrug() != null; if( ! OpenmrsUtil.nullSafeEquals(order.getConcept(), previousOrder.getConcept())) { throw new APIException(\"The concept of the previous order and the new one order don't match\"); } else if(isDrugOrderAndHasADrug) { DrugOrder drugOrder1 = (DrugOrder)order; DrugOrder drugOrder2 = (DrugOrder)previousOrder; if( ! OpenmrsUtil.nullSafeEquals(drugOrder1.getDrug(), drugOrder2.getDrug())) { throw new APIException(\"The drug of the previous order and the new one order don't match\"); } } else if( ! order.getOrderType().equals(previousOrder.getOrderType())) { throw new APIException(\"The order type does not match that of the previous order\"); } else if( ! order.getCareSetting().equals(previousOrder.getCareSetting())) { throw new APIException(\"The care setting does not match that of the previous order\"); } else if( ! getActualType(order).equals(getActualType(previousOrder))) { throw new APIException(\"The class does not match that of the previous order\"); } } if(DISCONTINUE != order.getAction()) { List < Order > activeOrders = getActiveOrders(order.getPatient(), null, order.getCareSetting(), null); List < String > parallelOrders = Collections.emptyList(); if(orderContext != null && orderContext.getAttribute(PARALLEL_ORDERS) != null) { parallelOrders = Arrays.asList((String[])orderContext.getAttribute(PARALLEL_ORDERS)); } for(Order activeOrder : activeOrders) { if( ! parallelOrders.contains(activeOrder.getUuid()) && areDrugOrdersOfSameOrderableAndOverlappingSchedule(order, activeOrder)) { throw new AmbiguousOrderException(\"Cannot have more than one active order for the same orderable and care setting at same time\"); } } } return saveOrderInternal(order, orderContext); } ",
        "focal_src": "public synchronized Order saveOrder(Order order, OrderContext orderContext)throws APIException { if(order.getOrderId() != null) { throw new APIException(\"Cannot edit an existing order, you need to revise it instead\"); } if(order.getDateActivated() == null) { order.setDateActivated(new Date()); } boolean isDrugOrder = DrugOrder.class.isAssignableFrom(getActualType(order)); Concept concept = order.getConcept(); if(concept == null && isDrugOrder) { DrugOrder drugOrder = (DrugOrder)order; if(drugOrder.getDrug() != null) { concept = drugOrder.getDrug().getConcept(); drugOrder.setConcept(concept); } } if(isDrugOrder) { ((DrugOrder)order).setAutoExpireDateBasedOnDuration(); } if(concept == null) { throw new APIException(\"concept is required for an order\"); } Order previousOrder = order.getPreviousOrder(); if(order.getOrderType() == null) { OrderType orderType = null; if(orderContext != null) { orderType = orderContext.getOrderType(); } if(orderType == null) { orderType = getOrderTypeByConcept(concept); } if(orderType == null && order instanceof DrugOrder) { orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.DRUG_ORDER_TYPE_UUID); } if(orderType == null && order instanceof TestOrder) { orderType = Context.getOrderService().getOrderTypeByUuid(OrderType.TEST_ORDER_TYPE_UUID); } if(orderType == null || (previousOrder != null && ! orderType.equals(previousOrder.getOrderType()))) { throw new APIException(\"Cannot determine the order type of the order, make sure the concept's class is mapped to an order type\"); } order.setOrderType(orderType); } if(order.getCareSetting() == null) { CareSetting careSetting = null; if(orderContext != null) { careSetting = orderContext.getCareSetting(); } if(careSetting == null || (previousOrder != null && ! careSetting.equals(previousOrder.getCareSetting()))) { throw new APIException(\"Cannot determine the care setting of the order\"); } order.setCareSetting(careSetting); } if( ! order.getOrderType().getJavaClass().isAssignableFrom(order.getClass())) { throw new APIException(\"Order type class \" + order.getOrderType().getJavaClass() + \" does not match the order class \" + order.getClass().getName()); } if(REVISE == order.getAction()) { if(previousOrder == null) { throw new APIException(\"Previous Order is required for a revised order\"); } stopOrder(previousOrder, aMomentBefore(order.getDateActivated())); } else if(DISCONTINUE == order.getAction()) { discontinueExistingOrdersIfNecessary(order); } if(previousOrder != null) { boolean isPreviousDrugOrder = DrugOrder.class.isAssignableFrom(previousOrder.getClass()); List < List < Object > > rows = dao.getOrderFromDatabase(previousOrder, isPreviousDrugOrder); List < Object > rowData = rows.get(0); if( ! rowData.get(0).equals(previousOrder.getPatient().getPatientId())) { throw new APIException(\"Cannot change the patient of an order\"); } else if( ! rowData.get(1).equals(previousOrder.getCareSetting().getCareSettingId())) { throw new APIException(\"Cannot change the careSetting of an order\"); } else if( ! rowData.get(2).equals(previousOrder.getConcept().getConceptId())) { throw new APIException(\"Cannot change the concept of an order\"); } else if(isPreviousDrugOrder) { Drug previousDrug = ((DrugOrder)previousOrder).getDrug(); if(previousDrug == null && rowData.get(3) != null) { throw new APIException(\"Cannot change the drug of a drug order\"); } else if(previousDrug != null && ! OpenmrsUtil.nullSafeEquals(rowData.get(3), previousDrug.getDrugId())) { throw new APIException(\"Cannot change the drug of a drug order\"); } } if( ! order.hasSameOrderableAs(previousOrder)) { throw new APIException(\"The orderable of the previous order and the new one order don't match\"); } else if( ! order.getOrderType().equals(previousOrder.getOrderType())) { throw new APIException(\"The order type does not match that of the previous order\"); } else if( ! order.getCareSetting().equals(previousOrder.getCareSetting())) { throw new APIException(\"The care setting does not match that of the previous order\"); } else if( ! getActualType(order).equals(getActualType(previousOrder))) { throw new APIException(\"The class does not match that of the previous order\"); } } if(DISCONTINUE != order.getAction()) { List < Order > activeOrders = getActiveOrders(order.getPatient(), null, order.getCareSetting(), null); List < String > parallelOrders = Collections.emptyList(); if(orderContext != null && orderContext.getAttribute(PARALLEL_ORDERS) != null) { parallelOrders = Arrays.asList((String[])orderContext.getAttribute(PARALLEL_ORDERS)); } for(Order activeOrder : activeOrders) { if( ! parallelOrders.contains(activeOrder.getUuid()) && areDrugOrdersOfSameOrderableAndOverlappingSchedule(order, activeOrder)) { throw new AmbiguousOrderException(\"Cannot have more than one active order for the same orderable and care setting at same time\"); } } } return saveOrderInternal(order, orderContext); } ",
        "test_tgt": "@Test public void saveOrder_shouldFailIfTheExistingDrugOrderMatchesTheConceptAndNotDrugOfTheDCOrder()throws Exception { final DrugOrder orderToDiscontinue = (DrugOrder)orderService.getOrder(5); assertTrue(OrderUtilTest.isActiveOrder(orderToDiscontinue, null)); Drug discontinuationOrderDrug = new Drug(); discontinuationOrderDrug.setConcept(orderToDiscontinue.getConcept()); discontinuationOrderDrug = conceptService.saveDrug(discontinuationOrderDrug); assertNotEquals(discontinuationOrderDrug, orderToDiscontinue.getDrug()); assertNotNull(orderToDiscontinue.getDrug()); DrugOrder order = orderToDiscontinue.cloneForRevision(); order.setDateActivated(new Date()); order.setOrderer(providerService.getProvider(1)); order.setEncounter(encounterService.getEncounter(6)); order.setDrug(discontinuationOrderDrug); order.setOrderReasonNonCoded(\"Discontinue this\"); expectedException.expect(APIException.class); expectedException.expectMessage(\"The drug of the previous order and the new one order don't match\"); orderService.saveOrder(order, null); } "
    },
    {
        "test_src": "@Test(groups = { \"deferredEvent\", \"broken\" })public void testDeferEvent() { EventManager eventManager = new EventManager(manager); Observer < DangerCall > observer = new AnObserver < DangerCall > (); try { } catch(Exception e) { } assert this.registeredSynch != null; assert((DeferredEventNotification)this.registeredSynch).getObserver().equals(observer); } ",
        "focal_tgt": "private < T > void deferEvent(T event, Observer < T > observer) { TransactionListener transactionListener = ManagerImpl.instance().getInstanceByType(TransactionListener.class); DeferredEventNotification < T > deferredEvent = new DeferredEventNotification < T > (event, observer); transactionListener.registerSynhronization(deferredEvent); } ",
        "focal_src": "private < T > void deferEvent(T event, Observer < T > observer) { TransactionListener transactionListener = manager.getInstanceByType(TransactionListener.class); DeferredEventNotification < T > deferredEvent = new DeferredEventNotification < T > (event, observer); transactionListener.registerSynhronization(deferredEvent); } ",
        "test_tgt": "@Test(groups = { \"deferredEvent\", \"broken\" })public void testDeferEvent() { EventManager eventManager = new EventManager(); Observer < DangerCall > observer = new AnObserver < DangerCall > (); try { } catch(Exception e) { } assert this.registeredSynch != null; assert((DeferredEventNotification)this.registeredSynch).getObserver().equals(observer); } "
    },
    {
        "test_src": "@Test public void testGetDefaultInstance()throws PropertyException { Map < String, Object > defaultProps = new HashMap < String, Object > (); defaultProps.put(DummyComp.PROP_FRONTEND, new DummyFrontEnd()); DummyComp dc = (DummyComp)ConMan.getDefaultInstance(DummyComp.class, defaultProps); Assert.assertEquals(dc.getBeamWidth(), 4); Assert.assertEquals(1.3, dc.getAlpha(), 1E-10); Assert.assertTrue(dc.getFrontEnd() != null); Assert.assertTrue(dc.getBestASR().equals(\"sphinx4\")); Assert.assertTrue(dc.getLogger() != null); } ",
        "focal_tgt": "public static SimpleConfigurable getDefaultInstance(Class < ? extends SimpleConfigurable > targetClass, Map < String, Object > props)throws InstantiationException, PropertyException { PropSheet ps = getPropSheetInstanceFromClass(targetClass, props); SimpleConfigurable configurable = ps.getOwner(); configurable.newProperties(ps); return configurable; } ",
        "focal_src": "public static SimpleConfigurable getDefaultInstance(Class < ? extends SimpleConfigurable > targetClass, Map < String, Object > defaultProps) { return getPropSheetInstanceFromClass(targetClass, defaultProps).getOwner(); } ",
        "test_tgt": "@Test public void testGetDefaultInstance()throws PropertyException, InstantiationException { Map < String, Object > defaultProps = new HashMap < String, Object > (); defaultProps.put(DummyComp.PROP_FRONTEND, new DummyFrontEnd()); DummyComp dc = (DummyComp)ConMan.getDefaultInstance(DummyComp.class, defaultProps); Assert.assertEquals(4, dc.getBeamWidth()); Assert.assertEquals(1.3, dc.getAlpha(), 1E-10); Assert.assertTrue(dc.getFrontEnd() != null); Assert.assertTrue(dc.getBestASR().equals(\"sphinx4\")); Assert.assertTrue(dc.getLogger() != null); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should serialize correctly if given object has variants\", method = \"serialize(Object)\")public void serialize_shouldSerializeCorrectlyIfGivenObjectHasVariants()throws Exception { LocalizedString ls = new LocalizedString(); ls.setUnlocalizedValue(\"Favorite Color\"); Map < Locale, String > variants = new LinkedHashMap < Locale, String > (); variants.put(new Locale(\"en\", \"UK\"), \"Favourite Colour\"); variants.put(new Locale(\"fr\"), \"Couleur pr\ufffd\ufffdf\ufffd\ufffdr\ufffd\ufffde\"); ls.setVariants(variants); String expected = \"Favorite Color^v1^en_UK:Favourite Colour;fr:Couleur pr\ufffd\ufffdf\ufffd\ufffdr\ufffd\ufffde\"; OpenmrsSerializer serializer = new LocalizedStringSerializer(); String actual = serializer.serialize(ls); assertEquals(expected, actual); } ",
        "focal_tgt": "@Override public String serialize(Object o)throws SerializationException { if(o == null)return null; if(o instanceof LocalizedString) { LocalizedString localizedString = (LocalizedString)o; StringBuffer sb = new StringBuffer(\"\"); sb.append(LocalizedStringUtil.escapeDelimiter(localizedString.getUnlocalizedValue())); if(localizedString.getVariants() != null && ! localizedString.getVariants().isEmpty()) { sb.insert(0, HEADER); sb.insert(HEADER.length(), \"unlocalized:\"); sb.append(\";\"); Iterator < Entry < Locale, String > > it = localizedString.getVariants().entrySet().iterator(); while(it.hasNext()) { Entry < Locale, String > entry = it.next(); sb.append(entry.getKey()); sb.append(PARTITION); sb.append(LocalizedStringUtil.escapeDelimiter(entry.getValue())); sb.append(SPLITTER); } } return sb.toString(); } else { throw new SerializationException(\"Can not serialize an object of type:\" + o.getClass().getName()); } } ",
        "focal_src": "@Override public String serialize(Object o)throws SerializationException { if(o == null)return null; if(o instanceof LocalizedString) { LocalizedString localizedString = (LocalizedString)o; StringBuffer sb = new StringBuffer(\"\"); sb.append(localizedString.getUnlocalizedValue()); if(localizedString.getVariants() != null && ! localizedString.getVariants().isEmpty()) { sb.append(SEPERATOR); Iterator < Entry < Locale, String > > it = localizedString.getVariants().entrySet().iterator(); while(it.hasNext()) { Entry < Locale, String > entry = it.next(); sb.append(entry.getKey()); sb.append(PARTITION); sb.append(entry.getValue()); if(it.hasNext())sb.append(SPLITTER); } } return sb.toString(); } else { throw new SerializationException(\"Can not serialize an object of type:\" + o.getClass().getName()); } } ",
        "test_tgt": "@Test@Verifies(value = \"should serialize correctly if given object has variants\", method = \"serialize(Object)\")public void serialize_shouldSerializeCorrectlyIfGivenObjectHasVariants()throws Exception { LocalizedString ls = new LocalizedString(); ls.setUnlocalizedValue(\"Favorite Color\"); Map < Locale, String > variants = new LinkedHashMap < Locale, String > (); variants.put(new Locale(\"en\", \"UK\"), \"Favourite Colour\"); variants.put(new Locale(\"fr\"), \"Couleur pr\ufffd\ufffdf\ufffd\ufffdr\ufffd\ufffde\"); ls.setVariants(variants); String expected = \"i18n:v1;unlocalized:Favorite Color;en_UK:Favourite Colour;fr:Couleur pr\ufffd\ufffdf\ufffd\ufffdr\ufffd\ufffde;\"; OpenmrsSerializer serializer = new LocalizedStringSerializer(); String actual = serializer.serialize(ls); assertEquals(expected, actual); } "
    },
    {
        "test_src": "@Test public void isRunning() { final String id = query(_ASYNC_EVAL.args(\"\\\"(1 to 1000000)[.=0]\\\"\")); query(_ASYNC_IS_RUNNING.args(id), \"true\"); } ",
        "focal_tgt": "public boolean finished(final String id, final InputInfo info)throws QueryException { return get(id, info).qp == null; } ",
        "focal_src": "public boolean isRunning(final String id, final InputInfo info)throws QueryException { return get(id, info).qp != null; } ",
        "test_tgt": "@Test public void finished() { final String id = query(_ASYNC_EVAL.args(\"\\\"(1 to 100000000)[.=0]\\\"\")); query(_ASYNC_FINISHED.args(id), \"false\"); query(_ASYNC_STOP.args(id)); error(_ASYNC_FINISHED.args(id), ASYNC_UNKNOWN_X); } "
    },
    {
        "test_src": "@Test public void testIterator() { assertFalse(emptyVector().iterator().hasNext()); try { emptyVector().iterator().next(); fail(\"iterator.next() should throw exception\"); } catch(NoSuchElementException x) { } Iterator < Long2DoubleMap.Entry > iter = singleton().iterator(); assertTrue(iter.hasNext()); Long2DoubleMap.Entry e = iter.next(); assertFalse(iter.hasNext()); assertEquals(5, e.getLongKey()); assertEquals(Long.valueOf(5), e.getKey()); assertThat(e.getDoubleValue(), closeTo(Math.PI)); assertThat(e.getValue(), closeTo(Double.valueOf(Math.PI))); try { iter.next(); fail(\"iter.next() should throw exception\"); } catch(NoSuchElementException x) { } Long2DoubleMap.Entry[]entries = Iterators.toArray(simpleVector().iterator(), Long2DoubleMap.Entry.class); assertEquals(3, entries.length); assertEquals(3, entries[0].getLongKey()); assertEquals(7, entries[1].getLongKey()); assertEquals(8, entries[2].getLongKey()); assertThat(entries[0].getDoubleValue(), closeTo(1.5)); assertThat(entries[1].getDoubleValue(), closeTo(3.5)); assertThat(entries[2].getDoubleValue(), closeTo(2)); } ",
        "focal_tgt": "@Override public abstract Iterator < VectorEntry > iterator(); ",
        "focal_src": "@Override public abstract Iterator < Long2DoubleMap.Entry > iterator(); ",
        "test_tgt": "@Test public void testIterator() { assertFalse(emptyVector().iterator().hasNext()); try { emptyVector().iterator().next(); fail(\"iterator.next() should throw exception\"); } catch(NoSuchElementException x) { } Iterator < VectorEntry > iter = singleton().iterator(); assertTrue(iter.hasNext()); Long2DoubleMap.Entry e = iter.next(); assertFalse(iter.hasNext()); assertEquals(5, e.getLongKey()); assertEquals(Long.valueOf(5), e.getKey()); assertThat(e.getDoubleValue(), closeTo(Math.PI)); assertThat(e.getValue(), closeTo(Double.valueOf(Math.PI))); try { iter.next(); fail(\"iter.next() should throw exception\"); } catch(NoSuchElementException x) { } Long2DoubleMap.Entry[]entries = Iterators.toArray(simpleVector().iterator(), Long2DoubleMap.Entry.class); assertEquals(3, entries.length); assertEquals(3, entries[0].getLongKey()); assertEquals(7, entries[1].getLongKey()); assertEquals(8, entries[2].getLongKey()); assertThat(entries[0].getDoubleValue(), closeTo(1.5)); assertThat(entries[1].getDoubleValue(), closeTo(3.5)); assertThat(entries[2].getDoubleValue(), closeTo(2)); } "
    },
    {
        "test_src": "@Test public void validate_shouldFailIfGroupDoesntHaveAnyMembers()throws Exception { User provider = Context.getUserService().getUser(501); Patient patient = Context.getPatientService().getPatient(6); OrderGroup group = new OrderGroup(null, patient); group.setCreator(provider); group.setDateCreated(new Date()); Errors errors = new BindException(group, \"group\"); validator.validate(group, errors); Assert.assertTrue(errors.hasErrors()); Assert.assertFalse(errors.hasFieldErrors(\"creator\")); Assert.assertFalse(errors.hasFieldErrors(\"patient\")); Assert.assertFalse(errors.hasFieldErrors(\"dateCreated\")); } ",
        "focal_tgt": "@Override public void validate(Object target, Errors errors) { OrderGroup group = (OrderGroup)target; if(group == null) { errors.reject(\"group\", \"error.general\"); } else { ValidationUtils.rejectIfEmpty(errors, \"creator\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"patient\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"dateCreated\", \"error.null\"); if(group.getMembers() == null || group.getMembers().isEmpty())errors.reject(\"OrderGroup.noMembersPresent\"); else { int index = 0; for(Order order : group.getMembers()) { try { errors.pushNestedPath(\"members[\" + index + \"]\"); ValidationUtils.invokeValidator(orderValidator, order, errors); } finally { errors.popNestedPath(); index ++ ; } if(order.getPatient() != null && ! order.getPatient().equals(group.getPatient()))errors.reject(\"OrderGroup.orderPatientMatching\"); } } } } ",
        "focal_src": "@Override public void validate(Object arg0, Errors errors) { OrderGroup group = (OrderGroup)arg0; if(group == null) { errors.reject(\"group\", \"error.general\"); } else { ValidationUtils.rejectIfEmpty(errors, \"creator\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"patient\", \"error.null\"); ValidationUtils.rejectIfEmpty(errors, \"dateCreated\", \"error.null\"); if(group.getMembers() == null || group.getMembers().isEmpty())errors.reject(\"OrderGroup.noMembersPresent\"); else { int index = 0; for(Order order : group.getMembers()) { try { errors.pushNestedPath(\"members[\" + index + \"]\"); ValidationUtils.invokeValidator(orderValidator, order, errors); } finally { errors.popNestedPath(); index ++ ; } if(order.getPatient() != null && ! order.getPatient().equals(group.getPatient()))errors.reject(\"OrderGroup.orderPatientMatching\"); } } } } ",
        "test_tgt": "@Test public void validate_shouldFailIfGroupDoesntHaveAnyMembers()throws Exception { User provider = new User(); provider.setUsername(\"test\"); Patient patient = new Patient(6); OrderGroup group = new OrderGroup(null, patient); group.setCreator(provider); group.setDateCreated(new Date()); Errors errors = new BindException(group, \"group\"); getValidator().validate(group, errors); Assert.assertTrue(errors.hasErrors()); Assert.assertFalse(errors.hasFieldErrors(\"creator\")); Assert.assertFalse(errors.hasFieldErrors(\"patient\")); Assert.assertFalse(errors.hasFieldErrors(\"dateCreated\")); } "
    },
    {
        "test_src": "@SuppressWarnings(\"serial\")@Test public void testInvokeAsync()throws Exception { runInAllDataModes(new TestRunnable() { @Override public void run()throws Exception { final IgniteCache cache = jcache().withKeepBinary(); Set keys = new LinkedHashSet() { { for(int i = 0; i < CNT; i ++ )add(key(i)); } }; for(final Object key : keys) { Object res = cache.invokeAsync(key, NOOP_ENTRY_PROC).get(); assertNull(res); assertNull(cache.getAsync(key).get()); } for(final Object key : keys) { Object res = cache.invokeAsync(key, INC_ENTRY_PROC_BINARY_OBJ, dataMode).get(); assertNull(res); assertEquals(value(0), deserializeBinary(cache.getAsync(key).get())); res = cache.invokeAsync(key, INC_ENTRY_PROC_BINARY_OBJ, dataMode).get(); assertEquals(value(0), deserializeBinary(res)); assertEquals(value(1), deserializeBinary(cache.getAsync(key).get())); assertTrue((Boolean)cache.removeAsync(key).get()); } interceptorBinaryObjExp = atomicityMode() == TRANSACTIONAL; try { for(final Object key : keys) { Object res = cache.invokeAsync(key, INC_ENTRY_PROC_USER_OBJ, dataMode).get(); assertNull(res); assertEquals(value(0), deserializeBinary(cache.getAsync(key).get())); res = cache.invokeAsync(key, INC_ENTRY_PROC_USER_OBJ, dataMode).get(); assertEquals(value(1), deserializeBinary(cache.getAsync(key).get())); assertTrue((Boolean)cache.removeAsync(key).get()); } } finally { interceptorBinaryObjExp = true; } } }, PLANE_OBJECT, SERIALIZABLE); } ",
        "focal_tgt": "public < K, V, T > IgniteInternalFuture < GridCacheReturn > invokeAsync(GridCacheContext cacheCtx, @Nullable AffinityTopologyVersion entryTopVer, @Nullable Map < ? extends K, ? extends EntryProcessor < K, V, Object > > map, Object ... invokeArgs) { return(IgniteInternalFuture < GridCacheReturn > )putAllAsync0(cacheCtx, entryTopVer, null, map, invokeArgs, null, true); } ",
        "focal_src": "@SuppressWarnings(\"unchecked\")public < K, V, T > IgniteInternalFuture < GridCacheReturn > invokeAsync(GridCacheContext cacheCtx, @Nullable AffinityTopologyVersion entryTopVer, @Nullable Map < ? extends K, ? extends EntryProcessor < K, V, Object > > map, Object ... invokeArgs) { return(IgniteInternalFuture < GridCacheReturn > )putAllAsync0(cacheCtx, entryTopVer, null, map, invokeArgs, null, true); } ",
        "test_tgt": "@SuppressWarnings(\"serial\")@Test public void testInvokeAsync()throws Exception { runInAllDataModes(new TestRunnable() { @Override public void run()throws Exception { final IgniteCache cache = jcache().withKeepBinary(); Set keys = new LinkedHashSet() { { for(int i = 0; i < CNT; i ++ )add(key(i)); } }; for(final Object key : keys) { Object res = cache.invokeAsync(key, NOOP_ENTRY_PROC).get(); assertNull(res); assertNull(cache.getAsync(key).get()); } for(final Object key : keys) { Object res = cache.invokeAsync(key, INC_ENTRY_PROC_BINARY_OBJ, dataMode).get(); assertNull(res); assertEquals(value(0), deserializeBinary(cache.getAsync(key).get())); res = cache.invokeAsync(key, INC_ENTRY_PROC_BINARY_OBJ, dataMode).get(); assertEquals(value(0), deserializeBinary(res)); assertEquals(value(1), deserializeBinary(cache.getAsync(key).get())); assertTrue((Boolean)cache.removeAsync(key).get()); } interceptorBinaryObjExp = atomicityMode() == TRANSACTIONAL; try { for(final Object key : keys) { Object res = cache.invokeAsync(key, INC_ENTRY_PROC_USER_OBJ, dataMode).get(); assertNull(res); assertEquals(value(0), deserializeBinary(cache.getAsync(key).get())); res = cache.invokeAsync(key, INC_ENTRY_PROC_USER_OBJ, dataMode).get(); assertEquals(value(1), deserializeBinary(cache.getAsync(key).get())); assertTrue((Boolean)cache.removeAsync(key).get()); } } finally { interceptorBinaryObjExp = true; } } }, PLANE_OBJECT, SERIALIZABLE); } "
    },
    {
        "test_src": "@SuppressWarnings(\"deprecation\")@Test public void testUserRatingVector() { Collection < Rating > ratings = new ArrayList < Rating > (); ratings.add(new SimpleRating(5, 7, 3.5)); ratings.add(new SimpleRating(5, 3, 1.5)); ratings.add(new SimpleRating(5, 8, 2)); SparseVector v = Ratings.userRatingVector(ratings); assertEquals(3, v.size()); assertEquals(7, v.sum(), EPSILON); assertEquals(simpleVector(), v); } ",
        "focal_tgt": "@Deprecated private static MutableSparseVector userRatingVector(ArrayList < Rating > ratings) { Rating rp = null; for(Rating r : ratings) { if(rp != null && ITEM_TIME_COMPARATOR.compare(rp, r) > 0) { Collections.sort(ratings, ITEM_TIME_COMPARATOR); break; } rp = r; } long[]items = new long[ratings.size()]; double[]values = new double[ratings.size()]; int li = - 1; for(Rating r : ratings) { long iid = r.getItemId(); if(li < 0 || items[li] != iid)li ++ ; items[li] = iid; values[li] = r.getRating(); } return MutableSparseVector.wrap(items, values, li + 1); } ",
        "focal_src": "private static MutableSparseVector userRatingVector(ArrayList < Rating > ratings) { Rating rp = null; for(Rating r : ratings) { if(rp != null && ITEM_TIME_COMPARATOR.compare(rp, r) > 0) { Collections.sort(ratings, ITEM_TIME_COMPARATOR); break; } rp = r; } long[]items = new long[ratings.size()]; double[]values = new double[ratings.size()]; int li = - 1; for(Rating r : ratings) { long iid = r.getItemId(); if(li < 0 || items[li] != iid)li ++ ; items[li] = iid; values[li] = r.getRating(); } return MutableSparseVector.wrap(items, values, li + 1); } ",
        "test_tgt": "@SuppressWarnings(\"deprecation\")@Test public void testUserRatingVector() { Collection < Rating > ratings = new ArrayList < Rating > (); ratings.add(new SimpleRating(1, 5, 7, 3.5)); ratings.add(new SimpleRating(2, 5, 3, 1.5)); ratings.add(new SimpleRating(3, 5, 8, 2)); SparseVector v = Ratings.userRatingVector(ratings); assertEquals(3, v.size()); assertEquals(7, v.sum(), EPSILON); assertEquals(simpleVector(), v); } "
    },
    {
        "test_src": "@Test public void testGo()throws Exception { final String importerDescription = \"Some description.\"; final AcceptsOneWidget container = mock(AcceptsOneWidget.class); final ProjectImporterDescriptor projectImporter = mock(ProjectImporterDescriptor.class); when(projectImporter.getDescription()).thenReturn(importerDescription); presenter.go(container); verify(container).setWidget(eq(view)); verify(view).setProjectName(anyString()); verify(view).setProjectDescription(anyString()); verify(view).setProjectUrl(anyString()); verify(view).setUrlTextBoxFocused(); } ",
        "focal_tgt": "@Override public void go(AcceptsOneWidget container) { if(Strings.isNullOrEmpty(dataObject.getName()) && Strings.isNullOrEmpty(dataObject.getSource().getLocation())) { ignoreChanges = true; view.setProjectUrlErrorHighlight(false); view.setProjectNameErrorHighlight(false); view.setURLErrorMessage(null); } view.setProjectName(dataObject.getName()); view.setProjectDescription(dataObject.getDescription()); view.setProjectUrl(dataObject.getSource().getLocation()); container.setWidget(view); view.setInputsEnableState(true); ignoreChanges = false; } ",
        "focal_src": "@Override public void go(AcceptsOneWidget container) { view.setProjectName(dataObject.getName()); view.setProjectDescription(dataObject.getDescription()); view.setProjectUrl(dataObject.getSource().getLocation()); container.setWidget(view); view.setUrlTextBoxFocused(); } ",
        "test_tgt": "@Test public void testGo()throws Exception { final String importerDescription = \"Some description.\"; final AcceptsOneWidget container = mock(AcceptsOneWidget.class); final ProjectImporterDescriptor projectImporter = mock(ProjectImporterDescriptor.class); when(projectImporter.getDescription()).thenReturn(importerDescription); presenter.go(container); verify(container).setWidget(eq(view)); verify(view).setProjectName(anyString()); verify(view).setProjectDescription(anyString()); verify(view).setProjectUrl(anyString()); verify(view).setInputsEnableState(eq(true)); } "
    },
    {
        "test_src": "@Test public final void testGetInstance1() { OsmUser user1 = OsmUser.getInstance(\"aUser\", 12); OsmUser.getInstance(\"bUser\", 14); OsmUser user2 = OsmUser.getInstance(\"aUser\", 12); assertEquals(\"Objects are not equal\", user1, user2); assertEquals(\"Hash codes are not equal\", user1.hashCode(), user2.hashCode()); } ",
        "focal_tgt": "public static OsmUser getInstance(StoreReader sr, StoreClassRegister scr) { return getInstance(sr.readString(), sr.readInteger()); } ",
        "focal_src": "public static OsmUser getInstance(StoreReader sr, StoreClassRegister scr) { if(sr.readBoolean()) { return getInstance(sr.readString(), sr.readInteger()); } else { return NO_USER; } } ",
        "test_tgt": "@Test public final void testGetInstanceSingleObjectReuse() { OsmUser user1 = OsmUser.getInstance(\"aUser\", 12); OsmUser.getInstance(\"bUser\", 14); OsmUser user2 = OsmUser.getInstance(\"aUser\", 12); assertEquals(\"Objects are not equal\", user1, user2); assertEquals(\"Hash codes are not equal\", user1.hashCode(), user2.hashCode()); } "
    },
    {
        "test_src": "@Test public void testMatch()throws QueryException { for(int i = 0; i < VALIDWC.length; i ++ ) { final String q = VALIDWC[i]; final FTWildcard wc = new FTWildcard(token(q), null); final String[]good = TEXTS_GOOD[i]; for(int j = 0; j < good.length; j ++ ) { assertTrue(\"\\\"\" + q + \"\\\" did NOT match \\\"\" + good[j] + \"\\\"\", wc.match(token(good[j]))); } final String[]bad = TEXTS_BAD[i]; for(int j = 0; j < bad.length; j ++ ) { assertFalse(\"\\\"\" + q + \"\\\" matched \\\"\" + bad[j] + \"\\\"\", wc.match(token(bad[j]))); } } } ",
        "focal_tgt": "private boolean match(final int[]t, final int tp, final int qp) { int qi = qp; int ti = tp; final int tl = t.length; final int wl = wc.length; while(qi < wl) { if(wc[qi] == DOT) { int n = min[qi]; final int m = max[qi ++ ]; while( ! match(t, ti + n, qi))if(ti + ++ n > tl)return false; if(n > m)return false; ti += n; } else { if(ti >= tl || t[ti ++ ] != wc[qi ++ ])return false; } } return ti == tl; } ",
        "focal_src": "private boolean match(final int[]t, final int tp, final int qp) { int ql = qp; int tl = tp; while(ql < wc.length) { if(wc[ql] == DOT) { int n = min[ql]; final int m = max[ql ++ ]; while( ! match(t, tl + n, ql))if(tl + ++ n > t.length)return false; if(n > m)return false; tl += n; } else { if(tl >= t.length || t[tl ++ ] != wc[ql ++ ])return false; } } return tl == t.length; } ",
        "test_tgt": "@Test public void testMatch()throws QueryException { for(int i = 0; i < VALIDWC.length; i ++ ) { final String q = VALIDWC[i]; final FTWildcard wc = new FTWildcard(token(q), null); final String[]good = TEXTS_GOOD[i]; for(final String element : good) { assertTrue(\"\\\"\" + q + \"\\\" did NOT match \\\"\" + element + \"\\\"\", wc.match(token(element))); } final String[]bad = TEXTS_BAD[i]; for(final String element : bad) { assertFalse(\"\\\"\" + q + \"\\\" matched \\\"\" + element + \"\\\"\", wc.match(token(element))); } } } "
    },
    {
        "test_src": "@Test public void testOnCreateOrUpdateCluster()throws GeniePreconditionException { this.c = new ClusterEntity(NAME, USER, VERSION, ClusterStatus.UP, CLUSTER_TYPE); Assert.assertNotNull(this.c.getTags()); Assert.assertTrue(this.c.getTags().isEmpty()); this.c.onCreateOrUpdateCluster(); Assert.assertEquals(2, this.c.getTags().size()); } ",
        "focal_tgt": "@PrePersist@PreUpdate protected void onCreateOrUpdateCluster()throws GenieException { this.setClusterTags(this.getFinalTags()); } ",
        "focal_src": "@PostPersist@PostUpdate protected void onCreateOrUpdateCluster()throws GeniePreconditionException { this.addAndValidateSystemTags(this.tags); } ",
        "test_tgt": "@Test public void testOnCreateOrUpdateCluster()throws GenieException { this.c = new ClusterEntity(NAME, USER, VERSION, ClusterStatus.UP, CLUSTER_TYPE); Assert.assertNotNull(this.c.getTags()); Assert.assertTrue(this.c.getTags().isEmpty()); this.c.onCreateOrUpdateCluster(); Assert.assertEquals(2, this.c.getTags().size()); } "
    },
    {
        "test_src": "@Test public void testExecuteDMLUpdates()throws Exception { } ",
        "focal_tgt": "@Override protected void executeDMLUpdates()throws AmbariException, SQLException { removeNagiosService(); } ",
        "focal_src": "@Override protected void executeDMLUpdates()throws AmbariException, SQLException { } ",
        "test_tgt": "@Test public void testExecuteDMLUpdates()throws Exception { Method removeNagiosService = UpgradeCatalog200.class.getDeclaredMethod(\"removeNagiosService\"); UpgradeCatalog200 upgradeCatalog = createMockBuilder(UpgradeCatalog200.class).addMockedMethod(removeNagiosService).createMock(); upgradeCatalog.removeNagiosService(); expectLastCall().once(); replay(upgradeCatalog); upgradeCatalog.executeDMLUpdates(); verify(upgradeCatalog); } "
    },
    {
        "test_src": "@Test public void testCompile() { sut.activate(); List < Intent > compiled = sut.compile(intent, Collections.emptyList(), Collections.emptySet()); assertThat(compiled, hasSize(1)); Collection < FlowRule > rules = ((FlowRuleIntent)compiled.get(0)).flowRules(); FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get(); verifyIdAndPriority(rule1, d1p0.deviceId()); assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build())); assertThat(rule1.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d1p1.port()).build())); FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get(); verifyIdAndPriority(rule2, d2p0.deviceId()); assertThat(rule2.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d2p0.port()).build())); assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d2p1.port()).build())); FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get(); verifyIdAndPriority(rule3, d3p1.deviceId()); assertThat(rule3.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d3p1.port()).build())); assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder(treatment).setOutput(d3p0.port()).build())); sut.deactivate(); } ",
        "focal_tgt": "List < Intent > compile(T intent, List < Intent > installable); ",
        "focal_src": "List < Intent > compile(T intent, List < Intent > installable, Set < LinkResourceAllocations > resources); ",
        "test_tgt": "@Test public void testCompile() { sut.activate(); List < Intent > compiled = sut.compile(intent, Collections.emptyList()); assertThat(compiled, hasSize(1)); Collection < FlowRule > rules = ((FlowRuleIntent)compiled.get(0)).flowRules(); FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get(); verifyIdAndPriority(rule1, d1p0.deviceId()); assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build())); assertThat(rule1.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d1p1.port()).build())); FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get(); verifyIdAndPriority(rule2, d2p0.deviceId()); assertThat(rule2.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d2p0.port()).build())); assertThat(rule2.treatment(), is(DefaultTrafficTreatment.builder().setOutput(d2p1.port()).build())); FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get(); verifyIdAndPriority(rule3, d3p1.deviceId()); assertThat(rule3.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d3p1.port()).build())); assertThat(rule3.treatment(), is(DefaultTrafficTreatment.builder(treatment).setOutput(d3p0.port()).build())); sut.deactivate(); } "
    },
    {
        "test_src": "@Test public void testChooseClusterForJob()throws GenieException { final List < Cluster > clusters = this.service.chooseClusterForJob(JOB_1_ID); Assert.assertEquals(1, clusters.size()); Assert.assertEquals(CLUSTER_1_ID, clusters.get(0).getId()); final Job job = this.jobService.getJob(JOB_1_ID); final String chosen = job.getChosenClusterCriteriaString(); Assert.assertEquals(8, chosen.length()); Assert.assertTrue(chosen.contains(\"prod\")); Assert.assertTrue(chosen.contains(\"pig\")); Assert.assertTrue(chosen.contains(\",\")); } ",
        "focal_tgt": "@Override@Transactional public List < Cluster > chooseClusterForJob(@NotBlank(message = \"No job id entered. Unable to continue.\")final String jobId)throws GenieException { if(LOG.isDebugEnabled()) { LOG.debug(\"Called\"); } final JobEntity jobEntity = this.jobRepo.findOne(jobId); if(jobEntity == null) { throw new GenieNotFoundException(\"No job with id \" + jobId + \" exists. Unable to continue.\"); } final List < ClusterCriteria > clusterCriterias = jobEntity.getClusterCriterias(); final Set < String > commandCriteria = jobEntity.getCommandCriteria(); for(final ClusterCriteria clusterCriteria : clusterCriterias) { @SuppressWarnings(\"unchecked\")final List < ClusterEntity > clusterEntities = this.clusterRepo.findAll(ClusterSpecs.findByClusterAndCommandCriteria(clusterCriteria, commandCriteria)); if( ! clusterEntities.isEmpty()) { jobEntity.setChosenClusterCriteriaString(StringUtils.join(clusterCriteria.getTags(), CRITERIA_DELIMITER)); return clusterEntities.stream().map(ClusterEntity :: getDTO).collect(Collectors.toList()); } } return new ArrayList < > (); } ",
        "focal_src": "@Override@Transactional public List < Cluster > chooseClusterForJob(@NotBlank(message = \"No job id entered. Unable to continue.\")final String jobId)throws GenieException { if(LOG.isDebugEnabled()) { LOG.debug(\"Called\"); } final Job job = this.jobRepo.findOne(jobId); if(job == null) { throw new GenieNotFoundException(\"No job with id \" + jobId + \" exists. Unable to continue.\"); } final List < ClusterCriteria > clusterCriterias = job.getClusterCriterias(); final Set < String > commandCriteria = job.getCommandCriteria(); for(final ClusterCriteria clusterCriteria : clusterCriterias) { @SuppressWarnings(\"unchecked\")final List < com.netflix.genie.common.model.Cluster > clusters = this.clusterRepo.findAll(ClusterSpecs.findByClusterAndCommandCriteria(clusterCriteria, commandCriteria)); if( ! clusters.isEmpty()) { job.setChosenClusterCriteriaString(StringUtils.join(clusterCriteria.getTags(), CRITERIA_DELIMITER)); return clusters.stream().map(com.netflix.genie.common.model.Cluster :: getDTO).collect(Collectors.toList()); } } return new ArrayList < > (); } ",
        "test_tgt": "@Test public void testChooseClusterForJob()throws GenieException { final List < Cluster > clusters = this.service.chooseClusterForJob(JOB_1_ID); Assert.assertEquals(1, clusters.size()); Assert.assertEquals(CLUSTER_1_ID, clusters.get(0).getId()); final JobEntity jobEntity = this.jobRepository.findOne(JOB_1_ID); final String chosen = jobEntity.getChosenClusterCriteriaString(); Assert.assertEquals(8, chosen.length()); Assert.assertTrue(chosen.contains(\"prod\")); Assert.assertTrue(chosen.contains(\"pig\")); Assert.assertTrue(chosen.contains(\",\")); } "
    },
    {
        "test_src": "@Test public void getTraces_binaryAnnotationWithEmptyValue() { Span span = Span.builder().traceId(1).name(\"call1\").id(1).timestamp((today + 1) * 1000).addBinaryAnnotation(BinaryAnnotation.create(\"empty\", \"\", ep)).build(); accept(span); assertThat(store().getTraces((QueryRequest.builder().serviceName(\"service\").build()))).containsExactly(asList(span)); assertThat(store().getTrace(1L)).containsExactly(span); } ",
        "focal_tgt": "public List < List < Span > > getTraces() { return storage.spanStore().getTraces(QueryRequest.builder().limit(Integer.MAX_VALUE).build()); } ",
        "focal_src": "public List < List < Span > > getTraces() { List < Long > traceIds = storage.spanStore().traceIds(); List < List < Span > > result = new ArrayList < > (traceIds.size()); for(long traceId : traceIds) { result.add(storage.spanStore().getTrace(traceId)); } return result; } ",
        "test_tgt": "@Test public void getTraces_binaryAnnotationWithEmptyValue() { Span span = Span.builder().traceId(1).name(\"call1\").id(1).timestamp((today + 1) * 1000).addBinaryAnnotation(BinaryAnnotation.create(\"empty\", \"\", ep)).build(); accept(span); assertThat(store().getTraces((QueryRequest.builder().serviceName(\"service\").build()))).containsExactly(asList(span)); assertThat(store().getTrace(span.traceIdHigh, span.traceId)).containsExactly(span); } "
    },
    {
        "test_src": "@Test public void testParseCSVFile() { logger.info(\"parseCSVFile\"); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); LinkedHashMap < String, TypeInference.DataType > headerDataTypes = new LinkedHashMap < > (); headerDataTypes.put(\"city\", TypeInference.DataType.CATEGORICAL); headerDataTypes.put(\"temperature\", TypeInference.DataType.NUMERICAL); headerDataTypes.put(\"is_sunny\", TypeInference.DataType.BOOLEAN); headerDataTypes.put(\"traffic_rank\", TypeInference.DataType.ORDINAL); headerDataTypes.put(\"is_capital\", TypeInference.DataType.BOOLEAN); headerDataTypes.put(\"name_of_port\", TypeInference.DataType.CATEGORICAL); headerDataTypes.put(\"metro_population\", TypeInference.DataType.NUMERICAL); Dataframe dataset; try(Reader fileReader = new InputStreamReader(this.getClass().getClassLoader().getResourceAsStream(\"datasets/cities.csv\"), \"UTF-8\")) { dataset = Dataframe.Builder.parseCSVFile(fileReader, \"metro_population\", headerDataTypes, ',', '\"', \"\\r\\n\", null, null, dbConf); } catch(UncheckedIOException | IOException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } Dataframe expResult = new Dataframe(dbConf); AssociativeArray xData1 = new AssociativeArray(); xData1.put(\"city\", \"Athens\"); xData1.put(\"temperature\", 30.0); xData1.put(\"is_sunny\", true); xData1.put(\"traffic_rank\", (short)3); xData1.put(\"is_capital\", true); xData1.put(\"name_of_port\", \"Piraeus\"); expResult.add(new Record(xData1, 3753783.0)); AssociativeArray xData2 = new AssociativeArray(); xData2.put(\"city\", \"London\"); xData2.put(\"temperature\", 14.0); xData2.put(\"is_sunny\", false); xData2.put(\"traffic_rank\", (short)2); xData2.put(\"is_capital\", true); xData2.put(\"name_of_port\", \"Port of London\"); expResult.add(new Record(xData2, 13614409.0)); AssociativeArray xData3 = new AssociativeArray(); xData3.put(\"city\", \"New York\"); xData3.put(\"temperature\", - 12.0); xData3.put(\"is_sunny\", true); xData3.put(\"traffic_rank\", (short)1); xData3.put(\"is_capital\", false); xData3.put(\"name_of_port\", \"New York's port\"); expResult.add(new Record(xData3, null)); AssociativeArray xData4 = new AssociativeArray(); xData4.put(\"city\", \"Atlantis, \\\"the lost city\\\"\"); xData4.put(\"temperature\", null); xData4.put(\"is_sunny\", null); xData4.put(\"traffic_rank\", (short)4); xData4.put(\"is_capital\", null); xData4.put(\"name_of_port\", null); expResult.add(new Record(xData4, null)); Iterator < Record > it1 = expResult.iterator(); Iterator < Record > it2 = dataset.iterator(); while(it1.hasNext() && it2.hasNext()) { assertEquals(it1.next().equals(it2.next()), true); } assertEquals(it1.hasNext(), it2.hasNext()); assertEquals(expResult.getYDataType(), dataset.getYDataType()); assertEquals(expResult.getXDataTypes().equals(dataset.getXDataTypes()), true); expResult.delete(); dataset.delete(); } ",
        "focal_tgt": "public static Dataframe parseCSVFile(Reader reader, String yVariable, LinkedHashMap < String, TypeInference.DataType > headerDataTypes, char delimiter, char quote, String recordSeparator, Long skip, Long limit, Configuration conf) { Logger logger = LoggerFactory.getLogger(Dataframe.Builder.class); if(skip == null) { skip = 0L; } if(limit == null) { limit = Long.MAX_VALUE; } logger.info(\"Parsing CSV file\"); if( ! headerDataTypes.containsKey(yVariable)) { logger.warn(\"WARNING: The file is missing the response variable column {}.\", yVariable); } TypeInference.DataType yDataType = headerDataTypes.get(yVariable); Map < String, TypeInference.DataType > xDataTypes = new HashMap < > (headerDataTypes); xDataTypes.remove(yVariable); Dataframe dataset = new Dataframe(conf, yDataType, xDataTypes); CSVFormat format = CSVFormat.RFC4180.withHeader().withDelimiter(delimiter).withQuote(quote).withRecordSeparator(recordSeparator); try(final CSVParser parser = new CSVParser(reader, format)) { ThreadMethods.throttledExecution(StreamMethods.enumerate(StreamMethods.stream(parser.spliterator(), false)).skip(skip).limit(limit), e -> { Integer rId = e.getKey(); CSVRecord row = e.getValue(); if( ! row.isConsistent()) { logger.warn(\"WARNING: Skipping row {} because its size does not match the header size.\", row.getRecordNumber()); } else { Object y = null; AssociativeArray xData = new AssociativeArray(); for(Map.Entry < String, TypeInference.DataType > entry : headerDataTypes.entrySet()) { String column = entry.getKey(); TypeInference.DataType dataType = entry.getValue(); Object value = TypeInference.DataType.parse(row.get(column), dataType); if(yVariable != null && yVariable.equals(column)) { y = value; } else { xData.put(column, value); } } Record r = new Record(xData, y); if(SynchronizedBlocks.WITHOUT_SYNCHRONIZED.isActivated()) { dataset._unsafe_set(rId, r); } else { synchronized(dataset) { dataset._unsafe_set(rId, r); } } } }, conf.getConcurrencyConfig()); } catch(IOException ex) { throw new RuntimeException(ex); } return dataset; } ",
        "focal_src": "public static Dataframe parseCSVFile(Reader reader, String yVariable, LinkedHashMap < String, TypeInference.DataType > headerDataTypes, char delimiter, char quote, String recordSeparator, Long skip, Long limit, DatabaseConfiguration dbConf) { Logger logger = LoggerFactory.getLogger(Dataframe.Builder.class); if(skip == null) { skip = 0L; } if(limit == null) { limit = Long.MAX_VALUE; } logger.info(\"Parsing CSV file\"); if( ! headerDataTypes.containsKey(yVariable)) { logger.warn(\"WARNING: The file is missing the response variable column {}.\", yVariable); } TypeInference.DataType yDataType = headerDataTypes.get(yVariable); Map < String, TypeInference.DataType > xDataTypes = new HashMap < > (headerDataTypes); xDataTypes.remove(yVariable); Dataframe dataset = new Dataframe(dbConf, yDataType, xDataTypes); CSVFormat format = CSVFormat.RFC4180.withHeader().withDelimiter(delimiter).withQuote(quote).withRecordSeparator(recordSeparator); try(final CSVParser parser = new CSVParser(reader, format)) { ThreadMethods.throttledExecution(StreamMethods.enumerate(StreamMethods.stream(parser.spliterator(), false)).skip(skip).limit(limit), e -> { Integer rId = e.getKey(); CSVRecord row = e.getValue(); if( ! row.isConsistent()) { logger.warn(\"WARNING: Skipping row {} because its size does not match the header size.\", row.getRecordNumber()); } else { Object y = null; AssociativeArray xData = new AssociativeArray(); for(Map.Entry < String, TypeInference.DataType > entry : headerDataTypes.entrySet()) { String column = entry.getKey(); TypeInference.DataType dataType = entry.getValue(); Object value = TypeInference.DataType.parse(row.get(column), dataType); if(yVariable != null && yVariable.equals(column)) { y = value; } else { xData.put(column, value); } } Record r = new Record(xData, y); if(SynchronizedBlocks.WITHOUT_SYNCHRONIZED.isActivated()) { dataset._unsafe_set(rId, r); } else { synchronized(dataset) { dataset._unsafe_set(rId, r); } } } }); } catch(IOException ex) { throw new RuntimeException(ex); } return dataset; } ",
        "test_tgt": "@Test public void testParseCSVFile() { logger.info(\"parseCSVFile\"); Configuration conf = TestUtils.getConfig(); LinkedHashMap < String, TypeInference.DataType > headerDataTypes = new LinkedHashMap < > (); headerDataTypes.put(\"city\", TypeInference.DataType.CATEGORICAL); headerDataTypes.put(\"temperature\", TypeInference.DataType.NUMERICAL); headerDataTypes.put(\"is_sunny\", TypeInference.DataType.BOOLEAN); headerDataTypes.put(\"traffic_rank\", TypeInference.DataType.ORDINAL); headerDataTypes.put(\"is_capital\", TypeInference.DataType.BOOLEAN); headerDataTypes.put(\"name_of_port\", TypeInference.DataType.CATEGORICAL); headerDataTypes.put(\"metro_population\", TypeInference.DataType.NUMERICAL); Dataframe dataset; try(Reader fileReader = new InputStreamReader(this.getClass().getClassLoader().getResourceAsStream(\"datasets/cities.csv\"), \"UTF-8\")) { dataset = Dataframe.Builder.parseCSVFile(fileReader, \"metro_population\", headerDataTypes, ',', '\"', \"\\r\\n\", null, null, conf); } catch(UncheckedIOException | IOException ex) { logger.warn(\"Unable to download datasets, skipping test.\"); throw new RuntimeException(ex); } Dataframe expResult = new Dataframe(conf); AssociativeArray xData1 = new AssociativeArray(); xData1.put(\"city\", \"Athens\"); xData1.put(\"temperature\", 30.0); xData1.put(\"is_sunny\", true); xData1.put(\"traffic_rank\", (short)3); xData1.put(\"is_capital\", true); xData1.put(\"name_of_port\", \"Piraeus\"); expResult.add(new Record(xData1, 3753783.0)); AssociativeArray xData2 = new AssociativeArray(); xData2.put(\"city\", \"London\"); xData2.put(\"temperature\", 14.0); xData2.put(\"is_sunny\", false); xData2.put(\"traffic_rank\", (short)2); xData2.put(\"is_capital\", true); xData2.put(\"name_of_port\", \"Port of London\"); expResult.add(new Record(xData2, 13614409.0)); AssociativeArray xData3 = new AssociativeArray(); xData3.put(\"city\", \"New York\"); xData3.put(\"temperature\", - 12.0); xData3.put(\"is_sunny\", true); xData3.put(\"traffic_rank\", (short)1); xData3.put(\"is_capital\", false); xData3.put(\"name_of_port\", \"New York's port\"); expResult.add(new Record(xData3, null)); AssociativeArray xData4 = new AssociativeArray(); xData4.put(\"city\", \"Atlantis, \\\"the lost city\\\"\"); xData4.put(\"temperature\", null); xData4.put(\"is_sunny\", null); xData4.put(\"traffic_rank\", (short)4); xData4.put(\"is_capital\", null); xData4.put(\"name_of_port\", null); expResult.add(new Record(xData4, null)); Iterator < Record > it1 = expResult.iterator(); Iterator < Record > it2 = dataset.iterator(); while(it1.hasNext() && it2.hasNext()) { assertEquals(it1.next().equals(it2.next()), true); } assertEquals(it1.hasNext(), it2.hasNext()); assertEquals(expResult.getYDataType(), dataset.getYDataType()); assertEquals(expResult.getXDataTypes().equals(dataset.getXDataTypes()), true); expResult.delete(); dataset.delete(); } "
    },
    {
        "test_src": "@TestTargetNew(level = TestLevel.PARTIAL_COMPLETE, notes = \"\", method = \"read\", args = { })public void test_read()throws Exception { pis = new PipedInputStream(); pos = new PipedOutputStream(); try { pis.read(); fail(\"Test 1: IOException expected since the stream is not connected.\"); } catch(IOException e) { } pis.connect(pos); t = new Thread(pw = new PWriter(pos, 100)); t.start(); synchronized(pw) { pw.wait(5000); } assertEquals(\"Test 2: Unexpected number of bytes available. \", 100, pis.available()); for(int i = 0; i < 100; i ++ ) { assertEquals(\"Test 3: read() returned incorrect byte. \", pw.bytes[i], (byte)pis.read()); } try { pis.read(); fail(\"Test 4: IOException expected since the thread that has \" + \"written to the pipe is no longer alive.\"); } catch(IOException e) { } pis.close(); try { pis.read(); fail(\"Test 5: IOException expected since the stream is closed.\"); } catch(IOException e) { } } ",
        "focal_tgt": "@Override public int read(byte[]buffer, int offset, int length)throws IOException { if(mEntry != null) { return - 1; } int r = super.read(buffer, offset, length); if(verStream != null && ! eos) { if(r == - 1) { eos = true; if(verifier != null) { if(isMeta) { verifier.addMetaEntry(jarEntry.getName(), ((ByteArrayOutputStream)verStream).toByteArray()); try { verifier.readCertificates(); } catch(SecurityException e) { verifier = null; throw e; } } else { ((JarVerifier.VerifierEntry)verStream).verify(); } } } else { verStream.write(buffer, offset, r); } } return r; } ",
        "focal_src": "@Override public int read(byte[]buffer, int offset, int length)throws IOException { if(mEntry != null) { return - 1; } int r = super.read(buffer, offset, length); if(verStream != null && ! eos) { if(r == - 1) { eos = true; if(verifier != null) { if(isMeta) { verifier.addMetaEntry(jarEntry.getName(), ((ByteArrayOutputStream)verStream).toByteArray()); try { verifier.readCertificates(); } catch(SecurityException e) { verifier = null; throw e; } } else { verifier.verifySignatures((JarVerifier.VerifierEntry)verStream, jarEntry); } } } else { verStream.write(buffer, offset, r); } } return r; } ",
        "test_tgt": "@TestTargetNew(level = TestLevel.PARTIAL_COMPLETE, notes = \"\", method = \"read\", args = { })public void test_read()throws Exception { pis = new PipedInputStream(); pos = new PipedOutputStream(); try { pis.read(); fail(\"Test 1: IOException expected since the stream is not connected.\"); } catch(IOException e) { } pis.connect(pos); t = new Thread(pw = new PWriter(pos, 100)); t.start(); synchronized(pw) { pw.wait(5000); } assertEquals(\"Test 2: Unexpected number of bytes available. \", 100, pis.available()); for(int i = 0; i < 100; i ++ ) { assertEquals(\"Test 3: read() returned incorrect byte. \", pw.bytes[i], (byte)pis.read()); } try { pis.read(); fail(\"Test 4: IOException expected since the thread that has \" + \"written to the pipe is no longer alive.\"); } catch(IOException e) { } pis.close(); try { pis.read(); fail(\"Test 5: IOException expected since the stream is closed.\"); } catch(IOException e) { } } "
    },
    {
        "test_src": "@Test public void test_projectGeoPoint_2() { final int latE6 = 52370816; final int lonE6 = 9735936; final int zoom = 8; final GeoPoint point = Mercator.projectGeoPoint(latE6, lonE6, zoom, null); assertEquals(\"TODO describe test\", 84, point.getLatitudeE6()); assertEquals(\"TODO describe test\", 134, point.getLongitudeE6()); } ",
        "focal_tgt": "public static Point projectGeoPoint(final double aLat, final double aLon, final int aZoom, final Point aUseAsReturnValue) { final Point p = aUseAsReturnValue != null ? aUseAsReturnValue : new Point(0, 0); p.x = ((int)Math.floor((aLon + 180) / 360 * (1 << aZoom))); p.y = ((int)Math.floor((1 - Math.log(Math.tan(aLat * DEG2RAD) + 1 / Math.cos(aLat * DEG2RAD)) / Math.PI) / 2 * (1 << aZoom))); return p; } ",
        "focal_src": "public static GeoPoint projectGeoPoint(final double aLat, final double aLon, final int aZoom, final GeoPoint aUseAsReturnValue) { final GeoPoint out = aUseAsReturnValue != null ? aUseAsReturnValue : new GeoPoint(0, 0); out.setLongitudeE6((int)Math.floor((aLon + 180) / 360 * (1 << aZoom))); out.setLatitudeE6((int)Math.floor((1 - Math.log(Math.tan(aLat * DEG2RAD) + 1 / Math.cos(aLat * DEG2RAD)) / Math.PI) / 2 * (1 << aZoom))); return out; } ",
        "test_tgt": "@Test public void test_projectGeoPoint_2() { final int latE6 = 52370816; final int lonE6 = 9735936; final int zoom = 8; final Point point = Mercator.projectGeoPoint(latE6, lonE6, zoom, null); assertEquals(\"TODO describe test\", 84, point.y); assertEquals(\"TODO describe test\", 134, point.x); } "
    },
    {
        "test_src": "@Test public void testGenerateHistogramSkeleton()throws Exception { DateTime from = parseDate(\"2015-01-01T00:00:00Z\"); DateTime to = parseDate(\"2015-01-10T00:00:00Z\"); UsageHistogramBean histogram = new UsageHistogramBean(); Map < String, UsageDataPoint > index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, UsageHistogramIntervalType.day); Assert.assertEquals(9, index.size()); Assert.assertEquals(9, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-01-03T00:00:00.000Z\", histogram.getData().get(2).getLabel()); Assert.assertEquals(\"2015-01-07T00:00:00.000Z\", histogram.getData().get(6).getLabel()); from = parseDate(\"2015-01-01T00:00:00Z\"); to = parseDate(\"2015-01-03T00:00:00Z\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, UsageHistogramIntervalType.hour); Assert.assertEquals(48, index.size()); Assert.assertEquals(48, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-01-01T02:00:00.000Z\", histogram.getData().get(2).getLabel()); Assert.assertEquals(\"2015-01-01T06:00:00.000Z\", histogram.getData().get(6).getLabel()); Assert.assertEquals(\"2015-01-02T18:00:00.000Z\", histogram.getData().get(42).getLabel()); from = parseDate(\"2015-01-01\"); to = parseDate(\"2015-01-03\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, UsageHistogramIntervalType.hour); Assert.assertEquals(48, index.size()); Assert.assertEquals(48, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-01-01T02:00:00.000Z\", histogram.getData().get(2).getLabel()); Assert.assertEquals(\"2015-01-01T06:00:00.000Z\", histogram.getData().get(6).getLabel()); Assert.assertEquals(\"2015-01-02T18:00:00.000Z\", histogram.getData().get(42).getLabel()); from = parseDate(\"2015-01-01T00:00:00Z\"); to = parseDate(\"2015-01-02T00:00:00Z\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, UsageHistogramIntervalType.minute); Assert.assertEquals(1440, index.size()); Assert.assertEquals(1440, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-01-01T00:20:00.000Z\", histogram.getData().get(20).getLabel()); Assert.assertEquals(\"2015-01-01T00:30:00.000Z\", histogram.getData().get(30).getLabel()); from = parseDate(\"2015-01-01\"); to = parseDate(\"2015-12-31\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, UsageHistogramIntervalType.month); Assert.assertEquals(12, index.size()); Assert.assertEquals(12, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-06-01T00:00:00.000Z\", histogram.getData().get(5).getLabel()); System.out.println(\"--------------------------------\"); from = parseDate(\"2015-01-01\"); to = parseDate(\"2015-12-30\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, UsageHistogramIntervalType.week); Assert.assertEquals(53, index.size()); Assert.assertEquals(53, histogram.getData().size()); Assert.assertEquals(\"2014-12-28T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-02-01T00:00:00.000Z\", histogram.getData().get(5).getLabel()); Assert.assertEquals(\"2015-04-12T00:00:00.000Z\", histogram.getData().get(15).getLabel()); } ",
        "focal_tgt": "public static < T extends HistogramDataPoint > Map < String, T > generateHistogramSkeleton(HistogramBean < T > rval, DateTime from, DateTime to, HistogramIntervalType interval, Class < T > dataType) { Map < String, T > index = new HashMap < > (); Calendar fromCal = from.toGregorianCalendar(); Calendar toCal = to.toGregorianCalendar(); switch(interval) { case day : fromCal.set(Calendar.HOUR_OF_DAY, 0); fromCal.set(Calendar.MINUTE, 0); fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; case hour : fromCal.set(Calendar.MINUTE, 0); fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; case minute : fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; case month : fromCal.set(Calendar.DAY_OF_MONTH, 1); fromCal.set(Calendar.HOUR_OF_DAY, 0); fromCal.set(Calendar.MINUTE, 0); fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; case week : fromCal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY); fromCal.set(Calendar.HOUR_OF_DAY, 0); fromCal.set(Calendar.MINUTE, 0); fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; default : break; } while(fromCal.before(toCal)) { String label = formatDateWithMillis(fromCal); T point; try { point = dataType.newInstance(); } catch(InstantiationException | IllegalAccessException e) { throw new RuntimeException(e); } point.setLabel(label); rval.addDataPoint(point); index.put(label, point); switch(interval) { case day : fromCal.add(Calendar.DAY_OF_YEAR, 1); break; case hour : fromCal.add(Calendar.HOUR_OF_DAY, 1); break; case minute : fromCal.add(Calendar.MINUTE, 1); break; case month : fromCal.add(Calendar.MONTH, 1); break; case week : fromCal.add(Calendar.WEEK_OF_YEAR, 1); break; default : break; } } return index; } ",
        "focal_src": "public static Map < String, UsageDataPoint > generateHistogramSkeleton(UsageHistogramBean rval, DateTime from, DateTime to, UsageHistogramIntervalType interval) { Map < String, UsageDataPoint > index = new HashMap < > (); Calendar fromCal = from.toGregorianCalendar(); Calendar toCal = to.toGregorianCalendar(); switch(interval) { case day : fromCal.set(Calendar.HOUR_OF_DAY, 0); fromCal.set(Calendar.MINUTE, 0); fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; case hour : fromCal.set(Calendar.MINUTE, 0); fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; case minute : fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; case month : fromCal.set(Calendar.DAY_OF_MONTH, 1); fromCal.set(Calendar.HOUR_OF_DAY, 0); fromCal.set(Calendar.MINUTE, 0); fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; case week : fromCal.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY); fromCal.set(Calendar.HOUR_OF_DAY, 0); fromCal.set(Calendar.MINUTE, 0); fromCal.set(Calendar.SECOND, 0); fromCal.set(Calendar.MILLISECOND, 0); break; default : break; } while(fromCal.before(toCal)) { String label = formatDateWithMillis(fromCal); UsageDataPoint point = new UsageDataPoint(label, 0L); rval.getData().add(point); index.put(label, point); switch(interval) { case day : fromCal.add(Calendar.DAY_OF_YEAR, 1); break; case hour : fromCal.add(Calendar.HOUR_OF_DAY, 1); break; case minute : fromCal.add(Calendar.MINUTE, 1); break; case month : fromCal.add(Calendar.MONTH, 1); break; case week : fromCal.add(Calendar.WEEK_OF_YEAR, 1); break; default : break; } } return index; } ",
        "test_tgt": "@Test public void testGenerateHistogramSkeleton()throws Exception { DateTime from = parseDate(\"2015-01-01T00:00:00Z\"); DateTime to = parseDate(\"2015-01-10T00:00:00Z\"); UsageHistogramBean histogram = new UsageHistogramBean(); Map < String, UsageDataPoint > index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, HistogramIntervalType.day, UsageDataPoint.class); Assert.assertEquals(9, index.size()); Assert.assertEquals(9, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-01-03T00:00:00.000Z\", histogram.getData().get(2).getLabel()); Assert.assertEquals(\"2015-01-07T00:00:00.000Z\", histogram.getData().get(6).getLabel()); from = parseDate(\"2015-01-01T00:00:00Z\"); to = parseDate(\"2015-01-03T00:00:00Z\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, HistogramIntervalType.hour, UsageDataPoint.class); Assert.assertEquals(48, index.size()); Assert.assertEquals(48, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-01-01T02:00:00.000Z\", histogram.getData().get(2).getLabel()); Assert.assertEquals(\"2015-01-01T06:00:00.000Z\", histogram.getData().get(6).getLabel()); Assert.assertEquals(\"2015-01-02T18:00:00.000Z\", histogram.getData().get(42).getLabel()); from = parseDate(\"2015-01-01\"); to = parseDate(\"2015-01-03\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, HistogramIntervalType.hour, UsageDataPoint.class); Assert.assertEquals(48, index.size()); Assert.assertEquals(48, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-01-01T02:00:00.000Z\", histogram.getData().get(2).getLabel()); Assert.assertEquals(\"2015-01-01T06:00:00.000Z\", histogram.getData().get(6).getLabel()); Assert.assertEquals(\"2015-01-02T18:00:00.000Z\", histogram.getData().get(42).getLabel()); from = parseDate(\"2015-01-01T00:00:00Z\"); to = parseDate(\"2015-01-02T00:00:00Z\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, HistogramIntervalType.minute, UsageDataPoint.class); Assert.assertEquals(1440, index.size()); Assert.assertEquals(1440, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-01-01T00:20:00.000Z\", histogram.getData().get(20).getLabel()); Assert.assertEquals(\"2015-01-01T00:30:00.000Z\", histogram.getData().get(30).getLabel()); from = parseDate(\"2015-01-01\"); to = parseDate(\"2015-12-31\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, HistogramIntervalType.month, UsageDataPoint.class); Assert.assertEquals(12, index.size()); Assert.assertEquals(12, histogram.getData().size()); Assert.assertEquals(\"2015-01-01T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-06-01T00:00:00.000Z\", histogram.getData().get(5).getLabel()); System.out.println(\"--------------------------------\"); from = parseDate(\"2015-01-01\"); to = parseDate(\"2015-12-30\"); histogram = new UsageHistogramBean(); index = ESMetricsAccessor.generateHistogramSkeleton(histogram, from, to, HistogramIntervalType.week, UsageDataPoint.class); Assert.assertEquals(53, index.size()); Assert.assertEquals(53, histogram.getData().size()); Assert.assertEquals(\"2014-12-28T00:00:00.000Z\", histogram.getData().get(0).getLabel()); Assert.assertEquals(\"2015-02-01T00:00:00.000Z\", histogram.getData().get(5).getLabel()); Assert.assertEquals(\"2015-04-12T00:00:00.000Z\", histogram.getData().get(15).getLabel()); } "
    },
    {
        "test_src": "@Test public void eval() { query(_XQUERY_EVAL.args(\"1\"), 1); query(_XQUERY_EVAL.args(\"1 + 2\"), 3); query(_XQUERY_EVAL.args(\"\\\"$a\\\"\", \" { '$a' : 'b' }\"), \"b\"); query(_XQUERY_EVAL.args(\"\\\"$a\\\"\", \" { 'a' : 'b' }\"), \"b\"); query(_XQUERY_EVAL.args(\"\\\"$a\\\"\", \" { 'a' : (1,2) }\"), \"1 2\"); query(_XQUERY_EVAL.args(\"\\\"declare variable $local:a external;$local:a\\\"\", \" { xs:QName('local:a') : 1 }\"), \"1\"); query(_XQUERY_EVAL.args(\".\", \" { '' : 1 }\"), \"1\"); error(_XQUERY_EVAL.args(\"1+\"), Err.CALCEXPR); error(\"declare variable $a:=1;\" + _XQUERY_EVAL.args(\"\\\"$a\\\"\"), Err.VARUNDEF); error(\"for $a in (1,2) return \" + _XQUERY_EVAL.args(\"\\\"$a\\\"\"), Err.VARUNDEF); error(_XQUERY_EVAL.args(\"delete node ()\"), Err.BXXQ_UPDATING); error(_XQUERY_EVAL.args(\"declare %updating function local:x() {()}; local:x()\"), Err.BXXQ_UPDATING); query(_XQUERY_EVAL.args(\"declare %updating function local:x() {()}; 1\")); } ",
        "focal_tgt": "private ValueBuilder eval(final QueryContext ctx, final boolean openDB)throws QueryException { return eval(ctx, checkStr(expr[0], ctx), null, openDB); } ",
        "focal_src": "private ValueBuilder eval(final QueryContext ctx)throws QueryException { return eval(ctx, checkStr(expr[0], ctx), null); } ",
        "test_tgt": "@Test public void eval() { query(_XQUERY_EVAL.args(\"1\"), 1); query(_XQUERY_EVAL.args(\"1 + 2\"), 3); query(_XQUERY_EVAL.args(\"\\\"$a\\\"\", \" { '$a' : 'b' }\"), \"b\"); query(_XQUERY_EVAL.args(\"\\\"$a\\\"\", \" { 'a' : 'b' }\"), \"b\"); query(_XQUERY_EVAL.args(\"\\\"$a\\\"\", \" { 'a' : (1,2) }\"), \"1 2\"); query(_XQUERY_EVAL.args(\"\\\"declare variable $local:a external;$local:a\\\"\", \" { xs:QName('local:a') : 1 }\"), \"1\"); query(_XQUERY_EVAL.args(\".\", \" { '' : 1 }\"), \"1\"); error(_XQUERY_EVAL.args(\"1+\"), Err.CALCEXPR); error(\"declare variable $a:=1;\" + _XQUERY_EVAL.args(\"\\\"$a\\\"\"), Err.VARUNDEF); error(\"for $a in (1,2) return \" + _XQUERY_EVAL.args(\"\\\"$a\\\"\"), Err.VARUNDEF); error(_XQUERY_EVAL.args(\"delete node ()\"), Err.BXXQ_UPDATING); error(_XQUERY_EVAL.args(\"declare %updating function local:x() {()}; local:x()\"), Err.BXXQ_UPDATING); query(_XQUERY_EVAL.args(\"declare %updating function local:x() {()}; 1\")); query(_XQUERY_EVAL.args(\"\\\"\" + DOC.args(PATH).replace('\"', '\\'') + \"\\\"\")); } "
    },
    {
        "test_src": "@Test public void testSetCovariance() { System.out.println(\"setCovariance\"); NormalM normalM = new NormalM(mean, covariance); Matrix t1 = Matrix.eye(3); Matrix t2 = new DenseMatrix(2, 3); Matrix t3 = new DenseMatrix(3, 2); Matrix[]shouldFail = new Matrix[] { t1, t2, t3 }; for(Matrix badMatrix : shouldFail)try { normalM.setCovariance(badMatrix); fail(\"Matrix was invalid, should have caused an exception\"); } catch(ArithmeticException ex) { } } ",
        "focal_tgt": "public void setCovariance(Matrix covMatrix) { if( ! covMatrix.isSquare())throw new ArithmeticException(\"Covariance matrix must be square\"); else if(covMatrix.rows() != this.mean.length())throw new ArithmeticException(\"Covariance matrix does not agree with the mean\"); CholeskyDecomposition cd = new CholeskyDecomposition(covMatrix.clone()); System.out.println(); L = cd.getLT(); L.mutableTranspose(); log_det = cd.getLogDet(); int k = mean.length(); if(Double.isNaN(log_det) || log_det < log(1e-10)) { SingularValueDecomposition svd = new SingularValueDecomposition(covMatrix.clone()); this.logPDFConst = 0.5 * log(svd.getPseudoDet()) + svd.getRank() * 0.5 * log(2 * PI); this.invCovariance = svd.getPseudoInverse(); } else { this.logPDFConst = ( - k * log(2 * PI) - log_det) * 0.5; this.invCovariance = cd.solve(Matrix.eye(k)); } this.invCov_diag = null; this.L_diag = null; } ",
        "focal_src": "public void setCovariance(Matrix covMatrix) { if( ! covMatrix.isSquare())throw new ArithmeticException(\"Covariance matrix must be square\"); else if(covMatrix.rows() != this.mean.length())throw new ArithmeticException(\"Covariance matrix does not agree with the mean\"); CholeskyDecomposition cd = new CholeskyDecomposition(covMatrix.clone()); L = cd.getLT(); L.mutableTranspose(); int k = mean.length(); if(Double.isNaN(log_det) || log_det < log(1e-10)) { SingularValueDecomposition svd = new SingularValueDecomposition(covMatrix.clone()); this.logPDFConst = 0.5 * log(svd.getPseudoDet()) + svd.getRank() * 0.5 * log(2 * PI); this.invCovariance = svd.getPseudoInverse(); } else { this.logPDFConst = ( - k * log(2 * PI) - log_det) * 0.5; this.invCovariance = cd.solve(Matrix.eye(k)); } } ",
        "test_tgt": "@Test public void testSetCovariance() { System.out.println(\"setCovariance\"); NormalM normalM = new NormalM(mean, covariance); Matrix t1 = Matrix.eye(3); Matrix t2 = new DenseMatrix(2, 3); Matrix t3 = new DenseMatrix(3, 2); Matrix[]shouldFail = new Matrix[] { t1, t2, t3 }; for(Matrix badMatrix : shouldFail)try { normalM.setCovariance(badMatrix); fail(\"Matrix was invalid, should have caused an exception\"); } catch(ArithmeticException ex) { } } "
    },
    {
        "test_src": "@Test public void connect() { query(conn()); query(EXISTS.args(' ' + conn())); error(_CLIENT_CONNECT.args(Text.S_LOCALHOST, 9999, ADMIN, \"\"), BXCL_CONN_X); error(_CLIENT_CONNECT.args(\"xxx\", 9999, ADMIN, ADMIN), BXCL_CONN_X); } ",
        "focal_tgt": "private HttpURLConnection connect(final String url, final HttpRequest request)throws QueryException, IOException { HttpURLConnection conn = connection(url, request); final String user = request.attribute(USERNAME), pass = request.attribute(PASSWORD); if(user != null) { if(request.authMethod == AuthMethod.BASIC) { conn.setRequestProperty(AUTHORIZATION, BASIC + ' ' + org.basex.util.Base64.encode(user + ':' + pass)); } else { conn.setRequestProperty(AUTHORIZATION, DIGEST); final EnumMap < Request, String > map = digestHeaders(conn.getHeaderField(WWW_AUTHENTICATE)); final String realm = map.get(REALM), nonce = map.get(NONCE), qop = map.get(QOP), opaque = map.get(OPAQUE), cnonce = Strings.md5(Long.toString(System.nanoTime())), nc = \"00000001\", uri = conn.getURL().getPath(), ha1 = Strings.md5(user + ':' + realm + ':' + pass), ha2 = Strings.md5(request.attribute(METHOD) + ':' + uri), rsp = Strings.md5(ha1 + ':' + nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2), creds = USERNAME + \"=\" + user + ',' + REALM + '=' + realm + ',' + NONCE + '=' + nonce + ',' + URI + '=' + uri + ',' + QOP + '=' + qop + ',' + NC + '=' + nc + ',' + CNONCE + '=' + cnonce + ',' + RESPONSE + '=' + rsp + ',' + OPAQUE + '=' + opaque; conn.disconnect(); conn = connection(url, request); conn.setRequestProperty(AUTHORIZATION, DIGEST + ' ' + creds); } } return conn; } ",
        "focal_src": "private HttpURLConnection connect(final String url, final HttpRequest request)throws QueryException, IOException { final HttpURLConnection conn = connection(url, request); if(request != null) { final byte[]sendAuth = request.attrs.get(SEND_AUTHORIZATION); if(sendAuth != null && Bln.parse(sendAuth, info)) { final String user = string(request.attrs.get(USERNAME)); final String pass = string(request.attrs.get(PASSWORD)); conn.setRequestProperty(AUTHORIZATION, BASIC + ' ' + org.basex.util.Base64.encode(user + ':' + pass)); } } return conn; } ",
        "test_tgt": "@Test public void connect() { query(conn()); query(EXISTS.args(' ' + conn())); error(_CLIENT_CONNECT.args(Text.S_LOCALHOST, DB_PORT, ADMIN, \"\"), BXCL_CONN_X); error(_CLIENT_CONNECT.args(\"xxx\", DB_PORT, ADMIN, ADMIN), BXCL_CONN_X); } "
    },
    {
        "test_src": "@Test public void rename()throws Exception { for(int i = 0; i < 10; i ++ ) { mFileSystem.createDirectory(new AlluxioURI(\"/i\" + i)); for(int j = 0; j < 10; j ++ ) { CreateFileOptions option = CreateFileOptions.defaults().setBlockSizeBytes((i + j + 1) * 64); AlluxioURI path = new AlluxioURI(\"/i\" + i + \"/j\" + j); mFileSystem.createFile(path, option).close(); mFileSystem.rename(path, new AlluxioURI(\"/i\" + i + \"/jj\" + j)); } mFileSystem.rename(new AlluxioURI(\"/i\" + i), new AlluxioURI(\"/ii\" + i)); } mLocalAlluxioCluster.stopFS(); renameTestUtil(); deleteFsMasterJournalLogs(); renameTestUtil(); } ",
        "focal_tgt": "void rename(AlluxioURI src, AlluxioURI dst, RenamePOptions options)throws FileDoesNotExistException, IOException, AlluxioException; ",
        "focal_src": "void rename(AlluxioURI src, AlluxioURI dst, RenameOptions options)throws FileDoesNotExistException, IOException, AlluxioException; ",
        "test_tgt": "@Test public void rename()throws Exception { for(int i = 0; i < 10; i ++ ) { mFileSystem.createDirectory(new AlluxioURI(\"/i\" + i)); for(int j = 0; j < 10; j ++ ) { CreateFilePOptions option = CreateFilePOptions.newBuilder().setBlockSizeBytes((i + j + 1) * 64).build(); AlluxioURI path = new AlluxioURI(\"/i\" + i + \"/j\" + j); mFileSystem.createFile(path, option).close(); mFileSystem.rename(path, new AlluxioURI(\"/i\" + i + \"/jj\" + j)); } mFileSystem.rename(new AlluxioURI(\"/i\" + i), new AlluxioURI(\"/ii\" + i)); } mLocalAlluxioCluster.stopFS(); renameTestUtil(); deleteFsMasterJournalLogs(); renameTestUtil(); } "
    },
    {
        "test_src": "@Test public void createSession() { when(reactor.process()).thenReturn(true); when(reactor.connectionToHost(connectionHandler.getHostname(), connectionHandler.getProtocolPort(), connectionHandler)).thenReturn(connectionProtonJ); when(connectionProtonJ.session()).thenReturn(session); when(session.attachments()).thenReturn(record); StepVerifier.create(connection.createSession(SESSION_NAME)).assertNext(s -> { Assert.assertNotNull(s); Assert.assertEquals(SESSION_NAME, s.getSessionName()); Assert.assertTrue(s instanceof ReactorSession); Assert.assertSame(session, ((ReactorSession)s).session()); }).verifyComplete(); StepVerifier.create(connection.createSession(SESSION_NAME)).assertNext(s -> { Assert.assertNotNull(s); Assert.assertEquals(SESSION_NAME, s.getSessionName()); Assert.assertTrue(s instanceof ReactorSession); Assert.assertSame(session, ((ReactorSession)s).session()); }).verifyComplete(); verify(record, Mockito.times(1)).set(Handler.class, Handler.class, sessionHandler); } ",
        "focal_tgt": "protected AmqpSession createSession(String sessionName, Session session, SessionHandler handler) { return new ReactorSession(session, handler, sessionName, reactorProvider, handlerProvider, getCBSNode(), tokenManagerProvider, messageSerializer, connectionOptions.getRetry().getTryTimeout()); } ",
        "focal_src": "protected AmqpSession createSession(String sessionName, Session session, SessionHandler handler) { return new ReactorSession(session, handler, sessionName, reactorProvider, handlerProvider, getCBSNode(), tokenManagerProvider, connectionOptions.getRetry().getTryTimeout()); } ",
        "test_tgt": "@Test public void createSession() { when(reactor.process()).thenReturn(true); when(reactor.connectionToHost(connectionHandler.getHostname(), connectionHandler.getProtocolPort(), connectionHandler)).thenReturn(connectionProtonJ); when(connectionProtonJ.session()).thenReturn(session); when(session.attachments()).thenReturn(record); StepVerifier.create(connection.createSession(SESSION_NAME)).assertNext(s -> { Assert.assertNotNull(s); Assert.assertEquals(SESSION_NAME, s.getSessionName()); Assert.assertTrue(s instanceof ReactorSession); Assert.assertSame(session, ((ReactorSession)s).session()); }).verifyComplete(); StepVerifier.create(connection.createSession(SESSION_NAME)).assertNext(s -> { Assert.assertNotNull(s); Assert.assertEquals(SESSION_NAME, s.getSessionName()); Assert.assertTrue(s instanceof ReactorSession); Assert.assertSame(session, ((ReactorSession)s).session()); }).verifyComplete(); verify(record, Mockito.times(1)).set(Handler.class, Handler.class, sessionHandler); } "
    },
    {
        "test_src": "@Test public void testGetProfileSchemaVersionsByApplicationId()throws Exception { List < ProfileSchemaDto > profileSchemas = new ArrayList < > (11); ApplicationDto application = createApplication(tenantAdminDto); loginTenantDeveloper(tenantDeveloperDto.getUsername()); List < ProfileSchemaDto > defaultProfileSchemas = client.getProfileSchemas(application.getId()); profileSchemas.addAll(defaultProfileSchemas); for(int i = 0; i < 10; i ++ ) { ProfileSchemaDto profileSchema = createProfileSchema(application.getId()); profileSchemas.add(profileSchema); } Collections.sort(profileSchemas, new IdComparator()); SchemaVersions schemaVersions = client.getSchemaVersionsByApplicationId(application.getId()); List < SchemaDto > storedProfileSchemas = schemaVersions.getProfileSchemaVersions(); Collections.sort(storedProfileSchemas, new IdComparator()); Assert.assertEquals(profileSchemas.size(), storedProfileSchemas.size()); for(int i = 0; i < profileSchemas.size(); i ++ ) { ProfileSchemaDto profileSchema = profileSchemas.get(i); SchemaDto storedProfileSchema = storedProfileSchemas.get(i); assertSchemasEquals(profileSchema, storedProfileSchema); } } ",
        "focal_tgt": "List < VersionDto > getProfileSchemaVersionsByApplicationId(String applicationId)throws ControlServiceException; ",
        "focal_src": "List < SchemaDto > getProfileSchemaVersionsByApplicationId(String applicationId)throws ControlServiceException; ",
        "test_tgt": "@Test public void testGetProfileSchemaVersionsByApplicationId()throws Exception { List < ProfileSchemaDto > profileSchemas = new ArrayList < > (11); ApplicationDto application = createApplication(tenantAdminDto); loginTenantDeveloper(tenantDeveloperDto.getUsername()); List < ProfileSchemaDto > defaultProfileSchemas = client.getProfileSchemas(application.getId()); profileSchemas.addAll(defaultProfileSchemas); CTLSchemaInfoDto ctlSchema = this.createCTLSchema(this.ctlRandomFieldType(), CTL_DEFAULT_NAMESPACE, 1, CTLSchemaScopeDto.TENANT, null, null, null); for(int i = 0; i < 10; i ++ ) { ProfileSchemaDto profileSchema = createProfileSchema(application.getId(), ctlSchema.getId()); profileSchemas.add(profileSchema); } Collections.sort(profileSchemas, new IdComparator()); SchemaVersions schemaVersions = client.getSchemaVersionsByApplicationId(application.getId()); List < VersionDto > storedProfileSchemas = schemaVersions.getProfileSchemaVersions(); Collections.sort(storedProfileSchemas, new IdComparator()); Assert.assertEquals(profileSchemas.size(), storedProfileSchemas.size()); for(int i = 0; i < profileSchemas.size(); i ++ ) { ProfileSchemaDto profileSchema = profileSchemas.get(i); VersionDto storedProfileSchema = storedProfileSchemas.get(i); assertSchemasEquals(profileSchema, storedProfileSchema); } } "
    },
    {
        "test_src": "@Test public void testSupports() { assertFalse(this.legacyTrustAdaptor.supports(null)); LegacyCasTrustedCredentials goodCred = new LegacyCasTrustedCredentials(); assertTrue(this.legacyTrustAdaptor.supports(goodCred)); LegacyCasCredentials badCred = new LegacyCasCredentials(); assertFalse(this.legacyTrustAdaptor.supports(badCred)); } ",
        "focal_tgt": "public final boolean supports(final Credential credential) { return credential != null && (this.classToSupport.equals(credential.getClass()) || (this.classToSupport.isAssignableFrom(credential.getClass())) && this.supportSubClasses); } ",
        "focal_src": "public final boolean supports(final Credentials credentials) { return credentials != null && (this.classToSupport.equals(credentials.getClass()) || (this.classToSupport.isAssignableFrom(credentials.getClass())) && this.supportSubClasses); } ",
        "test_tgt": "@Test public void testSupports() { assertFalse(this.legacyTrustAdaptor.supports(null)); LegacyCasTrustedCredential goodCred = new LegacyCasTrustedCredential(); assertTrue(this.legacyTrustAdaptor.supports(goodCred)); LegacyCasCredential badCred = new LegacyCasCredential(); assertFalse(this.legacyTrustAdaptor.supports(badCred)); } "
    },
    {
        "test_src": "@Test public void testTerminateAllConnections()throws SQLException { expect(mockConnectionHandles.poll()).andReturn(mockConnection).times(2).andReturn(null).once(); mockConnection.internalClose(); expectLastCall().once().andThrow(new SQLException()).once(); expect(mockPartition.getFreeConnections()).andReturn(mockConnectionHandles).anyTimes(); expect(mockConnection.getOriginatingPartition()).andReturn(mockPartition).anyTimes(); replay(mockConnectionsScheduler, mockKeepAliveScheduler, mockPartition, mockConnectionHandles, mockConnection); testClass.terminateAllConnections(); verify(mockConnectionsScheduler, mockKeepAliveScheduler, mockPartition, mockConnectionHandles, mockConnection); } ",
        "focal_tgt": "protected void terminateAllConnections() { if(this.terminationLock.tryLock()) { try { for(int i = 0; i < this.partitionCount; i ++ ) { ConnectionHandle conn; while((conn = this.partitions[i].getFreeConnections().poll()) != null) { postDestroyConnection(conn); try { conn.internalClose(); } catch(SQLException e) { logger.error(e); } } } } finally { this.terminationLock.unlock(); } } } ",
        "focal_src": "protected void terminateAllConnections() { for(int i = 0; i < this.partitionCount; i ++ ) { ConnectionHandle conn; while((conn = this.partitions[i].getFreeConnections().poll()) != null) { postDestroyConnection(conn); try { conn.internalClose(); } catch(SQLException e) { logger.error(e); } } } } ",
        "test_tgt": "@Test public void testTerminateAllConnections()throws SQLException { expect(mockConnectionHandles.poll()).andReturn(mockConnection).times(2).andReturn(null).once(); mockConnection.internalClose(); expectLastCall().once().andThrow(new SQLException()).once(); expect(mockPartition.getFreeConnections()).andReturn(mockConnectionHandles).anyTimes(); expect(mockConnection.getOriginatingPartition()).andReturn(mockPartition).anyTimes(); replay(mockConnectionsScheduler, mockKeepAliveScheduler, mockPartition, mockConnectionHandles, mockConnection); testClass.terminateAllConnections(); verify(mockConnectionsScheduler, mockKeepAliveScheduler, mockPartition, mockConnectionHandles, mockConnection); reset(mockConnectionsScheduler, mockKeepAliveScheduler, mockPartition, mockConnectionHandles, mockConnection); expect(mockConnectionHandles.poll()).andReturn(mockConnection).anyTimes(); mockConnection.internalClose(); expectLastCall().once().andThrow(new RuntimeException()).once(); expect(mockPartition.getFreeConnections()).andReturn(mockConnectionHandles).anyTimes(); expect(mockConnection.getOriginatingPartition()).andReturn(mockPartition).anyTimes(); replay(mockConnectionsScheduler, mockKeepAliveScheduler, mockPartition, mockConnectionHandles, mockConnection); try { testClass.terminateAllConnections(); fail(\"Should throw exception\"); } catch(RuntimeException e) { } verify(mockConnectionsScheduler, mockKeepAliveScheduler, mockPartition, mockConnectionHandles, mockConnection); } "
    },
    {
        "test_src": "@Test public void testSolve_doubleArr_doubleArr() { System.out.println(\"solve\"); double[][]A = { { 0.9000, 0.4000, 0.7000 }, { 0.4000, 0.5000, 0.3000 }, { 0.7000, 0.3000, 0.8000 } }; double[]B = { 0.5, 0.5, 0.5 }; double[]X = { - 0.2027027, 0.8783784, 0.4729730 }; SVD result = Matrix.newInstance(A).svd(); double[]x = new double[B.length]; result.solve(B, x); assertEquals(X.length, x.length); for(int i = 0; i < X.length; i ++ ) { assertEquals(X[i], x[i], 1E-7); } } ",
        "focal_tgt": "public void solve(double[]b) { DenseMatrix B = Matrix.of(b); solve(B); } ",
        "focal_src": "public void solve(double[]b) { DenseMatrix B = Matrix.newInstance(b); solve(B); } ",
        "test_tgt": "@Test public void testSolve_doubleArr_doubleArr() { System.out.println(\"solve\"); double[][]A = { { 0.9000, 0.4000, 0.7000 }, { 0.4000, 0.5000, 0.3000 }, { 0.7000, 0.3000, 0.8000 } }; double[]B = { 0.5, 0.5, 0.5 }; double[]X = { - 0.2027027, 0.8783784, 0.4729730 }; SVD result = Matrix.of(A).svd(); double[]x = new double[B.length]; result.solve(B, x); assertEquals(X.length, x.length); for(int i = 0; i < X.length; i ++ ) { assertEquals(X[i], x[i], 1E-7); } } "
    },
    {
        "test_src": "@Test public void testRemoveFinishedWrites() { final int timeIncrement = 1234 * 1000; AtomicLong time = new AtomicLong(); val q = new WriteQueue(time :: get); val writes = new ArrayDeque < Write > (); for(int i = 0; i < ITEM_COUNT; i ++ ) { time.addAndGet(timeIncrement); val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture < > ()); if(i % 2 == 0) { w.setEntryId(i); w.complete(); } q.add(w); writes.addLast(w); } while( ! writes.isEmpty()) { val write = writes.pollFirst(); if( ! write.isDone()) { val result1 = q.removeFinishedWrites(); Assert.assertEquals(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", WriteQueue.CleanupStatus.QueueNotEmpty, result1); val stats1 = q.getStatistics(); Assert.assertEquals(\"Unexpected size after removeFinishedWrites with no effect.\", writes.size() + 1, stats1.getSize()); write.setEntryId(time.get()); write.complete(); } long expectedElapsed = write.getQueueAddedTimestamp(); int removed = 1; while( ! writes.isEmpty() && writes.peekFirst().isDone()) { expectedElapsed += writes.pollFirst().getQueueAddedTimestamp(); removed ++ ; } expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed; val result2 = q.removeFinishedWrites(); val expectedResult = writes.isEmpty() ? WriteQueue.CleanupStatus.QueueEmpty : WriteQueue.CleanupStatus.QueueNotEmpty; Assert.assertEquals(\"Unexpected result from removeFinishedWrites.\", expectedResult, result2); val stats2 = q.getStatistics(); Assert.assertEquals(\"Unexpected size after removeFinishedWrites.\", writes.size(), stats2.getSize()); Assert.assertEquals(\"Unexpected getExpectedProcessingTimeMillis after clear.\", expectedElapsed, stats2.getExpectedProcessingTimeMillis()); } val w3 = new Write(new ByteArraySegment(new byte[1]), new TestWriteLedger(0), new CompletableFuture < > ()); q.add(w3); w3.fail(new IntentionalException(), true); val result3 = q.removeFinishedWrites(); Assert.assertEquals(\"Unexpected value from removeFinishedWrites when there were failed writes.\", WriteQueue.CleanupStatus.WriteFailed, result3); } ",
        "focal_tgt": "synchronized CleanupResult removeFinishedWrites() { Exceptions.checkNotClosed(this.closed, this); long currentTime = this.timeSupplier.get(); long totalElapsed = 0; int removedCount = 0; boolean failedWrite = false; while( ! this.writes.isEmpty() && this.writes.peekFirst().isDone()) { Write w = this.writes.removeFirst(); this.totalLength = Math.max(0, this.totalLength - w.data.getLength()); removedCount ++ ; totalElapsed += currentTime - w.getQueueAddedTimestamp(); failedWrite |= w.getFailureCause() != null; } if(removedCount > 0) { this.lastDurationMillis = (int)(totalElapsed / removedCount / AbstractTimer.NANOS_TO_MILLIS); } CleanupStatus status = failedWrite ? CleanupStatus.WriteFailed : this.writes.isEmpty() ? CleanupStatus.QueueEmpty : CleanupStatus.QueueNotEmpty; return new CleanupResult(status, removedCount); } ",
        "focal_src": "synchronized CleanupStatus removeFinishedWrites() { Exceptions.checkNotClosed(this.closed, this); long currentTime = this.timeSupplier.get(); long totalElapsed = 0; int removedCount = 0; boolean failedWrite = false; while( ! this.writes.isEmpty() && this.writes.peekFirst().isDone()) { Write w = this.writes.removeFirst(); this.totalLength = Math.max(0, this.totalLength - w.data.getLength()); removedCount ++ ; totalElapsed += currentTime - w.getQueueAddedTimestamp(); failedWrite |= w.getFailureCause() != null; } if(removedCount > 0) { this.lastDurationMillis = (int)(totalElapsed / removedCount / AbstractTimer.NANOS_TO_MILLIS); } return failedWrite ? CleanupStatus.WriteFailed : this.writes.isEmpty() ? CleanupStatus.QueueEmpty : CleanupStatus.QueueNotEmpty; } ",
        "test_tgt": "@Test public void testRemoveFinishedWrites() { final int timeIncrement = 1234 * 1000; AtomicLong time = new AtomicLong(); val q = new WriteQueue(time :: get); val writes = new ArrayDeque < Write > (); for(int i = 0; i < ITEM_COUNT; i ++ ) { time.addAndGet(timeIncrement); val w = new Write(new ByteArraySegment(new byte[i]), new TestWriteLedger(i), new CompletableFuture < > ()); if(i % 2 == 0) { w.setEntryId(i); w.complete(); } q.add(w); writes.addLast(w); } while( ! writes.isEmpty()) { val write = writes.pollFirst(); if( ! write.isDone()) { val result1 = q.removeFinishedWrites(); Assert.assertEquals(\"Unexpected value from removeFinishedWrites when there were writes left in the queue.\", WriteQueue.CleanupStatus.QueueNotEmpty, result1.getStatus()); val stats1 = q.getStatistics(); Assert.assertEquals(\"Unexpected size after removeFinishedWrites with no effect.\", writes.size() + 1, stats1.getSize()); write.setEntryId(time.get()); write.complete(); } long expectedElapsed = write.getQueueAddedTimestamp(); int removed = 1; while( ! writes.isEmpty() && writes.peekFirst().isDone()) { expectedElapsed += writes.pollFirst().getQueueAddedTimestamp(); removed ++ ; } expectedElapsed = (time.get() * removed - expectedElapsed) / AbstractTimer.NANOS_TO_MILLIS / removed; val result2 = q.removeFinishedWrites(); val expectedResult = writes.isEmpty() ? WriteQueue.CleanupStatus.QueueEmpty : WriteQueue.CleanupStatus.QueueNotEmpty; Assert.assertEquals(\"Unexpected result from removeFinishedWrites.\", expectedResult, result2.getStatus()); val stats2 = q.getStatistics(); Assert.assertEquals(\"Unexpected size after removeFinishedWrites.\", writes.size(), stats2.getSize()); Assert.assertEquals(\"Unexpected getExpectedProcessingTimeMillis after clear.\", expectedElapsed, stats2.getExpectedProcessingTimeMillis()); } val w3 = new Write(new ByteArraySegment(new byte[1]), new TestWriteLedger(0), new CompletableFuture < > ()); q.add(w3); w3.fail(new IntentionalException(), true); val result3 = q.removeFinishedWrites(); Assert.assertEquals(\"Unexpected value from removeFinishedWrites when there were failed writes.\", WriteQueue.CleanupStatus.WriteFailed, result3.getStatus()); } "
    },
    {
        "test_src": "@Test public void testExtractColumnValuesByY() { TestUtils.log(this.getClass(), \"extractColumnValuesByY\"); RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); Object column = \"height\"; Dataset instance = new Dataset(dbConf); AssociativeArray xData1 = new AssociativeArray(); xData1.put(\"height\", 188.0); xData1.put(\"weight\", 88.0); instance.add(new Record(xData1, \"Class1\")); AssociativeArray xData2 = new AssociativeArray(); xData2.put(\"height\", 189.0); xData2.put(\"weight\", 89.0); instance.add(new Record(xData2, \"Class1\")); AssociativeArray xData3 = new AssociativeArray(); xData3.put(\"height\", 190.0); xData3.put(\"weight\", null); instance.add(new Record(xData3, \"Class2\")); TransposeDataList expResult = new TransposeDataList(); expResult.put(\"Class1\", new FlatDataList(Arrays.asList(new Object[] { 188.0, 189.0 }))); expResult.put(\"Class2\", new FlatDataList(Arrays.asList(new Object[] { 190.0 }))); TransposeDataList result = instance.extractColumnValuesByY(column); assertEquals(expResult, result); } ",
        "focal_tgt": "public TransposeDataList extractXColumnValuesByY(Object column) { TransposeDataList transposeDataList = new TransposeDataList(); for(Integer rId : this) { Record r = recordList.get(rId); if( ! transposeDataList.containsKey(r.getY())) { transposeDataList.put(r.getY(), new FlatDataList(new ArrayList < > ())); } transposeDataList.get(r.getY()).add(r.getX().get(column)); } return transposeDataList; } ",
        "focal_src": "public TransposeDataList extractColumnValuesByY(Object column) { TransposeDataList transposeDataList = new TransposeDataList(); for(Integer rId : this) { Record r = recordList.get(rId); if( ! transposeDataList.containsKey(r.getY())) { transposeDataList.put(r.getY(), new FlatDataList(new ArrayList < > ())); } transposeDataList.get(r.getY()).add(r.getX().get(column)); } return transposeDataList; } ",
        "test_tgt": "@Test public void testExtractColumnValuesByY() { TestUtils.log(this.getClass(), \"extractColumnValuesByY\"); RandomSingleton.getInstance().setSeed(TestConfiguration.RANDOM_SEED); DatabaseConfiguration dbConf = TestUtils.getDBConfig(); Object column = \"height\"; Dataset instance = new Dataset(dbConf); AssociativeArray xData1 = new AssociativeArray(); xData1.put(\"height\", 188.0); xData1.put(\"weight\", 88.0); instance.add(new Record(xData1, \"Class1\")); AssociativeArray xData2 = new AssociativeArray(); xData2.put(\"height\", 189.0); xData2.put(\"weight\", 89.0); instance.add(new Record(xData2, \"Class1\")); AssociativeArray xData3 = new AssociativeArray(); xData3.put(\"height\", 190.0); xData3.put(\"weight\", null); instance.add(new Record(xData3, \"Class2\")); TransposeDataList expResult = new TransposeDataList(); expResult.put(\"Class1\", new FlatDataList(Arrays.asList(new Object[] { 188.0, 189.0 }))); expResult.put(\"Class2\", new FlatDataList(Arrays.asList(new Object[] { 190.0 }))); TransposeDataList result = instance.extractXColumnValuesByY(column); assertEquals(expResult, result); } "
    },
    {
        "test_src": "@Test public void testConfigure()throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException { expect(mockProperties.getProperty(CONFIG_TEST_STATEMENT)).andReturn(null).anyTimes(); expect(mockProperties.getProperty(CONFIG_PREPARED_STATEMENT_CACHE_SIZE)).andReturn(\"40\").anyTimes(); expect(mockProperties.getProperty(CONFIG_STATEMENTS_CACHED_PER_CONNECTION)).andReturn(\"30\").anyTimes(); expect(mockProperties.getProperty(CONFIG_MIN_CONNECTIONS_PER_PARTITION)).andReturn(\"20\").anyTimes(); expect(mockProperties.getProperty(CONFIG_MAX_CONNECTIONS_PER_PARTITION)).andReturn(\"50\").anyTimes(); expect(mockProperties.getProperty(CONFIG_ACQUIRE_INCREMENT)).andReturn(\"5\").anyTimes(); expect(mockProperties.getProperty(CONFIG_PARTITION_COUNT)).andReturn(\"5\").anyTimes(); expect(mockProperties.getProperty(CONFIG_RELEASE_HELPER_THREADS)).andReturn(\"3\").anyTimes(); expect(mockProperties.getProperty(CONFIG_IDLE_CONNECTION_TEST_PERIOD)).andReturn(\"60\").anyTimes(); expect(mockProperties.getProperty(CONFIG_IDLE_MAX_AGE)).andReturn(\"240\").anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_URL, \"JDBC URL NOT SET IN CONFIG\")).andReturn(URL).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_USERNAME, \"username not set\")).andReturn(USERNAME).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_PASSWORD, \"password not set\")).andReturn(PASSWORD).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_DRIVER_CLASS)).andReturn(DRIVER).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_HOOK_CLASS)).andReturn(\"com.jolbox.bonecp.provider.CustomHook\").anyTimes(); expect(mockProperties.getProperty(CONFIG_INIT_SQL)).andReturn(TEST_QUERY).anyTimes(); expect(mockProperties.getProperty(CONFIG_LOG_STATEMENTS_ENABLED)).andReturn(\"true\").anyTimes(); BoneCPConnectionProvider partialTestClass = createNiceMock(BoneCPConnectionProvider.class, BoneCPConnectionProvider.class.getDeclaredMethod(\"createPool\", BoneCPConfig.class)); expect(partialTestClass.createPool((BoneCPConfig)anyObject())).andReturn(mockPool).once(); replay(mockProperties, partialTestClass); partialTestClass.configure(mockProperties); BoneCPConfig config = partialTestClass.getConfig(); assertEquals(40, config.getStatementsCacheSize()); assertEquals(30, config.getStatementsCachedPerConnection()); assertEquals(20, config.getMinConnectionsPerPartition()); assertEquals(50, config.getMaxConnectionsPerPartition()); assertEquals(5, config.getAcquireIncrement()); assertEquals(5, config.getPartitionCount()); assertEquals(3, config.getReleaseHelperThreads()); assertEquals(60, config.getIdleConnectionTestPeriod()); assertEquals(240, config.getIdleMaxAge()); assertEquals(URL, config.getJdbcUrl()); assertEquals(USERNAME, config.getUsername()); assertEquals(PASSWORD, config.getPassword()); assertEquals(TEST_QUERY, config.getInitSQL()); assertEquals(true, config.isLogStatementsEnabled()); verify(mockProperties, partialTestClass); reset(mockProperties); expect(mockProperties.getProperty(CONFIG_CONNECTION_DRIVER_CLASS)).andReturn(null).anyTimes(); replay(mockProperties); try { testClass.configure(mockProperties); fail(\"Should have failed with exception\"); } catch(HibernateException e) { } reset(mockProperties); expect(mockProperties.getProperty(CONFIG_CONNECTION_DRIVER_CLASS)).andReturn(DRIVER).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_URL, \"JDBC URL NOT SET IN CONFIG\")).andReturn(\"somethinginvalid\").anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_USERNAME, \"username not set\")).andReturn(USERNAME).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_PASSWORD, \"password not set\")).andReturn(PASSWORD).anyTimes(); replay(mockProperties); try { testClass.configure(mockProperties); fail(\"Should have failed with exception\"); } catch(HibernateException e) { } verify(mockProperties); reset(mockProperties); expect(mockProperties.getProperty(CONFIG_CONNECTION_DRIVER_CLASS)).andReturn(\"somethingbad\").anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_URL, \"JDBC URL NOT SET IN CONFIG\")).andReturn(\"somethinginvalid\").anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_USERNAME, \"username not set\")).andReturn(USERNAME).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_PASSWORD, \"password not set\")).andReturn(PASSWORD).anyTimes(); replay(mockProperties); try { testClass.configure(mockProperties); fail(\"Should have failed with exception\"); } catch(HibernateException e) { } } ",
        "focal_tgt": "public void configure(Properties props)throws HibernateException { String connectionTestStatement = props.getProperty(CONFIG_TEST_STATEMENT); int preparedStatementCacheSize = configParseNumber(props, CONFIG_PREPARED_STATEMENT_CACHE_SIZE, 50); int statementsCachedPerConnection = configParseNumber(props, CONFIG_STATEMENTS_CACHED_PER_CONNECTION, 30); int minsize = configParseNumber(props, CONFIG_MIN_CONNECTIONS_PER_PARTITION, 20); int maxsize = configParseNumber(props, CONFIG_MAX_CONNECTIONS_PER_PARTITION, 50); int acquireIncrement = configParseNumber(props, CONFIG_ACQUIRE_INCREMENT, 10); int partcount = configParseNumber(props, CONFIG_PARTITION_COUNT, 3); int releaseHelperThreads = configParseNumber(props, CONFIG_RELEASE_HELPER_THREADS, 3); long idleMaxAge = configParseNumber(props, CONFIG_IDLE_MAX_AGE, 240); long idleConnectionTestPeriod = configParseNumber(props, CONFIG_IDLE_CONNECTION_TEST_PERIOD, 60); int acquireRetryDelay = configParseNumber(props, CONFIG_ACQUIRE_RETRY_DELAY, 100); String url = props.getProperty(CONFIG_CONNECTION_URL, \"JDBC URL NOT SET IN CONFIG\"); String username = props.getProperty(CONFIG_CONNECTION_USERNAME, \"username not set\"); String password = props.getProperty(CONFIG_CONNECTION_PASSWORD, \"password not set\"); String connectionHookClass = props.getProperty(CONFIG_CONNECTION_HOOK_CLASS); String initSQL = props.getProperty(CONFIG_INIT_SQL); boolean closeConnectionWatch = configParseBoolean(props, CONFIG_CLOSE_CONNECTION_WATCH, false); boolean logStatementsEnabled = configParseBoolean(props, CONFIG_LOG_STATEMENTS_ENABLED, false); this.isolation = PropertiesHelper.getInteger(Environment.ISOLATION, props); this.autocommit = PropertiesHelper.getBoolean(Environment.AUTOCOMMIT, props); try { String driver = props.getProperty(CONFIG_CONNECTION_DRIVER_CLASS); if(driver != null && ! driver.trim().equals(\"\")) { loadClass(driver); } logger.debug(String.format(CONFIG_STATUS, url, username, minsize, maxsize, acquireIncrement, partcount, idleConnectionTestPeriod / 1000, idleMaxAge / (60 * 1000))); this.config = new BoneCPConfig(); this.config.setMinConnectionsPerPartition(minsize); this.config.setMaxConnectionsPerPartition(maxsize); this.config.setAcquireIncrement(acquireIncrement); this.config.setPartitionCount(partcount); this.config.setJdbcUrl(url); this.config.setUsername(username); this.config.setPassword(password); this.config.setReleaseHelperThreads(releaseHelperThreads); this.config.setIdleConnectionTestPeriod(idleConnectionTestPeriod); this.config.setIdleMaxAge(idleMaxAge); this.config.setConnectionTestStatement(connectionTestStatement); this.config.setStatementsCacheSize(preparedStatementCacheSize); this.config.setStatementsCachedPerConnection(statementsCachedPerConnection); this.config.setInitSQL(initSQL); this.config.setCloseConnectionWatch(closeConnectionWatch); this.config.setLogStatementsEnabled(logStatementsEnabled); this.config.setAcquireRetryDelay(acquireRetryDelay); if(connectionHookClass != null) { Object hookClass = loadClass(connectionHookClass).newInstance(); this.config.setConnectionHook((ConnectionHook)hookClass); } this.pool = createPool(this.config); } catch(NullPointerException e) { throw new HibernateException(e); } catch(Exception e) { throw new HibernateException(e); } } ",
        "focal_src": "public void configure(Properties props)throws HibernateException { String connectionTestStatement = props.getProperty(CONFIG_TEST_STATEMENT); int preparedStatementCacheSize = configParseNumber(props, CONFIG_PREPARED_STATEMENT_CACHE_SIZE, 50); int statementsCachedPerConnection = configParseNumber(props, CONFIG_STATEMENTS_CACHED_PER_CONNECTION, 30); int minsize = configParseNumber(props, CONFIG_MIN_CONNECTIONS_PER_PARTITION, 20); int maxsize = configParseNumber(props, CONFIG_MAX_CONNECTIONS_PER_PARTITION, 50); int acquireIncrement = configParseNumber(props, CONFIG_ACQUIRE_INCREMENT, 10); int partcount = configParseNumber(props, CONFIG_PARTITION_COUNT, 3); int releaseHelperThreads = configParseNumber(props, CONFIG_RELEASE_HELPER_THREADS, 3); long idleMaxAge = configParseNumber(props, CONFIG_IDLE_MAX_AGE, 240); long idleConnectionTestPeriod = configParseNumber(props, CONFIG_IDLE_CONNECTION_TEST_PERIOD, 60); int acquireRetryDelay = configParseNumber(props, CONFIG_ACQUIRE_RETRY_DELAY, 100); String url = props.getProperty(CONFIG_CONNECTION_URL, \"JDBC URL NOT SET IN CONFIG\"); String username = props.getProperty(CONFIG_CONNECTION_USERNAME, \"username not set\"); String password = props.getProperty(CONFIG_CONNECTION_PASSWORD, \"password not set\"); String connectionHookClass = props.getProperty(CONFIG_CONNECTION_HOOK_CLASS); String initSQL = props.getProperty(CONFIG_INIT_SQL); boolean closeConnectionWatch = configParseBoolean(props, CONFIG_CLOSE_CONNECTION_WATCH, false); boolean logStatementsEnabled = configParseBoolean(props, CONFIG_LOG_STATEMENTS_ENABLED, false); this.isolation = PropertiesHelper.getInteger(Environment.ISOLATION, props); this.autocommit = PropertiesHelper.getBoolean(Environment.AUTOCOMMIT, props); try { String driver = props.getProperty(CONFIG_CONNECTION_DRIVER_CLASS, \"\"); if( ! driver.trim().equals(\"\")) { loadClass(driver); } logger.debug(String.format(CONFIG_STATUS, url, username, minsize, maxsize, acquireIncrement, partcount, idleConnectionTestPeriod / 1000, idleMaxAge / (60 * 1000))); this.config = new BoneCPConfig(); this.config.setMinConnectionsPerPartition(minsize); this.config.setMaxConnectionsPerPartition(maxsize); this.config.setAcquireIncrement(acquireIncrement); this.config.setPartitionCount(partcount); this.config.setJdbcUrl(url); this.config.setUsername(username); this.config.setPassword(password); this.config.setReleaseHelperThreads(releaseHelperThreads); this.config.setIdleConnectionTestPeriod(idleConnectionTestPeriod); this.config.setIdleMaxAge(idleMaxAge); this.config.setConnectionTestStatement(connectionTestStatement); this.config.setStatementsCacheSize(preparedStatementCacheSize); this.config.setStatementsCachedPerConnection(statementsCachedPerConnection); this.config.setInitSQL(initSQL); this.config.setCloseConnectionWatch(closeConnectionWatch); this.config.setLogStatementsEnabled(logStatementsEnabled); this.config.setAcquireRetryDelay(acquireRetryDelay); if(connectionHookClass != null) { Object hookClass = loadClass(connectionHookClass).newInstance(); this.config.setConnectionHook((ConnectionHook)hookClass); } this.pool = createPool(this.config); } catch(NullPointerException e) { throw new HibernateException(e); } catch(Exception e) { throw new HibernateException(e); } } ",
        "test_tgt": "@Test public void testConfigure()throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException, NoSuchMethodException, ClassNotFoundException { expect(mockProperties.getProperty(CONFIG_TEST_STATEMENT)).andReturn(null).anyTimes(); expect(mockProperties.getProperty(CONFIG_PREPARED_STATEMENT_CACHE_SIZE)).andReturn(\"40\").anyTimes(); expect(mockProperties.getProperty(CONFIG_STATEMENTS_CACHED_PER_CONNECTION)).andReturn(\"30\").anyTimes(); expect(mockProperties.getProperty(CONFIG_MIN_CONNECTIONS_PER_PARTITION)).andReturn(\"20\").anyTimes(); expect(mockProperties.getProperty(CONFIG_MAX_CONNECTIONS_PER_PARTITION)).andReturn(\"50\").anyTimes(); expect(mockProperties.getProperty(CONFIG_ACQUIRE_INCREMENT)).andReturn(\"5\").anyTimes(); expect(mockProperties.getProperty(CONFIG_PARTITION_COUNT)).andReturn(\"5\").anyTimes(); expect(mockProperties.getProperty(CONFIG_RELEASE_HELPER_THREADS)).andReturn(\"3\").anyTimes(); expect(mockProperties.getProperty(CONFIG_IDLE_CONNECTION_TEST_PERIOD)).andReturn(\"60\").anyTimes(); expect(mockProperties.getProperty(CONFIG_IDLE_MAX_AGE)).andReturn(\"240\").anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_URL, \"JDBC URL NOT SET IN CONFIG\")).andReturn(URL).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_USERNAME, \"username not set\")).andReturn(USERNAME).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_PASSWORD, \"password not set\")).andReturn(PASSWORD).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_DRIVER_CLASS)).andReturn(DRIVER).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_HOOK_CLASS)).andReturn(\"com.jolbox.bonecp.provider.CustomHook\").anyTimes(); expect(mockProperties.getProperty(CONFIG_INIT_SQL)).andReturn(TEST_QUERY).anyTimes(); expect(mockProperties.getProperty(CONFIG_LOG_STATEMENTS_ENABLED)).andReturn(\"true\").anyTimes(); BoneCPConnectionProvider partialTestClass = createNiceMock(BoneCPConnectionProvider.class, BoneCPConnectionProvider.class.getDeclaredMethod(\"createPool\", BoneCPConfig.class)); expect(partialTestClass.createPool((BoneCPConfig)anyObject())).andReturn(mockPool).once(); replay(mockProperties, partialTestClass); partialTestClass.configure(mockProperties); BoneCPConfig config = partialTestClass.getConfig(); assertEquals(40, config.getStatementsCacheSize()); assertEquals(30, config.getStatementsCachedPerConnection()); assertEquals(20, config.getMinConnectionsPerPartition()); assertEquals(50, config.getMaxConnectionsPerPartition()); assertEquals(5, config.getAcquireIncrement()); assertEquals(5, config.getPartitionCount()); assertEquals(3, config.getReleaseHelperThreads()); assertEquals(60, config.getIdleConnectionTestPeriod()); assertEquals(240, config.getIdleMaxAge()); assertEquals(URL, config.getJdbcUrl()); assertEquals(USERNAME, config.getUsername()); assertEquals(PASSWORD, config.getPassword()); assertEquals(TEST_QUERY, config.getInitSQL()); assertEquals(true, config.isLogStatementsEnabled()); verify(mockProperties, partialTestClass); reset(mockProperties); expect(mockProperties.getProperty(CONFIG_CONNECTION_DRIVER_CLASS)).andReturn(null).anyTimes(); replay(mockProperties); try { testClass.configure(mockProperties); fail(\"Should have failed with exception\"); } catch(HibernateException e) { } reset(mockProperties); expect(mockProperties.getProperty(CONFIG_CONNECTION_DRIVER_CLASS)).andReturn(DRIVER).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_URL, \"JDBC URL NOT SET IN CONFIG\")).andReturn(\"somethinginvalid\").anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_USERNAME, \"username not set\")).andReturn(USERNAME).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_PASSWORD, \"password not set\")).andReturn(PASSWORD).anyTimes(); replay(mockProperties); try { testClass.configure(mockProperties); fail(\"Should have failed with exception\"); } catch(HibernateException e) { } verify(mockProperties); reset(mockProperties); expect(mockProperties.getProperty(CONFIG_CONNECTION_DRIVER_CLASS)).andReturn(\"somethingbad\").anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_URL, \"JDBC URL NOT SET IN CONFIG\")).andReturn(\"somethinginvalid\").anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_USERNAME, \"username not set\")).andReturn(USERNAME).anyTimes(); expect(mockProperties.getProperty(CONFIG_CONNECTION_PASSWORD, \"password not set\")).andReturn(PASSWORD).anyTimes(); replay(mockProperties); try { testClass.configure(mockProperties); fail(\"Should have failed with exception\"); } catch(HibernateException e) { } testClass.setClassLoader(getClass().getClassLoader()); testClass.loadClass(\"java.lang.String\"); testClass.setClassLoader(this.getClass().getClassLoader()); assertEquals(this.getClass().getClassLoader(), testClass.getClassLoader()); } "
    },
    {
        "test_src": "@Test public void testBuild() { final String xToken = X_TOKEN; final Request request = RequestBuilder.post(urlWithQuery).bodyContent(\"body1\", HttpMediaType.TEXT_PLAIN).header(X_TOKEN, \"token1\").build(); assertEquals(\"POST\", request.method()); assertEquals(\"token1\", request.header(xToken)); } ",
        "focal_tgt": "public Request build() { final Request.Builder builder = new Request.Builder(); builder.url(toUrl()); if(method == HTTPMethod.GET) { Validator.isNull(body, \"cannot send a RequestBody in a GET request\"); } else if( ! formParams.isEmpty()) { final FormBody.Builder formBody = new FormBody.Builder(); for(final NameValue param : formParams) { final String value = param.getValue() != null ? param.getValue() : \"\"; formBody.add(param.getName(), value); } body = formBody.build(); } else if(body == null) { body = RequestBody.create(null, new byte[0]); } builder.method(method.name(), body); builder.header(HttpHeaders.ACCEPT, HttpMediaType.APPLICATION_JSON); for(final NameValue header : headers) { builder.header(header.getName(), header.getValue()); } return builder.build(); } ",
        "focal_src": "public Request build() { final Request.Builder builder = new Request.Builder(); builder.url(toUrl()); RequestBody requestBody = body; if(body == null)requestBody = RequestBody.create(null, new byte[0]); if( ! formParams.isEmpty()) { final FormBody.Builder formBody = new FormBody.Builder(); for(final NameValue param : formParams) { final String value = param.getValue() != null ? param.getValue() : \"\"; formBody.add(param.getName(), value); } requestBody = formBody.build(); } builder.header(HttpHeaders.ACCEPT, HttpMediaType.APPLICATION_JSON); if( ! headers.isEmpty()) { for(final NameValue header : headers) { builder.header(header.getName(), header.getValue()); } } switch(method) { case GET : builder.get(); break; case POST : builder.post(requestBody); break; case PUT : builder.put(requestBody); break; case DELETE : builder.delete(requestBody); break; } return builder.build(); } ",
        "test_tgt": "@Test public void testBuild() { final String xToken = X_TOKEN; final RequestBuilder builder = RequestBuilder.post(urlWithQuery).bodyContent(\"body1\", HttpMediaType.TEXT_PLAIN).header(X_TOKEN, \"token1\"); final Request request = builder.build(); assertEquals(\"POST\", request.method()); assertEquals(\"token1\", request.header(xToken)); assertNotNull(builder.toString()); } "
    },
    {
        "test_src": "@Override public final List < TestExecutionListener > getTestExecutionListeners() { Class < ? > clazz = getBootstrapContext().getTestClass(); Class < TestExecutionListeners > annotationType = TestExecutionListeners.class; List < Class < ? extends TestExecutionListener > > classesList = new ArrayList < > (); boolean usingDefaults = false; AnnotationDescriptor < TestExecutionListeners > descriptor = MetaAnnotationUtils.findAnnotationDescriptor(clazz, annotationType); if(descriptor == null) { if(logger.isDebugEnabled()) { logger.debug(String.format(\"@TestExecutionListeners is not present for class [%s]: using defaults.\", clazz.getName())); } usingDefaults = true; classesList.addAll(getDefaultTestExecutionListenerClasses()); } else { while(descriptor != null) { Class < ? > declaringClass = descriptor.getDeclaringClass(); TestExecutionListeners testExecutionListeners = descriptor.synthesizeAnnotation(); if(logger.isTraceEnabled()) { logger.trace(String.format(\"Retrieved @TestExecutionListeners [%s] for declaring class [%s].\", testExecutionListeners, declaringClass.getName())); } boolean inheritListeners = testExecutionListeners.inheritListeners(); AnnotationDescriptor < TestExecutionListeners > superDescriptor = MetaAnnotationUtils.findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType); if(( ! inheritListeners || superDescriptor == null) && testExecutionListeners.mergeMode() == MergeMode.MERGE_WITH_DEFAULTS) { if(logger.isDebugEnabled()) { logger.debug(String.format(\"Merging default listeners with listeners configured via \" + \"@TestExecutionListeners for class [%s].\", descriptor.getRootDeclaringClass().getName())); } usingDefaults = true; classesList.addAll(getDefaultTestExecutionListenerClasses()); } classesList.addAll(0, Arrays.asList(testExecutionListeners.listeners())); descriptor = (inheritListeners ? superDescriptor : null); } } if(usingDefaults) { Set < Class < ? extends TestExecutionListener > > classesSet = new HashSet < > (); classesSet.addAll(classesList); classesList.clear(); classesList.addAll(classesSet); } List < TestExecutionListener > listeners = instantiateListeners(classesList); if(usingDefaults) { AnnotationAwareOrderComparator.sort(listeners); } if(logger.isInfoEnabled()) { logger.info(String.format(\"Using TestExecutionListeners: %s\", listeners)); } return listeners; } ",
        "focal_tgt": "@Nullable public Object get(String propertyName) { PropertyValue pv = getPropertyValue(propertyName); return(pv != null ? pv.getValue() : null); } ",
        "focal_src": "public Object get(String propertyName) { PropertyValue pv = getPropertyValue(propertyName); return(pv != null ? pv.getValue() : null); } ",
        "test_tgt": "@Override public final List < TestExecutionListener > getTestExecutionListeners() { Class < ? > clazz = getBootstrapContext().getTestClass(); Class < TestExecutionListeners > annotationType = TestExecutionListeners.class; List < Class < ? extends TestExecutionListener > > classesList = new ArrayList < > (); boolean usingDefaults = false; AnnotationDescriptor < TestExecutionListeners > descriptor = MetaAnnotationUtils.findAnnotationDescriptor(clazz, annotationType); if(descriptor == null) { if(logger.isDebugEnabled()) { logger.debug(String.format(\"@TestExecutionListeners is not present for class [%s]: using defaults.\", clazz.getName())); } usingDefaults = true; classesList.addAll(getDefaultTestExecutionListenerClasses()); } else { while(descriptor != null) { Class < ? > declaringClass = descriptor.getDeclaringClass(); TestExecutionListeners testExecutionListeners = descriptor.synthesizeAnnotation(); if(logger.isTraceEnabled()) { logger.trace(String.format(\"Retrieved @TestExecutionListeners [%s] for declaring class [%s].\", testExecutionListeners, declaringClass.getName())); } boolean inheritListeners = testExecutionListeners.inheritListeners(); AnnotationDescriptor < TestExecutionListeners > superDescriptor = MetaAnnotationUtils.findAnnotationDescriptor(descriptor.getRootDeclaringClass().getSuperclass(), annotationType); if(( ! inheritListeners || superDescriptor == null) && testExecutionListeners.mergeMode() == MergeMode.MERGE_WITH_DEFAULTS) { if(logger.isDebugEnabled()) { logger.debug(String.format(\"Merging default listeners with listeners configured via \" + \"@TestExecutionListeners for class [%s].\", descriptor.getRootDeclaringClass().getName())); } usingDefaults = true; classesList.addAll(getDefaultTestExecutionListenerClasses()); } classesList.addAll(0, Arrays.asList(testExecutionListeners.listeners())); descriptor = (inheritListeners ? superDescriptor : null); } } if(usingDefaults) { Set < Class < ? extends TestExecutionListener > > classesSet = new HashSet < > (); classesSet.addAll(classesList); classesList.clear(); classesList.addAll(classesSet); } List < TestExecutionListener > listeners = instantiateListeners(classesList); if(usingDefaults) { AnnotationAwareOrderComparator.sort(listeners); } if(logger.isInfoEnabled()) { logger.info(String.format(\"Using TestExecutionListeners: %s\", listeners)); } return listeners; } "
    },
    {
        "test_src": "@Test public void persistShoudRemoveTTL() { nativeConnection.setex(KEY_1_BYTES, 10, VALUE_1_BYTES); assertThat(clusterConnection.persist(KEY_1_BYTES), is(Boolean.TRUE)); assertThat(nativeConnection.ttl(KEY_1_BYTES), is( - 1L)); } ",
        "focal_tgt": "void persistShouldRemoveTTL(); ",
        "focal_src": "void persistShoudRemoveTTL(); ",
        "test_tgt": "@Test public void persistShouldRemoveTTL() { nativeConnection.setex(KEY_1_BYTES, 10, VALUE_1_BYTES); assertThat(clusterConnection.persist(KEY_1_BYTES), is(Boolean.TRUE)); assertThat(nativeConnection.ttl(KEY_1_BYTES), is( - 1L)); } "
    },
    {
        "test_src": "@Test public void getBlockLocation() { BlockStoreLocation expectedLocation = new BlockStoreLocation(mTier.getTierAlias(), mDir.getDirIndex()); Assert.assertEquals(expectedLocation, mBlockMeta.getBlockLocation()); } ",
        "focal_tgt": "public BlockStoreLocation getBlockLocation() { StorageTier tier = mDir.getParentTier(); return new BlockStoreLocation(tier.getTierAlias(), mDir.getDirIndex(), mDir.getDirMedium()); } ",
        "focal_src": "public BlockStoreLocation getBlockLocation() { StorageTier tier = mDir.getParentTier(); return new BlockStoreLocation(tier.getTierAlias(), mDir.getDirIndex()); } ",
        "test_tgt": "@Test public void getBlockLocation() { BlockStoreLocation expectedLocation = new BlockStoreLocation(mTier.getTierAlias(), mDir.getDirIndex(), mDir.getDirMedium()); Assert.assertEquals(expectedLocation, mBlockMeta.getBlockLocation()); } "
    },
    {
        "test_src": "@Test void scorePath() { Planar < GrayU16 > costYXD = new Planar < > (GrayU16.class, rangeD, width, height); GImageMiscOps.fillUniform(costYXD, rand, 0, SgmDisparityCost.MAX_COST); SgmCostAggregation alg = new SgmCostAggregation(); alg.init(costYXD); alg.scorePath(0, 0, 1, 1); int length = alg.computePathLength(0, 0, 1, 1); int foundCount = countNotZero(alg.aggregated); assertEquals(length * rangeD, foundCount); } ",
        "focal_tgt": "void scorePath(int x0, int y0, int dx, int dy) { { int minCost = Integer.MAX_VALUE; final GrayU16 costXD = costYXD.getBand(y0); final int idxCost = costXD.getIndex(0, x0); final int localLengthD = helper.localDisparityRangeLeft(x0); for(int d = 0; d < localLengthD; d ++ ) { int v = costXD.data[idxCost + d] & 0xFFFF; workCostLr[d] = costXD.data[idxCost + d]; minCost = Math.min(minCost, v); } for(int d = 0; d < localLengthD; d ++ ) { workCostLr[d] = (short)((workCostLr[d] & 0xFFFF) - minCost); } } int lengthPath = computePathLength(x0, y0, dx, dy); int x = x0 + dx; int y = y0 + dy; for(int i = 1; i < lengthPath; i ++ , x += dx, y += dy) { final GrayU16 costXD = costYXD.getBand(y); final int idxCost = costXD.getIndex(0, x); final int lengthLocalD = helper.localDisparityRangeLeft(x); int idxLrPrev = (i - 1) * lengthD; computeCostInnerD(costXD, idxCost, idxLrPrev, lengthLocalD); computeCostBorderD(idxCost, idxLrPrev, 0, costXD, lengthLocalD); computeCostBorderD(idxCost, idxLrPrev, lengthLocalD - 1, costXD, lengthLocalD); int minCost = Integer.MAX_VALUE; int idxLr = i * lengthD; for(int d = 0; d < lengthLocalD; d ++ ) { minCost = Math.min(minCost, workCostLr[idxLr + d] & 0xFFFF); } for(int d = 0; d < lengthLocalD; d ++ ) { workCostLr[idxLr + d] = (short)((workCostLr[idxLr + d] & 0xFFFF) - minCost); } } saveWorkToAggregated(x0, y0, dx, dy, lengthPath); } ",
        "focal_src": "void scorePath(int x0, int y0, int dx, int dy) { { final GrayU16 costXD = costYXD.getBand(y0); final int idxCost = costXD.getIndex(0, x0); final int localLengthD = helper.localDisparityRangeLeft(x0); for(int d = 0; d < localLengthD; d ++ ) { workCostLr[d] = costXD.data[idxCost + d]; } } int lengthPath = computePathLength(x0, y0, dx, dy); int x = x0 + dx; int y = y0 + dy; for(int i = 1; i < lengthPath; i ++ , x += dx, y += dy) { int idxLrPrev = (i - 1) * lengthD; final int prevLengthD = helper.localDisparityRangeLeft(x - dx); int minLrPrev = Integer.MAX_VALUE; for(int d = 0; d < prevLengthD; d ++ ) { int cost = workCostLr[idxLrPrev + d] & 0xFFFF; if(cost < minLrPrev)minLrPrev = cost; } final GrayU16 costXD = costYXD.getBand(y); final int idxCost = costXD.getIndex(0, x); final int localLengthD = helper.localDisparityRangeLeft(x); computeCostInnerD(costXD, idxCost, idxLrPrev, minLrPrev, localLengthD); computeCostBorderD(idxCost, idxLrPrev, 0, costXD, minLrPrev, localLengthD); computeCostBorderD(idxCost, idxLrPrev, localLengthD - 1, costXD, minLrPrev, localLengthD); } saveWorkToAggregated(x0, y0, dx, dy, lengthPath); } ",
        "test_tgt": "@Test void scorePath() { Planar < GrayU16 > costYXD = new Planar < > (GrayU16.class, rangeD, width, height); GImageMiscOps.fillUniform(costYXD, rand, 0, SgmDisparityCost.MAX_COST); SgmCostAggregation alg = new SgmCostAggregation(); alg.init(costYXD); alg.scorePath(0, 0, 1, 1); int length = alg.computePathLength(0, 0, 1, 1); int foundCount = countNotZero(alg.aggregated); assertEquals(length * rangeD, foundCount); } "
    },
    {
        "test_src": "@Test public void create() { count(_ARCHIVE_CREATE.args(\"X\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry level='9'>X</archive:entry>\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry encoding='US-ASCII'>X</archive:entry>\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry \" + \"last-modified='2000-01-01T12:12:12'>X</archive:entry>\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { }\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format':'zip', 'algorithm':'deflate' }\"), 1); count(_ARCHIVE_CREATE.args(\"X\", \"\", \" map {}\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format': 'zip', 'algorithm': 'deflate' }\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format': 'zip' }\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format': 'gzip' }\"), 1); error(_ARCHIVE_CREATE.args(\"X\", \" ()\"), ARCHIVE_NUMBER_X_X); error(_ARCHIVE_CREATE.args(\" <archive:entry/>\", \"\"), ARCHIVE_DESC1); error(_ARCHIVE_CREATE.args(\" <archive:entry compression-level='x'>X</archive:entry>\", \"\"), ARCHIVE_DESC2_X); error(_ARCHIVE_CREATE.args(\" <archive:entry compression-level='10'>X</archive:entry>\", \"\"), ARCHIVE_DESC2_X); error(_ARCHIVE_CREATE.args(\" <archive:entry last-modified='2020'>X</archive:entry>\", \"\"), ARCHIVE_DESC3_X); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \" 123\"), STRBIN_X_X); error(_ARCHIVE_CREATE.args(\" <archive:entry encoding='x'>X</archive:entry>\", \"\"), ARCHIVE_ENCODE1_X); error(_ARCHIVE_CREATE.args(\" <archive:entry encoding='US-ASCII'>X</archive:entry>\", \"\u00fc\"), ARCHIVE_ENCODE2_X); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format':'rar' }\"), ARCHIVE_FORMAT); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'x':'y' }\"), INVALIDOPT_X); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format': 'xxx' }\"), ARCHIVE_FORMAT); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'algorithm': 'unknown' }\"), ARCHIVE_FORMAT_X_X); error(_ARCHIVE_CREATE.args(\" ('x','y')\", \" ('a','b')\", \" map { 'format': 'gzip' }\"), ARCHIVE_SINGLE_X); } ",
        "focal_tgt": "private Data create(final QueryInput input, final boolean single, final InputInfo info)throws QueryException { final Context context = qc.context; if( ! context.user().has(Perm.READ))throw XQUERY_PERMISSION1_X.get(info, Util.info(Text.PERM_REQUIRED_X, Perm.READ)); final IO io = input.io; if( ! io.exists())throw WHICHRES_X.get(info, io); if(single && io.isDir())throw RESDIR_X.get(info, io); final boolean mem = ! context.options.get(MainOptions.FORCECREATE); final MainOptions opts = new MainOptions(context.options, true); final Parser parser = new DirParser(io, opts); final Data data; try { data = CreateDB.create(io.dbName(), parser, context, opts, mem); } catch(final IOException ex) { throw IOERR_X.get(info, ex); } return addData(data); } ",
        "focal_src": "private Data create(final QueryInput input, final boolean single, final InputInfo info)throws QueryException { final Context context = qc.context; if( ! context.user().has(Perm.READ))throw BXXQ_PERM_X.get(info, Util.info(Text.PERM_REQUIRED_X, Perm.READ)); final IO io = input.io; if( ! io.exists())throw WHICHRES_X.get(info, io); if(single && io.isDir())throw RESDIR_X.get(info, io); final boolean mem = ! context.options.get(MainOptions.FORCECREATE); final MainOptions opts = new MainOptions(context.options, true); final Parser parser = new DirParser(io, opts); final Data data; try { data = CreateDB.create(io.dbName(), parser, context, opts, mem); } catch(final IOException ex) { throw IOERR_X.get(info, ex); } return addData(data); } ",
        "test_tgt": "@Test public void create() { count(_ARCHIVE_CREATE.args(\"X\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry level='9'>X</archive:entry>\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry encoding='US-ASCII'>X</archive:entry>\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry \" + \"last-modified='2000-01-01T12:12:12'>X</archive:entry>\", \"\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { }\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format':'zip', 'algorithm':'deflate' }\"), 1); count(_ARCHIVE_CREATE.args(\"X\", \"\", \" map {}\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format': 'zip', 'algorithm': 'deflate' }\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format': 'zip' }\"), 1); count(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format': 'gzip' }\"), 1); error(_ARCHIVE_CREATE.args(\"X\", \" ()\"), ARCHIVE_NUMBER_X_X); error(_ARCHIVE_CREATE.args(\" <archive:entry/>\", \"\"), ARCHIVE_DESCRIPTOR1); error(_ARCHIVE_CREATE.args(\" <archive:entry compression-level='x'>X</archive:entry>\", \"\"), ARCHIVE_DESCRIPTOR2_X); error(_ARCHIVE_CREATE.args(\" <archive:entry compression-level='10'>X</archive:entry>\", \"\"), ARCHIVE_DESCRIPTOR2_X); error(_ARCHIVE_CREATE.args(\" <archive:entry last-modified='2020'>X</archive:entry>\", \"\"), ARCHIVE_DESCRIPTOR3_X); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \" 123\"), STRBIN_X_X); error(_ARCHIVE_CREATE.args(\" <archive:entry encoding='x'>X</archive:entry>\", \"\"), ARCHIVE_ENCODE1_X); error(_ARCHIVE_CREATE.args(\" <archive:entry encoding='US-ASCII'>X</archive:entry>\", \"\u00fc\"), ARCHIVE_ENCODE2_X); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format':'rar' }\"), ARCHIVE_FORMAT); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'x':'y' }\"), INVALIDOPT_X); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'format': 'xxx' }\"), ARCHIVE_FORMAT); error(_ARCHIVE_CREATE.args(\" <archive:entry>X</archive:entry>\", \"\", \" map { 'algorithm': 'unknown' }\"), ARCHIVE_FORMAT_X_X); error(_ARCHIVE_CREATE.args(\" ('x','y')\", \" ('a','b')\", \" map { 'format': 'gzip' }\"), ARCHIVE_SINGLE_X); } "
    },
    {
        "test_src": "@Test public void testReadAll_IT()throws Exception { assertFF4J.assertThatStoreHasSize(5); final Feature f1 = ff4j.getFeature(F1); final ResourceConfig rc = new PackagesResourceConfig(\"org.ff4j\"); final Map < String, Object > config = new HashMap < String, Object > (); config.put(\"com.sun.jersey.api.json.POJOMappingFeature\", true); rc.setPropertiesAndFeatures(config); WebResource wRes3 = resource().path(APIPATH).path(\"features\").path(\"first\"); ClientResponse httpRes3 = wRes3.get(ClientResponse.class); System.out.println(String.valueOf(httpRes3.getEntity(String.class))); WebResource wRes0 = resource().path(APIPATH).path(\"features\").path(\"tralala\").path(\"enable\"); ClientResponse httpRes0 = wRes0.post(ClientResponse.class); System.out.println(String.valueOf(httpRes0.getStatus())); ClientResponse httpRes4 = wRes3.delete(ClientResponse.class); System.out.println(String.valueOf(httpRes4.getStatus())); ClientResponse httpRes5 = wRes3.get(ClientResponse.class); System.out.println(String.valueOf(httpRes5.getStatus())); wRes3.put(f1.toString().getBytes()); } ",
        "focal_tgt": "@GET@Produces(MediaType.APPLICATION_JSON)public Response readAll() { Set < String > setOfGroup = getStore().readAllGroups(); StringBuilder sb = new StringBuilder(\" {\"); boolean first = true; for(String group : setOfGroup) { if( ! first) { sb.append(\",\"); } first = false; sb.append(\"\\\"\" + group + \"\\\":\\\"\" + uriInfo.getAbsolutePath() + group + \"\\\"\"); } sb.append(\"}\"); return Response.ok(sb.toString()).build(); } ",
        "focal_src": "@GET@Produces(MediaType.APPLICATION_JSON)public Response readAll() { Set < String > setOfGroup = getStore().readAllGroups(); StringBuilder sb = new StringBuilder(\"{ groups:\"); boolean first = true; for(String group : setOfGroup) { if( ! first) { sb.append(\",\"); } first = false; sb.append(\"{\\\"\" + group + \"\\\":\\\"\" + uriInfo.getAbsolutePath() + group + \"\\\"}\"); } sb.append(\"}\"); return Response.ok(sb.toString()).build(); } ",
        "test_tgt": "@Test public void testReadAll_IT()throws Exception { assertFF4J.assertThatStoreHasSize(5); final Feature f1 = ff4j.getFeature(F1); final ResourceConfig rc = new PackagesResourceConfig(\"org.ff4j\"); final Map < String, Object > config = new HashMap < String, Object > (); config.put(\"com.sun.jersey.api.json.POJOMappingFeature\", true); rc.setPropertiesAndFeatures(config); WebResource wRes3 = resource().path(APIPATH).path(\"features\").path(\"first\"); ClientResponse httpRes3 = wRes3.get(ClientResponse.class); System.out.println(String.valueOf(httpRes3.getEntity(String.class))); WebResource wRes0 = resource().path(APIPATH).path(\"features\").path(\"tralala\").path(\"enable\"); ClientResponse httpRes0 = wRes0.post(ClientResponse.class); System.out.println(String.valueOf(httpRes0.getStatus())); ClientResponse httpRes4 = wRes3.delete(ClientResponse.class); System.out.println(String.valueOf(httpRes4.getStatus())); ClientResponse httpRes5 = wRes3.get(ClientResponse.class); System.out.println(String.valueOf(httpRes5.getStatus())); wRes3.put(f1.toString().getBytes()); } "
    },
    {
        "test_src": "@Test public void testGetVacantEventClassFamiliesByApplicationToken()throws Exception { ApplicationDto application = createApplication(tenantAdminDto); EventClassFamilyDto eventClassFamily = createEventClassFamily(application.getTenantId()); createApplicationEventFamilyMap(application.getId(), eventClassFamily.getId(), 1); loginTenantDeveloper(tenantDeveloperUser); List < EcfInfoDto > vacantEcfs = client.getVacantEventClassFamiliesByApplicationToken(application.getApplicationToken()); Assert.assertNotNull(vacantEcfs); Assert.assertEquals(0, vacantEcfs.size()); loginTenantAdmin(tenantAdminUser); client.addEventClassFamilySchema(eventClassFamily.getId(), TEST_EVENT_CLASS_FAMILY_SCHEMA); loginTenantDeveloper(tenantDeveloperUser); vacantEcfs = client.getVacantEventClassFamiliesByApplicationToken(application.getApplicationToken()); Assert.assertNotNull(vacantEcfs); Assert.assertEquals(1, vacantEcfs.size()); Assert.assertNotNull(vacantEcfs.get(0)); Assert.assertEquals(eventClassFamily.getId(), vacantEcfs.get(0).getEcfId()); Assert.assertEquals(eventClassFamily.getName(), vacantEcfs.get(0).getEcfName()); Assert.assertEquals(2, vacantEcfs.get(0).getVersion()); } ",
        "focal_tgt": "public List < EcfInfoDto > getVacantEventClassFamiliesByApplicationToken(String applicationToken)throws Exception { ResponseEntity < List < EcfInfoDto > > entity = restTemplate.exchange(restTemplate.getUrl() + \"vacantEventClassFamilies/\" + applicationToken, HttpMethod.GET, null, new ParameterizedTypeReference < List < EcfInfoDto > > () { }); return entity.getBody(); } ",
        "focal_src": "public List < EcfInfoDto > getVacantEventClassFamiliesByApplicationToken(String applicationToken)throws Exception { ParameterizedTypeReference < List < EcfInfoDto > > typeRef = new ParameterizedTypeReference < List < EcfInfoDto > > () { }; ResponseEntity < List < EcfInfoDto > > entity = restTemplate.exchange(restTemplate.getUrl() + \"vacantEventClassFamiliesByAppToken/\" + applicationToken, HttpMethod.GET, null, typeRef); return entity.getBody(); } ",
        "test_tgt": "@Test public void testGetVacantEventClassFamiliesByApplicationToken()throws Exception { ApplicationDto application = createApplication(tenantAdminDto); EventClassFamilyDto eventClassFamily = createEventClassFamily(application.getTenantId()); createApplicationEventFamilyMap(application.getApplicationToken(), eventClassFamily.getId(), 1); loginTenantDeveloper(tenantDeveloperUser); List < EcfInfoDto > vacantEcfs = client.getVacantEventClassFamiliesByApplicationToken(application.getApplicationToken()); Assert.assertNotNull(vacantEcfs); Assert.assertEquals(0, vacantEcfs.size()); loginTenantAdmin(tenantAdminUser); EventClassFamilyVersionDto eventClassFamilyVersion = createEventClassFamilyVersion(tenantAdminDto.getTenantId()); client.addEventClassFamilyVersion(eventClassFamily.getId(), eventClassFamilyVersion); loginTenantDeveloper(tenantDeveloperUser); vacantEcfs = client.getVacantEventClassFamiliesByApplicationToken(application.getApplicationToken()); Assert.assertNotNull(vacantEcfs); Assert.assertEquals(1, vacantEcfs.size()); Assert.assertNotNull(vacantEcfs.get(0)); Assert.assertEquals(eventClassFamily.getId(), vacantEcfs.get(0).getEcfId()); Assert.assertEquals(eventClassFamily.getName(), vacantEcfs.get(0).getEcfName()); Assert.assertEquals(2, vacantEcfs.get(0).getVersion()); } "
    },
    {
        "test_src": "@Test public void testCreateApplication()throws GenieException { final Application app = new Application(APP_1_NAME, APP_1_USER, ApplicationStatus.ACTIVE, APP_1_VERSION); final String id = UUID.randomUUID().toString(); app.setId(id); final Application created = this.service.createApplication(app); Assert.assertNotNull(this.service.getApplication(id)); Assert.assertEquals(id, created.getId()); Assert.assertEquals(APP_1_NAME, created.getName()); Assert.assertEquals(APP_1_USER, created.getUser()); Assert.assertEquals(ApplicationStatus.ACTIVE, created.getStatus()); this.service.deleteApplication(id); try { this.service.getApplication(id); Assert.fail(\"Should have thrown exception\"); } catch(final GenieException ge) { Assert.assertEquals(HttpURLConnection.HTTP_NOT_FOUND, ge.getErrorCode()); } } ",
        "focal_tgt": "public Application createApplication(final Application application)throws GenieException { if(application == null) { throw new GeniePreconditionException(\"No application passed in. Unable to validate.\"); } final HttpRequest request = BaseGenieClient.buildRequest(Verb.POST, BASE_CONFIG_APPLICATION_REST_URL, null, application); return(Application)this.executeRequest(request, null, Application.class); } ",
        "focal_src": "public Application createApplication(final Application application)throws GenieException { if(application == null) { throw new GeniePreconditionException(\"No application passed in. Unable to validate.\"); } application.validate(); final HttpRequest request = BaseGenieClient.buildRequest(Verb.POST, BASE_CONFIG_APPLICATION_REST_URL, null, application); return(Application)this.executeRequest(request, null, Application.class); } ",
        "test_tgt": "@Test public void testCreateApplication()throws GenieException { final Application app = new Application(APP_1_NAME, APP_1_USER, APP_1_VERSION, ApplicationStatus.ACTIVE); final String id = UUID.randomUUID().toString(); app.setId(id); final Application created = this.service.createApplication(app); Assert.assertNotNull(this.service.getApplication(id)); Assert.assertEquals(id, created.getId()); Assert.assertEquals(APP_1_NAME, created.getName()); Assert.assertEquals(APP_1_USER, created.getUser()); Assert.assertEquals(ApplicationStatus.ACTIVE, created.getStatus()); this.service.deleteApplication(id); try { this.service.getApplication(id); Assert.fail(\"Should have thrown exception\"); } catch(final GenieException ge) { Assert.assertEquals(HttpURLConnection.HTTP_NOT_FOUND, ge.getErrorCode()); } } "
    },
    {
        "test_src": "@Test public void clearPersistedFiles()throws Exception { writeFileWithBlocks(1L, ImmutableList.of(2L, 3L)); mManager.clearPersistedFiles(ImmutableList.of(1L)); assertEquals(Collections.emptyList(), mManager.getPersistedFiles()); } ",
        "focal_tgt": "public void clearPersistedFiles(List < Long > persistedFiles) { synchronized(mLock) { for(long persistedId : persistedFiles) { mPersistedFilesInfo.remove(persistedId); } } } ",
        "focal_src": "public void clearPersistedFiles(List < Long > persistedFiles) { synchronized(mLock) { mPersistedFiles.removeAll(persistedFiles); } } ",
        "test_tgt": "@Test public void clearPersistedFiles()throws Exception { writeFileWithBlocks(1L, ImmutableList.of(2L, 3L)); mManager.clearPersistedFiles(ImmutableList.of(1L)); FileDataManager.PersistedFilesInfo info = mManager.getPersistedFilesInfo(); assertEquals(Collections.emptyList(), info.idList()); } "
    },
    {
        "test_src": "@Test public void onCandidateNewOrChange() { final BigDecimal olderStockQty = ELEVEN; final MaterialDescriptor olderMaterialDescriptor = MaterialDescriptor.builder().productDescriptor(createProductDescriptor()).warehouseId(WAREHOUSE_ID).quantity(olderStockQty).date(NOW).build(); final Candidate olderStockCandidate = Candidate.builder().type(CandidateType.STOCK).clientId(CLIENT_ID).orgId(ORG_ID).materialDescriptor(olderMaterialDescriptor).build(); candidateRepositoryWriteService.addOrUpdateOverwriteStoredSeqNo(olderStockCandidate); final MaterialDescriptor materialDescriptoriptor = MaterialDescriptor.builder().productDescriptor(createProductDescriptor()).warehouseId(WAREHOUSE_ID).quantity(TWENTY_THREE).date(AFTER_NOW).build(); final Candidate candidate = Candidate.builder().type(CandidateType.SUPPLY).clientId(CLIENT_ID).orgId(ORG_ID).materialDescriptor(materialDescriptoriptor).businessCase(CandidateBusinessCase.PRODUCTION).build(); supplyCandiateHandler.onCandidateNewOrChange(candidate); final List < I_MD_Candidate > records = retrieveAllRecords(); assertThat(records).hasSize(3); final I_MD_Candidate stockRecord = filter(CandidateType.STOCK, AFTER_NOW).get(0); final I_MD_Candidate supplyRecord = filter(CandidateType.SUPPLY).get(0); assertThat(supplyRecord.getQty()).isEqualByComparingTo(TWENTY_THREE); assertThat(supplyRecord.getMD_Candidate_BusinessCase()).isEqualTo(CandidateBusinessCase.PRODUCTION.toString()); assertThat(stockRecord.getQty()).isEqualByComparingTo(ELEVEN.add(TWENTY_THREE)); assertThat(supplyRecord.getSeqNo()).isEqualTo(stockRecord.getSeqNo() + 1); } ",
        "focal_tgt": "@Override public Candidate onCandidateNewOrChange(@NonNull final Candidate candidate) { assertCorrectCandidateType(candidate); final SaveResult candidateSaveResult = candidateRepositoryWriteService.addOrUpdateOverwriteStoredSeqNo(candidate); if( ! candidateSaveResult.isDateChanged() && ! candidateSaveResult.isQtyChanged()) { return candidateSaveResult.toCandidateWithQtyDelta(); } final Candidate stockCandidate; final Candidate savedCandidate = candidateSaveResult.getCandidate(); final Optional < Candidate > childStockCandidate = candidateRepository.retrieveSingleChild(savedCandidate.getId()); if(childStockCandidate.isPresent()) { stockCandidate = stockCandidateService.createStockCandidate(savedCandidate.withNegatedQuantity()).withId(childStockCandidate.get().getId()); } else { stockCandidate = stockCandidateService.createStockCandidate(savedCandidate.withNegatedQuantity()); } final Candidate savedStockCandidate = candidateRepositoryWriteService.addOrUpdateOverwriteStoredSeqNo(stockCandidate.withParentId(savedCandidate.getId())).getCandidate(); final SaveResult deltaToApplyToLaterStockCandiates = SaveResult.builder().previousQty(candidateSaveResult.getPreviousQty()).previousTime(candidateSaveResult.getPreviousTime()).candidate(savedCandidate).build(); stockCandidateService.applyDeltaToMatchingLaterStockCandidates(deltaToApplyToLaterStockCandiates); candidateRepositoryWriteService.updateCandidateById(savedCandidate.withParentId(savedStockCandidate.getId())); final Candidate candidateToReturn = candidateSaveResult.toCandidateWithQtyDelta().withParentId(savedStockCandidate.getId()); if(savedCandidate.getType() == CandidateType.DEMAND) { fireSupplyRequiredEventIfQtyBelowZero(candidateToReturn); } return candidateToReturn; } ",
        "focal_src": "@Override public Candidate onCandidateNewOrChange(@NonNull final Candidate demandCandidate) { assertCorrectCandidateType(demandCandidate); final Candidate demandCandidateDeltaWithId = candidateRepositoryWriteService.addOrUpdateOverwriteStoredSeqNo(demandCandidate); if(demandCandidateDeltaWithId.getQuantity().signum() == 0) { return demandCandidateDeltaWithId; } final int expectedStockSeqNo = demandCandidateDeltaWithId.getSeqNo() + 1; final Candidate childStockWithDemand; final Candidate childStockWithDemandDelta; final Optional < Candidate > possibleChildStockCandidate = candidateRepository.retrieveSingleChild(demandCandidateDeltaWithId.getId()); if(possibleChildStockCandidate.isPresent()) { childStockWithDemand = possibleChildStockCandidate.get().withQuantity(demandCandidate.getQuantity().negate()); childStockWithDemandDelta = stockCandidateService.updateQty(childStockWithDemand); } else { final Candidate templateForNewDemandCandidateChild = demandCandidateDeltaWithId.withNegatedQuantity().withSeqNo(expectedStockSeqNo); final Candidate newDemandCandidateChild = stockCandidateService.createStockCandidate(templateForNewDemandCandidateChild); childStockWithDemandDelta = candidateRepositoryWriteService.addOrUpdatePreserveExistingSeqNo(newDemandCandidateChild); childStockWithDemand = childStockWithDemandDelta.withQuantity(newDemandCandidateChild.getQuantity()); } candidateRepositoryWriteService.updateCandidateById(childStockWithDemand.withParentId(demandCandidateDeltaWithId.getId())); stockCandidateService.applyDeltaToMatchingLaterStockCandidates(childStockWithDemandDelta); final Candidate demandCandidateToReturn; if(childStockWithDemandDelta.getSeqNo() != expectedStockSeqNo) { demandCandidateToReturn = demandCandidate.withSeqNo(childStockWithDemandDelta.getSeqNo() - 1); candidateRepositoryWriteService.addOrUpdateOverwriteStoredSeqNo(demandCandidateToReturn); } else { demandCandidateToReturn = demandCandidateDeltaWithId; } if(demandCandidateDeltaWithId.getType() == CandidateType.DEMAND) { fireSupplyRequiredEventIfQtyBelowZero(demandCandidateDeltaWithId); } return demandCandidateToReturn; } ",
        "test_tgt": "@Test public void onCandidateNewOrChange() { final BigDecimal olderStockQty = ELEVEN; final MaterialDescriptor olderMaterialDescriptor = MaterialDescriptor.builder().productDescriptor(createProductDescriptor()).warehouseId(WAREHOUSE_ID).quantity(olderStockQty).date(NOW).build(); final Candidate olderStockCandidate = Candidate.builder().type(CandidateType.STOCK).clientId(CLIENT_ID).orgId(ORG_ID).materialDescriptor(olderMaterialDescriptor).build(); candidateRepositoryWriteService.addOrUpdateOverwriteStoredSeqNo(olderStockCandidate); final MaterialDescriptor materialDescriptoriptor = MaterialDescriptor.builder().productDescriptor(createProductDescriptor()).warehouseId(WAREHOUSE_ID).quantity(TWENTY_THREE).date(AFTER_NOW).build(); final Candidate candidate = Candidate.builder().type(CandidateType.SUPPLY).clientId(CLIENT_ID).orgId(ORG_ID).materialDescriptor(materialDescriptoriptor).businessCase(CandidateBusinessCase.PRODUCTION).build(); supplyCandiateHandler.onCandidateNewOrChange(candidate); final List < I_MD_Candidate > records = retrieveAllRecords(); assertThat(records).hasSize(3); final I_MD_Candidate stockRecord = filter(CandidateType.STOCK, AFTER_NOW).get(0); final I_MD_Candidate supplyRecord = filter(CandidateType.SUPPLY).get(0); assertThat(supplyRecord.getQty()).isEqualByComparingTo(TWENTY_THREE); assertThat(supplyRecord.getMD_Candidate_BusinessCase()).isEqualTo(CandidateBusinessCase.PRODUCTION.toString()); assertThat(stockRecord.getQty()).isEqualByComparingTo(ELEVEN.add(TWENTY_THREE)); assertThat(supplyRecord.getSeqNo()).isEqualTo(stockRecord.getSeqNo()); } "
    },
    {
        "test_src": "@Test public void testNext()throws ServiceException, InterruptedException { final AbstractInvokable memOwner = new DummyInvokable(); reader = new CollectionReader < PactInteger > (objects); SpillingResettableIterator < PactInteger > iterator = new SpillingResettableIterator < PactInteger > (memman, ioman, reader, SpillingResettableIterator.MIN_BUFFER_SIZE * SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS, deserializer, memOwner); try { iterator.open(); } catch(IOException e) { Assert.fail(\"Could not open resettable iterator:\" + e.getMessage()); } PactInteger record; int cnt = 0; while(cnt < NUM_TESTRECORDS) { record = iterator.next(); Assert.assertTrue(\"Record was not read from iterator\", record != null); cnt ++ ; } record = iterator.next(); Assert.assertTrue(\"Too many records were read from iterator\", record == null); iterator.close(); } ",
        "focal_tgt": "@Override public ManagementVertex next() { if(this.traversalStack.isEmpty()) { if(this.numVisitedEntryVertices < 0) { return null; } TraversalEntry newentry; if(this.forward) { newentry = new TraversalEntry(this.managementGraph.getInputVertex(this.startStage, this.numVisitedEntryVertices), 0, 0); } else { newentry = new TraversalEntry(managementGraph.getOutputVertex(this.startStage, this.numVisitedEntryVertices), 0, 0); } this.traversalStack.push(newentry); this.alreadyVisited.add(newentry.getManagementVertex()); } final ManagementVertex returnVertex = this.traversalStack.peek().getManagementVertex(); do { final TraversalEntry te = this.traversalStack.peek(); final ManagementVertex candidateVertex = getCandidateVertex(te, this.forward); if(candidateVertex == null) { this.traversalStack.pop(); } else { final TraversalEntry newte = new TraversalEntry(candidateVertex, 0, 0); this.traversalStack.push(newte); this.alreadyVisited.add(candidateVertex); break; } } while( ! this.traversalStack.isEmpty()); return returnVertex; } ",
        "focal_src": "@Override public ManagementVertex next() { if(traversalStack.isEmpty()) { if(numVisitedEntryVertices < 0) { return null; } TraversalEntry newentry; if(forward) { newentry = new TraversalEntry(managementGraph.getInputVertex(this.startStage, numVisitedEntryVertices), 0, 0); } else { newentry = new TraversalEntry(managementGraph.getOutputVertex(this.startStage, numVisitedEntryVertices), 0, 0); } traversalStack.push(newentry); } final ManagementVertex returnVertex = traversalStack.peek().getManagementVertex(); do { final TraversalEntry te = traversalStack.peek(); final ManagementVertex candidateVertex = getCandidateVertex(te, forward); if(candidateVertex == null) { traversalStack.pop(); } else { final TraversalEntry newte = new TraversalEntry(candidateVertex, 0, 0); traversalStack.add(newte); break; } } while( ! traversalStack.isEmpty()); alreadyVisited.add(returnVertex); return returnVertex; } ",
        "test_tgt": "@Test public void testNext()throws ServiceException, InterruptedException { final AbstractInvokable memOwner = new DummyInvokable(); reader = new CollectionIterator < PactInteger > (objects); SpillingResettableIterator < PactInteger > iterator = new SpillingResettableIterator < PactInteger > (memman, ioman, reader, SpillingResettableIterator.MIN_BUFFER_SIZE * SpillingResettableIterator.MINIMUM_NUMBER_OF_BUFFERS, deserializer, memOwner); try { iterator.open(); } catch(IOException e) { Assert.fail(\"Could not open resettable iterator:\" + e.getMessage()); } PactInteger record; int cnt = 0; while(cnt < NUM_TESTRECORDS) { record = iterator.next(); Assert.assertTrue(\"Record was not read from iterator\", record != null); cnt ++ ; } record = iterator.next(); Assert.assertTrue(\"Too many records were read from iterator\", record == null); iterator.close(); } "
    },
    {
        "test_src": "@Test public void testPackAlignments() { String path = \"/broad/1KG/DCC_merged/freeze4/NA12878.ceu.daughter.bam\"; String serverURL = \"http://www.broadinstitute.org/webservices/igv\"; String chr = \"1\"; int start = 557000; int end = 558000; boolean contained = false; ResourceLocator rl = new ResourceLocator(serverURL, path); BAMRemoteQueryReader bamReader = new BAMRemoteQueryReader(rl); CloseableIterator < Alignment > iter = bamReader.query(chr, start, end, contained); boolean showDuplicates = false; int qualityThreshold = 0; int maxLevels = 1000; List < AlignmentInterval.Row > result = (new AlignmentPacker()).packAlignments(iter, maxLevels, end, false); } ",
        "focal_tgt": "public List < AlignmentInterval.Row > packAlignments(Iterator < Alignment > iter, int end, boolean pairAlignments, AlignmentTrack.SortOption groupBy) { Comparator lengthComparator = new Comparator < Alignment > () { public int compare(Alignment row1, Alignment row2) { return(row2.getEnd() - row2.getStart()) - (row1.getEnd() - row2.getStart()); } }; List < Row > alignmentRows = new ArrayList(1000); if(iter == null || ! iter.hasNext()) { return alignmentRows; } if(groupBy == null) { pack(iter, end, pairAlignments, lengthComparator, alignmentRows); } else { List < Alignment > nullGroup = new ArrayList(); HashMap < String, List < Alignment > > groupedAlignments = new HashMap(); while(iter.hasNext()) { Alignment al = iter.next(); String groupKey = getGroupValue(al, groupBy); if(groupKey == null)nullGroup.add(al); else { List < Alignment > group = groupedAlignments.get(groupKey); if(group == null) { group = new ArrayList(1000); groupedAlignments.put(groupKey, group); } group.add(al); } } List < String > keys = new ArrayList(groupedAlignments.keySet()); Collections.sort(keys); for(String key : keys) { List < Alignment > group = groupedAlignments.get(key); pack(group.iterator(), end, pairAlignments, lengthComparator, alignmentRows); } pack(nullGroup.iterator(), end, pairAlignments, lengthComparator, alignmentRows); } return alignmentRows; } ",
        "focal_src": "public List < AlignmentInterval.Row > packAlignments(Iterator < Alignment > iter, int maxLevels, int end, boolean pairAlignments, AlignmentTrack.SortOption groupBy) { Comparator lengthComparator = new Comparator < Alignment > () { public int compare(Alignment row1, Alignment row2) { return(row2.getEnd() - row2.getStart()) - (row1.getEnd() - row2.getStart()); } }; List < Row > alignmentRows = new ArrayList(1000); if(iter == null || ! iter.hasNext()) { return alignmentRows; } if(groupBy == null) { pack(iter, maxLevels, end, pairAlignments, lengthComparator, alignmentRows); } else { List < Alignment > nullGroup = new ArrayList(); HashMap < String, List < Alignment > > groupedAlignments = new HashMap(); while(iter.hasNext()) { Alignment al = iter.next(); String groupKey = getGroupValue(al, groupBy); if(groupKey == null)nullGroup.add(al); else { List < Alignment > group = groupedAlignments.get(groupKey); if(group == null) { group = new ArrayList(1000); groupedAlignments.put(groupKey, group); } group.add(al); } } List < String > keys = new ArrayList(groupedAlignments.keySet()); Collections.sort(keys); for(String key : keys) { List < Alignment > group = groupedAlignments.get(key); pack(group.iterator(), maxLevels, end, pairAlignments, lengthComparator, alignmentRows); } pack(nullGroup.iterator(), maxLevels, end, pairAlignments, lengthComparator, alignmentRows); } return alignmentRows; } ",
        "test_tgt": "@Test public void testPackAlignments() { String path = \"/broad/1KG/DCC_merged/freeze4/NA12878.ceu.daughter.bam\"; String serverURL = \"http://www.broadinstitute.org/webservices/igv\"; String chr = \"1\"; int start = 557000; int end = 558000; boolean contained = false; ResourceLocator rl = new ResourceLocator(serverURL, path); BAMRemoteQueryReader bamReader = new BAMRemoteQueryReader(rl); CloseableIterator < Alignment > iter = bamReader.query(chr, start, end, contained); boolean showDuplicates = false; int qualityThreshold = 0; int maxLevels = 1000; List < AlignmentInterval.Row > result = (new AlignmentPacker()).packAlignments(iter, end, false); } "
    },
    {
        "test_src": "@Test public void testAddWord()throws InterruptedException, FileNotFoundException { String id = \"foo\"; Word newWord = loadFixture(\"src/test/resources/speech_to_text/word.json\", Word.class); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\")); service.addWord(id, newWord).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"PUT\", request.getMethod()); assertEquals(String.format(PATH_WORD, id, newWord.getWord()), request.getPath()); assertEquals(GSON.toJson(newWord), request.getBody().readUtf8()); } ",
        "focal_tgt": "public ServiceCall < Void > addWord(AddWordOptions addWordOptions) { Validator.notNull(addWordOptions, \"addWordOptions cannot be null\"); RequestBuilder builder = RequestBuilder.put(String.format(\"/v1/customizations/%s/words/%s\", addWordOptions.customizationId(), addWordOptions.wordName())); builder.header(\"Content-Type\", addWordOptions.contentType()); if(addWordOptions.contentType().equalsIgnoreCase(AddWordOptions.ContentType.APPLICATION_JSON)) { builder.bodyJson(GsonSingleton.getGson().toJsonTree(addWordOptions.customWord()).getAsJsonObject()); } else { builder.bodyContent(addWordOptions.body(), addWordOptions.contentType()); } return createServiceCall(builder.build(), ResponseConverterUtils.getVoid()); } ",
        "focal_src": "public ServiceCall < Void > addWord(String customizationId, Word word) { Validator.notNull(customizationId, \"customizationId cannot be null\"); Validator.notNull(word, \"word cannot be null\"); Validator.notNull(word.getWord(), \"word.word cannot be null\"); RequestBuilder requestBuilder = RequestBuilder.put(String.format(PATH_WORD, customizationId, word.getWord())); requestBuilder.bodyContent(GSON.toJson(word), HttpMediaType.APPLICATION_JSON); return createServiceCall(requestBuilder.build(), ResponseConverterUtils.getVoid()); } ",
        "test_tgt": "@Test public void testAddWord()throws InterruptedException, FileNotFoundException { String id = \"foo\"; Word newWord = loadFixture(\"src/test/resources/speech_to_text/word.json\", Word.class); server.enqueue(new MockResponse().addHeader(CONTENT_TYPE, HttpMediaType.APPLICATION_JSON).setBody(\"{}\")); AddWordOptions addOptions = new AddWordOptions.Builder().wordName(newWord.getWord()).customizationId(id).customWord(new CustomWord.Builder().word(newWord.getWord()).displayAs(newWord.getDisplayAs()).soundsLike(newWord.getSoundsLike()).build()).build(); service.addWord(addOptions).execute(); final RecordedRequest request = server.takeRequest(); assertEquals(\"PUT\", request.getMethod()); assertEquals(String.format(PATH_WORD, id, newWord.getWord()), request.getPath()); assertEquals(GSON.toJson(newWord), request.getBody().readUtf8()); } "
    },
    {
        "test_src": "@Test public void testNext() { try { SpillingResettableIterator < PactInteger > iterator = new SpillingResettableIterator < PactInteger > (this.reader, this.serializer, this.memman, this.ioman, 2 * 32 * 1024, this.memOwner); try { iterator.open(); } catch(IOException e) { Assert.fail(\"Could not open resettable iterator:\" + e.getMessage()); } PactInteger record; int cnt = 0; while(cnt < NUM_TESTRECORDS) { record = iterator.next(); Assert.assertTrue(\"Record was not read from iterator\", record != null); cnt ++ ; } try { record = iterator.next(); Assert.fail(\"Too many records were read from iterator.\"); } catch(NoSuchElementException nseex) { } iterator.close(); } catch(Exception ex) { ex.printStackTrace(); Assert.fail(\"Test encountered an exception.\"); } } ",
        "focal_tgt": "@Override public boolean next(StringValue target) { final char[]data = this.toTokenize.getCharArray(); final int limit = this.limit; int pos = this.pos; for(; pos < limit && Character.isWhitespace(data[pos]); pos ++ ); if(pos >= limit) { this.pos = pos; return false; } final int start = pos; for(; pos < limit && ! Character.isWhitespace(data[pos]); pos ++ ); this.pos = pos; target.setValue(this.toTokenize, start, pos - start); return true; } ",
        "focal_src": "@Override public boolean next(PactString target) { final char[]data = this.toTokenize.getCharArray(); final int limit = this.limit; int pos = this.pos; for(; pos < limit && Character.isWhitespace(data[pos]); pos ++ ); if(pos >= limit) { this.pos = pos; return false; } final int start = pos; for(; pos < limit && ! Character.isWhitespace(data[pos]); pos ++ ); this.pos = pos; target.setValue(this.toTokenize, start, pos - start); return true; } ",
        "test_tgt": "@Test public void testNext() { try { SpillingResettableIterator < IntValue > iterator = new SpillingResettableIterator < IntValue > (this.reader, this.serializer, this.memman, this.ioman, 2 * 32 * 1024, this.memOwner); try { iterator.open(); } catch(IOException e) { Assert.fail(\"Could not open resettable iterator:\" + e.getMessage()); } IntValue record; int cnt = 0; while(cnt < NUM_TESTRECORDS) { record = iterator.next(); Assert.assertTrue(\"Record was not read from iterator\", record != null); cnt ++ ; } try { record = iterator.next(); Assert.fail(\"Too many records were read from iterator.\"); } catch(NoSuchElementException nseex) { } iterator.close(); } catch(Exception ex) { ex.printStackTrace(); Assert.fail(\"Test encountered an exception.\"); } } "
    },
    {
        "test_src": "@Test public void testCreateStream()throws ExecutionException, InterruptedException { when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest)); assertEquals(\"Create Stream Status\", 201, response.get().getStatus()); streamResponseActual = response.get().readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus2); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest)); assertEquals(\"Create Stream Status\", 409, response.get().getStatus()); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus3); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest2)); assertEquals(\"Create Stream Status\", 500, response.get().getStatus()); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus4); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest3)); assertEquals(\"Create Stream Status for non-existent scope\", 404, response.get().getStatus()); } ",
        "focal_tgt": "@Override public void createStream(final String scopeName, final CreateStreamRequest createStreamRequest, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"createStream\"); StreamConfiguration streamConfiguration = ModelHelper.getCreateStreamConfig(createStreamRequest, scopeName); controllerService.createStream(streamConfiguration, System.currentTimeMillis()).thenApply(streamStatus -> { Response resp = null; if(streamStatus.getStatus() == CreateStreamStatus.Status.SUCCESS) { log.info(\"Successfully created stream: {}/{}\", scopeName, streamConfiguration.getStreamName()); resp = Response.status(Status.CREATED).entity(ModelHelper.encodeStreamResponse(streamConfiguration)).build(); } else if(streamStatus.getStatus() == CreateStreamStatus.Status.STREAM_EXISTS) { log.warn(\"Stream already exists: {}/{}\", scopeName, streamConfiguration.getStreamName()); resp = Response.status(Status.CONFLICT).build(); } else if(streamStatus.getStatus() == CreateStreamStatus.Status.SCOPE_NOT_FOUND) { log.warn(\"Scope not found: {}\", scopeName); resp = Response.status(Status.NOT_FOUND).build(); } else if(streamStatus.getStatus() == CreateStreamStatus.Status.INVALID_STREAM_NAME) { log.warn(\"Invalid stream name: {}\", streamConfiguration.getStreamName()); resp = Response.status(Status.BAD_REQUEST).build(); } else { log.warn(\"createStream failed for : {}/{}\", scopeName, streamConfiguration.getStreamName()); resp = Response.status(Status.INTERNAL_SERVER_ERROR).build(); } return resp; }).exceptionally(exception -> { log.warn(\"createStream for {}/{} failed {}: \", scopeName, streamConfiguration.getStreamName(), exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); }).thenApply(asyncResponse :: resume); LoggerHelpers.traceLeave(log, \"createStream\", traceId); } ",
        "focal_src": "@Override public void createStream(final String scopeName, final CreateStreamRequest createStreamRequest, final SecurityContext securityContext, final AsyncResponse asyncResponse) { long traceId = LoggerHelpers.traceEnter(log, \"createStream\"); StreamConfiguration streamConfiguration = ModelHelper.getCreateStreamConfig(createStreamRequest, scopeName); controllerService.createStream(streamConfiguration, System.currentTimeMillis()).thenApply(streamStatus -> { if(streamStatus == CreateStreamStatus.SUCCESS) { log.info(\"Successfully created stream: {}/{}\", scopeName, streamConfiguration.getStreamName()); return Response.status(Status.CREATED).entity(ModelHelper.encodeStreamResponse(streamConfiguration)).build(); } else if(streamStatus == CreateStreamStatus.STREAM_EXISTS) { log.warn(\"Stream already exists: {}/{}\", scopeName, streamConfiguration.getStreamName()); return Response.status(Status.CONFLICT).build(); } else if(streamStatus == CreateStreamStatus.SCOPE_NOT_FOUND) { return Response.status(Status.NOT_FOUND).build(); } else { log.warn(\"createStream failed for : {}/{}\", scopeName, streamConfiguration.getStreamName()); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); } }).exceptionally(exception -> { log.warn(\"createStream for {}/{} failed {}: \", scopeName, streamConfiguration.getStreamName(), exception); return Response.status(Status.INTERNAL_SERVER_ERROR).build(); }).thenApply(asyncResponse :: resume); LoggerHelpers.traceLeave(log, \"createStream\", traceId); } ",
        "test_tgt": "@Test public void testCreateStream()throws ExecutionException, InterruptedException { when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest)); assertEquals(\"Create Stream Status\", 201, response.get().getStatus()); streamResponseActual = response.get().readEntity(StreamProperty.class); testExpectedVsActualObject(streamResponseExpected, streamResponseActual); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus2); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest)); assertEquals(\"Create Stream Status\", 409, response.get().getStatus()); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus3); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest2)); assertEquals(\"Create Stream Status\", 500, response.get().getStatus()); when(mockControllerService.createStream(any(), anyLong())).thenReturn(createStreamStatus4); response = target(streamResourceURI).request().async().post(Entity.json(createStreamRequest3)); assertEquals(\"Create Stream Status for non-existent scope\", 404, response.get().getStatus()); } "
    },
    {
        "test_src": "@Test public void testComputeActivity() { Parameters p = Parameters.getTemporalDefaultParameters(); p.set(KEY.COLUMN_DIMENSIONS, new int[] { 32 }); p.set(KEY.CELLS_PER_COLUMN, 32); Connections connections = new Connections(); p.apply(connections); TemporalMemory.init(connections); DistalDendrite segment1a = connections.createSegment(connections.getCell(10)); connections.createSynapse(segment1a, connections.getCell(150), .85); connections.createSynapse(segment1a, connections.getCell(151), .15); DistalDendrite segment2a = connections.createSegment(connections.getCell(20)); connections.createSynapse(segment2a, connections.getCell(80), .85); connections.createSynapse(segment2a, connections.getCell(81), .85); Synapse synapse = connections.createSynapse(segment2a, connections.getCell(82), .85); synapse.setPermanence(null, 0.15); DistalDendrite segment2b = connections.createSegment(connections.getCell(20)); connections.createSynapse(segment2b, connections.getCell(50), .85); connections.createSynapse(segment2b, connections.getCell(51), .85); connections.createSynapse(segment2b, connections.getCell(52), .15); connections.createSynapse(segment2b, connections.getCell(53), .05); DistalDendrite segment3a = connections.createSegment(connections.getCell(30)); connections.createSynapse(segment3a, connections.getCell(53), .05); Connections c = connections; List < Cell > inputVec = IntStream.of(50, 52, 53, 80, 81, 82, 150, 151).mapToObj(i -> c.getCell(i)).collect(Collectors.toList()); Activity activity = c.newComputeActivity(inputVec, .5, 2, .1, 1, true); List < SegmentOverlap > active = activity.activeSegments; List < SegmentOverlap > matching = activity.matchingSegments; assertEquals(1, active.size()); assertEquals(segment2a, active.get(0).segment); assertEquals(2, active.get(0).overlap); assertEquals(3, matching.size()); assertEquals(segment1a, matching.get(0).segment); assertEquals(2, matching.get(0).overlap); assertEquals(segment2a, matching.get(1).segment); assertEquals(3, matching.get(1).overlap); assertEquals(segment2b, matching.get(2).segment); assertEquals(2, matching.get(2).overlap); } ",
        "focal_tgt": "public Activity computeActivity(Collection < Cell > activeInput, double activePermanenceThreshold, int activeSynapseThreshold, double matchingPermananceThreshold, int matchingSynapseThreshold, boolean recordIteration) { int nextSegmentIdx = getSegmentCount(); Object[][]numActiveSynapsesForSegment = new Object[nextSegmentIdx][2]; Arrays.stream(numActiveSynapsesForSegment).forEach(arr -> arr[1] = 0); Object[][]numMatchingSynapsesForSegment = new Object[nextSegmentIdx][2]; Arrays.stream(numMatchingSynapsesForSegment).forEach(arr -> arr[1] = 0); for(Cell cell : activeInput) { for(Synapse synapse : cell.getReceptorSynapses(this)) { Segment segment = synapse.getSegment(); double permanence = synapse.getPermanence(); if(permanence - matchingPermananceThreshold > - EPSILON) { numMatchingSynapsesForSegment[segment.getIndex()][0] = segment; numMatchingSynapsesForSegment[segment.getIndex()][1] = ((int)numMatchingSynapsesForSegment[segment.getIndex()][1]) + 1; if(permanence - activePermanenceThreshold > - EPSILON) { numActiveSynapsesForSegment[segment.getIndex()][0] = segment; numActiveSynapsesForSegment[segment.getIndex()][1] = ((int)numActiveSynapsesForSegment[segment.getIndex()][1]) + 1; } } } } if(recordIteration) { tmIteration ++ ; } List < SegmentOverlap > activeSegments = new ArrayList < > (); List < SegmentOverlap > matchingSegments = new ArrayList < > (); for(int i = 0; i < nextSegmentIdx; i ++ ) { if(((int)numActiveSynapsesForSegment[i][1]) >= activeSynapseThreshold) { activeSegments.add(new SegmentOverlap(((DistalDendrite)numActiveSynapsesForSegment[i][0]), (int)numActiveSynapsesForSegment[i][1])); if(recordIteration) { ((DistalDendrite)numActiveSynapsesForSegment[i][0]).setLastUsedIteration(tmIteration); } } } for(int i = 0; i < nextSegmentIdx; i ++ ) { if(((int)numMatchingSynapsesForSegment[i][1]) >= matchingSynapseThreshold) { matchingSegments.add(new SegmentOverlap(((DistalDendrite)numMatchingSynapsesForSegment[i][0]), (int)numMatchingSynapsesForSegment[i][1])); } } Collections.sort(activeSegments, (as1, as2) -> as1.segment.getIndex() - as2.segment.getIndex()); Collections.sort(matchingSegments, (ms1, ms2) -> ms1.segment.getIndex() - ms2.segment.getIndex()); return new Activity(activeSegments, matchingSegments); } ",
        "focal_src": "@Deprecated public Tuple computeActivity(Set < Cell > activeInput, double activePermanenceThreshold, int activeSynapseThreshold, double matchingPermananceThreshold, int matchingSynapseThreshold) { int nextSegmentIdx = getSegmentCount(); Object[][]numActiveSynapsesForSegment = new Object[nextSegmentIdx][2]; Arrays.stream(numActiveSynapsesForSegment).forEach(arr -> arr[1] = 0); Object[][]numMatchingSynapsesForSegment = new Object[nextSegmentIdx][2]; Arrays.stream(numMatchingSynapsesForSegment).forEach(arr -> arr[1] = 0); for(Cell cell : activeInput) { for(Synapse synapse : cell.getReceptorSynapses(this)) { Segment segment = synapse.getSegment(); double permanence = synapse.getPermanence(); if(permanence - matchingPermananceThreshold > - EPSILON) { numMatchingSynapsesForSegment[segment.getIndex()][0] = segment; numMatchingSynapsesForSegment[segment.getIndex()][1] = ((int)numMatchingSynapsesForSegment[segment.getIndex()][1]) + 1; if(permanence - activePermanenceThreshold > - EPSILON) { numActiveSynapsesForSegment[segment.getIndex()][0] = segment; numActiveSynapsesForSegment[segment.getIndex()][1] = ((int)numActiveSynapsesForSegment[segment.getIndex()][1]) + 1; } } } } List < DistalDendrite > activeSegments = new ArrayList < > (); List < DistalDendrite > matchingSegments = new ArrayList < > (); for(int i = 0; i < nextSegmentIdx; i ++ ) { if(((int)numActiveSynapsesForSegment[i][1]) >= activeSynapseThreshold) { activeSegments.add(((DistalDendrite)numActiveSynapsesForSegment[i][0])); } } for(int i = 0; i < nextSegmentIdx; i ++ ) { if(((int)numMatchingSynapsesForSegment[i][1]) >= matchingSynapseThreshold) { matchingSegments.add(((DistalDendrite)numMatchingSynapsesForSegment[i][0])); } } return new Tuple((Object)activeSegments.stream().sorted().collect(Collectors.toCollection(LinkedHashSet < DistalDendrite > :: new)), (Object)matchingSegments.stream().sorted().collect(Collectors.toCollection(LinkedHashSet < DistalDendrite > :: new))); } ",
        "test_tgt": "@Test public void testComputeActivity() { Parameters p = Parameters.getTemporalDefaultParameters(); p.set(KEY.COLUMN_DIMENSIONS, new int[] { 32 }); p.set(KEY.CELLS_PER_COLUMN, 32); Connections connections = new Connections(); p.apply(connections); TemporalMemory.init(connections); DistalDendrite segment1a = connections.createSegment(connections.getCell(10)); connections.createSynapse(segment1a, connections.getCell(150), .85); connections.createSynapse(segment1a, connections.getCell(151), .15); DistalDendrite segment2a = connections.createSegment(connections.getCell(20)); connections.createSynapse(segment2a, connections.getCell(80), .85); connections.createSynapse(segment2a, connections.getCell(81), .85); Synapse synapse = connections.createSynapse(segment2a, connections.getCell(82), .85); synapse.setPermanence(null, 0.15); DistalDendrite segment2b = connections.createSegment(connections.getCell(20)); connections.createSynapse(segment2b, connections.getCell(50), .85); connections.createSynapse(segment2b, connections.getCell(51), .85); connections.createSynapse(segment2b, connections.getCell(52), .15); connections.createSynapse(segment2b, connections.getCell(53), .05); DistalDendrite segment3a = connections.createSegment(connections.getCell(30)); connections.createSynapse(segment3a, connections.getCell(53), .05); Connections c = connections; List < Cell > inputVec = IntStream.of(50, 52, 53, 80, 81, 82, 150, 151).mapToObj(i -> c.getCell(i)).collect(Collectors.toList()); Activity activity = c.computeActivity(inputVec, .5, 2, .1, 1, true); List < SegmentOverlap > active = activity.activeSegments; List < SegmentOverlap > matching = activity.matchingSegments; assertEquals(1, active.size()); assertEquals(segment2a, active.get(0).segment); assertEquals(2, active.get(0).overlap); assertEquals(3, matching.size()); assertEquals(segment1a, matching.get(0).segment); assertEquals(2, matching.get(0).overlap); assertEquals(segment2a, matching.get(1).segment); assertEquals(3, matching.get(1).overlap); assertEquals(segment2b, matching.get(2).segment); assertEquals(2, matching.get(2).overlap); } "
    },
    {
        "test_src": "@Test public void getAllUsers_shouldNotContainsAnyDuplicateUsers() { executeDataSet(XML_FILENAME); List < User > users = userService.getAllUsers(); Assert.assertEquals(12, users.size()); } ",
        "focal_tgt": "@Override@SuppressWarnings(\"unchecked\")public List < User > getAllUsers()throws DAOException { return sessionFactory.getCurrentSession().createQuery(\"from User where not uuid = :daemonUserUuid order by userId\").setString(\"daemonUserUuid\", Daemon.getDaemonUserUuid()).list(); } ",
        "focal_src": "@Override@SuppressWarnings(\"unchecked\")public List < User > getAllUsers()throws DAOException { return sessionFactory.getCurrentSession().createQuery(\"from User u order by u.userId\").list(); } ",
        "test_tgt": "@Test public void getAllUsers_shouldNotContainsAnyDuplicateUsers() { executeDataSet(XML_FILENAME); List < User > users = userService.getAllUsers(); assertEquals(11, users.size()); } "
    },
    {
        "test_src": "@Test@Verifies(value = \"should return user using first and last name given user ID is null\", method = \"resolveUserId(null)\")public void resolveUserId_shouldReturnUserUsingFirstAndLastNameGivenUserIDIsNull()throws Exception { HL7Service hl7service = Context.getHL7Service(); Message message = hl7service.parseHL7String(\"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\" + \"PID|||3^^^^||John3^Doe^||\\r\" + \"NK1|1|Hornblower^Horatio^L|2B^Sibling^99REL||||||||||||M|19410501|||||||||||||||||1000^^^L^PN||||\\r\" + \"ORC|RE||||||||20080226102537|^Otterbourg^Bruno\\r\" + \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\" + \"OBX|1|NM|5497^CD4, BY FACS^99DCT||450|||||||||20080206\\r\" + \"OBX|2|DT|5096^RETURN VISIT DATE^99DCT||20080229|||||||||20080212\"); ORU_R01 oru = (ORU_R01)message; ORC orc = oru.getPATIENT_RESULT().getORDER_OBSERVATION().getORC(); XCN xcn = orc.getEnteredBy(0); Integer userId = hl7service.resolveUserId(xcn); assertNotNull(userId); } ",
        "focal_tgt": "@Transactional(readOnly = true)public Integer resolveUserId(XCN xcn)throws HL7Exception { String idNumber = xcn.getIDNumber().getValue(); String familyName = xcn.getFamilyName().getSurname().getValue(); String givenName = xcn.getGivenName().getValue(); if(idNumber != null && idNumber.length() > 0) { try { Integer userId = Integer.valueOf(idNumber); User user = Context.getUserService().getUser(userId); return user.getUserId(); } catch(Exception e) { log.error(\"Invalid user ID '\" + idNumber + \"'\", e); return null; } } else { try { List < User > users = Context.getUserService().getUsersByName(givenName, familyName, true); if(users.size() == 1) { return users.get(0).getUserId(); } else if(users.size() > 1) { log.error(getFindingUserErrorMessage(idNumber, familyName, givenName) + \": Found \" + users.size() + \" ambiguous users.\"); return null; } else { StringBuilder username = new StringBuilder(); if(familyName != null) { username.append(familyName); } if(givenName != null) { if(username.length() > 0) { username.append(\" \"); } username.append(givenName); } User user = Context.getUserService().getUserByUsername(username.toString()); if(user == null) { log.error(getFindingUserErrorMessage(idNumber, familyName, givenName) + \": User not found\"); return null; } return user.getUserId(); } } catch(Exception e) { log.error(getFindingUserErrorMessage(idNumber, familyName, givenName), e); return null; } } } ",
        "focal_src": "@Transactional(readOnly = true)public Integer resolveUserId(XCN xcn)throws HL7Exception { String idNumber = xcn.getIDNumber().getValue(); String familyName = xcn.getFamilyName().getSurname().getValue(); String givenName = xcn.getGivenName().getValue(); if(idNumber != null && idNumber.length() > 0) { try { Integer userId = Integer.valueOf(idNumber); User user = Context.getUserService().getUser(userId); return user.getUserId(); } catch(Exception e) { log.error(\"Invalid user ID '\" + idNumber + \"'\", e); return null; } } else { try { List < User > users = Context.getUserService().getUsersByName(givenName, familyName, true); if(users == null) { log.error(getFindingUserErrorMessage(idNumber, familyName, givenName) + \": User not found\"); return null; } else if(users.size() == 1) { return users.get(0).getUserId(); } else { log.error(getFindingUserErrorMessage(idNumber, familyName, givenName) + \": Found \" + users.size() + \" ambiguous users.\"); return null; } } catch(Exception e) { log.error(getFindingUserErrorMessage(idNumber, familyName, givenName), e); return null; } } } ",
        "test_tgt": "@Test@Verifies(value = \"should return user using first and last name given user ID is null\", method = \"resolveUserId(null)\")public void resolveUserId_shouldReturnUserUsingFirstAndLastNameGivenUserIDIsNull()throws Exception { HL7Service hl7service = Context.getHL7Service(); Message message = hl7service.parseHL7String(\"MSH|^~\\\\&|FORMENTRY|AMRS.ELD|HL7LISTENER|AMRS.ELD|20080226102656||ORU^R01|JqnfhKKtouEz8kzTk6Zo|P|2.5|1||||||||16^AMRS.ELD.FORMID\\r\" + \"PID|||3^^^^||John3^Doe^||\\r\" + \"NK1|1|Hornblower^Horatio^L|2B^Sibling^99REL||||||||||||M|19410501|||||||||||||||||1000^^^L^PN||||\\r\" + \"ORC|RE||||||||20080226102537|^Otterbourg^Bruno\\r\" + \"OBR|1|||1238^MEDICAL RECORD OBSERVATIONS^99DCT\\r\" + \"OBX|1|NM|5497^CD4, BY FACS^99DCT||450|||||||||20080206\\r\" + \"OBX|2|DT|5096^RETURN VISIT DATE^99DCT||20080229|||||||||20080212\"); ORU_R01 oru = (ORU_R01)message; ORC orc = oru.getPATIENT_RESULT().getORDER_OBSERVATION().getORC(); XCN xcn = orc.getEnteredBy(0); Integer userId = hl7service.resolveUserId(xcn); assertThat(userId, is(501)); } "
    },
    {
        "test_src": "@TestTargetNew(level = TestLevel.PARTIAL_COMPLETE, notes = \"\", method = \"valueOf\", args = { java.lang.String.class })public void testValueOf() { String SQL_NOTVALID1 = \"ABCDEF\"; String SQL_NOTVALID2 = \"12321.43.56\"; String SQL_NOTVALID3 = null; String[]SQL_INVALIDARRAY = { SQL_NOTVALID1, SQL_NOTVALID2, SQL_NOTVALID3 }; Date theDate; for(String element : SQL_DATEARRAY) { theDate = Date.valueOf(element); assertEquals(element, theDate.toString()); } for(String element : SQL_INVALIDARRAY) { try { theDate = Date.valueOf(element); fail(\"Should throw IllegalArgumentException.\"); } catch(IllegalArgumentException e) { } } } ",
        "focal_tgt": "public static Timestamp valueOf(String s)throws IllegalArgumentException { if(s == null) { throw new IllegalArgumentException(Messages.getString(\"sql.3\")); } s = s.trim(); if( ! Pattern.matches(TIME_FORMAT_REGEX, s)) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); ParsePosition pp = new ParsePosition(0); Date theDate; try { theDate = df.parse(s, pp); } catch(Exception e) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } if(theDate == null) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } int position = pp.getIndex(); int remaining = s.length() - position; int theNanos; if(remaining == 0) { theNanos = 0; } else { if((s.length() - position) < \".n\".length()) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } if((s.length() - position) > \".nnnnnnnnn\".length()) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } if(s.charAt(position) != '.') { throw new NumberFormatException(Messages.getString(\"sql.4\", s.charAt(position))); } int nanoLength = s.length() - position - 1; String theNanoString = s.substring(position + 1, position + 1 + nanoLength); theNanoString = theNanoString + \"000000000\"; theNanoString = theNanoString.substring(0, 9); try { theNanos = Integer.parseInt(theNanoString); } catch(Exception e) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } } if(theNanos < 0 || theNanos > 999999999) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } Timestamp theTimestamp = new Timestamp(theDate.getTime()); theTimestamp.setNanos(theNanos); return theTimestamp; } ",
        "focal_src": "public static Timestamp valueOf(String s)throws IllegalArgumentException { if(s == null) { throw new IllegalArgumentException(Messages.getString(\"sql.3\")); } SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); ParsePosition pp = new ParsePosition(0); Date theDate; try { theDate = df.parse(s, pp); } catch(Exception e) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } if(theDate == null) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } int position = pp.getIndex(); int remaining = s.length() - position; int theNanos; if(remaining == 0) { theNanos = 0; } else { if((s.length() - position) < \".n\".length()) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } if((s.length() - position) > \".nnnnnnnnn\".length()) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } if(s.charAt(position) != '.') { throw new NumberFormatException(Messages.getString(\"sql.4\", s.charAt(position))); } int nanoLength = s.length() - position - 1; String theNanoString = s.substring(position + 1, position + 1 + nanoLength); theNanoString = theNanoString + \"000000000\"; theNanoString = theNanoString.substring(0, 9); try { theNanos = Integer.parseInt(theNanoString); } catch(Exception e) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } } if(theNanos < 0 || theNanos > 999999999) { throw new IllegalArgumentException(Messages.getString(\"sql.2\")); } Timestamp theTimestamp = new Timestamp(theDate.getTime()); theTimestamp.setNanos(theNanos); return theTimestamp; } ",
        "test_tgt": "@TestTargetNew(level = TestLevel.PARTIAL_COMPLETE, notes = \"\", method = \"valueOf\", args = { java.lang.String.class })public void testValueOf() { String SQL_NOTVALID1 = \"ABCDEF\"; String SQL_NOTVALID2 = \"12321.43.56\"; String SQL_NOTVALID3 = null; String[]SQL_INVALIDARRAY = { SQL_NOTVALID1, SQL_NOTVALID2, SQL_NOTVALID3 }; Date theDate; for(String element : SQL_DATEARRAY) { theDate = Date.valueOf(element); assertEquals(element, theDate.toString()); } for(String element : SQL_INVALIDARRAY) { try { theDate = Date.valueOf(element); fail(\"Should throw IllegalArgumentException.\"); } catch(IllegalArgumentException e) { } } } "
    }
]